var Ce=class extends Error{},dt=class extends Error{},Fe=class extends Error{},je=class extends Error{},Be=class extends Error{},Me=class extends Error{};var xr=Object.defineProperty,eu=(e,t,n)=>t in e?xr(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Yn=(e,t,n)=>(eu(e,typeof t!="symbol"?t+"":t,n),n);function y(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var tu=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),we=class extends Error{constructor(e){tu()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function h(e,t){if(!e)throw new we(t)}var Un=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function v(e){return e===null||typeof e>"u"}var nu=Un.map(e=>e.name);function p(e){try{return e instanceof Array?!0:v(e.constructor)?!1:Un.indexOf(e.constructor)>-1||nu.indexOf(e.constructor.name)>-1}catch{return!1}}function F(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function $(e){return typeof e=="function"}function ae(e){return typeof e=="object"&&!v(e)&&!p(e)}function D(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function Je(e,t){if(F(e)){let o=Je(e.values,t);return o.length>0&&y(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o.length>1&&y(o[1])&&o[1]>=0&&o[1]<e.columns.length&&(o[1]=e.columns[o[1]]),o}if(D(e)){let o=Je(e.values,t);return o.length>0&&y(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o}if(h(ae(e)||p(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!$(t)){let o=t;t=i=>i===o}function n(o,i,s){if(s=s||[],s.indexOf(o)>-1)return null;if(ae(o)){s.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let l=0;l<a.length;l++){let c=a[l],m=o[c];if(i(m))return[c];let d=n(m,i,s);if(d&&d.length>0)return[c].concat(d)}}else if(p(o)){s.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let c=n(l,i,s);if(c&&c.length>0)return[a].concat(c)}}else if(i(o))return[];return null}function r(o){try{return t(o)}catch{return!1}}let u=n(e,r);return u&&u.length>0?u:null}function U(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(p(n))return n instanceof Array?n.map(u=>U(u)):n.slice();if(D(n)){let u=n.copy();return u.values=U(u.values),u}if(F(n)){let u=n.copy();return u.values=U(n.values),u}if(n instanceof Date)return new Date(n.getTime());n=Ke(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(u=>{r[u]=U(n[u])}),r}else return n}return t(Ke(e))}function Ke(e){function t(u,o,i){if(o=o||[],i=i||"",o.indexOf(u)>-1){let s=i.split("/").slice(i.startsWith("/")?1:0);if(s.some((l,c)=>{let m=s.slice(0,s.length-c-1),d=n;return m.forEach(w=>{d=d[w]}),d===u}))return`<reference to "${n===u?"/":"/"+Je(n,u).join("/")}">`}return typeof u=="object"?u===null?null:(o.push(u),p(u)?typeof u.constructor<"u"&&u.constructor.name!=="Array"?u.slice():u.map((s,a)=>t(s,o,i+"/"+a)):(Object.keys(u).concat(Object.getOwnPropertySymbols(u)).forEach(s=>{u[s]=t(u[s],o,i+"/"+s.toString())}),u)):u}let n=e,r=t(n);if(F(e)){let u=e.copy();u._values=r.values,u._columns=r.columns,u._index=r.index,r=u}if(D(e)){let u=e.copy();u.name=r.name,u._values=r.values,u._index=r.index,r=u}return r}function pe(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var jn=["number","int","float","bigint"];function x(e,t){function n(r,u){let o=typeof r,i=typeof u;if(o!==i&&!jn.includes(o)&&!jn.includes(i))return!1;if(o==="undefined"&&i==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===u;if(o==="number"||o==="bigint")try{let s=r.toString(),a=u.toString();return s===a}catch{return!1}if(o==="string"||o==="function")return r===u;if(o==="object"){if(r===null||u===null)return r===null&&u===null;{if(pe(r))return pe(u)?r.getTime()===u.getTime():!1;if(pe(u))return!1;if(r instanceof RegExp&&u instanceof RegExp)return r.toString()===u.toString();if(p(r)!==p(u))return!1;let s=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));if(s.length!==a.length)return!1;for(let l=0;l<s.length;l++){let c=s[l];if(!n(r[c],u[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Ke(e),Ke(t))}}function tt(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var ru=tt(16),uu=tt(16),ou=tt(16),iu=tt(16),su=tt(16),au=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)p(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?ru:v(e)?uu:$(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+su:e===1/0?ou:e===-1/0?iu:typeof e=="bigint"?e.toString():F(e)?e.toJSONString():D(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!v(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function ne(e){if(F(e)||D(e))return ne(e.values);h(p(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(u=>{p(u)?r=r.concat(t(u)):r.push(u)}),r}return t(e)}function H(e,t){t=t||{};let n=new au,r={},u=ne(e),o=[],i=-1/0,s=1/0,a=!1,l=0;for(let m of u){if(typeof m=="bigint"&&(a=!0),!t.shouldDropNaNs||y(m))try{m>i&&(i=m),m<s&&(s=m),l+=Number(m),o.push(m)}catch{i=NaN,s=NaN,l=NaN}n.increment(m)}let c=l/o.length;if(r.counts=n,r.max=i,r.mean=c,r.min=s,r.n=u.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=o.length),t.mode){let m=Array.from(n.values.map(_=>[_,n.get(_)])).toSorted((_,I)=>I[1]-_[1]),d=m[0][1],w=[];for(let _ of m)if(_[1]==d)w.push(_[0]);else break;r.mode=w.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let m=o.toSorted((w,_)=>Number(w)-Number(_)),d=Math.floor(m.length/2);if(m.length%2===0){let w=m[d-1],_=m[d];if(r.median=(Number(w)+Number(_))/2,a&&typeof w=="bigint"&&typeof _=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=m[d]}if(t.stdev||t.variance){let m=0;for(let w of o)m+=Math.pow(Number(w)-c,2);m/=o.length;let d=Math.sqrt(m);r.stdev=d,r.variance=m}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(m=>{try{return BigInt(m)}catch{return m}}))}return r}function Nt(e,t){let{counts:n}=H(e);return v(t)||($(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{x(r,t)||n.delete(r)})),n}function qt(e){if(F(e)||D(e))return qt(e.values);if(p(e)){let t=!1,n=!1,r=null;for(let u of e){if(qt(u))return!0;if(p(u)){if(r===null)r=u.length;else if(u.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function nt(e){return qt(Ke(e))}function Ot(e){if(F(e)||D(e))return Ot(e.values);h(p(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(p(e[t]))return!0;return!1}var Pe="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function te(e){h(!v(e),Pe),p(e)||(e=[e]),h(!Ot(e),Pe),h(e.length>0,Pe);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),h(y(t),Pe),h(t>=0,Pe),h(Math.floor(t)===t,Pe),h(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(te(e.slice(1)));return n}}function se(e){if(F(e)||D(e)){let n=e.copy();return n.values=se(n.values),n.index=se(n.index),n}h(p(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function K(e,t,n=1){h(!v(e)&&!v(t)&&!v(n),"You must pass two numbers and optionally a step value to the `range` function!"),h(y(e)&&y(t)&&y(n),"You must pass two numbers and optionally a step value to the `range` function!"),h(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,u=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let i=e;e=t+n,t=i+n}let o=[];for(let i=e;i<t;i+=n)if(u)try{o.push(BigInt(i))}catch{o.push(i)}else o.push(i);return r&&(o=se(o)),o}function rt(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var lu=rt(256),cu=rt(256),fu=rt(256),hu=rt(256),mu=rt(256);function Q(e){if(F(e)||D(e))return Q(e.values);h(p(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return ne(e).forEach(r=>{let u=typeof r=="object"&&r===null?lu:v(r)?cu:$(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+mu:r===1/0?fu:r===-1/0?hu:typeof r=="bigint"?r.toString():F(r)?r.toJSONString():D(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[u]||t.push(r),n[u]=!0}),t}function Ln(e){if(p(e)){let t=Ln(e[0]);return[e.length].concat(t||[])}else return}function S(e){return F(e)||D(e)?S(e.values):(h(p(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Ln(e))}function Vn(e,t,n){if(v(n)&&(n=0),h(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),p(t)){h(!nt(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=S(t);if(r.length===1)if(n===0){let u=e.copy();u._values.push(t);let o=Math.max(e.shape[1],r[0]);for(u._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let u=Math.max(e.shape[0],r[0]),o=e.copy();for(K(0,u).forEach(i=>{i>=o._values.length&&o._values.push(te(e.shape[1])),o._values[i].push(t[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let u=Math.max(...t.map(i=>i.length).concat([e.shape[1]])),o=e.copy();for(o._values=o._values.concat(t).map(i=>{for(;i.length<u;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let u=Math.max(...t.map(s=>s.length))+e.shape[1],o=Math.max(e.shape[0],r[0]),i=e.copy();for(K(0,o).forEach(s=>{for(s>=i._values.length&&i._values.push(te(e.shape[1])),i._values[s]=i._values[s].concat(t[s]);i._values[s].length<u;)i._values[s].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<u;)i._columns.push("col"+i._columns.length);return i}else throw new we("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(D(t)){let r=Vn(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(F(t))if(n===0){let r=e.copy(),u=Q(r._columns.concat(t._columns)).length;for(r._values.forEach(o=>{for(;o.length<u;)o.push(void 0)}),t.apply(o=>{let i=o.copy(),s=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(s.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):s.push(void 0)}),r._values.push(s.concat(i._values))},1),r._columns=r._columns.concat(t._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(e._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((u,o)=>{let i=t._index.indexOf(u);i>-1?r._values[o]=r._values[o].concat(t._values[i]):r._values[o]=r._values[o].concat(te(t.shape[1]))}),t._index.forEach((u,o)=>{r._index.indexOf(u)<0&&(r._index.push(u),r._values.push(te(r._columns.length).concat(t._values[o])))}),r._columns=r._columns.concat(t._columns.map(u=>u+(r._columns.indexOf(u)>-1?" (2)":""))),r}else throw new we("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function du(e,t,n,r,u){if(u=u||0,h($(r),"The first parameter to the `apply` method must be a function."),h(u===0||u===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),u===0){let o={},i;if(n.columns.forEach((s,a)=>{let l=new t(n.values.map(m=>m[a]));l.name=s,l.index=n.index;let c=r(l,a,n);c instanceof t?o[s]=c.values:o[s]=c,v(i)&&(i=c instanceof t||p(c))}),i){let s=new e(o);return s.index=n.index,s}else{let s=new t(n.columns.map(a=>o[a]));return s.index=n.columns,s}}else if(u===1){let o,i=n.values.map((s,a)=>{let l=new t(s);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return v(o)&&(o=c instanceof t||p(c)),c instanceof t?c.values:c});if(o){let s=new e(i);return s.index=n.index,s.columns=n.columns,s}else{let s=new t(i);return s.index=n.index,s}}}function A(e){return typeof e=="string"}function gu(e,t,n,r,u){let o=s=>s instanceof e,i=s=>s instanceof t;if(v(u)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(ae(r)){let s=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<s;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new we("You must pass a DataFrame, Series, or object into the `assign` method!")}else{h(A(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),h(p(u)&&!nt(u)&&S(u).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let s=n.append(u,1);return s.columns[s.columns.length-1]=r,s}}function pu(e,t){if(t.isEmpty)return new e;let n=new e(U(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function yu(e,t,n,r,u){v(r)&&(r=[]),v(u)&&(u=[]),(A(r)||y(r))&&(r=[r]),(A(u)||y(u))&&(u=[u]),h(p(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),h(p(u),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),h(S(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),h(S(u).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{u.indexOf(a)<0&&u.indexOf(l)<0&&(i||(i=[]),i.push(a))});let s=n.get(o,i);if(s instanceof t){let a=new e;a=a.assign(s),n.index.indexOf(s.name)>-1&&(a=a.transpose()),s=a}return s}function Gn(e){return y(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function $e(e){return Gn(e)&&e>=0}function bu(e,t,n,r,u,o){r=r||0,h(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,h($e(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),u=o>0?"none":u||"any",h(u==="any"||u==="all"||u==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let c=0;for(let m=0;m<l.length;m++){let d=l[m];if(v(d)&&c++,c>=o)return[]}}else if(u==="any")for(let c=0;c<l.length;c++){let m=l[c];if(v(m))return[]}else if(u==="all"){for(let c=0;c<l.length;c++){let m=l[c];if(!v(m))return l}return[]}return l}let s=n.copy(),a=Math.random().toString();if(r===0){s=s.assign(a,s.index);let l=s.values.map(i).filter(m=>m.length>0);if(S(l).length<2)return new e;s.values=l;let c=s.get(null,a);if(v(c))return new e;A(c)&&(c=[c]),c instanceof t&&(c=c.values),s.index=c,s=s.drop(null,a)}else if(r===1){let l={};if(s.columns.forEach((m,d)=>{let w=s.values.map(I=>I[d]),_=i(w);_.length>0&&(l[m]=_)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=s.index,c}return s}function un(e){if(F(e)||D(e))return e.dropNaN(...Object.values(arguments).slice(1));h(p(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(un(n))}catch{if(y(n))return t.push(n)}}),t}function vu(e,t,n,r,u){n=n||0,h(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),u=u||0,h($e(u),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=u>0?"none":r||"any",h(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(s){let a=un(s);return u>0?s.length-a.length<u:r==="any"?a.length===s.length:r==="all"?a.length>0:!0}let i=t.copy();if(n===0){let s=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return s.length>0?i.get(s,null):new e}else if(n===1){let s=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return s.length>0?i.get(null,s):new e}return i}function Bn(e){let t={};return ne(e).forEach((n,r)=>{t[n]=r}),t}function ke(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function wu(e,t,n,r,u){h($(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),v(u)&&(u=0),h(u===0||u===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=Bn(o.index),s=Bn(o.columns);if(u===0){let a=0,l=o.values.filter((c,m)=>{let d=new t(c);d.name=n.index[m],d.index=n.columns;let w=r(d,m,n);return w?a++:delete i[o.index[m]],w});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=ke(i)[0],c.index=ke(s),c}o.values=l,o.index=ke(i)}else if(u===1){o=o.transpose();let a=0,l=o.values.filter((c,m)=>{let d=new t(c);d.name=n.columns[m],d.index=n.index;let w=r(d,m,n);return w?a++:delete s[o.index[m]],w});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=ke(s)[0],c.index=ke(i),c}o.values=l,o.index=ke(s),o=o.transpose()}return o}function Nu(e,t,n){(A(t)||y(t))&&(t=[t]),(A(n)||y(n))&&(n=[n]);for(let u in t)typeof t[u]=="bigint"&&(t[u]=Number(t[u]));for(let u in n)typeof n[u]=="bigint"&&(n[u]=Number(n[u]));let r=Q((t||[]).concat(n||[]).map(u=>typeof u));return h(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&h(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(h(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),h(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),v(t)||(t=t.map(u=>{if(A(u))return h(e.index.indexOf(u)>-1,`Row "${u}" does not exist!`),u;if(y(u))return h(u>=0,`Index ${u} is out of bounds!`),h(Math.floor(u)===u,"Row numbers must be integers!"),h(u<e.index.length,`Index ${u} is out of bounds!`),e.index[u]})),v(n)||(n=n.map(u=>{if(A(u))return h(e.columns.indexOf(u)>-1,`Column "${u}" does not exist!`),u;if(y(u))return h(u>=0,`Column ${u} is out of bounds!`),h(Math.floor(u)===u,"Column numbers must be integers!"),h(u<e.columns.length,`Column ${u} is out of bounds!`),e.columns[u]})),e.getSubsetByNames(t,n)}function Du(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Te(e,t){if(v(t)&&(t=Du),F(e)||D(e))return e.sort(...Object.values(arguments).slice(1));h(p(e),"The `sort` function only works on arrays, Series, and DataFrames!"),h($(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function Eu(e){let t=e.toLowerCase(),n="";for(let u=0;u<t.length;u++){let o=t[u];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(u=>u.length>0);return r[0]+r.slice(1).map(u=>u[0].toUpperCase()+u.substring(1)).join("")}function Mn(e,t,n){v(n)?n=t.columns:A(n)&&(n=[n]);let r={};n.forEach(o=>{h(A(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=t.columns.indexOf(o);h(i>-1,`The given DataFrame does not have a column called "${o}"!`);let s=t.values.map(l=>l[i]),a=Te(Q(s));s.forEach(l=>{a.forEach(c=>{let m=o+"_"+Eu(c.toString());r[m]||(r[m]=[]),l===c?r[m].push(1):r[m].push(0)})})});let u=new e(r);return u.index=t.index,u}function Su(e,t,n){let r=e.shape;v(t)&&(t=K(0,r[0])),v(n)&&(n=K(0,r[1])),y(t)&&(t=[t]),y(n)&&(n=[n]),h(p(t)&&p(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),h(S(t).length===1&&S(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),h(t.length>0,"The `rowIndices` array must contain at least one index."),h(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(i=>{h($e(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),h(i<e.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{h($e(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),h(i<e.columns.length,`The column index ${i} is out of bounds.`)});let u=t.map(i=>e.index[i]),o=n.map(i=>e.columns[i]);return e.getSubsetByNames(u,o)}function Fu(e,t,n,r,u){v(r)&&(r=n.index),v(u)&&(u=n.columns),A(r)&&(r=[r]),A(u)&&(u=[u]),h(p(r)&&p(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),h(S(r).length===1&&S(u).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),h(r.length>0,"The `rows` array must contain at least one row name."),h(u.length>0,"The `cols` array must contain at least one column name."),r.forEach(s=>{h(A(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),h(n.index.indexOf(s)>-1,`The row name "${s}" does not exist in the list of rows.`)}),u.forEach(s=>{h(A(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),h(n.columns.indexOf(s)>-1,`The column name "${s}" does not exist in the list of columns.`)});let o=r.map(s=>u.map(a=>n.values[n.index.indexOf(s)][n.columns.indexOf(a)]));if(r.length===1&&u.length===1)return o[0][0];if(r.length===1){let s=new t(o[0]);return s.name=r[0],s.index=u,s}if(u.length===1){let s=new t(o.map(a=>a[0]));return s.name=u[0],s.index=r,s}let i=new e(o);return i.columns=u,i.index=r,i}function Ou(e,t,n){function r(d,w){return A(d)&&d.length>w?d.substring(0,w-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let u=typeof window>"u"?20:10,o=Math.floor(u/2),i=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,s=Math.floor(i/2),a=u>n.index.length?null:K(0,o).concat(K(n.index.length-o,n.index.length)),l=i>n.columns.length?null:K(0,s).concat(K(n.columns.length-s,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),u<=n.index.length&&(c._index.splice(o,0,"..."),c._values.splice(o,0,K(0,c.columns.length).map(()=>"..."))),i<=n.columns.length&&(c._columns.splice(s,0,"..."),c._values=c._values.map(d=>(d.splice(s,0,"..."),d)));let m=28;return c instanceof t?(c.values=c.values.map(d=>r(d,m)),c.name=r(c.name,m),c.index=c.index.map(d=>r(d,m))):(c.values=c.values.map(d=>d.map(w=>r(w,m))),c.columns=c.columns.map(d=>r(d,m)),c.index=c.index.map(d=>r(d,m))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function Re(e,t){h(y(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function Tu(e,t){let n=t?e:e.copy();return n.index=K(0,e.shape[0]).map(r=>"row"+Re(r,(n.index.length-1).toString().length)),n}function ut(e,t){if(F(e)||D(e))return ut(e.values,t);h(p(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=ne(e),r=!1,u=1;for(let o of n){if(!y(o))if(t)o=1;else return NaN;typeof o=="bigint"&&(r=!0,o=Number(o)),u*=o}if(r)try{return BigInt(u)}catch{}return u}catch{return NaN}}function _u(e){return Gn(e)&&e>0}function et(e,t){if(F(e)||D(e))return et(e.values,t);if(h(p(e),"The first argument passed into the `reshape` function must be an array!"),y(t)&&(t=[t]),h(p(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),h(S(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(o=>(typeof o=="bigint"&&(o=Number(o)),h(_u(o),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(o))),t.length===0)return ne(e);let n=ne(e);if(t.length===1&&t[0]===n.length)return n;h(ut(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],u=Math.floor(n.length/t[0]);for(let o=0;o<t[0];o++){let i=n.slice(o*u,(o+1)*u);r.push(et(i,t.slice(1)))}return r}var zn=Math.pow(2,64),M=[];qn(Math.floor(Math.random()*zn));function Au(e,t){e=V(e);function n(){e+=V("0x9e3779b97f4a7c15");let u=U(e);return u=(u^u>>BigInt(30))*V("0xbf58476d1ce4e5b9"),u=(u^u>>BigInt(27))*V("0x94d049bb133111eb"),u^u>>BigInt(31)}let r=[];for(let u=0;u<t;u++)r.push(n());return r}function V(e){return BigInt.asUintN(64,BigInt(e))}function Pn(e,t){return e=V(e),t=BigInt(t),V(V(e<<t)|V(e>>V(BigInt(64)-t)))}function qn(e){if(typeof e=="bigint"&&(e=Number(e)),v(e))return U(M);{h(y(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=Au(Math.floor(e),4);M[0]=t[0],M[1]=t[1],M[2]=t[2],M[3]=t[3]}}function kn(){let e=V(Pn(M[0]+M[3],23)+M[0]),t=V(M[1]<<BigInt(17));return M[2]=V(M[2]^M[0]),M[3]=V(M[3]^M[1]),M[1]=V(M[1]^M[2]),M[0]=V(M[0]^M[3]),M[2]=V(M[2]^t),M[3]=Pn(M[3],45),Math.floor(Number(e))/zn}function Ye(e){return v(e)?kn():(p(e)||(e=[e]),et(te(ut(e)).map(kn),e))}function Dt(e){if(F(e)||D(e))return e.shuffle(...Object.values(arguments).slice(1));h(p(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let u=Math.floor(Ye()*n.length);t.push(n.splice(u,1)[0])}return t}function Iu(e,t){return v(t)&&(t=0),h(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?Dt(e.index):null,t===1?Dt(e.columns):null)}function Oe(e){return typeof e=="boolean"}function Cu(e,t,n){return $(t)?ju(e,t,n):Bu(e,t,n)}function ju(e,t,n){if(n=v(n)?0:n,h($(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),h(y(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Te(e.index,(u,o)=>t(e.get(u,null),e.get(o,null)));return e.get(r,null)}else{let r=Te(e.columns,(u,o)=>t(e.get(null,u),e.get(null,o)));return e.get(null,r)}}function Bu(e,t,n){let r=e.copy(),u=Ye().toString();r=r.assign(u,r.index),v(t)&&(t=[u],n=[!0]),(y(t)||A(t))&&(t=[t],(Oe(n)||A(n))&&(n=[n])),h(p(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),h(S(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),v(n)&&(n=K(0,t.length).map(()=>!0)),h(p(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),h(S(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),h(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(i=>{if(h(A(i)||y(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),A(i)){let s=r.columns.indexOf(i);return h(s>-1,`The column "${i}" does not exist!`),s}if(y(i))return h($e(i),"Column indices must be whole numbers!"),h(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(h(A(i)||Oe(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),A(i)){let s=i.trim().toLowerCase();return h(s==="ascending"||s==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),s==="ascending"}if(Oe(i))return i}),r.values=Te(r.values,(i,s)=>{let a=0;for(;i[t[a]]===s[t[a]]&&a<t.length;)a++;let l=n[a];if(i[t[a]]===s[t[a]])return 0;if(i[t[a]]<s[t[a]])return l?-1:1;if(i[t[a]]>s[t[a]])return l?1:-1});let o=r.columns.indexOf(u);return r.index=r.values.map(i=>i[o]),r=r.dropColumns(u),r}function Mu(e,t){v(t)?t=0:h(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,u)=>{let o={};e.columns.forEach((i,s)=>{o[i]=e.values[u][s]}),n[r]=o}):e.columns.forEach((r,u)=>{let o={};e.index.forEach((i,s)=>{o[i]=e.values[s][u]}),n[r]=o}),n}function Wn(e,t){return JSON.stringify(e.toObject(t))}async function Pu(e,t,n){let r=Wn(e,n),u=!1,o=!1,i,s;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),u=!0}catch(a){i=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),o=!0}catch(a){s=a}if(!u&&!o)throw typeof window<"u"?new we(i):typeof module<"u"?new we(s):new we("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function ku(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function ye(e){if(F(e)||D(e))return e.transpose();h(p(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=S(e);if(h(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return se(e);if(t.length===2){let n=te(se(t));for(let r=0;r<t[0];r++)for(let u=0;u<t[1];u++)n[u][r]=e[r][u];return n}}function Hn(e,t,n){if(D(n))return new e(t.values.concat(n.values));if(p(n)){let r=S(n);h(r.length===1&&!Ot(r),"Only vectors can be appended to Series!");let u=t.copy();return n.forEach((o,i)=>{u._values.push(o),u._index.push("item"+(t.values.length+i))}),u}return Hn(t,[n])}function Ru(e,t){h($(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,u)=>t(r,u)),n}function Ju(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,u)=>v(r)?!1:(n.push(t.index[u]),!0)),t._index=n,t}function Ku(e,t){let n=[],r=[];t.values.forEach((o,i)=>{y(o)&&(r.push(o),n.push(t.index[i]))});let u=new e(r);return u.name=t.name,u.index=n,u}function $u(e,t,n){let r=t.copy(),u=U(r.index),o=[],i=r.values.filter((s,a)=>{let l=n(s,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(s=>{u.splice(u.indexOf(s),1)}),i.length===0?(r=new e,r.name=t.name,r):(r.values=i,r.index=u,r)}function Yu(e,t){(A(t)||y(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Q((t||[]).map(r=>typeof r));return h(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&h(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(h(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),h(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),v(t)||(t=t.map(r=>{if(typeof r=="string")return h(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return h(r>=0,`Index ${r} is out of bounds!`),h(Math.floor(r)===r,"Indices must be integers!"),h(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function Uu(e,t){let n=e.shape;v(t)&&(t=K(0,n[0])),h(p(t),"The `indices` array must be 1-dimensional array of whole numbers."),h(S(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),h(t.length>0,"The `indices` array must contain at least one index."),t.forEach(u=>{h($e(u),"The `indices` array must be a 1-dimensional array of whole numbers."),h(u<e.index.length,`The row index ${u} is out of bounds.`)});let r=t.map(u=>e.index[u]);return e.getSubsetByNames(r)}function Lu(e,t,n){v(n)&&(n=t.index),h(p(n),"The `indices` array must be a 1-dimensional array of strings."),h(S(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),h(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{h(A(o),"The `indices` array must contain only strings."),h(t.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>t.values[t.index.indexOf(o)]);if(r.length===1)return r[0];let u=new e(r);return u.index=n,u.name=t.name,u}function Vu(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(K(0,n/2).concat(K(t.index.length-n/2,t.index.length)));let u=U(t.index);u.splice(Math.floor(u.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(u)}let r={};return t.values.forEach((u,o)=>{let i={};i[t.name]=u,r[t.index[o]]=i}),console.table(r),console.log("Shape:",e.shape,`
`),e}function Gu(e){let t=e.copy();return t.get(Dt(t.index))}function zu(e,t,n){n=n||((a,l)=>a<l?-1:1),h(v(n)||$(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=ye([t.values,t.index]),u=Te(r,(a,l)=>n(a[0],l[0])),o=[],i=[];u.forEach(a=>{o.push(a[0]),i.push(a[1])});let s=new e;return s._values=o,s._index=i,s.name=t.name,s}function qu(e,t){let n=ye([t.values,t.index]);n=ye(Te(n,(u,o)=>{if(u[1]===o[1])return 0;if(u[1]<o[1])return-1;if(u[1]>o[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function Wu(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Rn=Symbol.for("@jrc03c/js-math-tools/series");function Hu(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Rn}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Rn}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(u){h(p(u),"The new values must be a 1-dimensional array!");let o=S(u);h(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<this._index.length?this._index=this._index.slice(0,o[0]):o[0]>this._index.length&&(this._index=this._index.concat(K(this._index.length,o[0]).map(i=>"item"+Re(i,(u.length-1).toString().length)))),this._values=u}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(u){h(p(u),"The new index must be a 1-dimensional array of strings!"),h(u.length===this.shape[0],"The new index must be the same length as the old index!"),h(S(u).length===1,"The new index must be a 1-dimensional array of strings!"),u.forEach(o=>{h(A(o),"All of the row names must be strings!")}),this._index=u}}),r){if(r instanceof t)this.name=r.name,this.values=U(r.values),this.index=U(r.index);else if(p(r)){let u=S(r);h(u.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let u=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(s=>s.toString());h(u.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=u[0],i=r[o];h(S(i).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=o,this.values=i.slice()}}}get shape(){return S(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!v(r)).length===0}clear(){let r=this.copy();return r.values.forEach((u,o)=>{r.values[o]=void 0}),r}get(r){return Yu(this,r)}getSubsetByNames(r){return Lu(t,this,r)}getSubsetByIndices(r){return Uu(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(se(this.values));return r.index=se(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=K(0,this.shape[0]).map(u=>"item"+Re(u,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=U(this.values),r._index=U(this.index),r.name=this.name,r}append(r){return Hn(t,this,r)}apply(r){return Ru(this,r)}concat(r){return this.append(r)}dropMissing(r,u){return Ju(this,r,u)}dropNaN(){return Ku(t,this)}toObject(){return Wu(this)}print(){return Vu(this)}shuffle(){return Gu(this)}sort(r){return zu(t,this,r)}sortByIndex(){return qu(t,this)}filter(r){return $u(t,this,r)}toDataFrame(){let r=new e(ye([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=se(r.values),r.index=se(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Jn=Symbol.for("@jrc03c/js-math-tools/dataframe");function gt(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(Ye()*t.length)];return n}var k=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Jn}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Jn}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!v(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){h(p(t),"The new values must be a 2-dimensional array!");let n=S(t);h(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(K(this._index.length,n[0]).map(r=>"row"+Re(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(K(this._columns.length,n[1]).map(r=>"col"+Re(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){h(p(t),"The new columns list must be a 1-dimensional array of strings!"),h(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),h(S(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+gt(8):r.trim()));let n=(()=>{let r=Nt(t),u={};return r.values.forEach(o=>{u[o]=r.get(o)}),u})();t=t.map(r=>n[r]>1?r+"_"+gt(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){h(p(t),"The new index must be a 1-dimensional array of strings!"),h(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),h(S(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+gt(8):r.trim()));let n=(()=>{let r=Nt(t),u={};return r.values.forEach(o=>{u[o]=r.get(o)}),u})();t=t.map(r=>n[r]>1?r+"_"+gt(8):r),this._index=t}}),h(v(e)||ae(e)||p(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof k)this.values=U(e.values),this.columns=U(e.columns),this.index=U(e.index);else if(p(e)){let t=S(e);h(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),h(!nt(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(o=>o.toString());let t=[],n=null,r=null;this._columns.forEach(o=>{v(r)&&(n=o,r=e[o].length),h(e[o].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${o}" points to an array containing ${e[o].length} items.`),r=e[o].length;let i=e[o];t.push(i)}),this._values=ye(t);let u=S(this.values);this._index=K(0,u[0]).map(o=>"row"+Re(o,(u[0]-1).toString().length))}}get shape(){return S(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new k(te(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return Nu(this,e,t)}getSubsetByNames(e,t){return Fu(k,z,this,e,t)}getSubsetByIndices(e,t){return Su(this,e,t)}getDummies(e){return Mn(k,this,e)}oneHotEncode(e){return Mn(k,this,e)}transpose(){let e=new k(ye(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return Tu(this,e)}copy(){return pu(k,this)}assign(e,t){return gu(k,z,this,e,t)}apply(e,t){return du(k,z,this,e,t)}dropMissing(e,t,n){return bu(k,z,this,e,t,n)}dropNaN(e,t,n){return vu(k,this,e,t,n)}drop(e,t){return yu(k,z,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return Mu(this,e)}toObject(){return ku(this)}toJSONString(e){return Wn(this,e)}saveAsJSON(e,t){return Pu(this,e,t)}print(){return Ou(k,z,this)}sort(e,t){return Cu(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return wu(k,z,this,e,t)}shuffle(e){return Iu(this,e)}append(e,t){return Vn(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},z=Hu(k);function Tt(e,t){return H(e,{shouldDropNaNs:t}).max}function j(e){return h($(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,u=[],o=[],i=Object.keys(arguments).filter(s=>{let a=arguments[s];return p(a)?!0:D(a)?(n=!0,u.push(a),!0):F(a)?(r=!0,o.push(a),!0):!1}).map(s=>arguments[s]);if(i.slice(0,-1).forEach((s,a)=>{h(x(p(s)?S(s):s.shape,p(i[a+1])?S(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let s=Tt(i.map(l=>l.length?l.length:l.values.length)),a=K(0,s).map(l=>{let c=Object.keys(arguments).map(m=>p(arguments[m])?arguments[m][l]:D(arguments[m])||F(arguments[m])?arguments[m].values[l]:arguments[m]);return t(...c)});if(r)try{if(o.length===1&&x(S(o[0]),S(a))){let l=new k(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new k(a)}catch{return a}if(n)try{if(u.length===1&&u[0].length===a.length){let l=new z(a);return l.name=u[0].name,l.index=u[0].index.slice(),l}else return new z(a)}catch{return a}return a}else return e(...arguments)}}function Xu(e){try{return y(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var on=j(Xu);function Zu(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!y(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Et=j(Zu);function Qu(e,t){try{return t(e)}catch{return NaN}}var _t=j(Qu);function xu(e){try{return y(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var eo=j(xu);function to(e){try{return y(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var no=j(to);function ro(e){try{return y(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var uo=j(ro);function Wt(e,t){if(F(e)){let n=Wt(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(D(e)){let n=Wt(e.values,t);return e.index[n]}h(p(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=Je(e,Tt(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Xn(e,t){return H(e,{shouldDropNaNs:t}).min}function Ht(e,t){if(F(e)){let n=Ht(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(D(e)){let n=Ht(e.values,t);return e.index[n]}h(p(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=Je(e,Xn(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function W(e,t){if(F(e)||D(e))return e.apply(n=>W(n,t));if(p(e))return e.map(n=>W(n,t));if(t==="null")return null;if(t==="number"){if(v(e))return NaN;let n=W(e,"boolean");if(Oe(n))return n?1:0;try{JSON.parse(e)}catch{let o=W(e,"date");if(pe(o))return o.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=W(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return W(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(W(e,"int"));if(t==="boolean"){if(Oe(e))return e;if(y(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(pe(e))return e;if(v(e))return null;let n=parseFloat(e);if(!isNaN(n)){let u=new Date(e);return pe(u)?u:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(ae(e))return e;let n=W(e,"boolean");if(Oe(n))return null;try{let u=W(e,"number");if(y(u))return JSON.parse(e),null}catch{}let r=W(e,"date");if(r)return r;try{let u=JSON.parse(e);return p(u)?u.map(o=>W(o,t)):u}catch{return null}}if(t==="string")return v(e)?x(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function oo(e){try{return y(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var io=j(oo);function so(e,t){try{if(!y(e))return NaN;if(typeof e=="bigint")return e;if(v(t))t=1e-10;else if(!y(t))return NaN;return on(e)<t?0:e}catch{return NaN}}var ao=j(so);function Xt(e){if(F(e)||D(e)){let t=e.copy();return t.values=Xt(t.values),t}if(p(e))return e.map(t=>Xt(t));try{let t=JSON.parse(e);return y(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var le=j(Xt);function Zn(e,t,n){try{return y(e)?y(t)?y(n)?typeof e=="bigint"?BigInt(Zn(le(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var lo=j(Zn);function St(e,t){function*n(r,u){if(u>r.length)yield r;else if(u<=0)yield[];else if(r.length<2)yield r;else for(let o=0;o<r.length;o++){let i=r[o],s=r.slice(o+1);if(!(s.length<u-1)&&u-1>=0)for(let a of St(s,u-1))yield[i].concat(a)}}return F(e)||D(e)?St(e.values,t):(h(p(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),h(y(t)&&le(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(ne(e),t))}function Qn(e,t){let n=[];for(let r of St(e,t))n.push(r.slice());return n}function xn(){let e=Object.values(arguments).map(n=>F(n)||D(n)?Q(n.values):(h(p(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Q(n)));return Q(e).filter(n=>e.every(r=>r.findIndex(u=>x(u,n))>-1))}var Ze=class{constructor(e){h(v(e)||e===Ze.DROP_NAN_MODE||e===Ze.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=v(e)?Ze.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(p(t)){let n=S(t);if(n.length===1)t=new z(t);else if(n.length===2)t=new k(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}h(F(t)||D(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===Ze.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=xn(...e),this}transform(){h(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(p(t)){let n=S(t);if(n.length===1)return new z(t).get(this.index).values;if(n.length===2)return new k(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return h(F(t)||D(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},At=Ze;Yn(At,"DROP_NAN_MODE","DROP_NAN_MODE");Yn(At,"DROP_MISSING_MODE","DROP_MISSING_MODE");function xe(e,t,n,r){if(D(e))return xe(e.values,t,n,r);if(D(t))return xe(e,t.values,n,r);if(h(p(e)&&p(t)&&S(e).length===1&&S(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),h(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return xe(...new At().fitAndTransform(e,t),!1,r);try{let u=H(e,{stdev:r}),o=H(t,{stdev:r}),i=Number(u.mean),s=Number(o.mean);if(!y(i)||!y(s))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let m=e[c],d=t[c];if(!y(m))return NaN;if(!y(d))return NaN;typeof m=="bigint"&&(m=Number(m)),typeof d=="bigint"&&(d=Number(d)),l+=(m-i)*(d-s)}return r?[l/e.length,u,o]:l/e.length}catch{return NaN}}function Zt(e,t,n){if(D(e))return Zt(e.values,t,n);if(D(t))return Zt(e,t.values,n);h(p(e)&&p(t)&&S(e).length===1&&S(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),h(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[u,o,i]=xe(e,t,n,!0),s=o.stdev*i.stdev;return u/s}catch{return NaN}}function co(e){try{return y(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var fo=j(co),ho=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Qt(e,t){if(F(e)||D(e))return Qt(e.values,t);if(F(t)||D(t))return Qt(e,t.values);h(p(e)&&p(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Q(e),r=Q(t),u=[];return n.forEach(o=>{r.findIndex(i=>x(i,o))<0&&u.push(o)}),u}function er(e,t){try{if(!y(e))return NaN;if(!y(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=er(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var sn=j(er);function tr(e){try{if(!y(e))return NaN;if(typeof e=="bigint"){let t=tr(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var nr=j(tr);function mo(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!y(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var rr=j(mo);function Ue(){return rr(...arguments)}function ur(e,t){return Et(e,Ue(t,-1))}function an(e,t){return H(e,{shouldDropNaNs:t}).sum}function xt(e,t){if(y(e)&&y(t))return on(e-t);if(F(e)||D(e))return xt(e.values,t);if(F(t)||D(t))return xt(e,t.values);p(e)&&p(t)&&h(x(S(e),S(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return nr(an(sn(ur(e,t),2)))}catch{return NaN}}function go(e,t){return Ue(e,sn(t,-1))}function ge(e,t){if(F(e)){let u=ge(e.values,t);if(S(u).length===1){let o=new z(u);return o.name=D(t)?t.name:o.name,o.index=e.index.slice(),o}else{let o=new k(u);return o.index=e.index.slice(),F(t)&&(o.columns=t.columns.slice()),o}}if(F(t)){let u=ge(e,t.values);if(S(u).length===1){let o=new z(u);return o.name=D(e)?e.name:o.name,o.index=t.columns.slice(),o}else{let o=new k(u);return o.columns=t.columns.slice(),o}}if(D(e))return ge(e.values,t);if(D(t))return ge(e,t.values);h(p(e)&&p(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=S(e),r=S(t);if(h(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),h(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return an(Ue(e,t));if(n.length===1&&r.length===2)return ye(t).map(u=>ge(e,u));if(n.length===2&&r.length===1)return e.map(u=>ge(u,t));if(n.length===2&&r.length===2){let u=ye(t),o=[];for(let i=0;i<e.length;i++){let s=[];for(let a=0;a<u.length;a++)s.push(ge(e[i],u[a]));o.push(s)}return o}}function ln(e){if(F(e)||D(e))return e.dropMissing(...Object.values(arguments).slice(1));h(p(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(ln(n))}catch{v(n)||t.push(n)}}),t}function yt(e,t){if(F(e)||D(e))return yt(e.values,t);if(F(t)||D(t))return yt(e,t.values);h(p(e)&&p(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),h(x(S(e),S(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let u=0;u<e.length;u++)try{let[o,i]=yt(e[u],t[u]);n.push(o),r.push(i)}catch{!v(e[u])&&!v(t[u])&&(n.push(e[u]),r.push(t[u]))}return[n,r]}function bt(e,t){if(F(e)||D(e))return bt(e.values,t);if(F(t)||D(t))return bt(e,t.values);h(p(e)&&p(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),h(x(S(e),S(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let u=0;u<e.length;u++)try{let[o,i]=bt(e[u],t[u]);n.push(o),r.push(i)}catch{y(e[u])&&y(t[u])&&(n.push(e[u]),r.push(t[u]))}return[n,r]}function po(e){return ln(e)}function Ft(e,t){if(F(e)||D(e))return Ft(e.values,t);h(p(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),h($(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(p(n)){if(!Ft(n,t))return!1}else if(!t(n))return!1;return!0}function yo(e){try{if(!y(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var bo=j(yo);function en(e){try{return typeof e=="bigint"?BigInt(en(le(e))):e!==le(e)?NaN:e<=1?1:e*en(e-1)}catch{return NaN}}var vo=j(en);function tn(e,t){if(F(e)||D(e))return tn(e.values,t);if(h(ae(e)||p(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!$(t)){let u=t;t=o=>o===u}function n(u,o,i){if(i=i||[],i.indexOf(u)>-1)return null;if(ae(u)){i.push(u);let s=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let a=0;a<s.length;a++){let l=s[a],c=u[l];if(o(c))return c;let m=n(c,o,i);if(m)return m}}else if(p(u)){i.push(u);for(let s=0;s<u.length;s++){let a=u[s];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(u))return u;return null}function r(u){try{return t(u)}catch{return!1}}return n(e,r)}function nn(e,t){if(F(e)||D(e))return nn(e.values,t);if(h(ae(e)||p(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!$(t)){let o=t;t=i=>i===o}function n(o,i,s){if(s=s||[],s.indexOf(o)>-1)return null;if(ae(o)){s.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o)),l=[];for(let c=0;c<a.length;c++){let m=a[c],d=o[m],w=!1;i(d)&&(l.push(d),w=!0);let _=n(d,i,s);_&&_.length>0&&_.slice(w?1:0).forEach(I=>l.push(I))}return l}else if(p(o)){s.push(o);let a=[];for(let l=0;l<o.length;l++){let c=o[l],m=!1;i(c)&&(a.push(c),m=!0);let d=n(c,i,s);d&&d.length>0&&d.slice(m?1:0).forEach(w=>a.push(w))}return a}else if(i(o))return[o];return null}function r(o){try{return t(o)}catch{return!1}}let u=n(e,r);return u&&u.length>0?u:null}function wo(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return y(t)?t:NaN}catch{return NaN}}var No=j(wo);function Do(e){try{return y(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var Eo=j(Do);function cn(e){y(e)&&(e=[e]);let t=[],n=ut(e);for(let r=0;r<n;r++)t.push(0);return et(t,e)}function So(e){typeof e=="bigint"&&(e=le(e)),h(!v(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),h(y(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),h(le(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),h(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=cn([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var Fo=["true","false","yes","no"],Oo=["null","none","nan","na","n/a","","undefined"];function pt(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=le(e.value)===e.value:e.isInteger=Ft(e.values,t=>y(t)?le(t)===t:!0)),e}function vt(e){if(F(e)){let o=e.copy(),i=vt(e.values);return o.values=i.values,pt({type:i.type,values:o})}if(D(e)){let o=e.copy(),i=vt(e.values);return o.values=i.values,pt({type:i.type,values:o})}if(!p(e)){let o=vt([e]);return o.value=o.values[0],delete o.values,pt(o)}h(p(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=ne(e).map(o=>{if(o===void 0)return"null";try{if(typeof o=="object"){let a=new Date(o.getTime());if(pe(a))return"date"}}catch{}A(o)||(typeof o=="bigint"?o=o.toString()+"n":o=JSON.stringify(o));let s=o.toLowerCase().trim();if(Oo.indexOf(s)>-1)return"null";if(Fo.indexOf(s)>-1)return"boolean";try{if(o.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(o);return y(a)?"number":typeof a=="object"?p(a)?"string":"object":"string"}catch{let l=new Date(o);return pe(l)?"date":"string"}}),n=Nt(t),u=n.values.toSorted((o,i)=>n.get(i)-n.get(o))[0];return pt({type:u,values:_t(e,o=>W(o,u))})}function wt(e){if(F(e)){let n=e.copy();return n.values=wt(n.values),n}h(p(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=S(e);if(h(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),h(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),h(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){h(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],u=e[1][0],o=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof u=="bigint"&&(u=Number(u)),typeof o=="bigint"&&(o=Number(o));let i=n*o-r*u;h(i!==0,"This matrix cannot be inverted!");let s=[[o,-r],[-u,n]];return Ue(s,1/i)}else if(t[0]>1){let n=(r,u)=>y(r)||y(u)?Ue(r,u):ge(r,u);for(let r=1;r<t[0]-1;r++)try{let u=e.slice(0,r).map(I=>I.slice(0,r)),o=e.slice(0,r).map(I=>I.slice(r,t[0])),i=e.slice(r,t[0]).map(I=>I.slice(0,r)),s=e.slice(r,t[0]).map(I=>I.slice(r,t[0])),a=wt(u),l=wt(Et(s,n(-1,n(n(i,a),o)))),c=Et(a,n(n(n(n(a,o),l),i),a)),m=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),w=l;return c.map((I,Se)=>I.concat(m[Se])).concat(d.map((I,Se)=>I.concat(w[Se])))}catch{}h(!1,"This matrix cannot be inverted!")}}var To=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function or(e,t,n){try{if(!y(e))return NaN;if(!y(t))return NaN;if(!y(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=or(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var _o=j(or);function ir(e,t){try{if(t=v(t)?Math.E:t,!y(e))return NaN;if(!y(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=ir(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var Ao=j(ir);function Io(e,t){return H(e,{shouldDropNaNs:t}).mean}function Co(e,t){return H(e,{shouldDropNaNs:t,median:!0}).median}function sr(e,t){try{if(!y(e))return NaN;if(!y(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=sr(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var jo=j(sr);function Bo(e,t){return H(e,{shouldDropNaNs:t,mode:!0}).mode}function Kn(){let e=Ye(),t=Ye();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function Mo(e){return v(e)?Kn():_t(te(e),Kn)}function Po(e){return _t(te(e),()=>1)}function fn(e,t){function*n(r,u){if(u=u||r.length,r.length===1){yield[r];return}for(let o of Qn(r,u)){if(!o.slice)continue;let i=cn(o.length);yield o;let s=1;for(;s<o.length;)if(i[s]<s){if(s%2===0){let a=o[0];o[0]=o[s],o[s]=a}else{let a=o[i[s]];o[i[s]]=o[s],o[s]=a}yield o,i[s]+=1,s=1}else i[s]=0,s+=1}}return F(e)||D(e)?fn(e.values,t):(h(p(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),v(t)&&(t=e.length),h(y(t)&&le(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(ne(e),t))}function ko(e,t){let n=[];for(let r of fn(e,t))n.push(r.slice());return n}function Ro(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(p(t))if(nt(t))console.log(t);else{let n=S(t);n.length===1?new z(t).print():n.length==2?new k(t).print():console.log(t)}else F(t)||D(t)?t.print():console.log(t)})}var Jo=j((e,t,n,r,u)=>{try{let o=!1;for(let l of[e,t,n,r,u]){if(!y(l))return NaN;typeof l=="bigint"&&(o=!0)}o&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),u=Number(u));let i=(u-r)*(e-t),s=n-t;if(s===0)return NaN;let a=i/s+r;if(o)try{return BigInt(a)}catch{}return a}catch{return NaN}});function Ko(e,t,n,r,u){if(p(e)&&v(r)&&v(u)){r=t,u=n;let o=H(e);t=o.min,n=o.max}return Jo(e,t,n,r,u)}function $o(e){try{return y(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var Yo=j($o);function ar(e){try{return y(e)?typeof e=="bigint"?BigInt(ar(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var Uo=j(ar);function Lo(e){try{return y(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Vo=j(Lo);function rn(e,t){if(F(e)||D(e))return rn(e.values,t);h(p(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),h($(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(p(n)){if(rn(n,t))return!0}else if(t(n))return!0;return!1}function lr(e,t){return H(e,{shouldDropNaNs:t,stdev:!0}).stdev}function Go(e){return lr(e)}function zo(e){try{return y(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var qo=j(zo);function $n(e,t){h($(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function Wo(e,t){h($(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function Ho(){return Q([...arguments].map(e=>p(e)?e:F(e)||D(e)?e.values:[e]))}function Xo(e,t){return H(e,{shouldDropNaNs:t,variance:!0}).variance}function Zo(){let e=[],t=Object.values(arguments).map(n=>((F(n)||D(n))&&(n=n.values),h(p(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return K(0,Tt(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(u=>{let o=u[n];r.push(v(o)?void 0:o)}),e.push(r)}),e}var Qe={abs:on,add:Et,apply:_t,arccos:eo,arcsin:no,arctan:uo,argmax:Wt,argmin:Ht,assert:h,cast:W,ceil:io,chop:ao,clamp:lo,combinations:Qn,combinationsIterator:St,copy:U,correl:Zt,cos:fo,count:Nt,covariance:xe,DataFrame:k,dataTypes:ho,decycle:Ke,diff:Qt,distance:xt,divide:go,dot:ge,dropMissing:ln,dropMissingPairwise:yt,dropNaN:un,dropNaNPairwise:bt,dropUndefined:po,every:Ft,exp:bo,factorial:vo,find:tn,findAll:nn,flatten:ne,float:No,floor:Eo,identity:So,IndexMatcher:At,indexOf:Je,inferType:vt,int:le,intersect:xn,inverse:wt,isArray:p,isBoolean:Oe,isBrowser:To,isDataFrame:F,isDate:pe,isEqual:x,isFunction:$,isJagged:nt,isNested:Ot,isNumber:y,isObject:ae,isSeries:D,isString:A,isUndefined:v,lerp:_o,log:Ao,MathError:we,max:Tt,mean:Io,median:Co,min:Xn,mod:jo,mode:Bo,multiply:rr,ndarray:te,normal:Mo,ones:Po,permutations:ko,permutationsIterator:fn,pow:sn,print:Ro,product:ut,random:Ye,range:K,remap:Ko,reshape:et,reverse:se,round:Yo,scale:Ue,seed:qn,Series:z,set:Q,shape:S,shuffle:Dt,sign:Uo,sin:Vo,some:rn,sort:Te,sqrt:nr,stats:H,std:lr,stdev:Go,subtract:ur,sum:an,tan:qo,timeAsync:Wo,timeSync:$n,time:$n,transpose:ye,union:Ho,variance:Xo,vectorize:j,zeros:cn,zip:Zo,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Qe.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Qe).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Qe[t]})}catch{e[t]=Qe[t]}})}};typeof window<"u"&&(window.JSMathTools=Qe);function Dr(e){if(typeof e!="string")throw new Error("`text` must be a string!");e=e.trim();let t="",n=!1;for(let r=0;r<e.length;r++){let u=e[r];u.match(/[A-Za-z0-9]/g)?(t.length===0?t+=u.toLowerCase():n?t+=u.toUpperCase():t+=u,n=!1):!u.includes("'")&&!u.includes("\u2019")&&!u.includes("\u275C")&&(n=!0)}return t}var Qo=Object.defineProperty,xo=(e,t,n)=>t in e?Qo(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Er=(e,t,n)=>(xo(e,typeof t!="symbol"?t+"":t,n),n);function b(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var ei=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),De=class extends Error{constructor(e){ei()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function f(e,t){if(!e)throw new De(t)}var Sr=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function N(e){return e===null||typeof e>"u"}var ti=Sr.map(e=>e.name);function g(e){try{return e instanceof Array?!0:N(e.constructor)?!1:Sr.indexOf(e.constructor)>-1||ti.indexOf(e.constructor.name)>-1}catch{return!1}}function T(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function Y(e){return typeof e=="function"}function fe(e){return typeof e=="object"&&!N(e)&&!g(e)}function E(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function qe(e,t){if(T(e)){let o=qe(e.values,t);return o.length>0&&b(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o.length>1&&b(o[1])&&o[1]>=0&&o[1]<e.columns.length&&(o[1]=e.columns[o[1]]),o}if(E(e)){let o=qe(e.values,t);return o.length>0&&b(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o}if(f(fe(e)||g(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Y(t)){let o=t;t=i=>i===o}function n(o,i,s){if(s=s||[],s.indexOf(o)>-1)return null;if(fe(o)){s.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let l=0;l<a.length;l++){let c=a[l],m=o[c];if(i(m))return[c];let d=n(m,i,s);if(d&&d.length>0)return[c].concat(d)}}else if(g(o)){s.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let c=n(l,i,s);if(c&&c.length>0)return[a].concat(c)}}else if(i(o))return[];return null}function r(o){try{return t(o)}catch{return!1}}let u=n(e,r);return u&&u.length>0?u:null}function L(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(g(n))return n instanceof Array?n.map(u=>L(u)):n.slice();if(E(n)){let u=n.copy();return u.values=L(u.values),u}if(T(n)){let u=n.copy();return u.values=L(n.values),u}if(n instanceof Date)return new Date(n.getTime());n=Ae(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(u=>{r[u]=L(n[u])}),r}else return n}return t(Ae(e))}function Ae(e){function t(u,o,i){if(o=o||[],i=i||"",o.indexOf(u)>-1){let s=i.split("/").slice(i.startsWith("/")?1:0);if(s.some((l,c)=>{let m=s.slice(0,s.length-c-1),d=n;return m.forEach(w=>{d=d[w]}),d===u}))return`<reference to "${n===u?"/":"/"+qe(n,u).join("/")}">`}return typeof u=="object"?u===null?null:(o.push(u),g(u)?typeof u.constructor<"u"&&u.constructor.name!=="Array"?u.slice():u.map((s,a)=>t(s,o,i+"/"+a)):(Object.keys(u).concat(Object.getOwnPropertySymbols(u)).forEach(s=>{u[s]=t(u[s],o,i+"/"+s.toString())}),u)):u}let n=e,r=t(n);if(T(e)){let u=e.copy();u._values=r.values,u._columns=r.columns,u._index=r.index,r=u}if(E(e)){let u=e.copy();u.name=r.name,u._values=r.values,u._index=r.index,r=u}return r}function ue(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var cr=["number","int","float","bigint"];function he(e,t){function n(r,u){let o=typeof r,i=typeof u;if(o!==i&&!cr.includes(o)&&!cr.includes(i))return!1;if(o==="undefined"&&i==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===u;if(o==="number"||o==="bigint")try{let s=r.toString(),a=u.toString();return s===a}catch{return!1}if(o==="string"||o==="function")return r===u;if(o==="object"){if(r===null||u===null)return r===null&&u===null;{if(ue(r))return ue(u)?r.getTime()===u.getTime():!1;if(ue(u))return!1;if(r instanceof RegExp&&u instanceof RegExp)return r.toString()===u.toString();if(g(r)!==g(u))return!1;let s=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));if(s.length!==a.length)return!1;for(let l=0;l<s.length;l++){let c=s[l];if(!n(r[c],u[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Ae(e),Ae(t))}}function ct(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var ni=ct(16),ri=ct(16),ui=ct(16),oi=ct(16),ii=ct(16),si=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)g(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?ni:N(e)?ri:Y(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+ii:e===1/0?ui:e===-1/0?oi:typeof e=="bigint"?e.toString():T(e)?e.toJSONString():E(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!N(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function oe(e){if(T(e)||E(e))return oe(e.values);f(g(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(u=>{g(u)?r=r.concat(t(u)):r.push(u)}),r}return t(e)}function Z(e,t){t=t||{};let n=new si,r={},u=oe(e),o=[],i=-1/0,s=1/0,a=!1,l=0;for(let m of u){if(typeof m=="bigint"&&(a=!0),!t.shouldDropNaNs||b(m))try{m>i&&(i=m),m<s&&(s=m),l+=Number(m),o.push(m)}catch{i=NaN,s=NaN,l=NaN}n.increment(m)}let c=l/o.length;if(r.counts=n,r.max=i,r.mean=c,r.min=s,r.n=u.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=o.length),t.mode){let m=Array.from(n.values.map(_=>[_,n.get(_)])).toSorted((_,I)=>I[1]-_[1]),d=m[0][1],w=[];for(let _ of m)if(_[1]==d)w.push(_[0]);else break;r.mode=w.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let m=o.toSorted((w,_)=>Number(w)-Number(_)),d=Math.floor(m.length/2);if(m.length%2===0){let w=m[d-1],_=m[d];if(r.median=(Number(w)+Number(_))/2,a&&typeof w=="bigint"&&typeof _=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=m[d]}if(t.stdev||t.variance){let m=0;for(let w of o)m+=Math.pow(Number(w)-c,2);m/=o.length;let d=Math.sqrt(m);r.stdev=d,r.variance=m}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(m=>{try{return BigInt(m)}catch{return m}}))}return r}function kt(e,t){let{counts:n}=Z(e);return N(t)||(Y(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{he(r,t)||n.delete(r)})),n}function hn(e){if(T(e)||E(e))return hn(e.values);if(g(e)){let t=!1,n=!1,r=null;for(let u of e){if(hn(u))return!0;if(g(u)){if(r===null)r=u.length;else if(u.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function ft(e){return hn(Ae(e))}function Yt(e){if(T(e)||E(e))return Yt(e.values);f(g(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(g(e[t]))return!0;return!1}var Le="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function re(e){f(!N(e),Le),g(e)||(e=[e]),f(!Yt(e),Le),f(e.length>0,Le);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),f(b(t),Le),f(t>=0,Le),f(Math.floor(t)===t,Le),f(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(re(e.slice(1)));return n}}function ce(e){if(T(e)||E(e)){let n=e.copy();return n.values=ce(n.values),n.index=ce(n.index),n}f(g(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function J(e,t,n=1){f(!N(e)&&!N(t)&&!N(n),"You must pass two numbers and optionally a step value to the `range` function!"),f(b(e)&&b(t)&&b(n),"You must pass two numbers and optionally a step value to the `range` function!"),f(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,u=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let i=e;e=t+n,t=i+n}let o=[];for(let i=e;i<t;i+=n)if(u)try{o.push(BigInt(i))}catch{o.push(i)}else o.push(i);return r&&(o=ce(o)),o}function ht(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var ai=ht(256),li=ht(256),ci=ht(256),fi=ht(256),hi=ht(256);function ee(e){if(T(e)||E(e))return ee(e.values);f(g(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return oe(e).forEach(r=>{let u=typeof r=="object"&&r===null?ai:N(r)?li:Y(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+hi:r===1/0?ci:r===-1/0?fi:typeof r=="bigint"?r.toString():T(r)?r.toJSONString():E(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[u]||t.push(r),n[u]=!0}),t}function Fr(e){if(g(e)){let t=Fr(e[0]);return[e.length].concat(t||[])}else return}function O(e){return T(e)||E(e)?O(e.values):(f(g(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Fr(e))}function Or(e,t,n){if(N(n)&&(n=0),f(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),g(t)){f(!ft(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=O(t);if(r.length===1)if(n===0){let u=e.copy();u._values.push(t);let o=Math.max(e.shape[1],r[0]);for(u._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let u=Math.max(e.shape[0],r[0]),o=e.copy();for(J(0,u).forEach(i=>{i>=o._values.length&&o._values.push(re(e.shape[1])),o._values[i].push(t[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let u=Math.max(...t.map(i=>i.length).concat([e.shape[1]])),o=e.copy();for(o._values=o._values.concat(t).map(i=>{for(;i.length<u;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let u=Math.max(...t.map(s=>s.length))+e.shape[1],o=Math.max(e.shape[0],r[0]),i=e.copy();for(J(0,o).forEach(s=>{for(s>=i._values.length&&i._values.push(re(e.shape[1])),i._values[s]=i._values[s].concat(t[s]);i._values[s].length<u;)i._values[s].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<u;)i._columns.push("col"+i._columns.length);return i}else throw new De("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(E(t)){let r=Or(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(T(t))if(n===0){let r=e.copy(),u=ee(r._columns.concat(t._columns)).length;for(r._values.forEach(o=>{for(;o.length<u;)o.push(void 0)}),t.apply(o=>{let i=o.copy(),s=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(s.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):s.push(void 0)}),r._values.push(s.concat(i._values))},1),r._columns=r._columns.concat(t._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(e._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((u,o)=>{let i=t._index.indexOf(u);i>-1?r._values[o]=r._values[o].concat(t._values[i]):r._values[o]=r._values[o].concat(re(t.shape[1]))}),t._index.forEach((u,o)=>{r._index.indexOf(u)<0&&(r._index.push(u),r._values.push(re(r._columns.length).concat(t._values[o])))}),r._columns=r._columns.concat(t._columns.map(u=>u+(r._columns.indexOf(u)>-1?" (2)":""))),r}else throw new De("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function mi(e,t,n,r,u){if(u=u||0,f(Y(r),"The first parameter to the `apply` method must be a function."),f(u===0||u===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),u===0){let o={},i;if(n.columns.forEach((s,a)=>{let l=new t(n.values.map(m=>m[a]));l.name=s,l.index=n.index;let c=r(l,a,n);c instanceof t?o[s]=c.values:o[s]=c,N(i)&&(i=c instanceof t||g(c))}),i){let s=new e(o);return s.index=n.index,s}else{let s=new t(n.columns.map(a=>o[a]));return s.index=n.columns,s}}else if(u===1){let o,i=n.values.map((s,a)=>{let l=new t(s);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return N(o)&&(o=c instanceof t||g(c)),c instanceof t?c.values:c});if(o){let s=new e(i);return s.index=n.index,s.columns=n.columns,s}else{let s=new t(i);return s.index=n.index,s}}}function C(e){return typeof e=="string"}function di(e,t,n,r,u){let o=s=>s instanceof e,i=s=>s instanceof t;if(N(u)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(fe(r)){let s=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<s;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new De("You must pass a DataFrame, Series, or object into the `assign` method!")}else{f(C(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),f(g(u)&&!ft(u)&&O(u).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let s=n.append(u,1);return s.columns[s.columns.length-1]=r,s}}function gi(e,t){if(t.isEmpty)return new e;let n=new e(L(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function pi(e,t,n,r,u){N(r)&&(r=[]),N(u)&&(u=[]),(C(r)||b(r))&&(r=[r]),(C(u)||b(u))&&(u=[u]),f(g(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(g(u),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(O(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(O(u).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{u.indexOf(a)<0&&u.indexOf(l)<0&&(i||(i=[]),i.push(a))});let s=n.get(o,i);if(s instanceof t){let a=new e;a=a.assign(s),n.index.indexOf(s.name)>-1&&(a=a.transpose()),s=a}return s}function Tr(e){return b(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function We(e){return Tr(e)&&e>=0}function yi(e,t,n,r,u,o){r=r||0,f(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,f(We(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),u=o>0?"none":u||"any",f(u==="any"||u==="all"||u==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let c=0;for(let m=0;m<l.length;m++){let d=l[m];if(N(d)&&c++,c>=o)return[]}}else if(u==="any")for(let c=0;c<l.length;c++){let m=l[c];if(N(m))return[]}else if(u==="all"){for(let c=0;c<l.length;c++){let m=l[c];if(!N(m))return l}return[]}return l}let s=n.copy(),a=Math.random().toString();if(r===0){s=s.assign(a,s.index);let l=s.values.map(i).filter(m=>m.length>0);if(O(l).length<2)return new e;s.values=l;let c=s.get(null,a);if(N(c))return new e;C(c)&&(c=[c]),c instanceof t&&(c=c.values),s.index=c,s=s.drop(null,a)}else if(r===1){let l={};if(s.columns.forEach((m,d)=>{let w=s.values.map(I=>I[d]),_=i(w);_.length>0&&(l[m]=_)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=s.index,c}return s}function Sn(e){if(T(e)||E(e))return e.dropNaN(...Object.values(arguments).slice(1));f(g(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Sn(n))}catch{if(b(n))return t.push(n)}}),t}function bi(e,t,n,r,u){n=n||0,f(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),u=u||0,f(We(u),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=u>0?"none":r||"any",f(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(s){let a=Sn(s);return u>0?s.length-a.length<u:r==="any"?a.length===s.length:r==="all"?a.length>0:!0}let i=t.copy();if(n===0){let s=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return s.length>0?i.get(s,null):new e}else if(n===1){let s=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return s.length>0?i.get(null,s):new e}return i}function fr(e){let t={};return oe(e).forEach((n,r)=>{t[n]=r}),t}function Ve(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function vi(e,t,n,r,u){f(Y(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),N(u)&&(u=0),f(u===0||u===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=fr(o.index),s=fr(o.columns);if(u===0){let a=0,l=o.values.filter((c,m)=>{let d=new t(c);d.name=n.index[m],d.index=n.columns;let w=r(d,m,n);return w?a++:delete i[o.index[m]],w});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Ve(i)[0],c.index=Ve(s),c}o.values=l,o.index=Ve(i)}else if(u===1){o=o.transpose();let a=0,l=o.values.filter((c,m)=>{let d=new t(c);d.name=n.columns[m],d.index=n.index;let w=r(d,m,n);return w?a++:delete s[o.index[m]],w});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Ve(s)[0],c.index=Ve(i),c}o.values=l,o.index=Ve(s),o=o.transpose()}return o}function wi(e,t,n){(C(t)||b(t))&&(t=[t]),(C(n)||b(n))&&(n=[n]);for(let u in t)typeof t[u]=="bigint"&&(t[u]=Number(t[u]));for(let u in n)typeof n[u]=="bigint"&&(n[u]=Number(n[u]));let r=ee((t||[]).concat(n||[]).map(u=>typeof u));return f(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&f(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(f(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),f(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),N(t)||(t=t.map(u=>{if(C(u))return f(e.index.indexOf(u)>-1,`Row "${u}" does not exist!`),u;if(b(u))return f(u>=0,`Index ${u} is out of bounds!`),f(Math.floor(u)===u,"Row numbers must be integers!"),f(u<e.index.length,`Index ${u} is out of bounds!`),e.index[u]})),N(n)||(n=n.map(u=>{if(C(u))return f(e.columns.indexOf(u)>-1,`Column "${u}" does not exist!`),u;if(b(u))return f(u>=0,`Column ${u} is out of bounds!`),f(Math.floor(u)===u,"Column numbers must be integers!"),f(u<e.columns.length,`Column ${u} is out of bounds!`),e.columns[u]})),e.getSubsetByNames(t,n)}function Ni(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Ie(e,t){if(N(t)&&(t=Ni),T(e)||E(e))return e.sort(...Object.values(arguments).slice(1));f(g(e),"The `sort` function only works on arrays, Series, and DataFrames!"),f(Y(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function Di(e){let t=e.toLowerCase(),n="";for(let u=0;u<t.length;u++){let o=t[u];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(u=>u.length>0);return r[0]+r.slice(1).map(u=>u[0].toUpperCase()+u.substring(1)).join("")}function hr(e,t,n){N(n)?n=t.columns:C(n)&&(n=[n]);let r={};n.forEach(o=>{f(C(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=t.columns.indexOf(o);f(i>-1,`The given DataFrame does not have a column called "${o}"!`);let s=t.values.map(l=>l[i]),a=Ie(ee(s));s.forEach(l=>{a.forEach(c=>{let m=o+"_"+Di(c.toString());r[m]||(r[m]=[]),l===c?r[m].push(1):r[m].push(0)})})});let u=new e(r);return u.index=t.index,u}function Ei(e,t,n){let r=e.shape;N(t)&&(t=J(0,r[0])),N(n)&&(n=J(0,r[1])),b(t)&&(t=[t]),b(n)&&(n=[n]),f(g(t)&&g(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(O(t).length===1&&O(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(t.length>0,"The `rowIndices` array must contain at least one index."),f(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(i=>{f(We(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(i<e.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{f(We(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(i<e.columns.length,`The column index ${i} is out of bounds.`)});let u=t.map(i=>e.index[i]),o=n.map(i=>e.columns[i]);return e.getSubsetByNames(u,o)}function Si(e,t,n,r,u){N(r)&&(r=n.index),N(u)&&(u=n.columns),C(r)&&(r=[r]),C(u)&&(u=[u]),f(g(r)&&g(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(O(r).length===1&&O(u).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(r.length>0,"The `rows` array must contain at least one row name."),f(u.length>0,"The `cols` array must contain at least one column name."),r.forEach(s=>{f(C(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(n.index.indexOf(s)>-1,`The row name "${s}" does not exist in the list of rows.`)}),u.forEach(s=>{f(C(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(n.columns.indexOf(s)>-1,`The column name "${s}" does not exist in the list of columns.`)});let o=r.map(s=>u.map(a=>n.values[n.index.indexOf(s)][n.columns.indexOf(a)]));if(r.length===1&&u.length===1)return o[0][0];if(r.length===1){let s=new t(o[0]);return s.name=r[0],s.index=u,s}if(u.length===1){let s=new t(o.map(a=>a[0]));return s.name=u[0],s.index=r,s}let i=new e(o);return i.columns=u,i.index=r,i}function Fi(e,t,n){function r(d,w){return C(d)&&d.length>w?d.substring(0,w-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let u=typeof window>"u"?20:10,o=Math.floor(u/2),i=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,s=Math.floor(i/2),a=u>n.index.length?null:J(0,o).concat(J(n.index.length-o,n.index.length)),l=i>n.columns.length?null:J(0,s).concat(J(n.columns.length-s,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),u<=n.index.length&&(c._index.splice(o,0,"..."),c._values.splice(o,0,J(0,c.columns.length).map(()=>"..."))),i<=n.columns.length&&(c._columns.splice(s,0,"..."),c._values=c._values.map(d=>(d.splice(s,0,"..."),d)));let m=28;return c instanceof t?(c.values=c.values.map(d=>r(d,m)),c.name=r(c.name,m),c.index=c.index.map(d=>r(d,m))):(c.values=c.values.map(d=>d.map(w=>r(w,m))),c.columns=c.columns.map(d=>r(d,m)),c.index=c.index.map(d=>r(d,m))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function Ge(e,t){f(b(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function Oi(e,t){let n=t?e:e.copy();return n.index=J(0,e.shape[0]).map(r=>"row"+Ge(r,(n.index.length-1).toString().length)),n}function mt(e,t){if(T(e)||E(e))return mt(e.values,t);f(g(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=oe(e),r=!1,u=1;for(let o of n){if(!b(o))if(t)o=1;else return NaN;typeof o=="bigint"&&(r=!0,o=Number(o)),u*=o}if(r)try{return BigInt(u)}catch{}return u}catch{return NaN}}function Ti(e){return Tr(e)&&e>0}function at(e,t){if(T(e)||E(e))return at(e.values,t);if(f(g(e),"The first argument passed into the `reshape` function must be an array!"),b(t)&&(t=[t]),f(g(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),f(O(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(o=>(typeof o=="bigint"&&(o=Number(o)),f(Ti(o),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(o))),t.length===0)return oe(e);let n=oe(e);if(t.length===1&&t[0]===n.length)return n;f(mt(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],u=Math.floor(n.length/t[0]);for(let o=0;o<t[0];o++){let i=n.slice(o*u,(o+1)*u);r.push(at(i,t.slice(1)))}return r}var _r=Math.pow(2,64),P=[];Ar(Math.floor(Math.random()*_r));function _i(e,t){e=G(e);function n(){e+=G("0x9e3779b97f4a7c15");let u=L(e);return u=(u^u>>BigInt(30))*G("0xbf58476d1ce4e5b9"),u=(u^u>>BigInt(27))*G("0x94d049bb133111eb"),u^u>>BigInt(31)}let r=[];for(let u=0;u<t;u++)r.push(n());return r}function G(e){return BigInt.asUintN(64,BigInt(e))}function mr(e,t){return e=G(e),t=BigInt(t),G(G(e<<t)|G(e>>G(BigInt(64)-t)))}function Ar(e){if(typeof e=="bigint"&&(e=Number(e)),N(e))return L(P);{f(b(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=_i(Math.floor(e),4);P[0]=t[0],P[1]=t[1],P[2]=t[2],P[3]=t[3]}}function dr(){let e=G(mr(P[0]+P[3],23)+P[0]),t=G(P[1]<<BigInt(17));return P[2]=G(P[2]^P[0]),P[3]=G(P[3]^P[1]),P[1]=G(P[1]^P[2]),P[0]=G(P[0]^P[3]),P[2]=G(P[2]^t),P[3]=mr(P[3],45),Math.floor(Number(e))/_r}function He(e){return N(e)?dr():(g(e)||(e=[e]),at(re(mt(e)).map(dr),e))}function Rt(e){if(T(e)||E(e))return e.shuffle(...Object.values(arguments).slice(1));f(g(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let u=Math.floor(He()*n.length);t.push(n.splice(u,1)[0])}return t}function Ai(e,t){return N(t)&&(t=0),f(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?Rt(e.index):null,t===1?Rt(e.columns):null)}function _e(e){return typeof e=="boolean"}function Ii(e,t,n){return Y(t)?Ci(e,t,n):ji(e,t,n)}function Ci(e,t,n){if(n=N(n)?0:n,f(Y(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),f(b(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Ie(e.index,(u,o)=>t(e.get(u,null),e.get(o,null)));return e.get(r,null)}else{let r=Ie(e.columns,(u,o)=>t(e.get(null,u),e.get(null,o)));return e.get(null,r)}}function ji(e,t,n){let r=e.copy(),u=He().toString();r=r.assign(u,r.index),N(t)&&(t=[u],n=[!0]),(b(t)||C(t))&&(t=[t],(_e(n)||C(n))&&(n=[n])),f(g(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),f(O(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),N(n)&&(n=J(0,t.length).map(()=>!0)),f(g(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),f(O(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),f(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(i=>{if(f(C(i)||b(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),C(i)){let s=r.columns.indexOf(i);return f(s>-1,`The column "${i}" does not exist!`),s}if(b(i))return f(We(i),"Column indices must be whole numbers!"),f(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(f(C(i)||_e(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),C(i)){let s=i.trim().toLowerCase();return f(s==="ascending"||s==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),s==="ascending"}if(_e(i))return i}),r.values=Ie(r.values,(i,s)=>{let a=0;for(;i[t[a]]===s[t[a]]&&a<t.length;)a++;let l=n[a];if(i[t[a]]===s[t[a]])return 0;if(i[t[a]]<s[t[a]])return l?-1:1;if(i[t[a]]>s[t[a]])return l?1:-1});let o=r.columns.indexOf(u);return r.index=r.values.map(i=>i[o]),r=r.dropColumns(u),r}function Bi(e,t){N(t)?t=0:f(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,u)=>{let o={};e.columns.forEach((i,s)=>{o[i]=e.values[u][s]}),n[r]=o}):e.columns.forEach((r,u)=>{let o={};e.index.forEach((i,s)=>{o[i]=e.values[s][u]}),n[r]=o}),n}function Ir(e,t){return JSON.stringify(e.toObject(t))}async function Mi(e,t,n){let r=Ir(e,n),u=!1,o=!1,i,s;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),u=!0}catch(a){i=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),o=!0}catch(a){s=a}if(!u&&!o)throw typeof window<"u"?new De(i):typeof module<"u"?new De(s):new De("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function Pi(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function ve(e){if(T(e)||E(e))return e.transpose();f(g(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=O(e);if(f(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return ce(e);if(t.length===2){let n=re(ce(t));for(let r=0;r<t[0];r++)for(let u=0;u<t[1];u++)n[u][r]=e[r][u];return n}}function Cr(e,t,n){if(E(n))return new e(t.values.concat(n.values));if(g(n)){let r=O(n);f(r.length===1&&!Yt(r),"Only vectors can be appended to Series!");let u=t.copy();return n.forEach((o,i)=>{u._values.push(o),u._index.push("item"+(t.values.length+i))}),u}return Cr(t,[n])}function ki(e,t){f(Y(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,u)=>t(r,u)),n}function Ri(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,u)=>N(r)?!1:(n.push(t.index[u]),!0)),t._index=n,t}function Ji(e,t){let n=[],r=[];t.values.forEach((o,i)=>{b(o)&&(r.push(o),n.push(t.index[i]))});let u=new e(r);return u.name=t.name,u.index=n,u}function Ki(e,t,n){let r=t.copy(),u=L(r.index),o=[],i=r.values.filter((s,a)=>{let l=n(s,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(s=>{u.splice(u.indexOf(s),1)}),i.length===0?(r=new e,r.name=t.name,r):(r.values=i,r.index=u,r)}function $i(e,t){(C(t)||b(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=ee((t||[]).map(r=>typeof r));return f(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&f(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(f(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),f(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),N(t)||(t=t.map(r=>{if(typeof r=="string")return f(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return f(r>=0,`Index ${r} is out of bounds!`),f(Math.floor(r)===r,"Indices must be integers!"),f(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function Yi(e,t){let n=e.shape;N(t)&&(t=J(0,n[0])),f(g(t),"The `indices` array must be 1-dimensional array of whole numbers."),f(O(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),f(t.length>0,"The `indices` array must contain at least one index."),t.forEach(u=>{f(We(u),"The `indices` array must be a 1-dimensional array of whole numbers."),f(u<e.index.length,`The row index ${u} is out of bounds.`)});let r=t.map(u=>e.index[u]);return e.getSubsetByNames(r)}function Ui(e,t,n){N(n)&&(n=t.index),f(g(n),"The `indices` array must be a 1-dimensional array of strings."),f(O(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),f(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{f(C(o),"The `indices` array must contain only strings."),f(t.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>t.values[t.index.indexOf(o)]);if(r.length===1)return r[0];let u=new e(r);return u.index=n,u.name=t.name,u}function Li(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(J(0,n/2).concat(J(t.index.length-n/2,t.index.length)));let u=L(t.index);u.splice(Math.floor(u.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(u)}let r={};return t.values.forEach((u,o)=>{let i={};i[t.name]=u,r[t.index[o]]=i}),console.table(r),console.log("Shape:",e.shape,`
`),e}function Vi(e){let t=e.copy();return t.get(Rt(t.index))}function Gi(e,t,n){n=n||((a,l)=>a<l?-1:1),f(N(n)||Y(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=ve([t.values,t.index]),u=Ie(r,(a,l)=>n(a[0],l[0])),o=[],i=[];u.forEach(a=>{o.push(a[0]),i.push(a[1])});let s=new e;return s._values=o,s._index=i,s.name=t.name,s}function zi(e,t){let n=ve([t.values,t.index]);n=ve(Ie(n,(u,o)=>{if(u[1]===o[1])return 0;if(u[1]<o[1])return-1;if(u[1]>o[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function qi(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var gr=Symbol.for("@jrc03c/js-math-tools/series");function Wi(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===gr}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:gr}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(u){f(g(u),"The new values must be a 1-dimensional array!");let o=O(u);f(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<this._index.length?this._index=this._index.slice(0,o[0]):o[0]>this._index.length&&(this._index=this._index.concat(J(this._index.length,o[0]).map(i=>"item"+Ge(i,(u.length-1).toString().length)))),this._values=u}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(u){f(g(u),"The new index must be a 1-dimensional array of strings!"),f(u.length===this.shape[0],"The new index must be the same length as the old index!"),f(O(u).length===1,"The new index must be a 1-dimensional array of strings!"),u.forEach(o=>{f(C(o),"All of the row names must be strings!")}),this._index=u}}),r){if(r instanceof t)this.name=r.name,this.values=L(r.values),this.index=L(r.index);else if(g(r)){let u=O(r);f(u.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let u=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(s=>s.toString());f(u.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=u[0],i=r[o];f(O(i).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=o,this.values=i.slice()}}}get shape(){return O(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!N(r)).length===0}clear(){let r=this.copy();return r.values.forEach((u,o)=>{r.values[o]=void 0}),r}get(r){return $i(this,r)}getSubsetByNames(r){return Ui(t,this,r)}getSubsetByIndices(r){return Yi(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(ce(this.values));return r.index=ce(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=J(0,this.shape[0]).map(u=>"item"+Ge(u,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=L(this.values),r._index=L(this.index),r.name=this.name,r}append(r){return Cr(t,this,r)}apply(r){return ki(this,r)}concat(r){return this.append(r)}dropMissing(r,u){return Ri(this,r,u)}dropNaN(){return Ji(t,this)}toObject(){return qi(this)}print(){return Li(this)}shuffle(){return Vi(this)}sort(r){return Gi(t,this,r)}sortByIndex(){return zi(t,this)}filter(r){return Ki(t,this,r)}toDataFrame(){let r=new e(ve([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=ce(r.values),r.index=ce(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var pr=Symbol.for("@jrc03c/js-math-tools/dataframe");function It(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(He()*t.length)];return n}var R=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===pr}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:pr}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!N(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){f(g(t),"The new values must be a 2-dimensional array!");let n=O(t);f(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(J(this._index.length,n[0]).map(r=>"row"+Ge(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(J(this._columns.length,n[1]).map(r=>"col"+Ge(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){f(g(t),"The new columns list must be a 1-dimensional array of strings!"),f(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),f(O(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+It(8):r.trim()));let n=(()=>{let r=kt(t),u={};return r.values.forEach(o=>{u[o]=r.get(o)}),u})();t=t.map(r=>n[r]>1?r+"_"+It(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){f(g(t),"The new index must be a 1-dimensional array of strings!"),f(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),f(O(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+It(8):r.trim()));let n=(()=>{let r=kt(t),u={};return r.values.forEach(o=>{u[o]=r.get(o)}),u})();t=t.map(r=>n[r]>1?r+"_"+It(8):r),this._index=t}}),f(N(e)||fe(e)||g(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof R)this.values=L(e.values),this.columns=L(e.columns),this.index=L(e.index);else if(g(e)){let t=O(e);f(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),f(!ft(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(o=>o.toString());let t=[],n=null,r=null;this._columns.forEach(o=>{N(r)&&(n=o,r=e[o].length),f(e[o].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${o}" points to an array containing ${e[o].length} items.`),r=e[o].length;let i=e[o];t.push(i)}),this._values=ve(t);let u=O(this.values);this._index=J(0,u[0]).map(o=>"row"+Ge(o,(u[0]-1).toString().length))}}get shape(){return O(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new R(re(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return wi(this,e,t)}getSubsetByNames(e,t){return Si(R,q,this,e,t)}getSubsetByIndices(e,t){return Ei(this,e,t)}getDummies(e){return hr(R,this,e)}oneHotEncode(e){return hr(R,this,e)}transpose(){let e=new R(ve(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return Oi(this,e)}copy(){return gi(R,this)}assign(e,t){return di(R,q,this,e,t)}apply(e,t){return mi(R,q,this,e,t)}dropMissing(e,t,n){return yi(R,q,this,e,t,n)}dropNaN(e,t,n){return bi(R,this,e,t,n)}drop(e,t){return pi(R,q,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return Bi(this,e)}toObject(){return Pi(this)}toJSONString(e){return Ir(this,e)}saveAsJSON(e,t){return Mi(this,e,t)}print(){return Fi(R,q,this)}sort(e,t){return Ii(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return vi(R,q,this,e,t)}shuffle(e){return Ai(this,e)}append(e,t){return Or(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},q=Wi(R);function Ut(e,t){return Z(e,{shouldDropNaNs:t}).max}function B(e){return f(Y(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,u=[],o=[],i=Object.keys(arguments).filter(s=>{let a=arguments[s];return g(a)?!0:E(a)?(n=!0,u.push(a),!0):T(a)?(r=!0,o.push(a),!0):!1}).map(s=>arguments[s]);if(i.slice(0,-1).forEach((s,a)=>{f(he(g(s)?O(s):s.shape,g(i[a+1])?O(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let s=Ut(i.map(l=>l.length?l.length:l.values.length)),a=J(0,s).map(l=>{let c=Object.keys(arguments).map(m=>g(arguments[m])?arguments[m][l]:E(arguments[m])||T(arguments[m])?arguments[m].values[l]:arguments[m]);return t(...c)});if(r)try{if(o.length===1&&he(O(o[0]),O(a))){let l=new R(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new R(a)}catch{return a}if(n)try{if(u.length===1&&u[0].length===a.length){let l=new q(a);return l.name=u[0].name,l.index=u[0].index.slice(),l}else return new q(a)}catch{return a}return a}else return e(...arguments)}}function Hi(e){try{return b(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var Fn=B(Hi);function Xi(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!b(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Jt=B(Xi);function Zi(e,t){try{return t(e)}catch{return NaN}}var Lt=B(Zi);function Qi(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var xi=B(Qi);function es(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var ts=B(es);function ns(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var rs=B(ns);function mn(e,t){if(T(e)){let n=mn(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(E(e)){let n=mn(e.values,t);return e.index[n]}f(g(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=qe(e,Ut(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function jr(e,t){return Z(e,{shouldDropNaNs:t}).min}function dn(e,t){if(T(e)){let n=dn(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(E(e)){let n=dn(e.values,t);return e.index[n]}f(g(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=qe(e,jr(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function X(e,t){if(T(e)||E(e))return e.apply(n=>X(n,t));if(g(e))return e.map(n=>X(n,t));if(t==="null")return null;if(t==="number"){if(N(e))return NaN;let n=X(e,"boolean");if(_e(n))return n?1:0;try{JSON.parse(e)}catch{let o=X(e,"date");if(ue(o))return o.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=X(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return X(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(X(e,"int"));if(t==="boolean"){if(_e(e))return e;if(b(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(ue(e))return e;if(N(e))return null;let n=parseFloat(e);if(!isNaN(n)){let u=new Date(e);return ue(u)?u:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(fe(e))return e;let n=X(e,"boolean");if(_e(n))return null;try{let u=X(e,"number");if(b(u))return JSON.parse(e),null}catch{}let r=X(e,"date");if(r)return r;try{let u=JSON.parse(e);return g(u)?u.map(o=>X(o,t)):u}catch{return null}}if(t==="string")return N(e)?he(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function us(e){try{return b(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var os=B(us);function is(e,t){try{if(!b(e))return NaN;if(typeof e=="bigint")return e;if(N(t))t=1e-10;else if(!b(t))return NaN;return Fn(e)<t?0:e}catch{return NaN}}var ss=B(is);function gn(e){if(T(e)||E(e)){let t=e.copy();return t.values=gn(t.values),t}if(g(e))return e.map(t=>gn(t));try{let t=JSON.parse(e);return b(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var me=B(gn);function Br(e,t,n){try{return b(e)?b(t)?b(n)?typeof e=="bigint"?BigInt(Br(me(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var as=B(Br);function Kt(e,t){function*n(r,u){if(u>r.length)yield r;else if(u<=0)yield[];else if(r.length<2)yield r;else for(let o=0;o<r.length;o++){let i=r[o],s=r.slice(o+1);if(!(s.length<u-1)&&u-1>=0)for(let a of Kt(s,u-1))yield[i].concat(a)}}return T(e)||E(e)?Kt(e.values,t):(f(g(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),f(b(t)&&me(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(oe(e),t))}function Mr(e,t){let n=[];for(let r of Kt(e,t))n.push(r.slice());return n}function Pr(){let e=Object.values(arguments).map(n=>T(n)||E(n)?ee(n.values):(f(g(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),ee(n)));return ee(e).filter(n=>e.every(r=>r.findIndex(u=>he(u,n))>-1))}var ot=class{constructor(e){f(N(e)||e===ot.DROP_NAN_MODE||e===ot.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=N(e)?ot.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(g(t)){let n=O(t);if(n.length===1)t=new q(t);else if(n.length===2)t=new R(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}f(T(t)||E(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===ot.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Pr(...e),this}transform(){f(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(g(t)){let n=O(t);if(n.length===1)return new q(t).get(this.index).values;if(n.length===2)return new R(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return f(T(t)||E(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Vt=ot;Er(Vt,"DROP_NAN_MODE","DROP_NAN_MODE");Er(Vt,"DROP_MISSING_MODE","DROP_MISSING_MODE");function st(e,t,n,r){if(E(e))return st(e.values,t,n,r);if(E(t))return st(e,t.values,n,r);if(f(g(e)&&g(t)&&O(e).length===1&&O(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),f(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return st(...new Vt().fitAndTransform(e,t),!1,r);try{let u=Z(e,{stdev:r}),o=Z(t,{stdev:r}),i=Number(u.mean),s=Number(o.mean);if(!b(i)||!b(s))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let m=e[c],d=t[c];if(!b(m))return NaN;if(!b(d))return NaN;typeof m=="bigint"&&(m=Number(m)),typeof d=="bigint"&&(d=Number(d)),l+=(m-i)*(d-s)}return r?[l/e.length,u,o]:l/e.length}catch{return NaN}}function pn(e,t,n){if(E(e))return pn(e.values,t,n);if(E(t))return pn(e,t.values,n);f(g(e)&&g(t)&&O(e).length===1&&O(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),f(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[u,o,i]=st(e,t,n,!0),s=o.stdev*i.stdev;return u/s}catch{return NaN}}function ls(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var cs=B(ls),fs=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function yn(e,t){if(T(e)||E(e))return yn(e.values,t);if(T(t)||E(t))return yn(e,t.values);f(g(e)&&g(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=ee(e),r=ee(t),u=[];return n.forEach(o=>{r.findIndex(i=>he(i,o))<0&&u.push(o)}),u}function kr(e,t){try{if(!b(e))return NaN;if(!b(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=kr(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var On=B(kr);function Rr(e){try{if(!b(e))return NaN;if(typeof e=="bigint"){let t=Rr(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Jr=B(Rr);function hs(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!b(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var Kr=B(hs);function Xe(){return Kr(...arguments)}function $r(e,t){return Jt(e,Xe(t,-1))}function Tn(e,t){return Z(e,{shouldDropNaNs:t}).sum}function bn(e,t){if(b(e)&&b(t))return Fn(e-t);if(T(e)||E(e))return bn(e.values,t);if(T(t)||E(t))return bn(e,t.values);g(e)&&g(t)&&f(he(O(e),O(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Jr(Tn(On($r(e,t),2)))}catch{return NaN}}function ms(e,t){return Xe(e,On(t,-1))}function be(e,t){if(T(e)){let u=be(e.values,t);if(O(u).length===1){let o=new q(u);return o.name=E(t)?t.name:o.name,o.index=e.index.slice(),o}else{let o=new R(u);return o.index=e.index.slice(),T(t)&&(o.columns=t.columns.slice()),o}}if(T(t)){let u=be(e,t.values);if(O(u).length===1){let o=new q(u);return o.name=E(e)?e.name:o.name,o.index=t.columns.slice(),o}else{let o=new R(u);return o.columns=t.columns.slice(),o}}if(E(e))return be(e.values,t);if(E(t))return be(e,t.values);f(g(e)&&g(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=O(e),r=O(t);if(f(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),f(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Tn(Xe(e,t));if(n.length===1&&r.length===2)return ve(t).map(u=>be(e,u));if(n.length===2&&r.length===1)return e.map(u=>be(u,t));if(n.length===2&&r.length===2){let u=ve(t),o=[];for(let i=0;i<e.length;i++){let s=[];for(let a=0;a<u.length;a++)s.push(be(e[i],u[a]));o.push(s)}return o}}function _n(e){if(T(e)||E(e))return e.dropMissing(...Object.values(arguments).slice(1));f(g(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(_n(n))}catch{N(n)||t.push(n)}}),t}function jt(e,t){if(T(e)||E(e))return jt(e.values,t);if(T(t)||E(t))return jt(e,t.values);f(g(e)&&g(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),f(he(O(e),O(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let u=0;u<e.length;u++)try{let[o,i]=jt(e[u],t[u]);n.push(o),r.push(i)}catch{!N(e[u])&&!N(t[u])&&(n.push(e[u]),r.push(t[u]))}return[n,r]}function Bt(e,t){if(T(e)||E(e))return Bt(e.values,t);if(T(t)||E(t))return Bt(e,t.values);f(g(e)&&g(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),f(he(O(e),O(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let u=0;u<e.length;u++)try{let[o,i]=Bt(e[u],t[u]);n.push(o),r.push(i)}catch{b(e[u])&&b(t[u])&&(n.push(e[u]),r.push(t[u]))}return[n,r]}function ds(e){return _n(e)}function $t(e,t){if(T(e)||E(e))return $t(e.values,t);f(g(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),f(Y(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(g(n)){if(!$t(n,t))return!1}else if(!t(n))return!1;return!0}function gs(e){try{if(!b(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var ps=B(gs);function vn(e){try{return typeof e=="bigint"?BigInt(vn(me(e))):e!==me(e)?NaN:e<=1?1:e*vn(e-1)}catch{return NaN}}var ys=B(vn);function wn(e,t){if(T(e)||E(e))return wn(e.values,t);if(f(fe(e)||g(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Y(t)){let u=t;t=o=>o===u}function n(u,o,i){if(i=i||[],i.indexOf(u)>-1)return null;if(fe(u)){i.push(u);let s=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let a=0;a<s.length;a++){let l=s[a],c=u[l];if(o(c))return c;let m=n(c,o,i);if(m)return m}}else if(g(u)){i.push(u);for(let s=0;s<u.length;s++){let a=u[s];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(u))return u;return null}function r(u){try{return t(u)}catch{return!1}}return n(e,r)}function Nn(e,t){if(T(e)||E(e))return Nn(e.values,t);if(f(fe(e)||g(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Y(t)){let o=t;t=i=>i===o}function n(o,i,s){if(s=s||[],s.indexOf(o)>-1)return null;if(fe(o)){s.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o)),l=[];for(let c=0;c<a.length;c++){let m=a[c],d=o[m],w=!1;i(d)&&(l.push(d),w=!0);let _=n(d,i,s);_&&_.length>0&&_.slice(w?1:0).forEach(I=>l.push(I))}return l}else if(g(o)){s.push(o);let a=[];for(let l=0;l<o.length;l++){let c=o[l],m=!1;i(c)&&(a.push(c),m=!0);let d=n(c,i,s);d&&d.length>0&&d.slice(m?1:0).forEach(w=>a.push(w))}return a}else if(i(o))return[o];return null}function r(o){try{return t(o)}catch{return!1}}let u=n(e,r);return u&&u.length>0?u:null}function bs(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return b(t)?t:NaN}catch{return NaN}}var vs=B(bs);function ws(e){try{return b(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var Ns=B(ws);function An(e){b(e)&&(e=[e]);let t=[],n=mt(e);for(let r=0;r<n;r++)t.push(0);return at(t,e)}function Ds(e){typeof e=="bigint"&&(e=me(e)),f(!N(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),f(b(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),f(me(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),f(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=An([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var Es=["true","false","yes","no"],Ss=["null","none","nan","na","n/a","","undefined"];function Ct(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=me(e.value)===e.value:e.isInteger=$t(e.values,t=>b(t)?me(t)===t:!0)),e}function Mt(e){if(T(e)){let o=e.copy(),i=Mt(e.values);return o.values=i.values,Ct({type:i.type,values:o})}if(E(e)){let o=e.copy(),i=Mt(e.values);return o.values=i.values,Ct({type:i.type,values:o})}if(!g(e)){let o=Mt([e]);return o.value=o.values[0],delete o.values,Ct(o)}f(g(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=oe(e).map(o=>{if(o===void 0)return"null";try{if(typeof o=="object"){let a=new Date(o.getTime());if(ue(a))return"date"}}catch{}C(o)||(typeof o=="bigint"?o=o.toString()+"n":o=JSON.stringify(o));let s=o.toLowerCase().trim();if(Ss.indexOf(s)>-1)return"null";if(Es.indexOf(s)>-1)return"boolean";try{if(o.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(o);return b(a)?"number":typeof a=="object"?g(a)?"string":"object":"string"}catch{let l=new Date(o);return ue(l)?"date":"string"}}),n=kt(t),u=n.values.toSorted((o,i)=>n.get(i)-n.get(o))[0];return Ct({type:u,values:Lt(e,o=>X(o,u))})}function Pt(e){if(T(e)){let n=e.copy();return n.values=Pt(n.values),n}f(g(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=O(e);if(f(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),f(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),f(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){f(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],u=e[1][0],o=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof u=="bigint"&&(u=Number(u)),typeof o=="bigint"&&(o=Number(o));let i=n*o-r*u;f(i!==0,"This matrix cannot be inverted!");let s=[[o,-r],[-u,n]];return Xe(s,1/i)}else if(t[0]>1){let n=(r,u)=>b(r)||b(u)?Xe(r,u):be(r,u);for(let r=1;r<t[0]-1;r++)try{let u=e.slice(0,r).map(I=>I.slice(0,r)),o=e.slice(0,r).map(I=>I.slice(r,t[0])),i=e.slice(r,t[0]).map(I=>I.slice(0,r)),s=e.slice(r,t[0]).map(I=>I.slice(r,t[0])),a=Pt(u),l=Pt(Jt(s,n(-1,n(n(i,a),o)))),c=Jt(a,n(n(n(n(a,o),l),i),a)),m=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),w=l;return c.map((I,Se)=>I.concat(m[Se])).concat(d.map((I,Se)=>I.concat(w[Se])))}catch{}f(!1,"This matrix cannot be inverted!")}}var Fs=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Yr(e,t,n){try{if(!b(e))return NaN;if(!b(t))return NaN;if(!b(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Yr(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var Os=B(Yr);function Ur(e,t){try{if(t=N(t)?Math.E:t,!b(e))return NaN;if(!b(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Ur(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var Ts=B(Ur);function _s(e,t){return Z(e,{shouldDropNaNs:t}).mean}function As(e,t){return Z(e,{shouldDropNaNs:t,median:!0}).median}function Lr(e,t){try{if(!b(e))return NaN;if(!b(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Lr(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var Is=B(Lr);function Cs(e,t){return Z(e,{shouldDropNaNs:t,mode:!0}).mode}function yr(){let e=He(),t=He();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function js(e){return N(e)?yr():Lt(re(e),yr)}function Bs(e){return Lt(re(e),()=>1)}function In(e,t){function*n(r,u){if(u=u||r.length,r.length===1){yield[r];return}for(let o of Mr(r,u)){if(!o.slice)continue;let i=An(o.length);yield o;let s=1;for(;s<o.length;)if(i[s]<s){if(s%2===0){let a=o[0];o[0]=o[s],o[s]=a}else{let a=o[i[s]];o[i[s]]=o[s],o[s]=a}yield o,i[s]+=1,s=1}else i[s]=0,s+=1}}return T(e)||E(e)?In(e.values,t):(f(g(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),N(t)&&(t=e.length),f(b(t)&&me(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(oe(e),t))}function Ms(e,t){let n=[];for(let r of In(e,t))n.push(r.slice());return n}function Ps(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(g(t))if(ft(t))console.log(t);else{let n=O(t);n.length===1?new q(t).print():n.length==2?new R(t).print():console.log(t)}else T(t)||E(t)?t.print():console.log(t)})}var ks=B((e,t,n,r,u)=>{try{let o=!1;for(let l of[e,t,n,r,u]){if(!b(l))return NaN;typeof l=="bigint"&&(o=!0)}o&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),u=Number(u));let i=(u-r)*(e-t),s=n-t;if(s===0)return NaN;let a=i/s+r;if(o)try{return BigInt(a)}catch{}return a}catch{return NaN}});function Rs(e,t,n,r,u){if(g(e)&&N(r)&&N(u)){r=t,u=n;let o=Z(e);t=o.min,n=o.max}return ks(e,t,n,r,u)}function Js(e){try{return b(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var Ks=B(Js);function Vr(e){try{return b(e)?typeof e=="bigint"?BigInt(Vr(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var $s=B(Vr);function Ys(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Us=B(Ys);function Dn(e,t){if(T(e)||E(e))return Dn(e.values,t);f(g(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),f(Y(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(g(n)){if(Dn(n,t))return!0}else if(t(n))return!0;return!1}function Gr(e,t){return Z(e,{shouldDropNaNs:t,stdev:!0}).stdev}function Ls(e){return Gr(e)}function Vs(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var Gs=B(Vs);function br(e,t){f(Y(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function zs(e,t){f(Y(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function qs(){return ee([...arguments].map(e=>g(e)?e:T(e)||E(e)?e.values:[e]))}function Ws(e,t){return Z(e,{shouldDropNaNs:t,variance:!0}).variance}function Hs(){let e=[],t=Object.values(arguments).map(n=>((T(n)||E(n))&&(n=n.values),f(g(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return J(0,Ut(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(u=>{let o=u[n];r.push(N(o)?void 0:o)}),e.push(r)}),e}var it={abs:Fn,add:Jt,apply:Lt,arccos:xi,arcsin:ts,arctan:rs,argmax:mn,argmin:dn,assert:f,cast:X,ceil:os,chop:ss,clamp:as,combinations:Mr,combinationsIterator:Kt,copy:L,correl:pn,cos:cs,count:kt,covariance:st,DataFrame:R,dataTypes:fs,decycle:Ae,diff:yn,distance:bn,divide:ms,dot:be,dropMissing:_n,dropMissingPairwise:jt,dropNaN:Sn,dropNaNPairwise:Bt,dropUndefined:ds,every:$t,exp:ps,factorial:ys,find:wn,findAll:Nn,flatten:oe,float:vs,floor:Ns,identity:Ds,IndexMatcher:Vt,indexOf:qe,inferType:Mt,int:me,intersect:Pr,inverse:Pt,isArray:g,isBoolean:_e,isBrowser:Fs,isDataFrame:T,isDate:ue,isEqual:he,isFunction:Y,isJagged:ft,isNested:Yt,isNumber:b,isObject:fe,isSeries:E,isString:C,isUndefined:N,lerp:Os,log:Ts,MathError:De,max:Ut,mean:_s,median:As,min:jr,mod:Is,mode:Cs,multiply:Kr,ndarray:re,normal:js,ones:Bs,permutations:Ms,permutationsIterator:In,pow:On,print:Ps,product:mt,random:He,range:J,remap:Rs,reshape:at,reverse:ce,round:Ks,scale:Xe,seed:Ar,Series:q,set:ee,shape:O,shuffle:Rt,sign:$s,sin:Us,some:Dn,sort:Ie,sqrt:Jr,stats:Z,std:Gr,stdev:Ls,subtract:$r,sum:Tn,tan:Gs,timeAsync:zs,timeSync:br,time:br,transpose:ve,union:qs,variance:Ws,vectorize:B,zeros:An,zip:Hs,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new it.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(it).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:it[t]})}catch{e[t]=it[t]}})}};typeof window<"u"&&(window.JSMathTools=it);var Xs=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:void 0;function En(e){let t=Symbol.for("@TypedArrayConstructor"),n="Symbol(@TypedArrayConstructor)",r=t in e?t:n in e?n:void 0;if(r){if(!("values"in e))throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");return e[r]==="ArrayBuffer"?new Uint8Array(e.values).buffer:new Xs[e[r]](e.values)}if(g(e)&&e.constructor.name==="Array")return e;throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!")}function ze(e){if(e instanceof ArrayBuffer||e instanceof BigInt64Array||e instanceof BigUint64Array||e instanceof Float32Array||e instanceof Float64Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Int8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:e.constructor.name,values:e instanceof ArrayBuffer?Array.from(new Uint8Array(e)):Array.from(e)};if(g(e))return e.map(t=>{try{return ze(t)}catch{return t}});if(typeof e=="object"&e!==null){if(ue(e))return new Date(e.getTime());let t={};return Object.keys(e).forEach(n=>{try{t[n]=ze(e[n])}catch{t[n]=e[n]}}),t}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function zr(e){return e=e.trim(),!!(e.match(/^-?\d+(\.\d+)?$/g)||e.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g)||e.match(/^-?\.\d+$/g)||e==="NaN")}var qr="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";function Wr(e,t,n){if(typeof e!="string")throw new Error("`text` must be a string!");if(typeof t!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return e.split(t).join(n)}var vr="  ",wr=" ";function Cn(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t="";for(let n=0;n<e.length;n++){let r=e[n].toLowerCase();qr.includes(r)?t+=wr:t+=r}for(;t.includes(vr);)t=Wr(t,vr,wr);return t.trim()}function Zs(e,t){return t=t||"",e.split(`
`).map(n=>n.trim().length>0?t+n:n).join(`
`)}function Qs(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=Cn(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("-")}var Nr={"@Infinity":1/0,"@NegativeInfinity":-1/0,"@NaN":NaN,"@undefined":void 0};function lt(e){if(typeof e=="object"){if(e===null)return e;if(g(e))for(let t=0;t<e.length;t++)e[t]=lt(e[t]);else Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{e[t]=lt(e[t])});return e}else return typeof e>"u"||e==="Symbol(@undefined)"?void 0:e}function xs(e){if(typeof e=="bigint")return e;if(typeof e=="string")if(e.match(/^\s*?-?\d+n\s*?$/g))try{return BigInt(e.split("n")[0])}catch{return NaN}else return NaN;else return NaN}function ea(e){if(typeof e!="string")return typeof e=="number"?e:void 0;if(zr(e))return parseFloat(e)}function ta(e){if(typeof e!="string")return;let t="@jrc03c/js-text-tools/newline-replacer";if(e=e.replaceAll(`
`,t),e.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)){let n=e.replace("Symbol(@String):","");if(n.match(/^".*?"$/g))try{return JSON.parse(n)}catch{n=n.substring(1,n.length-1)}return n=n.replaceAll(t,`
`),n}}function na(e){if(typeof e!="string")return typeof e=="symbol"?{out:e,isASymbol:!0}:void 0;if(e.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)){let t=e.replace(/^.*?Symbol\(/g,"").replace(/\).*?$/g,"");return t in Nr?{out:Nr[t],isASymbol:!0}:{out:Symbol.for(t),isASymbol:!0}}}function ra(e){if(typeof e!="string")return e instanceof RegExp?e:void 0;let t=e.trim();if(t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g))try{let n=t.replace(/^\//g,"").replace(/\/(d|g|i|m|s|u|v|y)*?$/g,""),r=t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);return new RegExp(n,r)}catch{}}function ua(e){if(typeof e!="string")return typeof e=="object"?e:"Symbol(@undefined)";try{let t=JSON.parse(e,(n,r)=>{try{let u=ie(r);return typeof u>"u"?"Symbol(@undefined)":u}catch{return typeof r>"u"?"Symbol(@undefined)":r}});return g(t)&&(t=lt(t)),t}catch{return e}}function oa(e){if(typeof e!="string")return e instanceof Date&&e.toString()!=="Invalid Date"?e:void 0;try{let t=new Date(Date.parse(e));if(t.toString()!=="Invalid Date")return t}catch{}}function ia(e){return typeof e=="object"?e!==null?lt(e):void 0:(Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{try{let n=t;try{t=ie(t)}catch{}e[t]=ie(e[n]),t!==n&&delete e[n]}catch{}}),lt(e))}function ie(e){function t(n){if(typeof n=="string"){let r=ta(n);if(typeof r=="string")return r;let u=na(n);return r=u?u.out:void 0,u&&u.isASymbol||(r=ra(n),r instanceof RegExp)||(r=xs(n),typeof r=="bigint")||(r=ea(n),typeof r=="number")||(r=oa(n),r instanceof Date)?r:(r=ua(n),typeof r<"u"?r==="Symbol(@undefined)"?void 0:r:n)}if(typeof n=="object"){if(n===null)return null;let r;try{if(r=En(n),g(r))return r}catch{}if(r=ia(n),r)try{return En(r)}catch{return r}return n}return n}return t(e)}function sa(e){let t=Dr(e);return t[0].toUpperCase()+t.slice(1)}function aa(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=Cn(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("_")}function Ne(e,t){return!e||t<=0?"":J(0,t).map(()=>e).join("")}function de(e,t){f(C(t)||N(t),"The second parameter to the `stringify` function must be undefined or a string!");let n=t?`
`:"";function r(u,o,i){return i=i||0,typeof u=="bigint"?JSON.stringify(u.toString()+"n"):typeof u=="number"?u===1/0?'"Symbol(@Infinity)"':u===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(u)?'"Symbol(@NaN)"':u.toString():typeof u=="string"?JSON.stringify("Symbol(@String):"+u):typeof u=="boolean"?u.toString():typeof u>"u"?'"Symbol(@undefined)"':typeof u=="symbol"||typeof u=="function"?JSON.stringify(u.toString()):u instanceof RegExp?u.toString():typeof u=="object"?u===null?"null":ue(u)?JSON.stringify(u.toJSON()):g(u)?u.length===0?Ne(o,i-1)+"[]":u instanceof Array?Ne(o,i-1)+"["+n+u.map(s=>{let a=(()=>{try{return r(ze(s),o,i+1)}catch{return r(s,o,i+1)}})();return C(a)&&(a=a.trim()),Ne(o,i+1)+a}).join(","+n)+n+Ne(o,i)+"]":r(ze(u),null,o):Object.keys(u).length+Object.getOwnPropertySymbols(u).length===0?Ne(o,i-1)+"{}":Ne(o,i-1)+"{"+n+Object.keys(u).concat(Object.getOwnPropertySymbols(u)).map(s=>{let a=(()=>{try{return r(ze(u[s]),o,i+1)}catch{return r(u[s],o,i+1)}})();C(a)&&(a=a.trim());let l=typeof s=="symbol"?r(s):JSON.stringify(s);return Ne(o,i+1)+l+":"+(o?" ":"")+a}).join(","+n)+n+Ne(o,i)+"}":"undefined"}return r(Ae(e),t)}function la(e){let t=e.split(`
`),n=t.filter(u=>u.trim().length>0).map(u=>u.split("").findIndex(o=>!o.match(/\s/g))),r=Math.min(...n);return t.map(u=>u.substring(r)).join(`
`)}function ca(e,t){if(typeof e!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof t>"u"||t===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?t=process.stdout.columns>80?80:process.stdout.columns:t=80),isNaN(t)||typeof t!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return e.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let u=r.split(/[^\s]/g)[0],o=r.replace(u,"").split(" "),i=u;o.forEach(s=>{let a=i+(i.trim().length>0?" ":"")+s;a.length>t?(n.push(i),i=u+s):i=a}),i.length>0&&n.push(i)}),n.join(`
`)}typeof window<"u"&&(window.JSTextTools={camelify:Dr,convertObjectToTypedArray:En,convertTypedArrayToObject:ze,indent:Zs,isANumberString:zr,kebabify:Qs,parse:ie,pascalify:sa,punctuation:qr,replaceAll:Wr,snakeify:aa,stringify:de,strip:Cn,unindent:la,wrap:ca});function Gt(e){if(!A(e))throw new Error("The value passed into the `base64Decode` must be a string!");try{let t=decodeURIComponent(atob(e)),n=t,r=!0;for(;r;)try{t=ie(t),x(t,n)&&(r=!1),n=t}catch{r=!1}return t}catch(t){throw new Ce(t.toString())}}function zt(e){return A(e)||(e=de(e)),btoa(encodeURIComponent(e))}function Ee(e){return y(e)&&e>0&&parseInt(e)===e}async function Hr(e,t,n){n=n||{};let r=n.keyIterations||21e4;if(!A(e))throw new Error("The first argument passed into the `decrypt` function must be a string (i.e., the same string returned from the `encrypt` function)!");if(!A(t)||t.length===0)throw new Error("The second argument passed into the `decrypt` function must be a string representing the password with which to decrypt the encrypted data.");if(!Ee(r))throw new Error("The 'keyIterations' option passed into the `decrypt` function must be undefined or a natural number (i.e., a positive integer) representing the number of iterations used during the key derivation. NOTE: For decryption to be successful, this number must match the number of iterations that was used during the encryption of the data.");e=ie(Gt(e));let{iv:u,salt:o,value:i}=e;if(!u||!o||!i)throw new Error("The first argument passed into the `decrypt` function must be an object with properties 'iv', 'salt', and 'value' (i.e., the same object returned from the `encrypt` function)!");let s,a;try{let l=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveBits","deriveKey"]);a=await crypto.subtle.deriveKey({name:"PBKDF2",salt:o,iterations:r,hash:"SHA-512"},l,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}catch(l){throw new Fe(l.toString())}try{s=new TextDecoder().decode(await crypto.subtle.decrypt({name:"AES-GCM",iv:u},a,i))}catch{throw new Fe("Invalid password!")}try{return ie(s)}catch{return s}}async function Xr(e,t,n){n=n||{};let r=n.saltLength||32,u=n.ivLength||32,o=n.keyIterations||21e4;if(!A(t)&&t.length>0)throw new Error("The second argument passed into the `encrypt` function must be a string representing the password with which the data will be encrypted!");if(!Ee(r))throw new Error("The 'saltLength' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the length of the new salt to be generated.");if(!Ee(u))throw new Error("The 'ivLength' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the length of the initialization vector to be generated.");if(!Ee(o))throw new Error("The 'keyIterations' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the number of iterations used during the key derivation.");let i,s,a;try{s=crypto.getRandomValues(new Uint8Array(r));let l=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveBits","deriveKey"]),c=await crypto.subtle.deriveKey({name:"PBKDF2",salt:s,iterations:o,hash:"SHA-512"},l,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);a=crypto.getRandomValues(new Uint8Array(u)),i=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},c,new TextEncoder().encode(de(e)))}catch(l){throw new je(l.toString())}return zt(de({salt:s,iv:a,value:i}))}async function Zr(e,t){if(v(t))t="";else if(!A(t))throw new Error("The second value passed into the `hash` function must be undefined or a string representing a salt to be added to the first value before hashing!");A(e)||(e=de(e));try{return Array.from(new Uint8Array(await crypto.subtle.digest("SHA-512",new TextEncoder().encode(e+t)))).map(n=>n.toString(16).padStart(2,"0")).join("")}catch(n){throw new Be(n.toString())}}function Qr(e,t){if(v(e))e=256;else if(!Ee(e))throw new Error("The first value passed into the `randomString` function must be undefined or a positive integer representing the length of the returned string! If no length is passed, then the default length will be 256.");if(v(t))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";else if(!A(t)||t.length<=1)throw new Error("The second value passed into the `randomString` function must be undefined or a string representing the set of characters of which the returned string will be comprised! Note that a given character set must contain at least 2 characters in order to be secure. If the character set is undefined, then the default value is the lower- and upper-case Latin alphabet and the digits 0-9.");try{let n="";for(let r=0;r<e;r++){let u=crypto.getRandomValues(new Uint32Array(1))[0]%t.length;n+=t[u]}return n}catch(n){throw new Me(n.toString())}}typeof window<"u"&&(window.JSCryptoHelpers={base64Decode:Gt,Base64DecodingError:Ce,base64Encode:zt,Base64EncodingError:dt,decrypt:Hr,DecryptionError:Fe,encrypt:Xr,EncryptionError:je,hash:Zr,HashingError:Be,parse:ie,randomString:Qr,RandomStringGenerationError:Me,stringify:de});export{Ce as Base64DecodingError,dt as Base64EncodingError,Fe as DecryptionError,je as EncryptionError,Be as HashingError,Me as RandomStringGenerationError,Gt as base64Decode,zt as base64Encode,Hr as decrypt,Xr as encrypt,Zr as hash,ie as parse,Qr as randomString,de as stringify};
