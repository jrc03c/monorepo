function Jc(e){if(typeof e!="string")throw new Error("`text` must be a string!");e=e.trim();let t="",n=!1;for(let r=0;r<e.length;r++){let o=e[r];o.match(/[A-Za-z0-9]/g)?(t.length===0?t+=o.toLowerCase():n?t+=o.toUpperCase():t+=o,n=!1):!o.includes("'")&&!o.includes("\u2019")&&!o.includes("\u275C")&&(n=!0)}return t}var hg=Object.defineProperty,mg=(e,t,n)=>t in e?hg(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,$c=(e,t,n)=>(mg(e,typeof t!="symbol"?t+"":t,n),n);function C(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var dg=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),rr=class extends Error{constructor(e){dg()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function g(e,t){if(!e)throw new rr(t)}var Kc=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function Y(e){return e===null||typeof e>"u"}var gg=Kc.map(e=>e.name);function D(e){try{return e instanceof Array?!0:Y(e.constructor)?!1:Kc.indexOf(e.constructor)>-1||gg.indexOf(e.constructor.name)>-1}catch{return!1}}function X(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function qe(e){return typeof e=="function"}function mn(e){return typeof e=="object"&&!Y(e)&&!D(e)}function V(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function kr(e,t){if(X(e)){let u=kr(e.values,t);return u.length>0&&C(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&C(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(V(e)){let u=kr(e.values,t);return u.length>0&&C(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(g(mn(e)||D(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!qe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(mn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(D(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function tt(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(D(n))return n instanceof Array?n.map(o=>tt(o)):n.slice();if(V(n)){let o=n.copy();return o.values=tt(o.values),o}if(X(n)){let o=n.copy();return o.values=tt(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=dr(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=tt(n[o])}),r}else return n}return t(dr(e))}function dr(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+kr(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),D(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(X(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(V(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function Ht(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var _c=["number","int","float","bigint"];function dn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!_c.includes(u)&&!_c.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(Ht(r))return Ht(o)?r.getTime()===o.getTime():!1;if(Ht(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(D(r)!==D(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(dr(e),dr(t))}}function Uo(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var pg=Uo(16),yg=Uo(16),bg=Uo(16),vg=Uo(16),Ng=Uo(16),wg=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)D(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?pg:Y(e)?yg:qe(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Ng:e===1/0?bg:e===-1/0?vg:typeof e=="bigint"?e.toString():X(e)?e.toJSONString():V(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!Y(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function Qt(e){if(X(e)||V(e))return Qt(e.values);g(D(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{D(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Ft(e,t){t=t||{};let n=new wg,r={},o=Qt(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||C(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function Xu(e,t){let{counts:n}=Ft(e);return Y(t)||(qe(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{dn(r,t)||n.delete(r)})),n}function Hi(e){if(X(e)||V(e))return Hi(e.values);if(D(e)){let t=!1,n=!1,r=null;for(let o of e){if(Hi(o))return!0;if(D(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function Lo(e){return Hi(dr(e))}function os(e){if(X(e)||V(e))return os(e.values);g(D(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(D(e[t]))return!0;return!1}var Mr="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function qt(e){g(!Y(e),Mr),D(e)||(e=[e]),g(!os(e),Mr),g(e.length>0,Mr);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),g(C(t),Mr),g(t>=0,Mr),g(Math.floor(t)===t,Mr),g(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(qt(e.slice(1)));return n}}function hn(e){if(X(e)||V(e)){let n=e.copy();return n.values=hn(n.values),n.index=hn(n.index),n}g(D(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Be(e,t,n=1){g(!Y(e)&&!Y(t)&&!Y(n),"You must pass two numbers and optionally a step value to the `range` function!"),g(C(e)&&C(t)&&C(n),"You must pass two numbers and optionally a step value to the `range` function!"),g(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=hn(u)),u}function Vo(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Eg=Vo(256),Dg=Vo(256),Sg=Vo(256),Og=Vo(256),Fg=Vo(256);function Kt(e){if(X(e)||V(e))return Kt(e.values);g(D(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return Qt(e).forEach(r=>{let o=typeof r=="object"&&r===null?Eg:Y(r)?Dg:qe(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Fg:r===1/0?Sg:r===-1/0?Og:typeof r=="bigint"?r.toString():X(r)?r.toJSONString():V(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function Uc(e){if(D(e)){let t=Uc(e[0]);return[e.length].concat(t||[])}else return}function Z(e){return X(e)||V(e)?Z(e.values):(g(D(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Uc(e))}function Lc(e,t,n){if(Y(n)&&(n=0),g(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),D(t)){g(!Lo(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=Z(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Be(0,o).forEach(s=>{s>=u._values.length&&u._values.push(qt(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Be(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(qt(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new rr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(V(t)){let r=Lc(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(X(t))if(n===0){let r=e.copy(),o=Kt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(qt(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(qt(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new rr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function _g(e,t,n,r,o){if(o=o||0,g(qe(r),"The first parameter to the `apply` method must be a function."),g(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,Y(s)&&(s=c instanceof t||D(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return Y(u)&&(u=c instanceof t||D(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function he(e){return typeof e=="string"}function Tg(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(Y(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(mn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new rr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{g(he(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),g(D(o)&&!Lo(o)&&Z(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function Ag(e,t){if(t.isEmpty)return new e;let n=new e(tt(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function Ig(e,t,n,r,o){Y(r)&&(r=[]),Y(o)&&(o=[]),(he(r)||C(r))&&(r=[r]),(he(o)||C(o))&&(o=[o]),g(D(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),g(D(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),g(Z(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),g(Z(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function Vc(e){return C(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function Yr(e){return Vc(e)&&e>=0}function jg(e,t,n,r,o,u){r=r||0,g(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,g(Yr(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",g(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(Y(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(Y(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!Y(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(Z(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(Y(c))return new e;he(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function ia(e){if(X(e)||V(e))return e.dropNaN(...Object.values(arguments).slice(1));g(D(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(ia(n))}catch{if(C(n))return t.push(n)}}),t}function Cg(e,t,n,r,o){n=n||0,g(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,g(Yr(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",g(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=ia(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function Tc(e){let t={};return Qt(e).forEach((n,r)=>{t[n]=r}),t}function Br(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function Mg(e,t,n,r,o){g(qe(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),Y(o)&&(o=0),g(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=Tc(u.index),i=Tc(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Br(s)[0],c.index=Br(i),c}u.values=l,u.index=Br(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Br(i)[0],c.index=Br(s),c}u.values=l,u.index=Br(i),u=u.transpose()}return u}function Bg(e,t,n){(he(t)||C(t))&&(t=[t]),(he(n)||C(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Kt((t||[]).concat(n||[]).map(o=>typeof o));return g(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&g(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(g(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),g(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Y(t)||(t=t.map(o=>{if(he(o))return g(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(C(o))return g(o>=0,`Index ${o} is out of bounds!`),g(Math.floor(o)===o,"Row numbers must be integers!"),g(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),Y(n)||(n=n.map(o=>{if(he(o))return g(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(C(o))return g(o>=0,`Column ${o} is out of bounds!`),g(Math.floor(o)===o,"Column numbers must be integers!"),g(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function Pg(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function gr(e,t){if(Y(t)&&(t=Pg),X(e)||V(e))return e.sort(...Object.values(arguments).slice(1));g(D(e),"The `sort` function only works on arrays, Series, and DataFrames!"),g(qe(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function Rg(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function Ac(e,t,n){Y(n)?n=t.columns:he(n)&&(n=[n]);let r={};n.forEach(u=>{g(he(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);g(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=gr(Kt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+Rg(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function kg(e,t,n){let r=e.shape;Y(t)&&(t=Be(0,r[0])),Y(n)&&(n=Be(0,r[1])),C(t)&&(t=[t]),C(n)&&(n=[n]),g(D(t)&&D(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),g(Z(t).length===1&&Z(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),g(t.length>0,"The `rowIndices` array must contain at least one index."),g(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{g(Yr(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),g(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{g(Yr(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),g(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function Yg(e,t,n,r,o){Y(r)&&(r=n.index),Y(o)&&(o=n.columns),he(r)&&(r=[r]),he(o)&&(o=[o]),g(D(r)&&D(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),g(Z(r).length===1&&Z(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),g(r.length>0,"The `rows` array must contain at least one row name."),g(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{g(he(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),g(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{g(he(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),g(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function Jg(e,t,n){function r(h,m){return he(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Be(0,u).concat(Be(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Be(0,i).concat(Be(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Be(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function Pr(e,t){g(C(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function $g(e,t){let n=t?e:e.copy();return n.index=Be(0,e.shape[0]).map(r=>"row"+Pr(r,(n.index.length-1).toString().length)),n}function zo(e,t){if(X(e)||V(e))return zo(e.values,t);g(D(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=Qt(e),r=!1,o=1;for(let u of n){if(!C(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function Kg(e){return Vc(e)&&e>0}function $o(e,t){if(X(e)||V(e))return $o(e.values,t);if(g(D(e),"The first argument passed into the `reshape` function must be an array!"),C(t)&&(t=[t]),g(D(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),g(Z(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),g(Kg(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return Qt(e);let n=Qt(e);if(t.length===1&&t[0]===n.length)return n;g(zo(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push($o(s,t.slice(1)))}return r}var zc=Math.pow(2,64),Fe=[];Wc(Math.floor(Math.random()*zc));function Ug(e,t){e=at(e);function n(){e+=at("0x9e3779b97f4a7c15");let o=tt(e);return o=(o^o>>BigInt(30))*at("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*at("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function at(e){return BigInt.asUintN(64,BigInt(e))}function Ic(e,t){return e=at(e),t=BigInt(t),at(at(e<<t)|at(e>>at(BigInt(64)-t)))}function Wc(e){if(typeof e=="bigint"&&(e=Number(e)),Y(e))return tt(Fe);{g(C(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=Ug(Math.floor(e),4);Fe[0]=t[0],Fe[1]=t[1],Fe[2]=t[2],Fe[3]=t[3]}}function jc(){let e=at(Ic(Fe[0]+Fe[3],23)+Fe[0]),t=at(Fe[1]<<BigInt(17));return Fe[2]=at(Fe[2]^Fe[0]),Fe[3]=at(Fe[3]^Fe[1]),Fe[1]=at(Fe[1]^Fe[2]),Fe[0]=at(Fe[0]^Fe[3]),Fe[2]=at(Fe[2]^t),Fe[3]=Ic(Fe[3],45),Math.floor(Number(e))/zc}function Jr(e){return Y(e)?jc():(D(e)||(e=[e]),$o(qt(zo(e)).map(jc),e))}function xu(e){if(X(e)||V(e))return e.shuffle(...Object.values(arguments).slice(1));g(D(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(Jr()*n.length);t.push(n.splice(o,1)[0])}return t}function Lg(e,t){return Y(t)&&(t=0),g(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?xu(e.index):null,t===1?xu(e.columns):null)}function mr(e){return typeof e=="boolean"}function Vg(e,t,n){return qe(t)?zg(e,t,n):Wg(e,t,n)}function zg(e,t,n){if(n=Y(n)?0:n,g(qe(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),g(C(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=gr(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=gr(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function Wg(e,t,n){let r=e.copy(),o=Jr().toString();r=r.assign(o,r.index),Y(t)&&(t=[o],n=[!0]),(C(t)||he(t))&&(t=[t],(mr(n)||he(n))&&(n=[n])),g(D(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),g(Z(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Y(n)&&(n=Be(0,t.length).map(()=>!0)),g(D(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),g(Z(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),g(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(g(he(s)||C(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),he(s)){let i=r.columns.indexOf(s);return g(i>-1,`The column "${s}" does not exist!`),i}if(C(s))return g(Yr(s),"Column indices must be whole numbers!"),g(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(g(he(s)||mr(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),he(s)){let i=s.trim().toLowerCase();return g(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(mr(s))return s}),r.values=gr(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function Gg(e,t){Y(t)?t=0:g(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function Gc(e,t){return JSON.stringify(e.toObject(t))}async function qg(e,t,n){let r=Gc(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new rr(s):typeof module<"u"?new rr(i):new rr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function Hg(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function $n(e){if(X(e)||V(e))return e.transpose();g(D(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=Z(e);if(g(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return hn(e);if(t.length===2){let n=qt(hn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function qc(e,t,n){if(V(n))return new e(t.values.concat(n.values));if(D(n)){let r=Z(n);g(r.length===1&&!os(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return qc(t,[n])}function Qg(e,t){g(qe(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function Zg(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>Y(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function Xg(e,t){let n=[],r=[];t.values.forEach((u,s)=>{C(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function xg(e,t,n){let r=t.copy(),o=tt(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function ep(e,t){(he(t)||C(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Kt((t||[]).map(r=>typeof r));return g(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&g(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(g(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),g(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Y(t)||(t=t.map(r=>{if(typeof r=="string")return g(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return g(r>=0,`Index ${r} is out of bounds!`),g(Math.floor(r)===r,"Indices must be integers!"),g(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function tp(e,t){let n=e.shape;Y(t)&&(t=Be(0,n[0])),g(D(t),"The `indices` array must be 1-dimensional array of whole numbers."),g(Z(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),g(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{g(Yr(o),"The `indices` array must be a 1-dimensional array of whole numbers."),g(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function np(e,t,n){Y(n)&&(n=t.index),g(D(n),"The `indices` array must be a 1-dimensional array of strings."),g(Z(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),g(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{g(he(u),"The `indices` array must contain only strings."),g(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function rp(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Be(0,n/2).concat(Be(t.index.length-n/2,t.index.length)));let o=tt(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function op(e){let t=e.copy();return t.get(xu(t.index))}function up(e,t,n){n=n||((a,l)=>a<l?-1:1),g(Y(n)||qe(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=$n([t.values,t.index]),o=gr(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function sp(e,t){let n=$n([t.values,t.index]);n=$n(gr(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function ip(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Cc=Symbol.for("@jrc03c/js-math-tools/series");function ap(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Cc}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Cc}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){g(D(o),"The new values must be a 1-dimensional array!");let u=Z(o);g(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Be(this._index.length,u[0]).map(s=>"item"+Pr(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){g(D(o),"The new index must be a 1-dimensional array of strings!"),g(o.length===this.shape[0],"The new index must be the same length as the old index!"),g(Z(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{g(he(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=tt(r.values),this.index=tt(r.index);else if(D(r)){let o=Z(r);g(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());g(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];g(Z(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return Z(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!Y(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return ep(this,r)}getSubsetByNames(r){return np(t,this,r)}getSubsetByIndices(r){return tp(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(hn(this.values));return r.index=hn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Be(0,this.shape[0]).map(o=>"item"+Pr(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=tt(this.values),r._index=tt(this.index),r.name=this.name,r}append(r){return qc(t,this,r)}apply(r){return Qg(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return Zg(this,r,o)}dropNaN(){return Xg(t,this)}toObject(){return ip(this)}print(){return rp(this)}shuffle(){return op(this)}sort(r){return up(t,this,r)}sortByIndex(){return sp(t,this)}filter(r){return xg(t,this,r)}toDataFrame(){let r=new e($n([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=hn(r.values),r.index=hn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Mc=Symbol.for("@jrc03c/js-math-tools/dataframe");function Wu(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(Jr()*t.length)];return n}var Me=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Mc}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Mc}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!Y(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){g(D(t),"The new values must be a 2-dimensional array!");let n=Z(t);g(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Be(this._index.length,n[0]).map(r=>"row"+Pr(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Be(this._columns.length,n[1]).map(r=>"col"+Pr(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){g(D(t),"The new columns list must be a 1-dimensional array of strings!"),g(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),g(Z(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Wu(8):r.trim()));let n=(()=>{let r=Xu(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+Wu(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){g(D(t),"The new index must be a 1-dimensional array of strings!"),g(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),g(Z(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Wu(8):r.trim()));let n=(()=>{let r=Xu(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+Wu(8):r),this._index=t}}),g(Y(e)||mn(e)||D(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Me)this.values=tt(e.values),this.columns=tt(e.columns),this.index=tt(e.index);else if(D(e)){let t=Z(e);g(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),g(!Lo(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{Y(r)&&(n=u,r=e[u].length),g(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=$n(t);let o=Z(this.values);this._index=Be(0,o[0]).map(u=>"row"+Pr(u,(o[0]-1).toString().length))}}get shape(){return Z(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Me(qt(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return Bg(this,e,t)}getSubsetByNames(e,t){return Yg(Me,gt,this,e,t)}getSubsetByIndices(e,t){return kg(this,e,t)}getDummies(e){return Ac(Me,this,e)}oneHotEncode(e){return Ac(Me,this,e)}transpose(){let e=new Me($n(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return $g(this,e)}copy(){return Ag(Me,this)}assign(e,t){return Tg(Me,gt,this,e,t)}apply(e,t){return _g(Me,gt,this,e,t)}dropMissing(e,t,n){return jg(Me,gt,this,e,t,n)}dropNaN(e,t,n){return Cg(Me,this,e,t,n)}drop(e,t){return Ig(Me,gt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return Gg(this,e)}toObject(){return Hg(this)}toJSONString(e){return Gc(this,e)}saveAsJSON(e,t){return qg(this,e,t)}print(){return Jg(Me,gt,this)}sort(e,t){return Vg(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return Mg(Me,gt,this,e,t)}shuffle(e){return Lg(this,e)}append(e,t){return Lc(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},gt=ap(Me);function us(e,t){return Ft(e,{shouldDropNaNs:t}).max}function pe(e){return g(qe(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return D(a)?!0:V(a)?(n=!0,o.push(a),!0):X(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{g(dn(D(i)?Z(i):i.shape,D(s[a+1])?Z(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=us(s.map(l=>l.length?l.length:l.values.length)),a=Be(0,i).map(l=>{let c=Object.keys(arguments).map(f=>D(arguments[f])?arguments[f][l]:V(arguments[f])||X(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&dn(Z(u[0]),Z(a))){let l=new Me(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Me(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new gt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new gt(a)}catch{return a}return a}else return e(...arguments)}}function lp(e){try{return C(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var aa=pe(lp);function cp(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!C(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var es=pe(cp);function fp(e,t){try{return t(e)}catch{return NaN}}var ss=pe(fp);function hp(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var mp=pe(hp);function dp(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var gp=pe(dp);function pp(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var yp=pe(pp);function Qi(e,t){if(X(e)){let n=Qi(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(V(e)){let n=Qi(e.values,t);return e.index[n]}g(D(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=kr(e,us(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Hc(e,t){return Ft(e,{shouldDropNaNs:t}).min}function Zi(e,t){if(X(e)){let n=Zi(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(V(e)){let n=Zi(e.values,t);return e.index[n]}g(D(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=kr(e,Hc(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Ot(e,t){if(X(e)||V(e))return e.apply(n=>Ot(n,t));if(D(e))return e.map(n=>Ot(n,t));if(t==="null")return null;if(t==="number"){if(Y(e))return NaN;let n=Ot(e,"boolean");if(mr(n))return n?1:0;try{JSON.parse(e)}catch{let u=Ot(e,"date");if(Ht(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=Ot(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return Ot(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(Ot(e,"int"));if(t==="boolean"){if(mr(e))return e;if(C(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Ht(e))return e;if(Y(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return Ht(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(mn(e))return e;let n=Ot(e,"boolean");if(mr(n))return null;try{let o=Ot(e,"number");if(C(o))return JSON.parse(e),null}catch{}let r=Ot(e,"date");if(r)return r;try{let o=JSON.parse(e);return D(o)?o.map(u=>Ot(u,t)):o}catch{return null}}if(t==="string")return Y(e)?dn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function bp(e){try{return C(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var vp=pe(bp);function Np(e,t){try{if(!C(e))return NaN;if(typeof e=="bigint")return e;if(Y(t))t=1e-10;else if(!C(t))return NaN;return aa(e)<t?0:e}catch{return NaN}}var wp=pe(Np);function Xi(e){if(X(e)||V(e)){let t=e.copy();return t.values=Xi(t.values),t}if(D(e))return e.map(t=>Xi(t));try{let t=JSON.parse(e);return C(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var gn=pe(Xi);function Qc(e,t,n){try{return C(e)?C(t)?C(n)?typeof e=="bigint"?BigInt(Qc(gn(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var Ep=pe(Qc);function ts(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of ts(i,o-1))yield[s].concat(a)}}return X(e)||V(e)?ts(e.values,t):(g(D(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),g(C(t)&&gn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Qt(e),t))}function Zc(e,t){let n=[];for(let r of ts(e,t))n.push(r.slice());return n}function Xc(){let e=Object.values(arguments).map(n=>X(n)||V(n)?Kt(n.values):(g(D(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Kt(n)));return Kt(e).filter(n=>e.every(r=>r.findIndex(o=>dn(o,n))>-1))}var ko=class{constructor(e){g(Y(e)||e===ko.DROP_NAN_MODE||e===ko.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=Y(e)?ko.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(D(t)){let n=Z(t);if(n.length===1)t=new gt(t);else if(n.length===2)t=new Me(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}g(X(t)||V(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===ko.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Xc(...e),this}transform(){g(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(D(t)){let n=Z(t);if(n.length===1)return new gt(t).get(this.index).values;if(n.length===2)return new Me(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return g(X(t)||V(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},is=ko;$c(is,"DROP_NAN_MODE","DROP_NAN_MODE");$c(is,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Jo(e,t,n,r){if(V(e))return Jo(e.values,t,n,r);if(V(t))return Jo(e,t.values,n,r);if(g(D(e)&&D(t)&&Z(e).length===1&&Z(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),g(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Jo(...new is().fitAndTransform(e,t),!1,r);try{let o=Ft(e,{stdev:r}),u=Ft(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!C(s)||!C(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!C(f))return NaN;if(!C(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function xi(e,t,n){if(V(e))return xi(e.values,t,n);if(V(t))return xi(e,t.values,n);g(D(e)&&D(t)&&Z(e).length===1&&Z(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),g(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Jo(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function Dp(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var Sp=pe(Dp),Op=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function ea(e,t){if(X(e)||V(e))return ea(e.values,t);if(X(t)||V(t))return ea(e,t.values);g(D(e)&&D(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Kt(e),r=Kt(t),o=[];return n.forEach(u=>{r.findIndex(s=>dn(s,u))<0&&o.push(u)}),o}function xc(e,t){try{if(!C(e))return NaN;if(!C(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=xc(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var la=pe(xc);function ef(e){try{if(!C(e))return NaN;if(typeof e=="bigint"){let t=ef(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var tf=pe(ef);function Fp(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!C(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var nf=pe(Fp);function $r(){return nf(...arguments)}function rf(e,t){return es(e,$r(t,-1))}function ca(e,t){return Ft(e,{shouldDropNaNs:t}).sum}function ta(e,t){if(C(e)&&C(t))return aa(e-t);if(X(e)||V(e))return ta(e.values,t);if(X(t)||V(t))return ta(e,t.values);D(e)&&D(t)&&g(dn(Z(e),Z(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return tf(ca(la(rf(e,t),2)))}catch{return NaN}}function _p(e,t){return $r(e,la(t,-1))}function Jn(e,t){if(X(e)){let o=Jn(e.values,t);if(Z(o).length===1){let u=new gt(o);return u.name=V(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Me(o);return u.index=e.index.slice(),X(t)&&(u.columns=t.columns.slice()),u}}if(X(t)){let o=Jn(e,t.values);if(Z(o).length===1){let u=new gt(o);return u.name=V(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Me(o);return u.columns=t.columns.slice(),u}}if(V(e))return Jn(e.values,t);if(V(t))return Jn(e,t.values);g(D(e)&&D(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=Z(e),r=Z(t);if(g(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),g(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return ca($r(e,t));if(n.length===1&&r.length===2)return $n(t).map(o=>Jn(e,o));if(n.length===2&&r.length===1)return e.map(o=>Jn(o,t));if(n.length===2&&r.length===2){let o=$n(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(Jn(e[s],o[a]));u.push(i)}return u}}function fa(e){if(X(e)||V(e))return e.dropMissing(...Object.values(arguments).slice(1));g(D(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(fa(n))}catch{Y(n)||t.push(n)}}),t}function qu(e,t){if(X(e)||V(e))return qu(e.values,t);if(X(t)||V(t))return qu(e,t.values);g(D(e)&&D(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),g(dn(Z(e),Z(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=qu(e[o],t[o]);n.push(u),r.push(s)}catch{!Y(e[o])&&!Y(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function Hu(e,t){if(X(e)||V(e))return Hu(e.values,t);if(X(t)||V(t))return Hu(e,t.values);g(D(e)&&D(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),g(dn(Z(e),Z(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Hu(e[o],t[o]);n.push(u),r.push(s)}catch{C(e[o])&&C(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function Tp(e){return fa(e)}function ns(e,t){if(X(e)||V(e))return ns(e.values,t);g(D(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),g(qe(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(D(n)){if(!ns(n,t))return!1}else if(!t(n))return!1;return!0}function Ap(e){try{if(!C(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var Ip=pe(Ap);function na(e){try{return typeof e=="bigint"?BigInt(na(gn(e))):e!==gn(e)?NaN:e<=1?1:e*na(e-1)}catch{return NaN}}var jp=pe(na);function ra(e,t){if(X(e)||V(e))return ra(e.values,t);if(g(mn(e)||D(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!qe(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(mn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(D(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function oa(e,t){if(X(e)||V(e))return oa(e.values,t);if(g(mn(e)||D(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!qe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(mn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(D(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function Cp(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return C(t)?t:NaN}catch{return NaN}}var Mp=pe(Cp);function Bp(e){try{return C(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var Pp=pe(Bp);function ha(e){C(e)&&(e=[e]);let t=[],n=zo(e);for(let r=0;r<n;r++)t.push(0);return $o(t,e)}function Rp(e){typeof e=="bigint"&&(e=gn(e)),g(!Y(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),g(C(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),g(gn(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),g(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=ha([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var kp=["true","false","yes","no"],Yp=["null","none","nan","na","n/a","","undefined"];function Gu(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=gn(e.value)===e.value:e.isInteger=ns(e.values,t=>C(t)?gn(t)===t:!0)),e}function Qu(e){if(X(e)){let u=e.copy(),s=Qu(e.values);return u.values=s.values,Gu({type:s.type,values:u})}if(V(e)){let u=e.copy(),s=Qu(e.values);return u.values=s.values,Gu({type:s.type,values:u})}if(!D(e)){let u=Qu([e]);return u.value=u.values[0],delete u.values,Gu(u)}g(D(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=Qt(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(Ht(a))return"date"}}catch{}he(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(Yp.indexOf(i)>-1)return"null";if(kp.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return C(a)?"number":typeof a=="object"?D(a)?"string":"object":"string"}catch{let l=new Date(u);return Ht(l)?"date":"string"}}),n=Xu(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return Gu({type:o,values:ss(e,u=>Ot(u,o))})}function Zu(e){if(X(e)){let n=e.copy();return n.values=Zu(n.values),n}g(D(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=Z(e);if(g(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),g(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),g(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){g(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;g(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return $r(i,1/s)}else if(t[0]>1){let n=(r,o)=>C(r)||C(o)?$r(r,o):Jn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=Zu(o),l=Zu(es(i,n(-1,n(n(s,a),u)))),c=es(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}g(!1,"This matrix cannot be inverted!")}}var Jp=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function of(e,t,n){try{if(!C(e))return NaN;if(!C(t))return NaN;if(!C(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=of(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var $p=pe(of);function uf(e,t){try{if(t=Y(t)?Math.E:t,!C(e))return NaN;if(!C(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=uf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var Kp=pe(uf);function Up(e,t){return Ft(e,{shouldDropNaNs:t}).mean}function Lp(e,t){return Ft(e,{shouldDropNaNs:t,median:!0}).median}function sf(e,t){try{if(!C(e))return NaN;if(!C(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=sf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var Vp=pe(sf);function zp(e,t){return Ft(e,{shouldDropNaNs:t,mode:!0}).mode}function Bc(){let e=Jr(),t=Jr();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function Wp(e){return Y(e)?Bc():ss(qt(e),Bc)}function Gp(e){return ss(qt(e),()=>1)}function ma(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of Zc(r,o)){if(!u.slice)continue;let s=ha(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return X(e)||V(e)?ma(e.values,t):(g(D(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),Y(t)&&(t=e.length),g(C(t)&&gn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Qt(e),t))}function qp(e,t){let n=[];for(let r of ma(e,t))n.push(r.slice());return n}function Hp(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(D(t))if(Lo(t))console.log(t);else{let n=Z(t);n.length===1?new gt(t).print():n.length==2?new Me(t).print():console.log(t)}else X(t)||V(t)?t.print():console.log(t)})}var Qp=pe((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!C(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function Zp(e,t,n,r,o){if(D(e)&&Y(r)&&Y(o)){r=t,o=n;let u=Ft(e);t=u.min,n=u.max}return Qp(e,t,n,r,o)}function Xp(e){try{return C(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var xp=pe(Xp);function af(e){try{return C(e)?typeof e=="bigint"?BigInt(af(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var ey=pe(af);function ty(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var ny=pe(ty);function ua(e,t){if(X(e)||V(e))return ua(e.values,t);g(D(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),g(qe(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(D(n)){if(ua(n,t))return!0}else if(t(n))return!0;return!1}function lf(e,t){return Ft(e,{shouldDropNaNs:t,stdev:!0}).stdev}function ry(e){return lf(e)}function oy(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var uy=pe(oy);function Pc(e,t){g(qe(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function sy(e,t){g(qe(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function iy(){return Kt([...arguments].map(e=>D(e)?e:X(e)||V(e)?e.values:[e]))}function ay(e,t){return Ft(e,{shouldDropNaNs:t,variance:!0}).variance}function ly(){let e=[],t=Object.values(arguments).map(n=>((X(n)||V(n))&&(n=n.values),g(D(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Be(0,us(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(Y(u)?void 0:u)}),e.push(r)}),e}var Yo={abs:aa,add:es,apply:ss,arccos:mp,arcsin:gp,arctan:yp,argmax:Qi,argmin:Zi,assert:g,cast:Ot,ceil:vp,chop:wp,clamp:Ep,combinations:Zc,combinationsIterator:ts,copy:tt,correl:xi,cos:Sp,count:Xu,covariance:Jo,DataFrame:Me,dataTypes:Op,decycle:dr,diff:ea,distance:ta,divide:_p,dot:Jn,dropMissing:fa,dropMissingPairwise:qu,dropNaN:ia,dropNaNPairwise:Hu,dropUndefined:Tp,every:ns,exp:Ip,factorial:jp,find:ra,findAll:oa,flatten:Qt,float:Mp,floor:Pp,identity:Rp,IndexMatcher:is,indexOf:kr,inferType:Qu,int:gn,intersect:Xc,inverse:Zu,isArray:D,isBoolean:mr,isBrowser:Jp,isDataFrame:X,isDate:Ht,isEqual:dn,isFunction:qe,isJagged:Lo,isNested:os,isNumber:C,isObject:mn,isSeries:V,isString:he,isUndefined:Y,lerp:$p,log:Kp,MathError:rr,max:us,mean:Up,median:Lp,min:Hc,mod:Vp,mode:zp,multiply:nf,ndarray:qt,normal:Wp,ones:Gp,permutations:qp,permutationsIterator:ma,pow:la,print:Hp,product:zo,random:Jr,range:Be,remap:Zp,reshape:$o,reverse:hn,round:xp,scale:$r,seed:Wc,Series:gt,set:Kt,shape:Z,shuffle:xu,sign:ey,sin:ny,some:ua,sort:gr,sqrt:tf,stats:Ft,std:lf,stdev:ry,subtract:rf,sum:ca,tan:uy,timeAsync:sy,timeSync:Pc,time:Pc,transpose:$n,union:iy,variance:ay,vectorize:pe,zeros:ha,zip:ly,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Yo.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Yo).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Yo[t]})}catch{e[t]=Yo[t]}})}};typeof window<"u"&&(window.JSMathTools=Yo);var cy=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:void 0;function sa(e){let t=Symbol.for("@TypedArrayConstructor"),n="Symbol(@TypedArrayConstructor)",r=t in e?t:n in e?n:void 0;if(r){if(!("values"in e))throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");return e[r]==="ArrayBuffer"?new Uint8Array(e.values).buffer:new cy[e[r]](e.values)}if(D(e)&&e.constructor.name==="Array")return e;throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!")}function Rr(e){if(e instanceof ArrayBuffer||e instanceof BigInt64Array||e instanceof BigUint64Array||e instanceof Float32Array||e instanceof Float64Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Int8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:e.constructor.name,values:e instanceof ArrayBuffer?Array.from(new Uint8Array(e)):Array.from(e)};if(D(e))return e.map(t=>{try{return Rr(t)}catch{return t}});if(typeof e=="object"&e!==null){if(Ht(e))return new Date(e.getTime());let t={};return Object.keys(e).forEach(n=>{try{t[n]=Rr(e[n])}catch{t[n]=e[n]}}),t}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function cf(e){return e=e.trim(),!!(e.match(/^-?\d+(\.\d+)?$/g)||e.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g)||e.match(/^-?\.\d+$/g)||e==="NaN")}var ff="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";function hf(e,t,n){if(typeof e!="string")throw new Error("`text` must be a string!");if(typeof t!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return e.split(t).join(n)}var Rc="  ",kc=" ";function Wo(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t="";for(let n=0;n<e.length;n++){let r=e[n].toLowerCase();ff.includes(r)?t+=kc:t+=r}for(;t.includes(Rc);)t=hf(t,Rc,kc);return t.trim()}function fy(e,t){return t=t||"",e.split(`
`).map(n=>n.trim().length>0?t+n:n).join(`
`)}function hy(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=Wo(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("-")}var Yc={"@Infinity":1/0,"@NegativeInfinity":-1/0,"@NaN":NaN,"@undefined":void 0};function Ko(e){if(typeof e=="object"){if(e===null)return e;if(D(e))for(let t=0;t<e.length;t++)e[t]=Ko(e[t]);else Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{e[t]=Ko(e[t])});return e}else return typeof e>"u"||e==="Symbol(@undefined)"?void 0:e}function my(e){if(typeof e=="bigint")return e;if(typeof e=="string")if(e.match(/^\s*?-?\d+n\s*?$/g))try{return BigInt(e.split("n")[0])}catch{return NaN}else return NaN;else return NaN}function dy(e){if(typeof e!="string")return typeof e=="number"?e:void 0;if(cf(e))return parseFloat(e)}function gy(e){if(typeof e!="string")return;let t="@jrc03c/js-text-tools/newline-replacer";if(e=e.replaceAll(`
`,t),e.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)){let n=e.replace("Symbol(@String):","");if(n.match(/^".*?"$/g))try{return JSON.parse(n)}catch{n=n.substring(1,n.length-1)}return n=n.replaceAll(t,`
`),n}}function py(e){if(typeof e!="string")return typeof e=="symbol"?{out:e,isASymbol:!0}:void 0;if(e.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)){let t=e.replace(/^.*?Symbol\(/g,"").replace(/\).*?$/g,"");return t in Yc?{out:Yc[t],isASymbol:!0}:{out:Symbol.for(t),isASymbol:!0}}}function yy(e){if(typeof e!="string")return e instanceof RegExp?e:void 0;let t=e.trim();if(t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g))try{let n=t.replace(/^\//g,"").replace(/\/(d|g|i|m|s|u|v|y)*?$/g,""),r=t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);return new RegExp(n,r)}catch{}}function by(e){if(typeof e!="string")return typeof e=="object"?e:"Symbol(@undefined)";try{let t=JSON.parse(e,(n,r)=>{try{let o=rs(r);return typeof o>"u"?"Symbol(@undefined)":o}catch{return typeof r>"u"?"Symbol(@undefined)":r}});return D(t)&&(t=Ko(t)),t}catch{return e}}function vy(e){if(typeof e!="string")return e instanceof Date&&e.toString()!=="Invalid Date"?e:void 0;try{let t=new Date(Date.parse(e));if(t.toString()!=="Invalid Date")return t}catch{}}function Ny(e){return typeof e=="object"?e!==null?Ko(e):void 0:(Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{try{let n=t;try{t=rs(t)}catch{}e[t]=rs(e[n]),t!==n&&delete e[n]}catch{}}),Ko(e))}function rs(e){function t(n){if(typeof n=="string"){let r=gy(n);if(typeof r=="string")return r;let o=py(n);return r=o?o.out:void 0,o&&o.isASymbol||(r=yy(n),r instanceof RegExp)||(r=my(n),typeof r=="bigint")||(r=dy(n),typeof r=="number")||(r=vy(n),r instanceof Date)?r:(r=by(n),typeof r<"u"?r==="Symbol(@undefined)"?void 0:r:n)}if(typeof n=="object"){if(n===null)return null;let r;try{if(r=sa(n),D(r))return r}catch{}if(r=Ny(n),r)try{return sa(r)}catch{return r}return n}return n}return t(e)}function wy(e){let t=Jc(e);return t[0].toUpperCase()+t.slice(1)}function Ey(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=Wo(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("_")}function nr(e,t){return!e||t<=0?"":Be(0,t).map(()=>e).join("")}function mf(e,t){g(he(t)||Y(t),"The second parameter to the `stringify` function must be undefined or a string!");let n=t?`
`:"";function r(o,u,s){return s=s||0,typeof o=="bigint"?JSON.stringify(o.toString()+"n"):typeof o=="number"?o===1/0?'"Symbol(@Infinity)"':o===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(o)?'"Symbol(@NaN)"':o.toString():typeof o=="string"?JSON.stringify("Symbol(@String):"+o):typeof o=="boolean"?o.toString():typeof o>"u"?'"Symbol(@undefined)"':typeof o=="symbol"||typeof o=="function"?JSON.stringify(o.toString()):o instanceof RegExp?o.toString():typeof o=="object"?o===null?"null":Ht(o)?JSON.stringify(o.toJSON()):D(o)?o.length===0?nr(u,s-1)+"[]":o instanceof Array?nr(u,s-1)+"["+n+o.map(i=>{let a=(()=>{try{return r(Rr(i),u,s+1)}catch{return r(i,u,s+1)}})();return he(a)&&(a=a.trim()),nr(u,s+1)+a}).join(","+n)+n+nr(u,s)+"]":r(Rr(o),null,u):Object.keys(o).length+Object.getOwnPropertySymbols(o).length===0?nr(u,s-1)+"{}":nr(u,s-1)+"{"+n+Object.keys(o).concat(Object.getOwnPropertySymbols(o)).map(i=>{let a=(()=>{try{return r(Rr(o[i]),u,s+1)}catch{return r(o[i],u,s+1)}})();he(a)&&(a=a.trim());let l=typeof i=="symbol"?r(i):JSON.stringify(i);return nr(u,s+1)+l+":"+(u?" ":"")+a}).join(","+n)+n+nr(u,s)+"}":"undefined"}return r(dr(e),t)}function Dy(e){let t=e.split(`
`),n=t.filter(o=>o.trim().length>0).map(o=>o.split("").findIndex(u=>!u.match(/\s/g))),r=Math.min(...n);return t.map(o=>o.substring(r)).join(`
`)}function Sy(e,t){if(typeof e!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof t>"u"||t===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?t=process.stdout.columns>80?80:process.stdout.columns:t=80),isNaN(t)||typeof t!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return e.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let o=r.split(/[^\s]/g)[0],u=r.replace(o,"").split(" "),s=o;u.forEach(i=>{let a=s+(s.trim().length>0?" ":"")+i;a.length>t?(n.push(s),s=o+i):s=a}),s.length>0&&n.push(s)}),n.join(`
`)}typeof window<"u"&&(window.JSTextTools={camelify:Jc,convertObjectToTypedArray:sa,convertTypedArrayToObject:Rr,indent:fy,isANumberString:cf,kebabify:hy,parse:rs,pascalify:wy,punctuation:ff,replaceAll:hf,snakeify:Ey,stringify:mf,strip:Wo,unindent:Dy,wrap:Sy});function da(e){let t=e.match(/[A-Za-z]'([A-Za-z]|\s)/g);for(;t;)t.forEach(r=>{e=e.replaceAll(r,r.replaceAll("'",""))}),t=e.match(/[A-Za-z]'([A-Za-z]|\s)/g);let n=Wo(e.toLowerCase()).replaceAll(/\s/g," ");for(;n.includes("  ");)n=n.replaceAll("  "," ");return n.trim()}var Oy=Object.defineProperty,Fy=(e,t,n)=>t in e?Oy(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Df=(e,t,n)=>(Fy(e,typeof t!="symbol"?t+"":t,n),n);function M(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var _y=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),or=class extends Error{constructor(e){_y()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function b(e,t){if(!e)throw new or(t)}var Sf=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function K(e){return e===null||typeof e>"u"}var Ty=Sf.map(e=>e.name);function _(e){try{return e instanceof Array?!0:K(e.constructor)?!1:Sf.indexOf(e.constructor)>-1||Ty.indexOf(e.constructor.name)>-1}catch{return!1}}function ee(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function He(e){return typeof e=="function"}function yn(e){return typeof e=="object"&&!K(e)&&!_(e)}function z(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function Vr(e,t){if(ee(e)){let u=Vr(e.values,t);return u.length>0&&M(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&M(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(z(e)){let u=Vr(e.values,t);return u.length>0&&M(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(b(yn(e)||_(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!He(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(yn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(_(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function nt(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(_(n))return n instanceof Array?n.map(o=>nt(o)):n.slice();if(z(n)){let o=n.copy();return o.values=nt(o.values),o}if(ee(n)){let o=n.copy();return o.values=nt(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=zr(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=nt(n[o])}),r}else return n}return t(zr(e))}function zr(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+Vr(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),_(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(ee(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(z(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function Kn(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var df=["number","int","float","bigint"];function bn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!df.includes(u)&&!df.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(Kn(r))return Kn(o)?r.getTime()===o.getTime():!1;if(Kn(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(_(r)!==_(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(zr(e),zr(t))}}function Zo(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Ay=Zo(16),Iy=Zo(16),jy=Zo(16),Cy=Zo(16),My=Zo(16),By=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)_(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Ay:K(e)?Iy:He(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+My:e===1/0?jy:e===-1/0?Cy:typeof e=="bigint"?e.toString():ee(e)?e.toJSONString():z(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!K(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function Xt(e){if(ee(e)||z(e))return Xt(e.values);b(_(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{_(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function At(e,t){t=t||{};let n=new By,r={},o=Xt(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||M(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function ds(e,t){let{counts:n}=At(e);return K(t)||(He(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{bn(r,t)||n.delete(r)})),n}function ga(e){if(ee(e)||z(e))return ga(e.values);if(_(e)){let t=!1,n=!1,r=null;for(let o of e){if(ga(o))return!0;if(_(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function Xo(e){return ga(zr(e))}function vs(e){if(ee(e)||z(e))return vs(e.values);b(_(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(_(e[t]))return!0;return!1}var Kr="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Zt(e){b(!K(e),Kr),_(e)||(e=[e]),b(!vs(e),Kr),b(e.length>0,Kr);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),b(M(t),Kr),b(t>=0,Kr),b(Math.floor(t)===t,Kr),b(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(Zt(e.slice(1)));return n}}function pn(e){if(ee(e)||z(e)){let n=e.copy();return n.values=pn(n.values),n.index=pn(n.index),n}b(_(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Le(e,t,n=1){b(!K(e)&&!K(t)&&!K(n),"You must pass two numbers and optionally a step value to the `range` function!"),b(M(e)&&M(t)&&M(n),"You must pass two numbers and optionally a step value to the `range` function!"),b(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=pn(u)),u}function xo(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Py=xo(256),Ry=xo(256),ky=xo(256),Yy=xo(256),Jy=xo(256);function Et(e){if(ee(e)||z(e))return Et(e.values);b(_(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return Xt(e).forEach(r=>{let o=typeof r=="object"&&r===null?Py:K(r)?Ry:He(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Jy:r===1/0?ky:r===-1/0?Yy:typeof r=="bigint"?r.toString():ee(r)?r.toJSONString():z(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function Of(e){if(_(e)){let t=Of(e[0]);return[e.length].concat(t||[])}else return}function x(e){return ee(e)||z(e)?x(e.values):(b(_(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Of(e))}function Ff(e,t,n){if(K(n)&&(n=0),b(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),_(t)){b(!Xo(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=x(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Le(0,o).forEach(s=>{s>=u._values.length&&u._values.push(Zt(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Le(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(Zt(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new or("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(z(t)){let r=Ff(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(ee(t))if(n===0){let r=e.copy(),o=Et(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(Zt(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(Zt(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new or("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function $y(e,t,n,r,o){if(o=o||0,b(He(r),"The first parameter to the `apply` method must be a function."),b(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,K(s)&&(s=c instanceof t||_(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return K(u)&&(u=c instanceof t||_(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function Se(e){return typeof e=="string"}function Ky(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(K(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(yn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new or("You must pass a DataFrame, Series, or object into the `assign` method!")}else{b(Se(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),b(_(o)&&!Xo(o)&&x(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function Uy(e,t){if(t.isEmpty)return new e;let n=new e(nt(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function Ly(e,t,n,r,o){K(r)&&(r=[]),K(o)&&(o=[]),(Se(r)||M(r))&&(r=[r]),(Se(o)||M(o))&&(o=[o]),b(_(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),b(_(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),b(x(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),b(x(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function _f(e){return M(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function Wr(e){return _f(e)&&e>=0}function Vy(e,t,n,r,o,u){r=r||0,b(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,b(Wr(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",b(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(K(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(K(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!K(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(x(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(K(c))return new e;Se(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function Fa(e){if(ee(e)||z(e))return e.dropNaN(...Object.values(arguments).slice(1));b(_(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Fa(n))}catch{if(M(n))return t.push(n)}}),t}function zy(e,t,n,r,o){n=n||0,b(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,b(Wr(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",b(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=Fa(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function gf(e){let t={};return Xt(e).forEach((n,r)=>{t[n]=r}),t}function Ur(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function Wy(e,t,n,r,o){b(He(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),K(o)&&(o=0),b(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=gf(u.index),i=gf(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Ur(s)[0],c.index=Ur(i),c}u.values=l,u.index=Ur(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Ur(i)[0],c.index=Ur(s),c}u.values=l,u.index=Ur(i),u=u.transpose()}return u}function Gy(e,t,n){(Se(t)||M(t))&&(t=[t]),(Se(n)||M(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Et((t||[]).concat(n||[]).map(o=>typeof o));return b(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&b(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(b(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),b(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),K(t)||(t=t.map(o=>{if(Se(o))return b(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(M(o))return b(o>=0,`Index ${o} is out of bounds!`),b(Math.floor(o)===o,"Row numbers must be integers!"),b(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),K(n)||(n=n.map(o=>{if(Se(o))return b(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(M(o))return b(o>=0,`Column ${o} is out of bounds!`),b(Math.floor(o)===o,"Column numbers must be integers!"),b(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function qy(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Un(e,t){if(K(t)&&(t=qy),ee(e)||z(e))return e.sort(...Object.values(arguments).slice(1));b(_(e),"The `sort` function only works on arrays, Series, and DataFrames!"),b(He(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function Hy(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function pf(e,t,n){K(n)?n=t.columns:Se(n)&&(n=[n]);let r={};n.forEach(u=>{b(Se(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);b(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Un(Et(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+Hy(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function Qy(e,t,n){let r=e.shape;K(t)&&(t=Le(0,r[0])),K(n)&&(n=Le(0,r[1])),M(t)&&(t=[t]),M(n)&&(n=[n]),b(_(t)&&_(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),b(x(t).length===1&&x(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),b(t.length>0,"The `rowIndices` array must contain at least one index."),b(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{b(Wr(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),b(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{b(Wr(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),b(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function Zy(e,t,n,r,o){K(r)&&(r=n.index),K(o)&&(o=n.columns),Se(r)&&(r=[r]),Se(o)&&(o=[o]),b(_(r)&&_(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),b(x(r).length===1&&x(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),b(r.length>0,"The `rows` array must contain at least one row name."),b(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{b(Se(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),b(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{b(Se(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),b(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function Xy(e,t,n){function r(h,m){return Se(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Le(0,u).concat(Le(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Le(0,i).concat(Le(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Le(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function Lr(e,t){b(M(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function xy(e,t){let n=t?e:e.copy();return n.index=Le(0,e.shape[0]).map(r=>"row"+Lr(r,(n.index.length-1).toString().length)),n}function eu(e,t){if(ee(e)||z(e))return eu(e.values,t);b(_(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=Xt(e),r=!1,o=1;for(let u of n){if(!M(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function e0(e){return _f(e)&&e>0}function Qo(e,t){if(ee(e)||z(e))return Qo(e.values,t);if(b(_(e),"The first argument passed into the `reshape` function must be an array!"),M(t)&&(t=[t]),b(_(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),b(x(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),b(e0(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return Xt(e);let n=Xt(e);if(t.length===1&&t[0]===n.length)return n;b(eu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(Qo(s,t.slice(1)))}return r}var Tf=Math.pow(2,64),_e=[];Af(Math.floor(Math.random()*Tf));function t0(e,t){e=lt(e);function n(){e+=lt("0x9e3779b97f4a7c15");let o=nt(e);return o=(o^o>>BigInt(30))*lt("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*lt("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function lt(e){return BigInt.asUintN(64,BigInt(e))}function yf(e,t){return e=lt(e),t=BigInt(t),lt(lt(e<<t)|lt(e>>lt(BigInt(64)-t)))}function Af(e){if(typeof e=="bigint"&&(e=Number(e)),K(e))return nt(_e);{b(M(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=t0(Math.floor(e),4);_e[0]=t[0],_e[1]=t[1],_e[2]=t[2],_e[3]=t[3]}}function bf(){let e=lt(yf(_e[0]+_e[3],23)+_e[0]),t=lt(_e[1]<<BigInt(17));return _e[2]=lt(_e[2]^_e[0]),_e[3]=lt(_e[3]^_e[1]),_e[1]=lt(_e[1]^_e[2]),_e[0]=lt(_e[0]^_e[3]),_e[2]=lt(_e[2]^t),_e[3]=yf(_e[3],45),Math.floor(Number(e))/Tf}function Gr(e){return K(e)?bf():(_(e)||(e=[e]),Qo(Zt(eu(e)).map(bf),e))}function gs(e){if(ee(e)||z(e))return e.shuffle(...Object.values(arguments).slice(1));b(_(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(Gr()*n.length);t.push(n.splice(o,1)[0])}return t}function n0(e,t){return K(t)&&(t=0),b(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?gs(e.index):null,t===1?gs(e.columns):null)}function pr(e){return typeof e=="boolean"}function r0(e,t,n){return He(t)?o0(e,t,n):u0(e,t,n)}function o0(e,t,n){if(n=K(n)?0:n,b(He(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),b(M(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Un(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Un(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function u0(e,t,n){let r=e.copy(),o=Gr().toString();r=r.assign(o,r.index),K(t)&&(t=[o],n=[!0]),(M(t)||Se(t))&&(t=[t],(pr(n)||Se(n))&&(n=[n])),b(_(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),b(x(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),K(n)&&(n=Le(0,t.length).map(()=>!0)),b(_(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),b(x(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),b(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(b(Se(s)||M(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),Se(s)){let i=r.columns.indexOf(s);return b(i>-1,`The column "${s}" does not exist!`),i}if(M(s))return b(Wr(s),"Column indices must be whole numbers!"),b(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(b(Se(s)||pr(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),Se(s)){let i=s.trim().toLowerCase();return b(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(pr(s))return s}),r.values=Un(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function s0(e,t){K(t)?t=0:b(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function If(e,t){return JSON.stringify(e.toObject(t))}async function i0(e,t,n){let r=If(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new or(s):typeof module<"u"?new or(i):new or("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function a0(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function Ln(e){if(ee(e)||z(e))return e.transpose();b(_(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=x(e);if(b(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return pn(e);if(t.length===2){let n=Zt(pn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function jf(e,t,n){if(z(n))return new e(t.values.concat(n.values));if(_(n)){let r=x(n);b(r.length===1&&!vs(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return jf(t,[n])}function l0(e,t){b(He(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function c0(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>K(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function f0(e,t){let n=[],r=[];t.values.forEach((u,s)=>{M(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function h0(e,t,n){let r=t.copy(),o=nt(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function m0(e,t){(Se(t)||M(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Et((t||[]).map(r=>typeof r));return b(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&b(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(b(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),b(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),K(t)||(t=t.map(r=>{if(typeof r=="string")return b(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return b(r>=0,`Index ${r} is out of bounds!`),b(Math.floor(r)===r,"Indices must be integers!"),b(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function d0(e,t){let n=e.shape;K(t)&&(t=Le(0,n[0])),b(_(t),"The `indices` array must be 1-dimensional array of whole numbers."),b(x(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),b(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{b(Wr(o),"The `indices` array must be a 1-dimensional array of whole numbers."),b(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function g0(e,t,n){K(n)&&(n=t.index),b(_(n),"The `indices` array must be a 1-dimensional array of strings."),b(x(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),b(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{b(Se(u),"The `indices` array must contain only strings."),b(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function p0(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Le(0,n/2).concat(Le(t.index.length-n/2,t.index.length)));let o=nt(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function y0(e){let t=e.copy();return t.get(gs(t.index))}function b0(e,t,n){n=n||((a,l)=>a<l?-1:1),b(K(n)||He(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Ln([t.values,t.index]),o=Un(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function v0(e,t){let n=Ln([t.values,t.index]);n=Ln(Un(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function N0(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var vf=Symbol.for("@jrc03c/js-math-tools/series");function w0(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===vf}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:vf}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){b(_(o),"The new values must be a 1-dimensional array!");let u=x(o);b(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Le(this._index.length,u[0]).map(s=>"item"+Lr(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){b(_(o),"The new index must be a 1-dimensional array of strings!"),b(o.length===this.shape[0],"The new index must be the same length as the old index!"),b(x(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{b(Se(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=nt(r.values),this.index=nt(r.index);else if(_(r)){let o=x(r);b(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());b(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];b(x(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return x(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!K(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return m0(this,r)}getSubsetByNames(r){return g0(t,this,r)}getSubsetByIndices(r){return d0(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(pn(this.values));return r.index=pn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Le(0,this.shape[0]).map(o=>"item"+Lr(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=nt(this.values),r._index=nt(this.index),r.name=this.name,r}append(r){return jf(t,this,r)}apply(r){return l0(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return c0(this,r,o)}dropNaN(){return f0(t,this)}toObject(){return N0(this)}print(){return p0(this)}shuffle(){return y0(this)}sort(r){return b0(t,this,r)}sortByIndex(){return v0(t,this)}filter(r){return h0(t,this,r)}toDataFrame(){let r=new e(Ln([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=pn(r.values),r.index=pn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Nf=Symbol.for("@jrc03c/js-math-tools/dataframe");function as(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(Gr()*t.length)];return n}var Pe=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Nf}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Nf}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!K(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){b(_(t),"The new values must be a 2-dimensional array!");let n=x(t);b(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Le(this._index.length,n[0]).map(r=>"row"+Lr(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Le(this._columns.length,n[1]).map(r=>"col"+Lr(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){b(_(t),"The new columns list must be a 1-dimensional array of strings!"),b(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),b(x(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+as(8):r.trim()));let n=(()=>{let r=ds(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+as(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){b(_(t),"The new index must be a 1-dimensional array of strings!"),b(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),b(x(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+as(8):r.trim()));let n=(()=>{let r=ds(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+as(8):r),this._index=t}}),b(K(e)||yn(e)||_(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Pe)this.values=nt(e.values),this.columns=nt(e.columns),this.index=nt(e.index);else if(_(e)){let t=x(e);b(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),b(!Xo(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{K(r)&&(n=u,r=e[u].length),b(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=Ln(t);let o=x(this.values);this._index=Le(0,o[0]).map(u=>"row"+Lr(u,(o[0]-1).toString().length))}}get shape(){return x(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Pe(Zt(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return Gy(this,e,t)}getSubsetByNames(e,t){return Zy(Pe,pt,this,e,t)}getSubsetByIndices(e,t){return Qy(this,e,t)}getDummies(e){return pf(Pe,this,e)}oneHotEncode(e){return pf(Pe,this,e)}transpose(){let e=new Pe(Ln(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return xy(this,e)}copy(){return Uy(Pe,this)}assign(e,t){return Ky(Pe,pt,this,e,t)}apply(e,t){return $y(Pe,pt,this,e,t)}dropMissing(e,t,n){return Vy(Pe,pt,this,e,t,n)}dropNaN(e,t,n){return zy(Pe,this,e,t,n)}drop(e,t){return Ly(Pe,pt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return s0(this,e)}toObject(){return a0(this)}toJSONString(e){return If(this,e)}saveAsJSON(e,t){return i0(this,e,t)}print(){return Xy(Pe,pt,this)}sort(e,t){return r0(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return Wy(Pe,pt,this,e,t)}shuffle(e){return n0(this,e)}append(e,t){return Ff(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},pt=w0(Pe);function Ns(e,t){return At(e,{shouldDropNaNs:t}).max}function ye(e){return b(He(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return _(a)?!0:z(a)?(n=!0,o.push(a),!0):ee(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{b(bn(_(i)?x(i):i.shape,_(s[a+1])?x(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=Ns(s.map(l=>l.length?l.length:l.values.length)),a=Le(0,i).map(l=>{let c=Object.keys(arguments).map(f=>_(arguments[f])?arguments[f][l]:z(arguments[f])||ee(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&bn(x(u[0]),x(a))){let l=new Pe(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Pe(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new pt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new pt(a)}catch{return a}return a}else return e(...arguments)}}function E0(e){try{return M(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var _a=ye(E0);function D0(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!M(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var ps=ye(D0);function S0(e,t){try{return t(e)}catch{return NaN}}var ws=ye(S0);function O0(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var F0=ye(O0);function _0(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var T0=ye(_0);function A0(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var I0=ye(A0);function pa(e,t){if(ee(e)){let n=pa(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(z(e)){let n=pa(e.values,t);return e.index[n]}b(_(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=Vr(e,Ns(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Cf(e,t){return At(e,{shouldDropNaNs:t}).min}function ya(e,t){if(ee(e)){let n=ya(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(z(e)){let n=ya(e.values,t);return e.index[n]}b(_(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=Vr(e,Cf(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function _t(e,t){if(ee(e)||z(e))return e.apply(n=>_t(n,t));if(_(e))return e.map(n=>_t(n,t));if(t==="null")return null;if(t==="number"){if(K(e))return NaN;let n=_t(e,"boolean");if(pr(n))return n?1:0;try{JSON.parse(e)}catch{let u=_t(e,"date");if(Kn(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=_t(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return _t(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(_t(e,"int"));if(t==="boolean"){if(pr(e))return e;if(M(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Kn(e))return e;if(K(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return Kn(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(yn(e))return e;let n=_t(e,"boolean");if(pr(n))return null;try{let o=_t(e,"number");if(M(o))return JSON.parse(e),null}catch{}let r=_t(e,"date");if(r)return r;try{let o=JSON.parse(e);return _(o)?o.map(u=>_t(u,t)):o}catch{return null}}if(t==="string")return K(e)?bn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function j0(e){try{return M(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var C0=ye(j0);function M0(e,t){try{if(!M(e))return NaN;if(typeof e=="bigint")return e;if(K(t))t=1e-10;else if(!M(t))return NaN;return _a(e)<t?0:e}catch{return NaN}}var B0=ye(M0);function ba(e){if(ee(e)||z(e)){let t=e.copy();return t.values=ba(t.values),t}if(_(e))return e.map(t=>ba(t));try{let t=JSON.parse(e);return M(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var vn=ye(ba);function Mf(e,t,n){try{return M(e)?M(t)?M(n)?typeof e=="bigint"?BigInt(Mf(vn(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var Ta=ye(Mf);function ys(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of ys(i,o-1))yield[s].concat(a)}}return ee(e)||z(e)?ys(e.values,t):(b(_(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),b(M(t)&&vn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Xt(e),t))}function Bf(e,t){let n=[];for(let r of ys(e,t))n.push(r.slice());return n}function Pf(){let e=Object.values(arguments).map(n=>ee(n)||z(n)?Et(n.values):(b(_(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Et(n)));return Et(e).filter(n=>e.every(r=>r.findIndex(o=>bn(o,n))>-1))}var Go=class{constructor(e){b(K(e)||e===Go.DROP_NAN_MODE||e===Go.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=K(e)?Go.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(_(t)){let n=x(t);if(n.length===1)t=new pt(t);else if(n.length===2)t=new Pe(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}b(ee(t)||z(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===Go.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Pf(...e),this}transform(){b(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(_(t)){let n=x(t);if(n.length===1)return new pt(t).get(this.index).values;if(n.length===2)return new Pe(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return b(ee(t)||z(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Es=Go;Df(Es,"DROP_NAN_MODE","DROP_NAN_MODE");Df(Es,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Ho(e,t,n,r){if(z(e))return Ho(e.values,t,n,r);if(z(t))return Ho(e,t.values,n,r);if(b(_(e)&&_(t)&&x(e).length===1&&x(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),b(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Ho(...new Es().fitAndTransform(e,t),!1,r);try{let o=At(e,{stdev:r}),u=At(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!M(s)||!M(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!M(f))return NaN;if(!M(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function va(e,t,n){if(z(e))return va(e.values,t,n);if(z(t))return va(e,t.values,n);b(_(e)&&_(t)&&x(e).length===1&&x(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),b(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Ho(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function P0(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var R0=ye(P0),k0=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Na(e,t){if(ee(e)||z(e))return Na(e.values,t);if(ee(t)||z(t))return Na(e,t.values);b(_(e)&&_(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Et(e),r=Et(t),o=[];return n.forEach(u=>{r.findIndex(s=>bn(s,u))<0&&o.push(u)}),o}function Rf(e,t){try{if(!M(e))return NaN;if(!M(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Rf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var Aa=ye(Rf);function kf(e){try{if(!M(e))return NaN;if(typeof e=="bigint"){let t=kf(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Yf=ye(kf);function Y0(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!M(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var Jf=ye(Y0);function qr(){return Jf(...arguments)}function $f(e,t){return ps(e,qr(t,-1))}function Ia(e,t){return At(e,{shouldDropNaNs:t}).sum}function wa(e,t){if(M(e)&&M(t))return _a(e-t);if(ee(e)||z(e))return wa(e.values,t);if(ee(t)||z(t))return wa(e,t.values);_(e)&&_(t)&&b(bn(x(e),x(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Yf(Ia(Aa($f(e,t),2)))}catch{return NaN}}function J0(e,t){return qr(e,Aa(t,-1))}function Tt(e,t){if(ee(e)){let o=Tt(e.values,t);if(x(o).length===1){let u=new pt(o);return u.name=z(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Pe(o);return u.index=e.index.slice(),ee(t)&&(u.columns=t.columns.slice()),u}}if(ee(t)){let o=Tt(e,t.values);if(x(o).length===1){let u=new pt(o);return u.name=z(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Pe(o);return u.columns=t.columns.slice(),u}}if(z(e))return Tt(e.values,t);if(z(t))return Tt(e,t.values);b(_(e)&&_(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=x(e),r=x(t);if(b(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),b(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Ia(qr(e,t));if(n.length===1&&r.length===2)return Ln(t).map(o=>Tt(e,o));if(n.length===2&&r.length===1)return e.map(o=>Tt(o,t));if(n.length===2&&r.length===2){let o=Ln(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(Tt(e[s],o[a]));u.push(i)}return u}}function ja(e){if(ee(e)||z(e))return e.dropMissing(...Object.values(arguments).slice(1));b(_(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(ja(n))}catch{K(n)||t.push(n)}}),t}function cs(e,t){if(ee(e)||z(e))return cs(e.values,t);if(ee(t)||z(t))return cs(e,t.values);b(_(e)&&_(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),b(bn(x(e),x(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=cs(e[o],t[o]);n.push(u),r.push(s)}catch{!K(e[o])&&!K(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function fs(e,t){if(ee(e)||z(e))return fs(e.values,t);if(ee(t)||z(t))return fs(e,t.values);b(_(e)&&_(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),b(bn(x(e),x(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=fs(e[o],t[o]);n.push(u),r.push(s)}catch{M(e[o])&&M(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function $0(e){return ja(e)}function bs(e,t){if(ee(e)||z(e))return bs(e.values,t);b(_(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),b(He(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(_(n)){if(!bs(n,t))return!1}else if(!t(n))return!1;return!0}function K0(e){try{if(!M(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var U0=ye(K0);function Ea(e){try{return typeof e=="bigint"?BigInt(Ea(vn(e))):e!==vn(e)?NaN:e<=1?1:e*Ea(e-1)}catch{return NaN}}var L0=ye(Ea);function Da(e,t){if(ee(e)||z(e))return Da(e.values,t);if(b(yn(e)||_(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!He(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(yn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(_(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function Sa(e,t){if(ee(e)||z(e))return Sa(e.values,t);if(b(yn(e)||_(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!He(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(yn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(_(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function V0(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return M(t)?t:NaN}catch{return NaN}}var z0=ye(V0);function W0(e){try{return M(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var G0=ye(W0);function Ca(e){M(e)&&(e=[e]);let t=[],n=eu(e);for(let r=0;r<n;r++)t.push(0);return Qo(t,e)}function q0(e){typeof e=="bigint"&&(e=vn(e)),b(!K(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),b(M(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),b(vn(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),b(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Ca([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var H0=["true","false","yes","no"],Q0=["null","none","nan","na","n/a","","undefined"];function ls(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=vn(e.value)===e.value:e.isInteger=bs(e.values,t=>M(t)?vn(t)===t:!0)),e}function hs(e){if(ee(e)){let u=e.copy(),s=hs(e.values);return u.values=s.values,ls({type:s.type,values:u})}if(z(e)){let u=e.copy(),s=hs(e.values);return u.values=s.values,ls({type:s.type,values:u})}if(!_(e)){let u=hs([e]);return u.value=u.values[0],delete u.values,ls(u)}b(_(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=Xt(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(Kn(a))return"date"}}catch{}Se(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(Q0.indexOf(i)>-1)return"null";if(H0.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return M(a)?"number":typeof a=="object"?_(a)?"string":"object":"string"}catch{let l=new Date(u);return Kn(l)?"date":"string"}}),n=ds(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return ls({type:o,values:ws(e,u=>_t(u,o))})}function ms(e){if(ee(e)){let n=e.copy();return n.values=ms(n.values),n}b(_(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=x(e);if(b(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),b(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),b(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){b(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;b(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return qr(i,1/s)}else if(t[0]>1){let n=(r,o)=>M(r)||M(o)?qr(r,o):Tt(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=ms(o),l=ms(ps(i,n(-1,n(n(s,a),u)))),c=ps(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}b(!1,"This matrix cannot be inverted!")}}var Ds=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Kf(e,t,n){try{if(!M(e))return NaN;if(!M(t))return NaN;if(!M(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Kf(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var Z0=ye(Kf);function Uf(e,t){try{if(t=K(t)?Math.E:t,!M(e))return NaN;if(!M(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Uf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var X0=ye(Uf);function x0(e,t){return At(e,{shouldDropNaNs:t}).mean}function eb(e,t){return At(e,{shouldDropNaNs:t,median:!0}).median}function Lf(e,t){try{if(!M(e))return NaN;if(!M(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Lf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var tb=ye(Lf);function nb(e,t){return At(e,{shouldDropNaNs:t,mode:!0}).mode}function wf(){let e=Gr(),t=Gr();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function rb(e){return K(e)?wf():ws(Zt(e),wf)}function ob(e){return ws(Zt(e),()=>1)}function Ma(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of Bf(r,o)){if(!u.slice)continue;let s=Ca(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return ee(e)||z(e)?Ma(e.values,t):(b(_(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),K(t)&&(t=e.length),b(M(t)&&vn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Xt(e),t))}function ub(e,t){let n=[];for(let r of Ma(e,t))n.push(r.slice());return n}function sb(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(_(t))if(Xo(t))console.log(t);else{let n=x(t);n.length===1?new pt(t).print():n.length==2?new Pe(t).print():console.log(t)}else ee(t)||z(t)?t.print():console.log(t)})}var ib=ye((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!M(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function ab(e,t,n,r,o){if(_(e)&&K(r)&&K(o)){r=t,o=n;let u=At(e);t=u.min,n=u.max}return ib(e,t,n,r,o)}function lb(e){try{return M(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var cb=ye(lb);function Vf(e){try{return M(e)?typeof e=="bigint"?BigInt(Vf(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var fb=ye(Vf);function hb(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var mb=ye(hb);function Oa(e,t){if(ee(e)||z(e))return Oa(e.values,t);b(_(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),b(He(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(_(n)){if(Oa(n,t))return!0}else if(t(n))return!0;return!1}function zf(e,t){return At(e,{shouldDropNaNs:t,stdev:!0}).stdev}function db(e){return zf(e)}function gb(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var pb=ye(gb);function Ef(e,t){b(He(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function yb(e,t){b(He(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function bb(){return Et([...arguments].map(e=>_(e)?e:ee(e)||z(e)?e.values:[e]))}function vb(e,t){return At(e,{shouldDropNaNs:t,variance:!0}).variance}function Nb(){let e=[],t=Object.values(arguments).map(n=>((ee(n)||z(n))&&(n=n.values),b(_(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Le(0,Ns(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(K(u)?void 0:u)}),e.push(r)}),e}var qo={abs:_a,add:ps,apply:ws,arccos:F0,arcsin:T0,arctan:I0,argmax:pa,argmin:ya,assert:b,cast:_t,ceil:C0,chop:B0,clamp:Ta,combinations:Bf,combinationsIterator:ys,copy:nt,correl:va,cos:R0,count:ds,covariance:Ho,DataFrame:Pe,dataTypes:k0,decycle:zr,diff:Na,distance:wa,divide:J0,dot:Tt,dropMissing:ja,dropMissingPairwise:cs,dropNaN:Fa,dropNaNPairwise:fs,dropUndefined:$0,every:bs,exp:U0,factorial:L0,find:Da,findAll:Sa,flatten:Xt,float:z0,floor:G0,identity:q0,IndexMatcher:Es,indexOf:Vr,inferType:hs,int:vn,intersect:Pf,inverse:ms,isArray:_,isBoolean:pr,isBrowser:Ds,isDataFrame:ee,isDate:Kn,isEqual:bn,isFunction:He,isJagged:Xo,isNested:vs,isNumber:M,isObject:yn,isSeries:z,isString:Se,isUndefined:K,lerp:Z0,log:X0,MathError:or,max:Ns,mean:x0,median:eb,min:Cf,mod:tb,mode:nb,multiply:Jf,ndarray:Zt,normal:rb,ones:ob,permutations:ub,permutationsIterator:Ma,pow:Aa,print:sb,product:eu,random:Gr,range:Le,remap:ab,reshape:Qo,reverse:pn,round:cb,scale:qr,seed:Af,Series:pt,set:Et,shape:x,shuffle:gs,sign:fb,sin:mb,some:Oa,sort:Un,sqrt:Yf,stats:At,std:zf,stdev:db,subtract:$f,sum:Ia,tan:pb,timeAsync:yb,timeSync:Ef,time:Ef,transpose:Ln,union:bb,variance:vb,vectorize:ye,zeros:Ca,zip:Nb,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new qo.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(qo).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:qo[t]})}catch{e[t]=qo[t]}})}};typeof window<"u"&&(window.JSMathTools=qo);function Ss(e){return Math.sqrt(Tt(e,e))}function Ba(e,t){return Ta(Tt(e,t)/(Ss(e)*Ss(t)),0,1)}function yr(e){return typeof e=="number"&&!isNaN(e)&&e>=0&&Math.floor(e)===e&&e<1/0}var Dt=class extends Set{add(t){if(typeof t!="string")throw new Error("`StringSet` instances can only contain strings!");return super.add(t)}addAll(t){return t.forEach(n=>this.add(n)),this}delete(t){if(typeof t!="string")throw new Error("`StringSet` instances can only contain strings!");return super.delete(t)}deleteAll(t){return t.forEach(n=>this.delete(n)),this}has(t){if(typeof t!="string")throw new Error("`StringSet` instances can only contain strings!");return super.has(t)}hasAll(t){return t.every(n=>this.has(n))}toArray(){return Array.from(this)}toSortedArray(){return Un(this.toArray())}};function mh(e){if(typeof e!="string")throw new Error("`text` must be a string!");e=e.trim();let t="",n=!1;for(let r=0;r<e.length;r++){let o=e[r];o.match(/[A-Za-z0-9]/g)?(t.length===0?t+=o.toLowerCase():n?t+=o.toUpperCase():t+=o,n=!1):!o.includes("'")&&!o.includes("\u2019")&&!o.includes("\u275C")&&(n=!0)}return t}var wb=Object.defineProperty,Eb=(e,t,n)=>t in e?wb(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,dh=(e,t,n)=>(Eb(e,typeof t!="symbol"?t+"":t,n),n);function B(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Db=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),sr=class extends Error{constructor(e){Db()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function p(e,t){if(!e)throw new sr(t)}var gh=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function J(e){return e===null||typeof e>"u"}var Sb=gh.map(e=>e.name);function S(e){try{return e instanceof Array?!0:J(e.constructor)?!1:gh.indexOf(e.constructor)>-1||Sb.indexOf(e.constructor.name)>-1}catch{return!1}}function re(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function Qe(e){return typeof e=="function"}function Dn(e){return typeof e=="object"&&!J(e)&&!S(e)}function W(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function ro(e,t){if(re(e)){let u=ro(e.values,t);return u.length>0&&B(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&B(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(W(e)){let u=ro(e.values,t);return u.length>0&&B(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(p(Dn(e)||S(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Qe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Dn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(S(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function rt(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(S(n))return n instanceof Array?n.map(o=>rt(o)):n.slice();if(W(n)){let o=n.copy();return o.values=rt(o.values),o}if(re(n)){let o=n.copy();return o.values=rt(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=Nr(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=rt(n[o])}),r}else return n}return t(Nr(e))}function Nr(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+ro(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),S(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(re(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(W(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function tn(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var Wf=["number","int","float","bigint"];function Sn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!Wf.includes(u)&&!Wf.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(tn(r))return tn(o)?r.getTime()===o.getTime():!1;if(tn(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(S(r)!==S(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Nr(e),Nr(t))}}function fu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Ob=fu(16),Fb=fu(16),_b=fu(16),Tb=fu(16),Ab=fu(16),Ib=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)S(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Ob:J(e)?Fb:Qe(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Ab:e===1/0?_b:e===-1/0?Tb:typeof e=="bigint"?e.toString():re(e)?e.toJSONString():W(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!J(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function nn(e){if(re(e)||W(e))return nn(e.values);p(S(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{S(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Ct(e,t){t=t||{};let n=new Ib,r={},o=nn(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||B(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function ks(e,t){let{counts:n}=Ct(e);return J(t)||(Qe(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{Sn(r,t)||n.delete(r)})),n}function Pa(e){if(re(e)||W(e))return Pa(e.values);if(S(e)){let t=!1,n=!1,r=null;for(let o of e){if(Pa(o))return!0;if(S(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function hu(e){return Pa(Nr(e))}function qs(e){if(re(e)||W(e))return qs(e.values);p(S(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(S(e[t]))return!0;return!1}var Hr="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function xt(e){p(!J(e),Hr),S(e)||(e=[e]),p(!qs(e),Hr),p(e.length>0,Hr);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),p(B(t),Hr),p(t>=0,Hr),p(Math.floor(t)===t,Hr),p(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(xt(e.slice(1)));return n}}function Nn(e){if(re(e)||W(e)){let n=e.copy();return n.values=Nn(n.values),n.index=Nn(n.index),n}p(S(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Ye(e,t,n=1){p(!J(e)&&!J(t)&&!J(n),"You must pass two numbers and optionally a step value to the `range` function!"),p(B(e)&&B(t)&&B(n),"You must pass two numbers and optionally a step value to the `range` function!"),p(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=Nn(u)),u}function mu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var jb=mu(256),Cb=mu(256),Mb=mu(256),Bb=mu(256),Pb=mu(256);function Ut(e){if(re(e)||W(e))return Ut(e.values);p(S(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return nn(e).forEach(r=>{let o=typeof r=="object"&&r===null?jb:J(r)?Cb:Qe(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Pb:r===1/0?Mb:r===-1/0?Bb:typeof r=="bigint"?r.toString():re(r)?r.toJSONString():W(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function ph(e){if(S(e)){let t=ph(e[0]);return[e.length].concat(t||[])}else return}function te(e){return re(e)||W(e)?te(e.values):(p(S(e),"The `shape` function only works on arrays, Series, and DataFrames!"),ph(e))}function yh(e,t,n){if(J(n)&&(n=0),p(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),S(t)){p(!hu(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=te(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Ye(0,o).forEach(s=>{s>=u._values.length&&u._values.push(xt(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Ye(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(xt(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new sr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(W(t)){let r=yh(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(re(t))if(n===0){let r=e.copy(),o=Ut(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(xt(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(xt(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new sr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function Rb(e,t,n,r,o){if(o=o||0,p(Qe(r),"The first parameter to the `apply` method must be a function."),p(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,J(s)&&(s=c instanceof t||S(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return J(u)&&(u=c instanceof t||S(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function me(e){return typeof e=="string"}function kb(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(J(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(Dn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new sr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{p(me(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),p(S(o)&&!hu(o)&&te(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function Yb(e,t){if(t.isEmpty)return new e;let n=new e(rt(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function Jb(e,t,n,r,o){J(r)&&(r=[]),J(o)&&(o=[]),(me(r)||B(r))&&(r=[r]),(me(o)||B(o))&&(o=[o]),p(S(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),p(S(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),p(te(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),p(te(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function bh(e){return B(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function oo(e){return bh(e)&&e>=0}function $b(e,t,n,r,o,u){r=r||0,p(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,p(oo(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",p(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(J(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(J(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!J(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(te(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(J(c))return new e;me(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function ol(e){if(re(e)||W(e))return e.dropNaN(...Object.values(arguments).slice(1));p(S(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(ol(n))}catch{if(B(n))return t.push(n)}}),t}function Kb(e,t,n,r,o){n=n||0,p(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,p(oo(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",p(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=ol(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function Gf(e){let t={};return nn(e).forEach((n,r)=>{t[n]=r}),t}function Qr(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function Ub(e,t,n,r,o){p(Qe(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),J(o)&&(o=0),p(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=Gf(u.index),i=Gf(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Qr(s)[0],c.index=Qr(i),c}u.values=l,u.index=Qr(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Qr(i)[0],c.index=Qr(s),c}u.values=l,u.index=Qr(i),u=u.transpose()}return u}function Lb(e,t,n){(me(t)||B(t))&&(t=[t]),(me(n)||B(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Ut((t||[]).concat(n||[]).map(o=>typeof o));return p(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&p(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(p(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),p(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),J(t)||(t=t.map(o=>{if(me(o))return p(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(B(o))return p(o>=0,`Index ${o} is out of bounds!`),p(Math.floor(o)===o,"Row numbers must be integers!"),p(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),J(n)||(n=n.map(o=>{if(me(o))return p(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(B(o))return p(o>=0,`Column ${o} is out of bounds!`),p(Math.floor(o)===o,"Column numbers must be integers!"),p(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function Vb(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function wr(e,t){if(J(t)&&(t=Vb),re(e)||W(e))return e.sort(...Object.values(arguments).slice(1));p(S(e),"The `sort` function only works on arrays, Series, and DataFrames!"),p(Qe(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function zb(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function qf(e,t,n){J(n)?n=t.columns:me(n)&&(n=[n]);let r={};n.forEach(u=>{p(me(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);p(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=wr(Ut(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+zb(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function Wb(e,t,n){let r=e.shape;J(t)&&(t=Ye(0,r[0])),J(n)&&(n=Ye(0,r[1])),B(t)&&(t=[t]),B(n)&&(n=[n]),p(S(t)&&S(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),p(te(t).length===1&&te(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),p(t.length>0,"The `rowIndices` array must contain at least one index."),p(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{p(oo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),p(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{p(oo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),p(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function Gb(e,t,n,r,o){J(r)&&(r=n.index),J(o)&&(o=n.columns),me(r)&&(r=[r]),me(o)&&(o=[o]),p(S(r)&&S(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),p(te(r).length===1&&te(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),p(r.length>0,"The `rows` array must contain at least one row name."),p(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{p(me(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),p(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{p(me(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),p(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function qb(e,t,n){function r(h,m){return me(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Ye(0,u).concat(Ye(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Ye(0,i).concat(Ye(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Ye(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function eo(e,t){p(B(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function Hb(e,t){let n=t?e:e.copy();return n.index=Ye(0,e.shape[0]).map(r=>"row"+eo(r,(n.index.length-1).toString().length)),n}function du(e,t){if(re(e)||W(e))return du(e.values,t);p(S(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=nn(e),r=!1,o=1;for(let u of n){if(!B(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function Qb(e){return bh(e)&&e>0}function au(e,t){if(re(e)||W(e))return au(e.values,t);if(p(S(e),"The first argument passed into the `reshape` function must be an array!"),B(t)&&(t=[t]),p(S(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),p(te(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),p(Qb(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return nn(e);let n=nn(e);if(t.length===1&&t[0]===n.length)return n;p(du(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(au(s,t.slice(1)))}return r}var vh=Math.pow(2,64),Te=[];Nh(Math.floor(Math.random()*vh));function Zb(e,t){e=ct(e);function n(){e+=ct("0x9e3779b97f4a7c15");let o=rt(e);return o=(o^o>>BigInt(30))*ct("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*ct("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function ct(e){return BigInt.asUintN(64,BigInt(e))}function Hf(e,t){return e=ct(e),t=BigInt(t),ct(ct(e<<t)|ct(e>>ct(BigInt(64)-t)))}function Nh(e){if(typeof e=="bigint"&&(e=Number(e)),J(e))return rt(Te);{p(B(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=Zb(Math.floor(e),4);Te[0]=t[0],Te[1]=t[1],Te[2]=t[2],Te[3]=t[3]}}function Qf(){let e=ct(Hf(Te[0]+Te[3],23)+Te[0]),t=ct(Te[1]<<BigInt(17));return Te[2]=ct(Te[2]^Te[0]),Te[3]=ct(Te[3]^Te[1]),Te[1]=ct(Te[1]^Te[2]),Te[0]=ct(Te[0]^Te[3]),Te[2]=ct(Te[2]^t),Te[3]=Hf(Te[3],45),Math.floor(Number(e))/vh}function uo(e){return J(e)?Qf():(S(e)||(e=[e]),au(xt(du(e)).map(Qf),e))}function Ys(e){if(re(e)||W(e))return e.shuffle(...Object.values(arguments).slice(1));p(S(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(uo()*n.length);t.push(n.splice(o,1)[0])}return t}function Xb(e,t){return J(t)&&(t=0),p(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?Ys(e.index):null,t===1?Ys(e.columns):null)}function br(e){return typeof e=="boolean"}function xb(e,t,n){return Qe(t)?e1(e,t,n):t1(e,t,n)}function e1(e,t,n){if(n=J(n)?0:n,p(Qe(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),p(B(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=wr(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=wr(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function t1(e,t,n){let r=e.copy(),o=uo().toString();r=r.assign(o,r.index),J(t)&&(t=[o],n=[!0]),(B(t)||me(t))&&(t=[t],(br(n)||me(n))&&(n=[n])),p(S(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),p(te(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),J(n)&&(n=Ye(0,t.length).map(()=>!0)),p(S(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),p(te(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),p(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(p(me(s)||B(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),me(s)){let i=r.columns.indexOf(s);return p(i>-1,`The column "${s}" does not exist!`),i}if(B(s))return p(oo(s),"Column indices must be whole numbers!"),p(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(p(me(s)||br(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),me(s)){let i=s.trim().toLowerCase();return p(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(br(s))return s}),r.values=wr(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function n1(e,t){J(t)?t=0:p(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function wh(e,t){return JSON.stringify(e.toObject(t))}async function r1(e,t,n){let r=wh(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new sr(s):typeof module<"u"?new sr(i):new sr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function o1(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function Wn(e){if(re(e)||W(e))return e.transpose();p(S(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=te(e);if(p(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return Nn(e);if(t.length===2){let n=xt(Nn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function Eh(e,t,n){if(W(n))return new e(t.values.concat(n.values));if(S(n)){let r=te(n);p(r.length===1&&!qs(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return Eh(t,[n])}function u1(e,t){p(Qe(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function s1(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>J(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function i1(e,t){let n=[],r=[];t.values.forEach((u,s)=>{B(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function a1(e,t,n){let r=t.copy(),o=rt(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function l1(e,t){(me(t)||B(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Ut((t||[]).map(r=>typeof r));return p(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&p(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(p(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),p(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),J(t)||(t=t.map(r=>{if(typeof r=="string")return p(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return p(r>=0,`Index ${r} is out of bounds!`),p(Math.floor(r)===r,"Indices must be integers!"),p(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function c1(e,t){let n=e.shape;J(t)&&(t=Ye(0,n[0])),p(S(t),"The `indices` array must be 1-dimensional array of whole numbers."),p(te(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),p(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{p(oo(o),"The `indices` array must be a 1-dimensional array of whole numbers."),p(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function f1(e,t,n){J(n)&&(n=t.index),p(S(n),"The `indices` array must be a 1-dimensional array of strings."),p(te(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),p(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{p(me(u),"The `indices` array must contain only strings."),p(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function h1(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Ye(0,n/2).concat(Ye(t.index.length-n/2,t.index.length)));let o=rt(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function m1(e){let t=e.copy();return t.get(Ys(t.index))}function d1(e,t,n){n=n||((a,l)=>a<l?-1:1),p(J(n)||Qe(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Wn([t.values,t.index]),o=wr(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function g1(e,t){let n=Wn([t.values,t.index]);n=Wn(wr(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function p1(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Zf=Symbol.for("@jrc03c/js-math-tools/series");function y1(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Zf}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Zf}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){p(S(o),"The new values must be a 1-dimensional array!");let u=te(o);p(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Ye(this._index.length,u[0]).map(s=>"item"+eo(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){p(S(o),"The new index must be a 1-dimensional array of strings!"),p(o.length===this.shape[0],"The new index must be the same length as the old index!"),p(te(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{p(me(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=rt(r.values),this.index=rt(r.index);else if(S(r)){let o=te(r);p(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());p(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];p(te(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return te(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!J(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return l1(this,r)}getSubsetByNames(r){return f1(t,this,r)}getSubsetByIndices(r){return c1(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(Nn(this.values));return r.index=Nn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Ye(0,this.shape[0]).map(o=>"item"+eo(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=rt(this.values),r._index=rt(this.index),r.name=this.name,r}append(r){return Eh(t,this,r)}apply(r){return u1(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return s1(this,r,o)}dropNaN(){return i1(t,this)}toObject(){return p1(this)}print(){return h1(this)}shuffle(){return m1(this)}sort(r){return d1(t,this,r)}sortByIndex(){return g1(t,this)}filter(r){return a1(t,this,r)}toDataFrame(){let r=new e(Wn([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=Nn(r.values),r.index=Nn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Xf=Symbol.for("@jrc03c/js-math-tools/dataframe");function Os(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(uo()*t.length)];return n}var Re=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Xf}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Xf}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!J(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){p(S(t),"The new values must be a 2-dimensional array!");let n=te(t);p(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Ye(this._index.length,n[0]).map(r=>"row"+eo(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Ye(this._columns.length,n[1]).map(r=>"col"+eo(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){p(S(t),"The new columns list must be a 1-dimensional array of strings!"),p(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),p(te(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Os(8):r.trim()));let n=(()=>{let r=ks(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+Os(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){p(S(t),"The new index must be a 1-dimensional array of strings!"),p(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),p(te(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Os(8):r.trim()));let n=(()=>{let r=ks(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+Os(8):r),this._index=t}}),p(J(e)||Dn(e)||S(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Re)this.values=rt(e.values),this.columns=rt(e.columns),this.index=rt(e.index);else if(S(e)){let t=te(e);p(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),p(!hu(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{J(r)&&(n=u,r=e[u].length),p(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=Wn(t);let o=te(this.values);this._index=Ye(0,o[0]).map(u=>"row"+eo(u,(o[0]-1).toString().length))}}get shape(){return te(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Re(xt(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return Lb(this,e,t)}getSubsetByNames(e,t){return Gb(Re,yt,this,e,t)}getSubsetByIndices(e,t){return Wb(this,e,t)}getDummies(e){return qf(Re,this,e)}oneHotEncode(e){return qf(Re,this,e)}transpose(){let e=new Re(Wn(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return Hb(this,e)}copy(){return Yb(Re,this)}assign(e,t){return kb(Re,yt,this,e,t)}apply(e,t){return Rb(Re,yt,this,e,t)}dropMissing(e,t,n){return $b(Re,yt,this,e,t,n)}dropNaN(e,t,n){return Kb(Re,this,e,t,n)}drop(e,t){return Jb(Re,yt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return n1(this,e)}toObject(){return o1(this)}toJSONString(e){return wh(this,e)}saveAsJSON(e,t){return r1(this,e,t)}print(){return qb(Re,yt,this)}sort(e,t){return xb(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return Ub(Re,yt,this,e,t)}shuffle(e){return Xb(this,e)}append(e,t){return yh(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},yt=y1(Re);function Hs(e,t){return Ct(e,{shouldDropNaNs:t}).max}function be(e){return p(Qe(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return S(a)?!0:W(a)?(n=!0,o.push(a),!0):re(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{p(Sn(S(i)?te(i):i.shape,S(s[a+1])?te(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=Hs(s.map(l=>l.length?l.length:l.values.length)),a=Ye(0,i).map(l=>{let c=Object.keys(arguments).map(f=>S(arguments[f])?arguments[f][l]:W(arguments[f])||re(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&Sn(te(u[0]),te(a))){let l=new Re(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Re(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new yt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new yt(a)}catch{return a}return a}else return e(...arguments)}}function b1(e){try{return B(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var ul=be(b1);function v1(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!B(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Js=be(v1);function N1(e,t){try{return t(e)}catch{return NaN}}var Qs=be(N1);function w1(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var E1=be(w1);function D1(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var S1=be(D1);function O1(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var F1=be(O1);function Ra(e,t){if(re(e)){let n=Ra(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(W(e)){let n=Ra(e.values,t);return e.index[n]}p(S(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=ro(e,Hs(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Dh(e,t){return Ct(e,{shouldDropNaNs:t}).min}function ka(e,t){if(re(e)){let n=ka(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(W(e)){let n=ka(e.values,t);return e.index[n]}p(S(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=ro(e,Dh(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function It(e,t){if(re(e)||W(e))return e.apply(n=>It(n,t));if(S(e))return e.map(n=>It(n,t));if(t==="null")return null;if(t==="number"){if(J(e))return NaN;let n=It(e,"boolean");if(br(n))return n?1:0;try{JSON.parse(e)}catch{let u=It(e,"date");if(tn(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=It(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return It(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(It(e,"int"));if(t==="boolean"){if(br(e))return e;if(B(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(tn(e))return e;if(J(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return tn(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Dn(e))return e;let n=It(e,"boolean");if(br(n))return null;try{let o=It(e,"number");if(B(o))return JSON.parse(e),null}catch{}let r=It(e,"date");if(r)return r;try{let o=JSON.parse(e);return S(o)?o.map(u=>It(u,t)):o}catch{return null}}if(t==="string")return J(e)?Sn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function _1(e){try{return B(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var T1=be(_1);function A1(e,t){try{if(!B(e))return NaN;if(typeof e=="bigint")return e;if(J(t))t=1e-10;else if(!B(t))return NaN;return ul(e)<t?0:e}catch{return NaN}}var I1=be(A1);function Ya(e){if(re(e)||W(e)){let t=e.copy();return t.values=Ya(t.values),t}if(S(e))return e.map(t=>Ya(t));try{let t=JSON.parse(e);return B(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var On=be(Ya);function Sh(e,t,n){try{return B(e)?B(t)?B(n)?typeof e=="bigint"?BigInt(Sh(On(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var j1=be(Sh);function $s(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of $s(i,o-1))yield[s].concat(a)}}return re(e)||W(e)?$s(e.values,t):(p(S(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),p(B(t)&&On(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(nn(e),t))}function Oh(e,t){let n=[];for(let r of $s(e,t))n.push(r.slice());return n}function Fh(){let e=Object.values(arguments).map(n=>re(n)||W(n)?Ut(n.values):(p(S(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Ut(n)));return Ut(e).filter(n=>e.every(r=>r.findIndex(o=>Sn(o,n))>-1))}var tu=class{constructor(e){p(J(e)||e===tu.DROP_NAN_MODE||e===tu.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=J(e)?tu.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(S(t)){let n=te(t);if(n.length===1)t=new yt(t);else if(n.length===2)t=new Re(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}p(re(t)||W(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===tu.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Fh(...e),this}transform(){p(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(S(t)){let n=te(t);if(n.length===1)return new yt(t).get(this.index).values;if(n.length===2)return new Re(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return p(re(t)||W(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Zs=tu;dh(Zs,"DROP_NAN_MODE","DROP_NAN_MODE");dh(Zs,"DROP_MISSING_MODE","DROP_MISSING_MODE");function uu(e,t,n,r){if(W(e))return uu(e.values,t,n,r);if(W(t))return uu(e,t.values,n,r);if(p(S(e)&&S(t)&&te(e).length===1&&te(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),p(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return uu(...new Zs().fitAndTransform(e,t),!1,r);try{let o=Ct(e,{stdev:r}),u=Ct(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!B(s)||!B(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!B(f))return NaN;if(!B(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function Ja(e,t,n){if(W(e))return Ja(e.values,t,n);if(W(t))return Ja(e,t.values,n);p(S(e)&&S(t)&&te(e).length===1&&te(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),p(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=uu(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function C1(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var M1=be(C1),B1=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function $a(e,t){if(re(e)||W(e))return $a(e.values,t);if(re(t)||W(t))return $a(e,t.values);p(S(e)&&S(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Ut(e),r=Ut(t),o=[];return n.forEach(u=>{r.findIndex(s=>Sn(s,u))<0&&o.push(u)}),o}function _h(e,t){try{if(!B(e))return NaN;if(!B(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=_h(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var sl=be(_h);function Th(e){try{if(!B(e))return NaN;if(typeof e=="bigint"){let t=Th(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Ah=be(Th);function P1(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!B(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var Ih=be(P1);function so(){return Ih(...arguments)}function jh(e,t){return Js(e,so(t,-1))}function il(e,t){return Ct(e,{shouldDropNaNs:t}).sum}function Ka(e,t){if(B(e)&&B(t))return ul(e-t);if(re(e)||W(e))return Ka(e.values,t);if(re(t)||W(t))return Ka(e,t.values);S(e)&&S(t)&&p(Sn(te(e),te(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Ah(il(sl(jh(e,t),2)))}catch{return NaN}}function R1(e,t){return so(e,sl(t,-1))}function Vn(e,t){if(re(e)){let o=Vn(e.values,t);if(te(o).length===1){let u=new yt(o);return u.name=W(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Re(o);return u.index=e.index.slice(),re(t)&&(u.columns=t.columns.slice()),u}}if(re(t)){let o=Vn(e,t.values);if(te(o).length===1){let u=new yt(o);return u.name=W(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Re(o);return u.columns=t.columns.slice(),u}}if(W(e))return Vn(e.values,t);if(W(t))return Vn(e,t.values);p(S(e)&&S(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=te(e),r=te(t);if(p(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),p(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return il(so(e,t));if(n.length===1&&r.length===2)return Wn(t).map(o=>Vn(e,o));if(n.length===2&&r.length===1)return e.map(o=>Vn(o,t));if(n.length===2&&r.length===2){let o=Wn(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(Vn(e[s],o[a]));u.push(i)}return u}}function al(e){if(re(e)||W(e))return e.dropMissing(...Object.values(arguments).slice(1));p(S(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(al(n))}catch{J(n)||t.push(n)}}),t}function As(e,t){if(re(e)||W(e))return As(e.values,t);if(re(t)||W(t))return As(e,t.values);p(S(e)&&S(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),p(Sn(te(e),te(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=As(e[o],t[o]);n.push(u),r.push(s)}catch{!J(e[o])&&!J(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function Is(e,t){if(re(e)||W(e))return Is(e.values,t);if(re(t)||W(t))return Is(e,t.values);p(S(e)&&S(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),p(Sn(te(e),te(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Is(e[o],t[o]);n.push(u),r.push(s)}catch{B(e[o])&&B(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function k1(e){return al(e)}function Ks(e,t){if(re(e)||W(e))return Ks(e.values,t);p(S(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),p(Qe(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(S(n)){if(!Ks(n,t))return!1}else if(!t(n))return!1;return!0}function Y1(e){try{if(!B(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var J1=be(Y1);function Ua(e){try{return typeof e=="bigint"?BigInt(Ua(On(e))):e!==On(e)?NaN:e<=1?1:e*Ua(e-1)}catch{return NaN}}var $1=be(Ua);function La(e,t){if(re(e)||W(e))return La(e.values,t);if(p(Dn(e)||S(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Qe(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(Dn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(S(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function Va(e,t){if(re(e)||W(e))return Va(e.values,t);if(p(Dn(e)||S(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Qe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Dn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(S(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function K1(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return B(t)?t:NaN}catch{return NaN}}var U1=be(K1);function L1(e){try{return B(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var V1=be(L1);function ll(e){B(e)&&(e=[e]);let t=[],n=du(e);for(let r=0;r<n;r++)t.push(0);return au(t,e)}function z1(e){typeof e=="bigint"&&(e=On(e)),p(!J(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),p(B(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),p(On(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),p(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=ll([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var W1=["true","false","yes","no"],G1=["null","none","nan","na","n/a","","undefined"];function Fs(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=On(e.value)===e.value:e.isInteger=Ks(e.values,t=>B(t)?On(t)===t:!0)),e}function js(e){if(re(e)){let u=e.copy(),s=js(e.values);return u.values=s.values,Fs({type:s.type,values:u})}if(W(e)){let u=e.copy(),s=js(e.values);return u.values=s.values,Fs({type:s.type,values:u})}if(!S(e)){let u=js([e]);return u.value=u.values[0],delete u.values,Fs(u)}p(S(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=nn(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(tn(a))return"date"}}catch{}me(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(G1.indexOf(i)>-1)return"null";if(W1.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return B(a)?"number":typeof a=="object"?S(a)?"string":"object":"string"}catch{let l=new Date(u);return tn(l)?"date":"string"}}),n=ks(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return Fs({type:o,values:Qs(e,u=>It(u,o))})}function Cs(e){if(re(e)){let n=e.copy();return n.values=Cs(n.values),n}p(S(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=te(e);if(p(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),p(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),p(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){p(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;p(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return so(i,1/s)}else if(t[0]>1){let n=(r,o)=>B(r)||B(o)?so(r,o):Vn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=Cs(o),l=Cs(Js(i,n(-1,n(n(s,a),u)))),c=Js(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}p(!1,"This matrix cannot be inverted!")}}var q1=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Ch(e,t,n){try{if(!B(e))return NaN;if(!B(t))return NaN;if(!B(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Ch(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var H1=be(Ch);function Mh(e,t){try{if(t=J(t)?Math.E:t,!B(e))return NaN;if(!B(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Mh(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var Q1=be(Mh);function Z1(e,t){return Ct(e,{shouldDropNaNs:t}).mean}function X1(e,t){return Ct(e,{shouldDropNaNs:t,median:!0}).median}function Bh(e,t){try{if(!B(e))return NaN;if(!B(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Bh(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var x1=be(Bh);function ev(e,t){return Ct(e,{shouldDropNaNs:t,mode:!0}).mode}function xf(){let e=uo(),t=uo();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function tv(e){return J(e)?xf():Qs(xt(e),xf)}function nv(e){return Qs(xt(e),()=>1)}function cl(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of Oh(r,o)){if(!u.slice)continue;let s=ll(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return re(e)||W(e)?cl(e.values,t):(p(S(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),J(t)&&(t=e.length),p(B(t)&&On(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(nn(e),t))}function rv(e,t){let n=[];for(let r of cl(e,t))n.push(r.slice());return n}function ov(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(S(t))if(hu(t))console.log(t);else{let n=te(t);n.length===1?new yt(t).print():n.length==2?new Re(t).print():console.log(t)}else re(t)||W(t)?t.print():console.log(t)})}var uv=be((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!B(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function sv(e,t,n,r,o){if(S(e)&&J(r)&&J(o)){r=t,o=n;let u=Ct(e);t=u.min,n=u.max}return uv(e,t,n,r,o)}function iv(e){try{return B(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var av=be(iv);function Ph(e){try{return B(e)?typeof e=="bigint"?BigInt(Ph(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var lv=be(Ph);function cv(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var fv=be(cv);function za(e,t){if(re(e)||W(e))return za(e.values,t);p(S(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),p(Qe(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(S(n)){if(za(n,t))return!0}else if(t(n))return!0;return!1}function Rh(e,t){return Ct(e,{shouldDropNaNs:t,stdev:!0}).stdev}function hv(e){return Rh(e)}function mv(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var dv=be(mv);function eh(e,t){p(Qe(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function gv(e,t){p(Qe(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function pv(){return Ut([...arguments].map(e=>S(e)?e:re(e)||W(e)?e.values:[e]))}function yv(e,t){return Ct(e,{shouldDropNaNs:t,variance:!0}).variance}function bv(){let e=[],t=Object.values(arguments).map(n=>((re(n)||W(n))&&(n=n.values),p(S(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Ye(0,Hs(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(J(u)?void 0:u)}),e.push(r)}),e}var nu={abs:ul,add:Js,apply:Qs,arccos:E1,arcsin:S1,arctan:F1,argmax:Ra,argmin:ka,assert:p,cast:It,ceil:T1,chop:I1,clamp:j1,combinations:Oh,combinationsIterator:$s,copy:rt,correl:Ja,cos:M1,count:ks,covariance:uu,DataFrame:Re,dataTypes:B1,decycle:Nr,diff:$a,distance:Ka,divide:R1,dot:Vn,dropMissing:al,dropMissingPairwise:As,dropNaN:ol,dropNaNPairwise:Is,dropUndefined:k1,every:Ks,exp:J1,factorial:$1,find:La,findAll:Va,flatten:nn,float:U1,floor:V1,identity:z1,IndexMatcher:Zs,indexOf:ro,inferType:js,int:On,intersect:Fh,inverse:Cs,isArray:S,isBoolean:br,isBrowser:q1,isDataFrame:re,isDate:tn,isEqual:Sn,isFunction:Qe,isJagged:hu,isNested:qs,isNumber:B,isObject:Dn,isSeries:W,isString:me,isUndefined:J,lerp:H1,log:Q1,MathError:sr,max:Hs,mean:Z1,median:X1,min:Dh,mod:x1,mode:ev,multiply:Ih,ndarray:xt,normal:tv,ones:nv,permutations:rv,permutationsIterator:cl,pow:sl,print:ov,product:du,random:uo,range:Ye,remap:sv,reshape:au,reverse:Nn,round:av,scale:so,seed:Nh,Series:yt,set:Ut,shape:te,shuffle:Ys,sign:lv,sin:fv,some:za,sort:wr,sqrt:Ah,stats:Ct,std:Rh,stdev:hv,subtract:jh,sum:il,tan:dv,timeAsync:gv,timeSync:eh,time:eh,transpose:Wn,union:pv,variance:yv,vectorize:be,zeros:ll,zip:bv,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new nu.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(nu).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:nu[t]})}catch{e[t]=nu[t]}})}};typeof window<"u"&&(window.JSMathTools=nu);var vv=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:void 0;function Wa(e){let t=Symbol.for("@TypedArrayConstructor"),n="Symbol(@TypedArrayConstructor)",r=t in e?t:n in e?n:void 0;if(r){if(!("values"in e))throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");return e[r]==="ArrayBuffer"?new Uint8Array(e.values).buffer:new vv[e[r]](e.values)}if(S(e)&&e.constructor.name==="Array")return e;throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!")}function to(e){if(e instanceof ArrayBuffer||e instanceof BigInt64Array||e instanceof BigUint64Array||e instanceof Float32Array||e instanceof Float64Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Int8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:e.constructor.name,values:e instanceof ArrayBuffer?Array.from(new Uint8Array(e)):Array.from(e)};if(S(e))return e.map(t=>{try{return to(t)}catch{return t}});if(typeof e=="object"&e!==null){if(tn(e))return new Date(e.getTime());let t={};return Object.keys(e).forEach(n=>{try{t[n]=to(e[n])}catch{t[n]=e[n]}}),t}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function kh(e){return e=e.trim(),!!(e.match(/^-?\d+(\.\d+)?$/g)||e.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g)||e.match(/^-?\.\d+$/g)||e==="NaN")}var Yh="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";function Jh(e,t,n){if(typeof e!="string")throw new Error("`text` must be a string!");if(typeof t!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return e.split(t).join(n)}var th="  ",nh=" ";function fl(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t="";for(let n=0;n<e.length;n++){let r=e[n].toLowerCase();Yh.includes(r)?t+=nh:t+=r}for(;t.includes(th);)t=Jh(t,th,nh);return t.trim()}function Nv(e,t){return t=t||"",e.split(`
`).map(n=>n.trim().length>0?t+n:n).join(`
`)}function wv(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=fl(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("-")}var rh={"@Infinity":1/0,"@NegativeInfinity":-1/0,"@NaN":NaN,"@undefined":void 0};function lu(e){if(typeof e=="object"){if(e===null)return e;if(S(e))for(let t=0;t<e.length;t++)e[t]=lu(e[t]);else Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{e[t]=lu(e[t])});return e}else return typeof e>"u"||e==="Symbol(@undefined)"?void 0:e}function Ev(e){if(typeof e=="bigint")return e;if(typeof e=="string")if(e.match(/^\s*?-?\d+n\s*?$/g))try{return BigInt(e.split("n")[0])}catch{return NaN}else return NaN;else return NaN}function Dv(e){if(typeof e!="string")return typeof e=="number"?e:void 0;if(kh(e))return parseFloat(e)}function Sv(e){if(typeof e!="string")return;let t="@jrc03c/js-text-tools/newline-replacer";if(e=e.replaceAll(`
`,t),e.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)){let n=e.replace("Symbol(@String):","");if(n.match(/^".*?"$/g))try{return JSON.parse(n)}catch{n=n.substring(1,n.length-1)}return n=n.replaceAll(t,`
`),n}}function Ov(e){if(typeof e!="string")return typeof e=="symbol"?{out:e,isASymbol:!0}:void 0;if(e.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)){let t=e.replace(/^.*?Symbol\(/g,"").replace(/\).*?$/g,"");return t in rh?{out:rh[t],isASymbol:!0}:{out:Symbol.for(t),isASymbol:!0}}}function Fv(e){if(typeof e!="string")return e instanceof RegExp?e:void 0;let t=e.trim();if(t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g))try{let n=t.replace(/^\//g,"").replace(/\/(d|g|i|m|s|u|v|y)*?$/g,""),r=t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);return new RegExp(n,r)}catch{}}function _v(e){if(typeof e!="string")return typeof e=="object"?e:"Symbol(@undefined)";try{let t=JSON.parse(e,(n,r)=>{try{let o=Us(r);return typeof o>"u"?"Symbol(@undefined)":o}catch{return typeof r>"u"?"Symbol(@undefined)":r}});return S(t)&&(t=lu(t)),t}catch{return e}}function Tv(e){if(typeof e!="string")return e instanceof Date&&e.toString()!=="Invalid Date"?e:void 0;try{let t=new Date(Date.parse(e));if(t.toString()!=="Invalid Date")return t}catch{}}function Av(e){return typeof e=="object"?e!==null?lu(e):void 0:(Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{try{let n=t;try{t=Us(t)}catch{}e[t]=Us(e[n]),t!==n&&delete e[n]}catch{}}),lu(e))}function Us(e){function t(n){if(typeof n=="string"){let r=Sv(n);if(typeof r=="string")return r;let o=Ov(n);return r=o?o.out:void 0,o&&o.isASymbol||(r=Fv(n),r instanceof RegExp)||(r=Ev(n),typeof r=="bigint")||(r=Dv(n),typeof r=="number")||(r=Tv(n),r instanceof Date)?r:(r=_v(n),typeof r<"u"?r==="Symbol(@undefined)"?void 0:r:n)}if(typeof n=="object"){if(n===null)return null;let r;try{if(r=Wa(n),S(r))return r}catch{}if(r=Av(n),r)try{return Wa(r)}catch{return r}return n}return n}return t(e)}function hl(e){let t=mh(e);return t[0].toUpperCase()+t.slice(1)}function Iv(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=fl(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("_")}function ur(e,t){return!e||t<=0?"":Ye(0,t).map(()=>e).join("")}function jv(e,t){p(me(t)||J(t),"The second parameter to the `stringify` function must be undefined or a string!");let n=t?`
`:"";function r(o,u,s){return s=s||0,typeof o=="bigint"?JSON.stringify(o.toString()+"n"):typeof o=="number"?o===1/0?'"Symbol(@Infinity)"':o===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(o)?'"Symbol(@NaN)"':o.toString():typeof o=="string"?JSON.stringify("Symbol(@String):"+o):typeof o=="boolean"?o.toString():typeof o>"u"?'"Symbol(@undefined)"':typeof o=="symbol"||typeof o=="function"?JSON.stringify(o.toString()):o instanceof RegExp?o.toString():typeof o=="object"?o===null?"null":tn(o)?JSON.stringify(o.toJSON()):S(o)?o.length===0?ur(u,s-1)+"[]":o instanceof Array?ur(u,s-1)+"["+n+o.map(i=>{let a=(()=>{try{return r(to(i),u,s+1)}catch{return r(i,u,s+1)}})();return me(a)&&(a=a.trim()),ur(u,s+1)+a}).join(","+n)+n+ur(u,s)+"]":r(to(o),null,u):Object.keys(o).length+Object.getOwnPropertySymbols(o).length===0?ur(u,s-1)+"{}":ur(u,s-1)+"{"+n+Object.keys(o).concat(Object.getOwnPropertySymbols(o)).map(i=>{let a=(()=>{try{return r(to(o[i]),u,s+1)}catch{return r(o[i],u,s+1)}})();me(a)&&(a=a.trim());let l=typeof i=="symbol"?r(i):JSON.stringify(i);return ur(u,s+1)+l+":"+(u?" ":"")+a}).join(","+n)+n+ur(u,s)+"}":"undefined"}return r(Nr(e),t)}function Cv(e){let t=e.split(`
`),n=t.filter(o=>o.trim().length>0).map(o=>o.split("").findIndex(u=>!u.match(/\s/g))),r=Math.min(...n);return t.map(o=>o.substring(r)).join(`
`)}function Mv(e,t){if(typeof e!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof t>"u"||t===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?t=process.stdout.columns>80?80:process.stdout.columns:t=80),isNaN(t)||typeof t!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return e.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let o=r.split(/[^\s]/g)[0],u=r.replace(o,"").split(" "),s=o;u.forEach(i=>{let a=s+(s.trim().length>0?" ":"")+i;a.length>t?(n.push(s),s=o+i):s=a}),s.length>0&&n.push(s)}),n.join(`
`)}typeof window<"u"&&(window.JSTextTools={camelify:mh,convertObjectToTypedArray:Wa,convertTypedArrayToObject:to,indent:Nv,isANumberString:kh,kebabify:wv,parse:Us,pascalify:hl,punctuation:Yh,replaceAll:Jh,snakeify:Iv,stringify:jv,strip:fl,unindent:Cv,wrap:Mv});function Dr(e,t){if(typeof e!="string")throw new Error("The first argument passed into the `createType` function must be a string representing the type's name!");if(typeof t!="function")throw new Error("The second argument passed into the `createType` function must be a function that tests a single value and returns true or false depending on whether or not the value 'matches' the type!");let n=class{constructor(){throw new Error("This class is not meant to be instantiated or subclassed! Its only purpose is type checking.")}static[Symbol.hasInstance](r){try{return!!t(r)}catch{try{return r instanceof t}catch{return!1}}}};return Object.defineProperty(n,"name",{configurable:!1,enumerable:!1,writable:!1,value:hl(e)}),n}var Bv=Object.defineProperty,Pv=(e,t,n)=>t in e?Bv(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,$h=(e,t,n)=>(Pv(e,typeof t!="symbol"?t+"":t,n),n);function P(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Rv=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),ir=class extends Error{constructor(e){Rv()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function v(e,t){if(!e)throw new ir(t)}var Kh=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function U(e){return e===null||typeof e>"u"}var kv=Kh.map(e=>e.name);function F(e){try{return e instanceof Array?!0:U(e.constructor)?!1:Kh.indexOf(e.constructor)>-1||kv.indexOf(e.constructor.name)>-1}catch{return!1}}function oe(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function Ze(e){return typeof e=="function"}function Fn(e){return typeof e=="object"&&!U(e)&&!F(e)}function G(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function io(e,t){if(oe(e)){let u=io(e.values,t);return u.length>0&&P(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&P(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(G(e)){let u=io(e.values,t);return u.length>0&&P(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(v(Fn(e)||F(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Ze(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Fn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(F(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function ot(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(F(n))return n instanceof Array?n.map(o=>ot(o)):n.slice();if(G(n)){let o=n.copy();return o.values=ot(o.values),o}if(oe(n)){let o=n.copy();return o.values=ot(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=ao(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=ot(n[o])}),r}else return n}return t(ao(e))}function ao(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+io(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),F(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(oe(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(G(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function En(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var oh=["number","int","float","bigint"];function _n(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!oh.includes(u)&&!oh.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(En(r))return En(o)?r.getTime()===o.getTime():!1;if(En(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(F(r)!==F(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(ao(e),ao(t))}}function gu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Yv=gu(16),Jv=gu(16),$v=gu(16),Kv=gu(16),Uv=gu(16),Lv=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)F(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Yv:U(e)?Jv:Ze(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Uv:e===1/0?$v:e===-1/0?Kv:typeof e=="bigint"?e.toString():oe(e)?e.toJSONString():G(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!U(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function Vt(e){if(oe(e)||G(e))return Vt(e.values);v(F(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{F(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Mt(e,t){t=t||{};let n=new Lv,r={},o=Vt(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||P(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function Ls(e,t){let{counts:n}=Mt(e);return U(t)||(Ze(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{_n(r,t)||n.delete(r)})),n}function Ga(e){if(oe(e)||G(e))return Ga(e.values);if(F(e)){let t=!1,n=!1,r=null;for(let o of e){if(Ga(o))return!0;if(F(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function pu(e){return Ga(ao(e))}function Xs(e){if(oe(e)||G(e))return Xs(e.values);v(F(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(F(e[t]))return!0;return!1}var Zr="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function en(e){v(!U(e),Zr),F(e)||(e=[e]),v(!Xs(e),Zr),v(e.length>0,Zr);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),v(P(t),Zr),v(t>=0,Zr),v(Math.floor(t)===t,Zr),v(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(en(e.slice(1)));return n}}function wn(e){if(oe(e)||G(e)){let n=e.copy();return n.values=wn(n.values),n.index=wn(n.index),n}v(F(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Ve(e,t,n=1){v(!U(e)&&!U(t)&&!U(n),"You must pass two numbers and optionally a step value to the `range` function!"),v(P(e)&&P(t)&&P(n),"You must pass two numbers and optionally a step value to the `range` function!"),v(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=wn(u)),u}function yu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Vv=yu(256),zv=yu(256),Wv=yu(256),Gv=yu(256),qv=yu(256);function Lt(e){if(oe(e)||G(e))return Lt(e.values);v(F(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return Vt(e).forEach(r=>{let o=typeof r=="object"&&r===null?Vv:U(r)?zv:Ze(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+qv:r===1/0?Wv:r===-1/0?Gv:typeof r=="bigint"?r.toString():oe(r)?r.toJSONString():G(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function Uh(e){if(F(e)){let t=Uh(e[0]);return[e.length].concat(t||[])}else return}function ne(e){return oe(e)||G(e)?ne(e.values):(v(F(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Uh(e))}function Lh(e,t,n){if(U(n)&&(n=0),v(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),F(t)){v(!pu(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=ne(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Ve(0,o).forEach(s=>{s>=u._values.length&&u._values.push(en(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Ve(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(en(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new ir("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(G(t)){let r=Lh(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(oe(t))if(n===0){let r=e.copy(),o=Lt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(en(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(en(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new ir("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function Hv(e,t,n,r,o){if(o=o||0,v(Ze(r),"The first parameter to the `apply` method must be a function."),v(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,U(s)&&(s=c instanceof t||F(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return U(u)&&(u=c instanceof t||F(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function Oe(e){return typeof e=="string"}function Qv(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(U(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(Fn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new ir("You must pass a DataFrame, Series, or object into the `assign` method!")}else{v(Oe(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),v(F(o)&&!pu(o)&&ne(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function Zv(e,t){if(t.isEmpty)return new e;let n=new e(ot(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function Xv(e,t,n,r,o){U(r)&&(r=[]),U(o)&&(o=[]),(Oe(r)||P(r))&&(r=[r]),(Oe(o)||P(o))&&(o=[o]),v(F(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),v(F(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),v(ne(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),v(ne(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function Vh(e){return P(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function lo(e){return Vh(e)&&e>=0}function xv(e,t,n,r,o,u){r=r||0,v(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,v(lo(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",v(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(U(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(U(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!U(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(ne(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(U(c))return new e;Oe(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function ml(e){if(oe(e)||G(e))return e.dropNaN(...Object.values(arguments).slice(1));v(F(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(ml(n))}catch{if(P(n))return t.push(n)}}),t}function eN(e,t,n,r,o){n=n||0,v(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,v(lo(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",v(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=ml(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function uh(e){let t={};return Vt(e).forEach((n,r)=>{t[n]=r}),t}function Xr(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function tN(e,t,n,r,o){v(Ze(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),U(o)&&(o=0),v(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=uh(u.index),i=uh(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Xr(s)[0],c.index=Xr(i),c}u.values=l,u.index=Xr(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Xr(i)[0],c.index=Xr(s),c}u.values=l,u.index=Xr(i),u=u.transpose()}return u}function nN(e,t,n){(Oe(t)||P(t))&&(t=[t]),(Oe(n)||P(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Lt((t||[]).concat(n||[]).map(o=>typeof o));return v(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&v(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(v(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),v(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),U(t)||(t=t.map(o=>{if(Oe(o))return v(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(P(o))return v(o>=0,`Index ${o} is out of bounds!`),v(Math.floor(o)===o,"Row numbers must be integers!"),v(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),U(n)||(n=n.map(o=>{if(Oe(o))return v(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(P(o))return v(o>=0,`Column ${o} is out of bounds!`),v(Math.floor(o)===o,"Column numbers must be integers!"),v(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function rN(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Er(e,t){if(U(t)&&(t=rN),oe(e)||G(e))return e.sort(...Object.values(arguments).slice(1));v(F(e),"The `sort` function only works on arrays, Series, and DataFrames!"),v(Ze(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function oN(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function sh(e,t,n){U(n)?n=t.columns:Oe(n)&&(n=[n]);let r={};n.forEach(u=>{v(Oe(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);v(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Er(Lt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+oN(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function uN(e,t,n){let r=e.shape;U(t)&&(t=Ve(0,r[0])),U(n)&&(n=Ve(0,r[1])),P(t)&&(t=[t]),P(n)&&(n=[n]),v(F(t)&&F(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),v(ne(t).length===1&&ne(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),v(t.length>0,"The `rowIndices` array must contain at least one index."),v(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{v(lo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),v(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{v(lo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),v(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function sN(e,t,n,r,o){U(r)&&(r=n.index),U(o)&&(o=n.columns),Oe(r)&&(r=[r]),Oe(o)&&(o=[o]),v(F(r)&&F(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),v(ne(r).length===1&&ne(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),v(r.length>0,"The `rows` array must contain at least one row name."),v(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{v(Oe(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),v(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{v(Oe(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),v(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function iN(e,t,n){function r(h,m){return Oe(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Ve(0,u).concat(Ve(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Ve(0,i).concat(Ve(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Ve(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function no(e,t){v(P(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function aN(e,t){let n=t?e:e.copy();return n.index=Ve(0,e.shape[0]).map(r=>"row"+no(r,(n.index.length-1).toString().length)),n}function bu(e,t){if(oe(e)||G(e))return bu(e.values,t);v(F(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=Vt(e),r=!1,o=1;for(let u of n){if(!P(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function lN(e){return Vh(e)&&e>0}function cu(e,t){if(oe(e)||G(e))return cu(e.values,t);if(v(F(e),"The first argument passed into the `reshape` function must be an array!"),P(t)&&(t=[t]),v(F(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),v(ne(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),v(lN(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return Vt(e);let n=Vt(e);if(t.length===1&&t[0]===n.length)return n;v(bu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(cu(s,t.slice(1)))}return r}var zh=Math.pow(2,64),Ae=[];Wh(Math.floor(Math.random()*zh));function cN(e,t){e=ft(e);function n(){e+=ft("0x9e3779b97f4a7c15");let o=ot(e);return o=(o^o>>BigInt(30))*ft("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*ft("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function ft(e){return BigInt.asUintN(64,BigInt(e))}function ih(e,t){return e=ft(e),t=BigInt(t),ft(ft(e<<t)|ft(e>>ft(BigInt(64)-t)))}function Wh(e){if(typeof e=="bigint"&&(e=Number(e)),U(e))return ot(Ae);{v(P(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=cN(Math.floor(e),4);Ae[0]=t[0],Ae[1]=t[1],Ae[2]=t[2],Ae[3]=t[3]}}function ah(){let e=ft(ih(Ae[0]+Ae[3],23)+Ae[0]),t=ft(Ae[1]<<BigInt(17));return Ae[2]=ft(Ae[2]^Ae[0]),Ae[3]=ft(Ae[3]^Ae[1]),Ae[1]=ft(Ae[1]^Ae[2]),Ae[0]=ft(Ae[0]^Ae[3]),Ae[2]=ft(Ae[2]^t),Ae[3]=ih(Ae[3],45),Math.floor(Number(e))/zh}function co(e){return U(e)?ah():(F(e)||(e=[e]),cu(en(bu(e)).map(ah),e))}function Vs(e){if(oe(e)||G(e))return e.shuffle(...Object.values(arguments).slice(1));v(F(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(co()*n.length);t.push(n.splice(o,1)[0])}return t}function fN(e,t){return U(t)&&(t=0),v(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?Vs(e.index):null,t===1?Vs(e.columns):null)}function vr(e){return typeof e=="boolean"}function hN(e,t,n){return Ze(t)?mN(e,t,n):dN(e,t,n)}function mN(e,t,n){if(n=U(n)?0:n,v(Ze(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),v(P(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Er(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Er(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function dN(e,t,n){let r=e.copy(),o=co().toString();r=r.assign(o,r.index),U(t)&&(t=[o],n=[!0]),(P(t)||Oe(t))&&(t=[t],(vr(n)||Oe(n))&&(n=[n])),v(F(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),v(ne(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),U(n)&&(n=Ve(0,t.length).map(()=>!0)),v(F(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),v(ne(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),v(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(v(Oe(s)||P(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),Oe(s)){let i=r.columns.indexOf(s);return v(i>-1,`The column "${s}" does not exist!`),i}if(P(s))return v(lo(s),"Column indices must be whole numbers!"),v(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(v(Oe(s)||vr(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),Oe(s)){let i=s.trim().toLowerCase();return v(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(vr(s))return s}),r.values=Er(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function gN(e,t){U(t)?t=0:v(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function Gh(e,t){return JSON.stringify(e.toObject(t))}async function pN(e,t,n){let r=Gh(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new ir(s):typeof module<"u"?new ir(i):new ir("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function yN(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function Gn(e){if(oe(e)||G(e))return e.transpose();v(F(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=ne(e);if(v(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return wn(e);if(t.length===2){let n=en(wn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function qh(e,t,n){if(G(n))return new e(t.values.concat(n.values));if(F(n)){let r=ne(n);v(r.length===1&&!Xs(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return qh(t,[n])}function bN(e,t){v(Ze(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function vN(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>U(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function NN(e,t){let n=[],r=[];t.values.forEach((u,s)=>{P(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function wN(e,t,n){let r=t.copy(),o=ot(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function EN(e,t){(Oe(t)||P(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Lt((t||[]).map(r=>typeof r));return v(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&v(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(v(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),v(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),U(t)||(t=t.map(r=>{if(typeof r=="string")return v(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return v(r>=0,`Index ${r} is out of bounds!`),v(Math.floor(r)===r,"Indices must be integers!"),v(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function DN(e,t){let n=e.shape;U(t)&&(t=Ve(0,n[0])),v(F(t),"The `indices` array must be 1-dimensional array of whole numbers."),v(ne(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),v(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{v(lo(o),"The `indices` array must be a 1-dimensional array of whole numbers."),v(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function SN(e,t,n){U(n)&&(n=t.index),v(F(n),"The `indices` array must be a 1-dimensional array of strings."),v(ne(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),v(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{v(Oe(u),"The `indices` array must contain only strings."),v(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function ON(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Ve(0,n/2).concat(Ve(t.index.length-n/2,t.index.length)));let o=ot(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function FN(e){let t=e.copy();return t.get(Vs(t.index))}function _N(e,t,n){n=n||((a,l)=>a<l?-1:1),v(U(n)||Ze(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Gn([t.values,t.index]),o=Er(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function TN(e,t){let n=Gn([t.values,t.index]);n=Gn(Er(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function AN(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var lh=Symbol.for("@jrc03c/js-math-tools/series");function IN(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===lh}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:lh}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){v(F(o),"The new values must be a 1-dimensional array!");let u=ne(o);v(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Ve(this._index.length,u[0]).map(s=>"item"+no(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){v(F(o),"The new index must be a 1-dimensional array of strings!"),v(o.length===this.shape[0],"The new index must be the same length as the old index!"),v(ne(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{v(Oe(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=ot(r.values),this.index=ot(r.index);else if(F(r)){let o=ne(r);v(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());v(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];v(ne(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return ne(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!U(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return EN(this,r)}getSubsetByNames(r){return SN(t,this,r)}getSubsetByIndices(r){return DN(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(wn(this.values));return r.index=wn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Ve(0,this.shape[0]).map(o=>"item"+no(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=ot(this.values),r._index=ot(this.index),r.name=this.name,r}append(r){return qh(t,this,r)}apply(r){return bN(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return vN(this,r,o)}dropNaN(){return NN(t,this)}toObject(){return AN(this)}print(){return ON(this)}shuffle(){return FN(this)}sort(r){return _N(t,this,r)}sortByIndex(){return TN(t,this)}filter(r){return wN(t,this,r)}toDataFrame(){let r=new e(Gn([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=wn(r.values),r.index=wn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var ch=Symbol.for("@jrc03c/js-math-tools/dataframe");function _s(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(co()*t.length)];return n}var ke=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===ch}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:ch}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!U(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){v(F(t),"The new values must be a 2-dimensional array!");let n=ne(t);v(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Ve(this._index.length,n[0]).map(r=>"row"+no(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Ve(this._columns.length,n[1]).map(r=>"col"+no(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){v(F(t),"The new columns list must be a 1-dimensional array of strings!"),v(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),v(ne(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+_s(8):r.trim()));let n=(()=>{let r=Ls(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+_s(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){v(F(t),"The new index must be a 1-dimensional array of strings!"),v(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),v(ne(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+_s(8):r.trim()));let n=(()=>{let r=Ls(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+_s(8):r),this._index=t}}),v(U(e)||Fn(e)||F(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof ke)this.values=ot(e.values),this.columns=ot(e.columns),this.index=ot(e.index);else if(F(e)){let t=ne(e);v(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),v(!pu(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{U(r)&&(n=u,r=e[u].length),v(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=Gn(t);let o=ne(this.values);this._index=Ve(0,o[0]).map(u=>"row"+no(u,(o[0]-1).toString().length))}}get shape(){return ne(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new ke(en(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return nN(this,e,t)}getSubsetByNames(e,t){return sN(ke,bt,this,e,t)}getSubsetByIndices(e,t){return uN(this,e,t)}getDummies(e){return sh(ke,this,e)}oneHotEncode(e){return sh(ke,this,e)}transpose(){let e=new ke(Gn(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return aN(this,e)}copy(){return Zv(ke,this)}assign(e,t){return Qv(ke,bt,this,e,t)}apply(e,t){return Hv(ke,bt,this,e,t)}dropMissing(e,t,n){return xv(ke,bt,this,e,t,n)}dropNaN(e,t,n){return eN(ke,this,e,t,n)}drop(e,t){return Xv(ke,bt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return gN(this,e)}toObject(){return yN(this)}toJSONString(e){return Gh(this,e)}saveAsJSON(e,t){return pN(this,e,t)}print(){return iN(ke,bt,this)}sort(e,t){return hN(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return tN(ke,bt,this,e,t)}shuffle(e){return fN(this,e)}append(e,t){return Lh(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},bt=IN(ke);function xs(e,t){return Mt(e,{shouldDropNaNs:t}).max}function ve(e){return v(Ze(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return F(a)?!0:G(a)?(n=!0,o.push(a),!0):oe(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{v(_n(F(i)?ne(i):i.shape,F(s[a+1])?ne(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=xs(s.map(l=>l.length?l.length:l.values.length)),a=Ve(0,i).map(l=>{let c=Object.keys(arguments).map(f=>F(arguments[f])?arguments[f][l]:G(arguments[f])||oe(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&_n(ne(u[0]),ne(a))){let l=new ke(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new ke(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new bt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new bt(a)}catch{return a}return a}else return e(...arguments)}}function jN(e){try{return P(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var dl=ve(jN);function CN(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!P(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var zs=ve(CN);function MN(e,t){try{return t(e)}catch{return NaN}}var ei=ve(MN);function BN(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var PN=ve(BN);function RN(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var kN=ve(RN);function YN(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var JN=ve(YN);function qa(e,t){if(oe(e)){let n=qa(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(G(e)){let n=qa(e.values,t);return e.index[n]}v(F(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=io(e,xs(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Hh(e,t){return Mt(e,{shouldDropNaNs:t}).min}function Ha(e,t){if(oe(e)){let n=Ha(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(G(e)){let n=Ha(e.values,t);return e.index[n]}v(F(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=io(e,Hh(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function jt(e,t){if(oe(e)||G(e))return e.apply(n=>jt(n,t));if(F(e))return e.map(n=>jt(n,t));if(t==="null")return null;if(t==="number"){if(U(e))return NaN;let n=jt(e,"boolean");if(vr(n))return n?1:0;try{JSON.parse(e)}catch{let u=jt(e,"date");if(En(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=jt(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return jt(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(jt(e,"int"));if(t==="boolean"){if(vr(e))return e;if(P(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(En(e))return e;if(U(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return En(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Fn(e))return e;let n=jt(e,"boolean");if(vr(n))return null;try{let o=jt(e,"number");if(P(o))return JSON.parse(e),null}catch{}let r=jt(e,"date");if(r)return r;try{let o=JSON.parse(e);return F(o)?o.map(u=>jt(u,t)):o}catch{return null}}if(t==="string")return U(e)?_n(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function $N(e){try{return P(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var KN=ve($N);function UN(e,t){try{if(!P(e))return NaN;if(typeof e=="bigint")return e;if(U(t))t=1e-10;else if(!P(t))return NaN;return dl(e)<t?0:e}catch{return NaN}}var LN=ve(UN);function Qa(e){if(oe(e)||G(e)){let t=e.copy();return t.values=Qa(t.values),t}if(F(e))return e.map(t=>Qa(t));try{let t=JSON.parse(e);return P(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var Tn=ve(Qa);function Qh(e,t,n){try{return P(e)?P(t)?P(n)?typeof e=="bigint"?BigInt(Qh(Tn(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var VN=ve(Qh);function Ws(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of Ws(i,o-1))yield[s].concat(a)}}return oe(e)||G(e)?Ws(e.values,t):(v(F(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),v(P(t)&&Tn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Vt(e),t))}function Zh(e,t){let n=[];for(let r of Ws(e,t))n.push(r.slice());return n}function Xh(){let e=Object.values(arguments).map(n=>oe(n)||G(n)?Lt(n.values):(v(F(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Lt(n)));return Lt(e).filter(n=>e.every(r=>r.findIndex(o=>_n(o,n))>-1))}var ru=class{constructor(e){v(U(e)||e===ru.DROP_NAN_MODE||e===ru.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=U(e)?ru.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(F(t)){let n=ne(t);if(n.length===1)t=new bt(t);else if(n.length===2)t=new ke(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}v(oe(t)||G(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===ru.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Xh(...e),this}transform(){v(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(F(t)){let n=ne(t);if(n.length===1)return new bt(t).get(this.index).values;if(n.length===2)return new ke(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return v(oe(t)||G(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},ti=ru;$h(ti,"DROP_NAN_MODE","DROP_NAN_MODE");$h(ti,"DROP_MISSING_MODE","DROP_MISSING_MODE");function su(e,t,n,r){if(G(e))return su(e.values,t,n,r);if(G(t))return su(e,t.values,n,r);if(v(F(e)&&F(t)&&ne(e).length===1&&ne(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),v(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return su(...new ti().fitAndTransform(e,t),!1,r);try{let o=Mt(e,{stdev:r}),u=Mt(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!P(s)||!P(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!P(f))return NaN;if(!P(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function Za(e,t,n){if(G(e))return Za(e.values,t,n);if(G(t))return Za(e,t.values,n);v(F(e)&&F(t)&&ne(e).length===1&&ne(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),v(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=su(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function zN(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var WN=ve(zN),GN=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Xa(e,t){if(oe(e)||G(e))return Xa(e.values,t);if(oe(t)||G(t))return Xa(e,t.values);v(F(e)&&F(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Lt(e),r=Lt(t),o=[];return n.forEach(u=>{r.findIndex(s=>_n(s,u))<0&&o.push(u)}),o}function xh(e,t){try{if(!P(e))return NaN;if(!P(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=xh(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var gl=ve(xh);function em(e){try{if(!P(e))return NaN;if(typeof e=="bigint"){let t=em(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var tm=ve(em);function qN(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!P(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var nm=ve(qN);function fo(){return nm(...arguments)}function rm(e,t){return zs(e,fo(t,-1))}function pl(e,t){return Mt(e,{shouldDropNaNs:t}).sum}function xa(e,t){if(P(e)&&P(t))return dl(e-t);if(oe(e)||G(e))return xa(e.values,t);if(oe(t)||G(t))return xa(e,t.values);F(e)&&F(t)&&v(_n(ne(e),ne(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return tm(pl(gl(rm(e,t),2)))}catch{return NaN}}function HN(e,t){return fo(e,gl(t,-1))}function zn(e,t){if(oe(e)){let o=zn(e.values,t);if(ne(o).length===1){let u=new bt(o);return u.name=G(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new ke(o);return u.index=e.index.slice(),oe(t)&&(u.columns=t.columns.slice()),u}}if(oe(t)){let o=zn(e,t.values);if(ne(o).length===1){let u=new bt(o);return u.name=G(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new ke(o);return u.columns=t.columns.slice(),u}}if(G(e))return zn(e.values,t);if(G(t))return zn(e,t.values);v(F(e)&&F(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=ne(e),r=ne(t);if(v(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),v(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return pl(fo(e,t));if(n.length===1&&r.length===2)return Gn(t).map(o=>zn(e,o));if(n.length===2&&r.length===1)return e.map(o=>zn(o,t));if(n.length===2&&r.length===2){let o=Gn(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(zn(e[s],o[a]));u.push(i)}return u}}function yl(e){if(oe(e)||G(e))return e.dropMissing(...Object.values(arguments).slice(1));v(F(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(yl(n))}catch{U(n)||t.push(n)}}),t}function Ms(e,t){if(oe(e)||G(e))return Ms(e.values,t);if(oe(t)||G(t))return Ms(e,t.values);v(F(e)&&F(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),v(_n(ne(e),ne(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Ms(e[o],t[o]);n.push(u),r.push(s)}catch{!U(e[o])&&!U(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function Bs(e,t){if(oe(e)||G(e))return Bs(e.values,t);if(oe(t)||G(t))return Bs(e,t.values);v(F(e)&&F(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),v(_n(ne(e),ne(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Bs(e[o],t[o]);n.push(u),r.push(s)}catch{P(e[o])&&P(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function QN(e){return yl(e)}function Gs(e,t){if(oe(e)||G(e))return Gs(e.values,t);v(F(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),v(Ze(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(F(n)){if(!Gs(n,t))return!1}else if(!t(n))return!1;return!0}function ZN(e){try{if(!P(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var XN=ve(ZN);function el(e){try{return typeof e=="bigint"?BigInt(el(Tn(e))):e!==Tn(e)?NaN:e<=1?1:e*el(e-1)}catch{return NaN}}var xN=ve(el);function tl(e,t){if(oe(e)||G(e))return tl(e.values,t);if(v(Fn(e)||F(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Ze(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(Fn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(F(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function nl(e,t){if(oe(e)||G(e))return nl(e.values,t);if(v(Fn(e)||F(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Ze(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Fn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(F(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function ew(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return P(t)?t:NaN}catch{return NaN}}var tw=ve(ew);function nw(e){try{return P(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var rw=ve(nw);function bl(e){P(e)&&(e=[e]);let t=[],n=bu(e);for(let r=0;r<n;r++)t.push(0);return cu(t,e)}function ow(e){typeof e=="bigint"&&(e=Tn(e)),v(!U(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),v(P(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),v(Tn(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),v(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=bl([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var uw=["true","false","yes","no"],sw=["null","none","nan","na","n/a","","undefined"];function Ts(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=Tn(e.value)===e.value:e.isInteger=Gs(e.values,t=>P(t)?Tn(t)===t:!0)),e}function Ps(e){if(oe(e)){let u=e.copy(),s=Ps(e.values);return u.values=s.values,Ts({type:s.type,values:u})}if(G(e)){let u=e.copy(),s=Ps(e.values);return u.values=s.values,Ts({type:s.type,values:u})}if(!F(e)){let u=Ps([e]);return u.value=u.values[0],delete u.values,Ts(u)}v(F(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=Vt(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(En(a))return"date"}}catch{}Oe(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(sw.indexOf(i)>-1)return"null";if(uw.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return P(a)?"number":typeof a=="object"?F(a)?"string":"object":"string"}catch{let l=new Date(u);return En(l)?"date":"string"}}),n=Ls(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return Ts({type:o,values:ei(e,u=>jt(u,o))})}function Rs(e){if(oe(e)){let n=e.copy();return n.values=Rs(n.values),n}v(F(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=ne(e);if(v(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),v(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),v(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){v(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;v(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return fo(i,1/s)}else if(t[0]>1){let n=(r,o)=>P(r)||P(o)?fo(r,o):zn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=Rs(o),l=Rs(zs(i,n(-1,n(n(s,a),u)))),c=zs(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}v(!1,"This matrix cannot be inverted!")}}var iw=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function om(e,t,n){try{if(!P(e))return NaN;if(!P(t))return NaN;if(!P(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=om(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var aw=ve(om);function um(e,t){try{if(t=U(t)?Math.E:t,!P(e))return NaN;if(!P(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=um(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var lw=ve(um);function cw(e,t){return Mt(e,{shouldDropNaNs:t}).mean}function fw(e,t){return Mt(e,{shouldDropNaNs:t,median:!0}).median}function sm(e,t){try{if(!P(e))return NaN;if(!P(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=sm(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var hw=ve(sm);function mw(e,t){return Mt(e,{shouldDropNaNs:t,mode:!0}).mode}function fh(){let e=co(),t=co();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function dw(e){return U(e)?fh():ei(en(e),fh)}function gw(e){return ei(en(e),()=>1)}function vl(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of Zh(r,o)){if(!u.slice)continue;let s=bl(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return oe(e)||G(e)?vl(e.values,t):(v(F(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),U(t)&&(t=e.length),v(P(t)&&Tn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Vt(e),t))}function pw(e,t){let n=[];for(let r of vl(e,t))n.push(r.slice());return n}function yw(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(F(t))if(pu(t))console.log(t);else{let n=ne(t);n.length===1?new bt(t).print():n.length==2?new ke(t).print():console.log(t)}else oe(t)||G(t)?t.print():console.log(t)})}var bw=ve((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!P(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function vw(e,t,n,r,o){if(F(e)&&U(r)&&U(o)){r=t,o=n;let u=Mt(e);t=u.min,n=u.max}return bw(e,t,n,r,o)}function Nw(e){try{return P(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var ww=ve(Nw);function im(e){try{return P(e)?typeof e=="bigint"?BigInt(im(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var Ew=ve(im);function Dw(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Sw=ve(Dw);function rl(e,t){if(oe(e)||G(e))return rl(e.values,t);v(F(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),v(Ze(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(F(n)){if(rl(n,t))return!0}else if(t(n))return!0;return!1}function am(e,t){return Mt(e,{shouldDropNaNs:t,stdev:!0}).stdev}function Ow(e){return am(e)}function Fw(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var _w=ve(Fw);function hh(e,t){v(Ze(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function Tw(e,t){v(Ze(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function Aw(){return Lt([...arguments].map(e=>F(e)?e:oe(e)||G(e)?e.values:[e]))}function Iw(e,t){return Mt(e,{shouldDropNaNs:t,variance:!0}).variance}function jw(){let e=[],t=Object.values(arguments).map(n=>((oe(n)||G(n))&&(n=n.values),v(F(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Ve(0,xs(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(U(u)?void 0:u)}),e.push(r)}),e}var ou={abs:dl,add:zs,apply:ei,arccos:PN,arcsin:kN,arctan:JN,argmax:qa,argmin:Ha,assert:v,cast:jt,ceil:KN,chop:LN,clamp:VN,combinations:Zh,combinationsIterator:Ws,copy:ot,correl:Za,cos:WN,count:Ls,covariance:su,DataFrame:ke,dataTypes:GN,decycle:ao,diff:Xa,distance:xa,divide:HN,dot:zn,dropMissing:yl,dropMissingPairwise:Ms,dropNaN:ml,dropNaNPairwise:Bs,dropUndefined:QN,every:Gs,exp:XN,factorial:xN,find:tl,findAll:nl,flatten:Vt,float:tw,floor:rw,identity:ow,IndexMatcher:ti,indexOf:io,inferType:Ps,int:Tn,intersect:Xh,inverse:Rs,isArray:F,isBoolean:vr,isBrowser:iw,isDataFrame:oe,isDate:En,isEqual:_n,isFunction:Ze,isJagged:pu,isNested:Xs,isNumber:P,isObject:Fn,isSeries:G,isString:Oe,isUndefined:U,lerp:aw,log:lw,MathError:ir,max:xs,mean:cw,median:fw,min:Hh,mod:hw,mode:mw,multiply:nm,ndarray:en,normal:dw,ones:gw,permutations:pw,permutationsIterator:vl,pow:gl,print:yw,product:bu,random:co,range:Ve,remap:vw,reshape:cu,reverse:wn,round:ww,scale:fo,seed:Wh,Series:bt,set:Lt,shape:ne,shuffle:Vs,sign:Ew,sin:Sw,some:rl,sort:Er,sqrt:tm,stats:Mt,std:am,stdev:Ow,subtract:rm,sum:pl,tan:_w,timeAsync:Tw,timeSync:hh,time:hh,transpose:Gn,union:Aw,variance:Iw,vectorize:ve,zeros:bl,zip:jw,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new ou.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(ou).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:ou[t]})}catch{e[t]=ou[t]}})}};typeof window<"u"&&(window.JSMathTools=ou);function Nl(e,t,n){if(typeof n>"u"&&(n=!0),e===null||typeof e>"u"||t==="number"&&typeof e=="number"&&isNaN(e)||t===Date&&En(e))return!0;try{return e instanceof t&&(n||e.constructor.name===t.name)}catch{return typeof e===t}}var iu={allowsSubclassInstances:{},doesNotAllowSubclassInstances:{}},xr=class lm extends Array{static allowsSubclassInstances=!0;static registry={allowsSubclassInstances:{},doesNotAllowSubclassInstances:{}};static type=null;static from(t){arguments.length>1&&console.warn("WARNING: The `TypedArray.from` static method's implementation differs from the standard `Array.from` static method's implementation. The `TypedArray.from` method only accepts one argument: an array of values. That array can be nested arbitrarily deeply.");let n=this.allowsSubclassInstances?"allowsSubclassInstances":"doesNotAllowSubclassInstances",r=ni(lm.registry[n][this.name]);return arguments.length===0||t.forEach(o=>{if(this.isArray(o)){let u=this.allowsSubclassInstances?"allowsSubclassInstances":"doesNotAllowSubclassInstances";iu[u][this.type]=!0;let s=new this;iu[u][this.type]=!1,o.forEach(i=>s.push(i)),r.push(this.proxify(s))}else r.push(o)}),r}static proxify(t){return new Proxy(t,{get(){return Reflect.get(...arguments)},set(n,r,o,u){let s=parseInt(r);return!isNaN(s)&&parseFloat(r)===s&&s>=0&&u.challenge(o),Reflect.set(...arguments)}})}constructor(t,n){if(super(),t===null||typeof t>"u")throw new Error("A type must be passed as the first argument to the `TypedArray` constructor!");if(t===Array)throw new Error("It's not possible to create a TypedArray<Array>!");Object.defineProperty(this,"type",{configurable:!1,enumerable:!1,writable:!1,value:t}),(typeof n>"u"||n===null)&&(n=!0),Object.defineProperty(this,"allowsSubclassInstances",{configurable:!1,enumerable:!1,writable:!1,value:n})}static get typeString(){return typeof this.constructor.type=="function"?this.constructor.type.name:this.constructor.type}get allowsSubclassInstances(){return this.constructor.allowsSubclassInstances}get type(){return this.constructor.type}canAccept(t){return Nl(t,this.constructor.type,this.constructor.allowsSubclassInstances)||F(t)&&(t instanceof this.constructor||Vt(t).every(n=>this.canAccept(n)))}challenge(t){if(this.canAccept(t))return!0;throw new Error(`A ${this.constructor.name} cannot contain the value: ${typeof t=="string"||typeof t=="object"?JSON.stringify(t):t}`)}concat(){let t=this.constructor.from(this);return Array.from(arguments).forEach(n=>{n.forEach(r=>{this.challenge(r),t.push(r)})}),t}fill(t,n,r){return this.challenge(t),super.fill(t,n,r)}filter(t,n){typeof n<"u"?t=t.bind(n):t=t.bind(this);let r=Array.from(this).filter(t);try{return this.constructor.from(r)}catch{return Array.from(r)}}from(){return this.constructor.from(...arguments)}map(t,n){typeof n<"u"?t=t.bind(n):t=t.bind(this);let r=Array.from(this).map(t);try{return this.constructor.from(r)}catch{return Array.from(r)}}push(){return Array.from(arguments).forEach(t=>{this.challenge(t)}),super.push(...arguments)}slice(t,n){t||(t=0),n||(n=this.length);let r=this.constructor.from([]);for(let o=t;o<n;o++)r.push(this[o]);return r}splice(){let t=Array.from(arguments).slice(2).filter(u=>(this.challenge(u),!0)),n=t.length-arguments[1],r=this.length+n;for(let u=r-1;u>arguments[0]+arguments[1];u--)this[u]=this[u-n];let o=this.slice(arguments[0],arguments[0]+arguments[1]);return t.forEach((u,s)=>{this[arguments[0]+s]=u}),o}toReversed(){let t=this.constructor.from([]);for(let n=this.length-1;n>=0;n--)t.push(this[n]);return t}toSorted(){let t=Array.from(this);return t.sort(...arguments),this.constructor.from(t)}toSpliced(){let t=Array.from(this);return t.splice(...arguments),this.constructor.from(t)}unshift(){return Array.from(arguments).forEach(t=>{this.challenge(t)}),super.unshift(...arguments)}with(t,n){let r=this.slice();return r[t]=n,r}};function ni(e,t){let n=t?"allowsSubclassInstances":"doesNotAllowSubclassInstances",r=typeof e=="function"?e.name:e,o=(()=>{if(xr.registry[n][e])return xr.registry[n][e];{class s extends xr{constructor(){if(super(e,t),!iu[n][e])throw new Error(`New \`${this.constructor.name}\` instances cannot be created using the \`new\` keyword! They must be created using \`${this.constructor.name}.from([...])\`.`)}}return xr.registry[n][e]=s,s}})();iu[n][e]=!0;let u=new o(!0);return iu[n][e]=!1,Object.defineProperty(u.constructor,"name",{configurable:!1,enumerable:!1,writable:!1,value:`${hl(r)}Array`}),Object.defineProperty(o,"allowsSubclassInstances",{configurable:!0,enumerable:!0,writable:!1,value:t}),Object.defineProperty(o,"type",{configurable:!0,enumerable:!0,writable:!1,value:e}),xr.registry[n][u.constructor.name]=e,xr.proxify(u)}function ze(e,t,n,r){r=r||{configurable:!0,enumerable:!0};let o,u=typeof r.allowsSubclassInstances>"u"?!0:!!r.allowsSubclassInstances;if(typeof n!="function"&&typeof n!="string")throw new Error("A 'type' value (i.e., a class name or a string like \"number\" representing a primitive type) must be passed as the third argument to the `defineTypedProperty` function!");if(n===null||typeof n>"u")throw new Error("A 'type' value (i.e., a class name or a string like \"number\" representing a primitive type) must be passed as the third argument to the `defineTypedProperty` function!");if(n===Array)throw new Error("It's not possible to create a property of type Array (though you *can* create a TypedArray property)!");function s(){return typeof n=="function"?n.name:n}function i(l){return Nl(l,n,u)}function a(l){if(i(l))return!0;throw new Error(`The '${t}' property can only have ${s()} values assigned to it!`)}Object.defineProperty(e,t,{...r,get(){return o},set(l){a(l),o=l}})}typeof window<"u"&&(window.JSTypeExperiments={createType:Dr,createTypedArray:ni,defineTypedProperty:ze,isOfType:Nl});var jm=class extends Error{},Cw=class extends Error{},wl=class extends Error{},Cm=class extends Error{},Mm=class extends Error{},Bm=class extends Error{},Mw=Object.defineProperty,Bw=(e,t,n)=>t in e?Mw(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Pm=(e,t,n)=>(Bw(e,typeof t!="symbol"?t+"":t,n),n);function j(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Pw=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),lr=class extends Error{constructor(e){Pw()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function N(e,t){if(!e)throw new lr(t)}var Rm=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function k(e){return e===null||typeof e>"u"}var Rw=Rm.map(e=>e.name);function T(e){try{return e instanceof Array?!0:k(e.constructor)?!1:Rm.indexOf(e.constructor)>-1||Rw.indexOf(e.constructor.name)>-1}catch{return!1}}function ie(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function Xe(e){return typeof e=="function"}function jn(e){return typeof e=="object"&&!k(e)&&!T(e)}function q(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function No(e,t){if(ie(e)){let u=No(e.values,t);return u.length>0&&j(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&j(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(q(e)){let u=No(e.values,t);return u.length>0&&j(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(N(jn(e)||T(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Xe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(jn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(T(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function ut(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(T(n))return n instanceof Array?n.map(o=>ut(o)):n.slice();if(q(n)){let o=n.copy();return o.values=ut(o.values),o}if(ie(n)){let o=n.copy();return o.values=ut(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=wo(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=ut(n[o])}),r}else return n}return t(wo(e))}function wo(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+No(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),T(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(ie(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(q(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function Qn(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var cm=["number","int","float","bigint"];function sn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!cm.includes(u)&&!cm.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(Qn(r))return Qn(o)?r.getTime()===o.getTime():!1;if(Qn(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(T(r)!==T(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(wo(e),wo(t))}}function Au(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var kw=Au(16),Yw=Au(16),Jw=Au(16),$w=Au(16),Kw=Au(16),Uw=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)T(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?kw:k(e)?Yw:Xe(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Kw:e===1/0?Jw:e===-1/0?$w:typeof e=="bigint"?e.toString():ie(e)?e.toJSONString():q(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!k(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function an(e){if(ie(e)||q(e))return an(e.values);N(T(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{T(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Rt(e,t){t=t||{};let n=new Uw,r={},o=an(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||j(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function gi(e,t){let{counts:n}=Rt(e);return k(t)||(Xe(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{sn(r,t)||n.delete(r)})),n}function El(e){if(ie(e)||q(e))return El(e.values);if(T(e)){let t=!1,n=!1,r=null;for(let o of e){if(El(o))return!0;if(T(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function Iu(e){return El(wo(e))}function Oi(e){if(ie(e)||q(e))return Oi(e.values);N(T(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(T(e[t]))return!0;return!1}var ho="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function rn(e){N(!k(e),ho),T(e)||(e=[e]),N(!Oi(e),ho),N(e.length>0,ho);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),N(j(t),ho),N(t>=0,ho),N(Math.floor(t)===t,ho),N(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(rn(e.slice(1)));return n}}function An(e){if(ie(e)||q(e)){let n=e.copy();return n.values=An(n.values),n.index=An(n.index),n}N(T(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function We(e,t,n=1){N(!k(e)&&!k(t)&&!k(n),"You must pass two numbers and optionally a step value to the `range` function!"),N(j(e)&&j(t)&&j(n),"You must pass two numbers and optionally a step value to the `range` function!"),N(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=An(u)),u}function ju(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Lw=ju(256),Vw=ju(256),zw=ju(256),Ww=ju(256),Gw=ju(256);function zt(e){if(ie(e)||q(e))return zt(e.values);N(T(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return an(e).forEach(r=>{let o=typeof r=="object"&&r===null?Lw:k(r)?Vw:Xe(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Gw:r===1/0?zw:r===-1/0?Ww:typeof r=="bigint"?r.toString():ie(r)?r.toJSONString():q(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function km(e){if(T(e)){let t=km(e[0]);return[e.length].concat(t||[])}else return}function ue(e){return ie(e)||q(e)?ue(e.values):(N(T(e),"The `shape` function only works on arrays, Series, and DataFrames!"),km(e))}function Ym(e,t,n){if(k(n)&&(n=0),N(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),T(t)){N(!Iu(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=ue(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(We(0,o).forEach(s=>{s>=u._values.length&&u._values.push(rn(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(We(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(rn(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new lr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(q(t)){let r=Ym(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(ie(t))if(n===0){let r=e.copy(),o=zt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(rn(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(rn(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new lr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function qw(e,t,n,r,o){if(o=o||0,N(Xe(r),"The first parameter to the `apply` method must be a function."),N(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,k(s)&&(s=c instanceof t||T(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return k(u)&&(u=c instanceof t||T(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function fe(e){return typeof e=="string"}function Hw(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(k(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(jn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new lr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{N(fe(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),N(T(o)&&!Iu(o)&&ue(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function Qw(e,t){if(t.isEmpty)return new e;let n=new e(ut(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function Zw(e,t,n,r,o){k(r)&&(r=[]),k(o)&&(o=[]),(fe(r)||j(r))&&(r=[r]),(fe(o)||j(o))&&(o=[o]),N(T(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),N(T(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),N(ue(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),N(ue(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function Jm(e){return j(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function Eo(e){return Jm(e)&&e>=0}function Xw(e,t,n,r,o,u){r=r||0,N(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,N(Eo(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",N(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(k(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(k(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!k(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(ue(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(k(c))return new e;fe(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function zl(e){if(ie(e)||q(e))return e.dropNaN(...Object.values(arguments).slice(1));N(T(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(zl(n))}catch{if(j(n))return t.push(n)}}),t}function xw(e,t,n,r,o){n=n||0,N(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,N(Eo(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",N(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=zl(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function fm(e){let t={};return an(e).forEach((n,r)=>{t[n]=r}),t}function mo(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function e2(e,t,n,r,o){N(Xe(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),k(o)&&(o=0),N(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=fm(u.index),i=fm(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=mo(s)[0],c.index=mo(i),c}u.values=l,u.index=mo(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=mo(i)[0],c.index=mo(s),c}u.values=l,u.index=mo(i),u=u.transpose()}return u}function t2(e,t,n){(fe(t)||j(t))&&(t=[t]),(fe(n)||j(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=zt((t||[]).concat(n||[]).map(o=>typeof o));return N(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&N(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(N(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),N(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),k(t)||(t=t.map(o=>{if(fe(o))return N(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(j(o))return N(o>=0,`Index ${o} is out of bounds!`),N(Math.floor(o)===o,"Row numbers must be integers!"),N(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),k(n)||(n=n.map(o=>{if(fe(o))return N(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(j(o))return N(o>=0,`Column ${o} is out of bounds!`),N(Math.floor(o)===o,"Column numbers must be integers!"),N(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function n2(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Fr(e,t){if(k(t)&&(t=n2),ie(e)||q(e))return e.sort(...Object.values(arguments).slice(1));N(T(e),"The `sort` function only works on arrays, Series, and DataFrames!"),N(Xe(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function r2(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function hm(e,t,n){k(n)?n=t.columns:fe(n)&&(n=[n]);let r={};n.forEach(u=>{N(fe(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);N(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Fr(zt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+r2(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function o2(e,t,n){let r=e.shape;k(t)&&(t=We(0,r[0])),k(n)&&(n=We(0,r[1])),j(t)&&(t=[t]),j(n)&&(n=[n]),N(T(t)&&T(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),N(ue(t).length===1&&ue(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),N(t.length>0,"The `rowIndices` array must contain at least one index."),N(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{N(Eo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),N(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{N(Eo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),N(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function u2(e,t,n,r,o){k(r)&&(r=n.index),k(o)&&(o=n.columns),fe(r)&&(r=[r]),fe(o)&&(o=[o]),N(T(r)&&T(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),N(ue(r).length===1&&ue(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),N(r.length>0,"The `rows` array must contain at least one row name."),N(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{N(fe(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),N(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{N(fe(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),N(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function s2(e,t,n){function r(h,m){return fe(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:We(0,u).concat(We(n.index.length-u,n.index.length)),l=s>n.columns.length?null:We(0,i).concat(We(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,We(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function yo(e,t){N(j(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function i2(e,t){let n=t?e:e.copy();return n.index=We(0,e.shape[0]).map(r=>"row"+yo(r,(n.index.length-1).toString().length)),n}function Cu(e,t){if(ie(e)||q(e))return Cu(e.values,t);N(T(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=an(e),r=!1,o=1;for(let u of n){if(!j(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function a2(e){return Jm(e)&&e>0}function Fu(e,t){if(ie(e)||q(e))return Fu(e.values,t);if(N(T(e),"The first argument passed into the `reshape` function must be an array!"),j(t)&&(t=[t]),N(T(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),N(ue(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),N(a2(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return an(e);let n=an(e);if(t.length===1&&t[0]===n.length)return n;N(Cu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(Fu(s,t.slice(1)))}return r}var $m=Math.pow(2,64),Ie=[];Km(Math.floor(Math.random()*$m));function l2(e,t){e=ht(e);function n(){e+=ht("0x9e3779b97f4a7c15");let o=ut(e);return o=(o^o>>BigInt(30))*ht("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*ht("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function ht(e){return BigInt.asUintN(64,BigInt(e))}function mm(e,t){return e=ht(e),t=BigInt(t),ht(ht(e<<t)|ht(e>>ht(BigInt(64)-t)))}function Km(e){if(typeof e=="bigint"&&(e=Number(e)),k(e))return ut(Ie);{N(j(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=l2(Math.floor(e),4);Ie[0]=t[0],Ie[1]=t[1],Ie[2]=t[2],Ie[3]=t[3]}}function dm(){let e=ht(mm(Ie[0]+Ie[3],23)+Ie[0]),t=ht(Ie[1]<<BigInt(17));return Ie[2]=ht(Ie[2]^Ie[0]),Ie[3]=ht(Ie[3]^Ie[1]),Ie[1]=ht(Ie[1]^Ie[2]),Ie[0]=ht(Ie[0]^Ie[3]),Ie[2]=ht(Ie[2]^t),Ie[3]=mm(Ie[3],45),Math.floor(Number(e))/$m}function Do(e){return k(e)?dm():(T(e)||(e=[e]),Fu(rn(Cu(e)).map(dm),e))}function pi(e){if(ie(e)||q(e))return e.shuffle(...Object.values(arguments).slice(1));N(T(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(Do()*n.length);t.push(n.splice(o,1)[0])}return t}function c2(e,t){return k(t)&&(t=0),N(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?pi(e.index):null,t===1?pi(e.columns):null)}function Sr(e){return typeof e=="boolean"}function f2(e,t,n){return Xe(t)?h2(e,t,n):m2(e,t,n)}function h2(e,t,n){if(n=k(n)?0:n,N(Xe(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),N(j(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Fr(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Fr(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function m2(e,t,n){let r=e.copy(),o=Do().toString();r=r.assign(o,r.index),k(t)&&(t=[o],n=[!0]),(j(t)||fe(t))&&(t=[t],(Sr(n)||fe(n))&&(n=[n])),N(T(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),N(ue(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),k(n)&&(n=We(0,t.length).map(()=>!0)),N(T(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),N(ue(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),N(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(N(fe(s)||j(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),fe(s)){let i=r.columns.indexOf(s);return N(i>-1,`The column "${s}" does not exist!`),i}if(j(s))return N(Eo(s),"Column indices must be whole numbers!"),N(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(N(fe(s)||Sr(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),fe(s)){let i=s.trim().toLowerCase();return N(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Sr(s))return s}),r.values=Fr(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function d2(e,t){k(t)?t=0:N(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function Um(e,t){return JSON.stringify(e.toObject(t))}async function g2(e,t,n){let r=Um(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new lr(s):typeof module<"u"?new lr(i):new lr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function p2(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function Zn(e){if(ie(e)||q(e))return e.transpose();N(T(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=ue(e);if(N(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return An(e);if(t.length===2){let n=rn(An(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function Lm(e,t,n){if(q(n))return new e(t.values.concat(n.values));if(T(n)){let r=ue(n);N(r.length===1&&!Oi(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return Lm(t,[n])}function y2(e,t){N(Xe(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function b2(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>k(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function v2(e,t){let n=[],r=[];t.values.forEach((u,s)=>{j(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function N2(e,t,n){let r=t.copy(),o=ut(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function w2(e,t){(fe(t)||j(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=zt((t||[]).map(r=>typeof r));return N(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&N(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(N(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),N(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),k(t)||(t=t.map(r=>{if(typeof r=="string")return N(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return N(r>=0,`Index ${r} is out of bounds!`),N(Math.floor(r)===r,"Indices must be integers!"),N(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function E2(e,t){let n=e.shape;k(t)&&(t=We(0,n[0])),N(T(t),"The `indices` array must be 1-dimensional array of whole numbers."),N(ue(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),N(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{N(Eo(o),"The `indices` array must be a 1-dimensional array of whole numbers."),N(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function D2(e,t,n){k(n)&&(n=t.index),N(T(n),"The `indices` array must be a 1-dimensional array of strings."),N(ue(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),N(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{N(fe(u),"The `indices` array must contain only strings."),N(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function S2(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(We(0,n/2).concat(We(t.index.length-n/2,t.index.length)));let o=ut(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function O2(e){let t=e.copy();return t.get(pi(t.index))}function F2(e,t,n){n=n||((a,l)=>a<l?-1:1),N(k(n)||Xe(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Zn([t.values,t.index]),o=Fr(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function _2(e,t){let n=Zn([t.values,t.index]);n=Zn(Fr(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function T2(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var gm=Symbol.for("@jrc03c/js-math-tools/series");function A2(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===gm}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:gm}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){N(T(o),"The new values must be a 1-dimensional array!");let u=ue(o);N(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(We(this._index.length,u[0]).map(s=>"item"+yo(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){N(T(o),"The new index must be a 1-dimensional array of strings!"),N(o.length===this.shape[0],"The new index must be the same length as the old index!"),N(ue(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{N(fe(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=ut(r.values),this.index=ut(r.index);else if(T(r)){let o=ue(r);N(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());N(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];N(ue(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return ue(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!k(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return w2(this,r)}getSubsetByNames(r){return D2(t,this,r)}getSubsetByIndices(r){return E2(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(An(this.values));return r.index=An(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=We(0,this.shape[0]).map(o=>"item"+yo(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=ut(this.values),r._index=ut(this.index),r.name=this.name,r}append(r){return Lm(t,this,r)}apply(r){return y2(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return b2(this,r,o)}dropNaN(){return v2(t,this)}toObject(){return T2(this)}print(){return S2(this)}shuffle(){return O2(this)}sort(r){return F2(t,this,r)}sortByIndex(){return _2(t,this)}filter(r){return N2(t,this,r)}toDataFrame(){let r=new e(Zn([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=An(r.values),r.index=An(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var pm=Symbol.for("@jrc03c/js-math-tools/dataframe");function ri(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(Do()*t.length)];return n}var Je=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===pm}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:pm}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!k(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){N(T(t),"The new values must be a 2-dimensional array!");let n=ue(t);N(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(We(this._index.length,n[0]).map(r=>"row"+yo(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(We(this._columns.length,n[1]).map(r=>"col"+yo(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){N(T(t),"The new columns list must be a 1-dimensional array of strings!"),N(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),N(ue(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ri(8):r.trim()));let n=(()=>{let r=gi(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+ri(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){N(T(t),"The new index must be a 1-dimensional array of strings!"),N(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),N(ue(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ri(8):r.trim()));let n=(()=>{let r=gi(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+ri(8):r),this._index=t}}),N(k(e)||jn(e)||T(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Je)this.values=ut(e.values),this.columns=ut(e.columns),this.index=ut(e.index);else if(T(e)){let t=ue(e);N(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),N(!Iu(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{k(r)&&(n=u,r=e[u].length),N(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=Zn(t);let o=ue(this.values);this._index=We(0,o[0]).map(u=>"row"+yo(u,(o[0]-1).toString().length))}}get shape(){return ue(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Je(rn(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return t2(this,e,t)}getSubsetByNames(e,t){return u2(Je,vt,this,e,t)}getSubsetByIndices(e,t){return o2(this,e,t)}getDummies(e){return hm(Je,this,e)}oneHotEncode(e){return hm(Je,this,e)}transpose(){let e=new Je(Zn(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return i2(this,e)}copy(){return Qw(Je,this)}assign(e,t){return Hw(Je,vt,this,e,t)}apply(e,t){return qw(Je,vt,this,e,t)}dropMissing(e,t,n){return Xw(Je,vt,this,e,t,n)}dropNaN(e,t,n){return xw(Je,this,e,t,n)}drop(e,t){return Zw(Je,vt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return d2(this,e)}toObject(){return p2(this)}toJSONString(e){return Um(this,e)}saveAsJSON(e,t){return g2(this,e,t)}print(){return s2(Je,vt,this)}sort(e,t){return f2(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return e2(Je,vt,this,e,t)}shuffle(e){return c2(this,e)}append(e,t){return Ym(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},vt=A2(Je);function Fi(e,t){return Rt(e,{shouldDropNaNs:t}).max}function Ne(e){return N(Xe(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return T(a)?!0:q(a)?(n=!0,o.push(a),!0):ie(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{N(sn(T(i)?ue(i):i.shape,T(s[a+1])?ue(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=Fi(s.map(l=>l.length?l.length:l.values.length)),a=We(0,i).map(l=>{let c=Object.keys(arguments).map(f=>T(arguments[f])?arguments[f][l]:q(arguments[f])||ie(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&sn(ue(u[0]),ue(a))){let l=new Je(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Je(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new vt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new vt(a)}catch{return a}return a}else return e(...arguments)}}function I2(e){try{return j(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var Wl=Ne(I2);function j2(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!j(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var yi=Ne(j2);function C2(e,t){try{return t(e)}catch{return NaN}}var _i=Ne(C2);function M2(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var B2=Ne(M2);function P2(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var R2=Ne(P2);function k2(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var Y2=Ne(k2);function Dl(e,t){if(ie(e)){let n=Dl(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(q(e)){let n=Dl(e.values,t);return e.index[n]}N(T(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=No(e,Fi(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Vm(e,t){return Rt(e,{shouldDropNaNs:t}).min}function Sl(e,t){if(ie(e)){let n=Sl(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(q(e)){let n=Sl(e.values,t);return e.index[n]}N(T(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=No(e,Vm(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Bt(e,t){if(ie(e)||q(e))return e.apply(n=>Bt(n,t));if(T(e))return e.map(n=>Bt(n,t));if(t==="null")return null;if(t==="number"){if(k(e))return NaN;let n=Bt(e,"boolean");if(Sr(n))return n?1:0;try{JSON.parse(e)}catch{let u=Bt(e,"date");if(Qn(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=Bt(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return Bt(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(Bt(e,"int"));if(t==="boolean"){if(Sr(e))return e;if(j(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Qn(e))return e;if(k(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return Qn(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(jn(e))return e;let n=Bt(e,"boolean");if(Sr(n))return null;try{let o=Bt(e,"number");if(j(o))return JSON.parse(e),null}catch{}let r=Bt(e,"date");if(r)return r;try{let o=JSON.parse(e);return T(o)?o.map(u=>Bt(u,t)):o}catch{return null}}if(t==="string")return k(e)?sn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function J2(e){try{return j(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var $2=Ne(J2);function K2(e,t){try{if(!j(e))return NaN;if(typeof e=="bigint")return e;if(k(t))t=1e-10;else if(!j(t))return NaN;return Wl(e)<t?0:e}catch{return NaN}}var U2=Ne(K2);function Ol(e){if(ie(e)||q(e)){let t=e.copy();return t.values=Ol(t.values),t}if(T(e))return e.map(t=>Ol(t));try{let t=JSON.parse(e);return j(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var Cn=Ne(Ol);function zm(e,t,n){try{return j(e)?j(t)?j(n)?typeof e=="bigint"?BigInt(zm(Cn(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var L2=Ne(zm);function bi(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of bi(i,o-1))yield[s].concat(a)}}return ie(e)||q(e)?bi(e.values,t):(N(T(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),N(j(t)&&Cn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(an(e),t))}function Wm(e,t){let n=[];for(let r of bi(e,t))n.push(r.slice());return n}function Gm(){let e=Object.values(arguments).map(n=>ie(n)||q(n)?zt(n.values):(N(T(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),zt(n)));return zt(e).filter(n=>e.every(r=>r.findIndex(o=>sn(o,n))>-1))}var vu=class{constructor(e){N(k(e)||e===vu.DROP_NAN_MODE||e===vu.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=k(e)?vu.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(T(t)){let n=ue(t);if(n.length===1)t=new vt(t);else if(n.length===2)t=new Je(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}N(ie(t)||q(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===vu.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Gm(...e),this}transform(){N(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(T(t)){let n=ue(t);if(n.length===1)return new vt(t).get(this.index).values;if(n.length===2)return new Je(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return N(ie(t)||q(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ti=vu;Pm(Ti,"DROP_NAN_MODE","DROP_NAN_MODE");Pm(Ti,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Du(e,t,n,r){if(q(e))return Du(e.values,t,n,r);if(q(t))return Du(e,t.values,n,r);if(N(T(e)&&T(t)&&ue(e).length===1&&ue(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),N(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Du(...new Ti().fitAndTransform(e,t),!1,r);try{let o=Rt(e,{stdev:r}),u=Rt(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!j(s)||!j(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!j(f))return NaN;if(!j(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function Fl(e,t,n){if(q(e))return Fl(e.values,t,n);if(q(t))return Fl(e,t.values,n);N(T(e)&&T(t)&&ue(e).length===1&&ue(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),N(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Du(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function V2(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var z2=Ne(V2),W2=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function _l(e,t){if(ie(e)||q(e))return _l(e.values,t);if(ie(t)||q(t))return _l(e,t.values);N(T(e)&&T(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=zt(e),r=zt(t),o=[];return n.forEach(u=>{r.findIndex(s=>sn(s,u))<0&&o.push(u)}),o}function qm(e,t){try{if(!j(e))return NaN;if(!j(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=qm(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var Gl=Ne(qm);function Hm(e){try{if(!j(e))return NaN;if(typeof e=="bigint"){let t=Hm(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Qm=Ne(Hm);function G2(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!j(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var Zm=Ne(G2);function So(){return Zm(...arguments)}function Xm(e,t){return yi(e,So(t,-1))}function ql(e,t){return Rt(e,{shouldDropNaNs:t}).sum}function Tl(e,t){if(j(e)&&j(t))return Wl(e-t);if(ie(e)||q(e))return Tl(e.values,t);if(ie(t)||q(t))return Tl(e,t.values);T(e)&&T(t)&&N(sn(ue(e),ue(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Qm(ql(Gl(Xm(e,t),2)))}catch{return NaN}}function q2(e,t){return So(e,Gl(t,-1))}function qn(e,t){if(ie(e)){let o=qn(e.values,t);if(ue(o).length===1){let u=new vt(o);return u.name=q(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Je(o);return u.index=e.index.slice(),ie(t)&&(u.columns=t.columns.slice()),u}}if(ie(t)){let o=qn(e,t.values);if(ue(o).length===1){let u=new vt(o);return u.name=q(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Je(o);return u.columns=t.columns.slice(),u}}if(q(e))return qn(e.values,t);if(q(t))return qn(e,t.values);N(T(e)&&T(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=ue(e),r=ue(t);if(N(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),N(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return ql(So(e,t));if(n.length===1&&r.length===2)return Zn(t).map(o=>qn(e,o));if(n.length===2&&r.length===1)return e.map(o=>qn(o,t));if(n.length===2&&r.length===2){let o=Zn(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(qn(e[s],o[a]));u.push(i)}return u}}function Hl(e){if(ie(e)||q(e))return e.dropMissing(...Object.values(arguments).slice(1));N(T(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Hl(n))}catch{k(n)||t.push(n)}}),t}function ii(e,t){if(ie(e)||q(e))return ii(e.values,t);if(ie(t)||q(t))return ii(e,t.values);N(T(e)&&T(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),N(sn(ue(e),ue(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=ii(e[o],t[o]);n.push(u),r.push(s)}catch{!k(e[o])&&!k(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function ai(e,t){if(ie(e)||q(e))return ai(e.values,t);if(ie(t)||q(t))return ai(e,t.values);N(T(e)&&T(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),N(sn(ue(e),ue(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=ai(e[o],t[o]);n.push(u),r.push(s)}catch{j(e[o])&&j(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function H2(e){return Hl(e)}function vi(e,t){if(ie(e)||q(e))return vi(e.values,t);N(T(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),N(Xe(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(T(n)){if(!vi(n,t))return!1}else if(!t(n))return!1;return!0}function Q2(e){try{if(!j(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var Z2=Ne(Q2);function Al(e){try{return typeof e=="bigint"?BigInt(Al(Cn(e))):e!==Cn(e)?NaN:e<=1?1:e*Al(e-1)}catch{return NaN}}var X2=Ne(Al);function Il(e,t){if(ie(e)||q(e))return Il(e.values,t);if(N(jn(e)||T(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Xe(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(jn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(T(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function jl(e,t){if(ie(e)||q(e))return jl(e.values,t);if(N(jn(e)||T(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Xe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(jn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(T(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function x2(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return j(t)?t:NaN}catch{return NaN}}var eE=Ne(x2);function tE(e){try{return j(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var nE=Ne(tE);function Ql(e){j(e)&&(e=[e]);let t=[],n=Cu(e);for(let r=0;r<n;r++)t.push(0);return Fu(t,e)}function rE(e){typeof e=="bigint"&&(e=Cn(e)),N(!k(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),N(j(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),N(Cn(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),N(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Ql([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var oE=["true","false","yes","no"],uE=["null","none","nan","na","n/a","","undefined"];function oi(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=Cn(e.value)===e.value:e.isInteger=vi(e.values,t=>j(t)?Cn(t)===t:!0)),e}function li(e){if(ie(e)){let u=e.copy(),s=li(e.values);return u.values=s.values,oi({type:s.type,values:u})}if(q(e)){let u=e.copy(),s=li(e.values);return u.values=s.values,oi({type:s.type,values:u})}if(!T(e)){let u=li([e]);return u.value=u.values[0],delete u.values,oi(u)}N(T(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=an(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(Qn(a))return"date"}}catch{}fe(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(uE.indexOf(i)>-1)return"null";if(oE.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return j(a)?"number":typeof a=="object"?T(a)?"string":"object":"string"}catch{let l=new Date(u);return Qn(l)?"date":"string"}}),n=gi(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return oi({type:o,values:_i(e,u=>Bt(u,o))})}function ci(e){if(ie(e)){let n=e.copy();return n.values=ci(n.values),n}N(T(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=ue(e);if(N(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),N(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),N(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){N(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;N(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return So(i,1/s)}else if(t[0]>1){let n=(r,o)=>j(r)||j(o)?So(r,o):qn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=ci(o),l=ci(yi(i,n(-1,n(n(s,a),u)))),c=yi(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}N(!1,"This matrix cannot be inverted!")}}var sE=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function xm(e,t,n){try{if(!j(e))return NaN;if(!j(t))return NaN;if(!j(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=xm(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var iE=Ne(xm);function ed(e,t){try{if(t=k(t)?Math.E:t,!j(e))return NaN;if(!j(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=ed(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var aE=Ne(ed);function lE(e,t){return Rt(e,{shouldDropNaNs:t}).mean}function cE(e,t){return Rt(e,{shouldDropNaNs:t,median:!0}).median}function td(e,t){try{if(!j(e))return NaN;if(!j(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=td(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var fE=Ne(td);function hE(e,t){return Rt(e,{shouldDropNaNs:t,mode:!0}).mode}function ym(){let e=Do(),t=Do();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function mE(e){return k(e)?ym():_i(rn(e),ym)}function dE(e){return _i(rn(e),()=>1)}function Zl(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of Wm(r,o)){if(!u.slice)continue;let s=Ql(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return ie(e)||q(e)?Zl(e.values,t):(N(T(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),k(t)&&(t=e.length),N(j(t)&&Cn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(an(e),t))}function gE(e,t){let n=[];for(let r of Zl(e,t))n.push(r.slice());return n}function pE(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(T(t))if(Iu(t))console.log(t);else{let n=ue(t);n.length===1?new vt(t).print():n.length==2?new Je(t).print():console.log(t)}else ie(t)||q(t)?t.print():console.log(t)})}var yE=Ne((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!j(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function bE(e,t,n,r,o){if(T(e)&&k(r)&&k(o)){r=t,o=n;let u=Rt(e);t=u.min,n=u.max}return yE(e,t,n,r,o)}function vE(e){try{return j(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var NE=Ne(vE);function nd(e){try{return j(e)?typeof e=="bigint"?BigInt(nd(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var wE=Ne(nd);function EE(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var DE=Ne(EE);function Cl(e,t){if(ie(e)||q(e))return Cl(e.values,t);N(T(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),N(Xe(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(T(n)){if(Cl(n,t))return!0}else if(t(n))return!0;return!1}function rd(e,t){return Rt(e,{shouldDropNaNs:t,stdev:!0}).stdev}function SE(e){return rd(e)}function OE(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var FE=Ne(OE);function bm(e,t){N(Xe(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function _E(e,t){N(Xe(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function TE(){return zt([...arguments].map(e=>T(e)?e:ie(e)||q(e)?e.values:[e]))}function AE(e,t){return Rt(e,{shouldDropNaNs:t,variance:!0}).variance}function IE(){let e=[],t=Object.values(arguments).map(n=>((ie(n)||q(n))&&(n=n.values),N(T(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return We(0,Fi(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(k(u)?void 0:u)}),e.push(r)}),e}var Nu={abs:Wl,add:yi,apply:_i,arccos:B2,arcsin:R2,arctan:Y2,argmax:Dl,argmin:Sl,assert:N,cast:Bt,ceil:$2,chop:U2,clamp:L2,combinations:Wm,combinationsIterator:bi,copy:ut,correl:Fl,cos:z2,count:gi,covariance:Du,DataFrame:Je,dataTypes:W2,decycle:wo,diff:_l,distance:Tl,divide:q2,dot:qn,dropMissing:Hl,dropMissingPairwise:ii,dropNaN:zl,dropNaNPairwise:ai,dropUndefined:H2,every:vi,exp:Z2,factorial:X2,find:Il,findAll:jl,flatten:an,float:eE,floor:nE,identity:rE,IndexMatcher:Ti,indexOf:No,inferType:li,int:Cn,intersect:Gm,inverse:ci,isArray:T,isBoolean:Sr,isBrowser:sE,isDataFrame:ie,isDate:Qn,isEqual:sn,isFunction:Xe,isJagged:Iu,isNested:Oi,isNumber:j,isObject:jn,isSeries:q,isString:fe,isUndefined:k,lerp:iE,log:aE,MathError:lr,max:Fi,mean:lE,median:cE,min:Vm,mod:fE,mode:hE,multiply:Zm,ndarray:rn,normal:mE,ones:dE,permutations:gE,permutationsIterator:Zl,pow:Gl,print:pE,product:Cu,random:Do,range:We,remap:bE,reshape:Fu,reverse:An,round:NE,scale:So,seed:Km,Series:vt,set:zt,shape:ue,shuffle:pi,sign:wE,sin:DE,some:Cl,sort:Fr,sqrt:Qm,stats:Rt,std:rd,stdev:SE,subtract:Xm,sum:ql,tan:FE,timeAsync:_E,timeSync:bm,time:bm,transpose:Zn,union:TE,variance:AE,vectorize:Ne,zeros:Ql,zip:IE,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Nu.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Nu).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Nu[t]})}catch{e[t]=Nu[t]}})}};typeof window<"u"&&(window.JSMathTools=Nu);function od(e){if(typeof e!="string")throw new Error("`text` must be a string!");e=e.trim();let t="",n=!1;for(let r=0;r<e.length;r++){let o=e[r];o.match(/[A-Za-z0-9]/g)?(t.length===0?t+=o.toLowerCase():n?t+=o.toUpperCase():t+=o,n=!1):!o.includes("'")&&!o.includes("\u2019")&&!o.includes("\u275C")&&(n=!0)}return t}var jE=Object.defineProperty,CE=(e,t,n)=>t in e?jE(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,ud=(e,t,n)=>(CE(e,typeof t!="symbol"?t+"":t,n),n);function R(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var ME=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),cr=class extends Error{constructor(e){ME()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function y(e,t){if(!e)throw new cr(t)}var sd=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function $(e){return e===null||typeof e>"u"}var BE=sd.map(e=>e.name);function O(e){try{return e instanceof Array?!0:$(e.constructor)?!1:sd.indexOf(e.constructor)>-1||BE.indexOf(e.constructor.name)>-1}catch{return!1}}function ae(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function xe(e){return typeof e=="function"}function Mn(e){return typeof e=="object"&&!$(e)&&!O(e)}function H(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function Oo(e,t){if(ae(e)){let u=Oo(e.values,t);return u.length>0&&R(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&R(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(H(e)){let u=Oo(e.values,t);return u.length>0&&R(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(y(Mn(e)||O(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!xe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Mn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(O(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function st(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(O(n))return n instanceof Array?n.map(o=>st(o)):n.slice();if(H(n)){let o=n.copy();return o.values=st(o.values),o}if(ae(n)){let o=n.copy();return o.values=st(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=_r(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=st(n[o])}),r}else return n}return t(_r(e))}function _r(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+Oo(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),O(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(ae(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(H(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function un(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var vm=["number","int","float","bigint"];function Bn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!vm.includes(u)&&!vm.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(un(r))return un(o)?r.getTime()===o.getTime():!1;if(un(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(O(r)!==O(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(_r(e),_r(t))}}function Mu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var PE=Mu(16),RE=Mu(16),kE=Mu(16),YE=Mu(16),JE=Mu(16),$E=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)O(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?PE:$(e)?RE:xe(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+JE:e===1/0?kE:e===-1/0?YE:typeof e=="bigint"?e.toString():ae(e)?e.toJSONString():H(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!$(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function ln(e){if(ae(e)||H(e))return ln(e.values);y(O(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{O(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function kt(e,t){t=t||{};let n=new $E,r={},o=ln(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||R(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function Ni(e,t){let{counts:n}=kt(e);return $(t)||(xe(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{Bn(r,t)||n.delete(r)})),n}function Ml(e){if(ae(e)||H(e))return Ml(e.values);if(O(e)){let t=!1,n=!1,r=null;for(let o of e){if(Ml(o))return!0;if(O(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function Bu(e){return Ml(_r(e))}function Ai(e){if(ae(e)||H(e))return Ai(e.values);y(O(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(O(e[t]))return!0;return!1}var go="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function on(e){y(!$(e),go),O(e)||(e=[e]),y(!Ai(e),go),y(e.length>0,go);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),y(R(t),go),y(t>=0,go),y(Math.floor(t)===t,go),y(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(on(e.slice(1)));return n}}function In(e){if(ae(e)||H(e)){let n=e.copy();return n.values=In(n.values),n.index=In(n.index),n}y(O(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Ke(e,t,n=1){y(!$(e)&&!$(t)&&!$(n),"You must pass two numbers and optionally a step value to the `range` function!"),y(R(e)&&R(t)&&R(n),"You must pass two numbers and optionally a step value to the `range` function!"),y(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=In(u)),u}function Pu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var KE=Pu(256),UE=Pu(256),LE=Pu(256),VE=Pu(256),zE=Pu(256);function Wt(e){if(ae(e)||H(e))return Wt(e.values);y(O(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return ln(e).forEach(r=>{let o=typeof r=="object"&&r===null?KE:$(r)?UE:xe(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+zE:r===1/0?LE:r===-1/0?VE:typeof r=="bigint"?r.toString():ae(r)?r.toJSONString():H(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function id(e){if(O(e)){let t=id(e[0]);return[e.length].concat(t||[])}else return}function se(e){return ae(e)||H(e)?se(e.values):(y(O(e),"The `shape` function only works on arrays, Series, and DataFrames!"),id(e))}function ad(e,t,n){if($(n)&&(n=0),y(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),O(t)){y(!Bu(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=se(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Ke(0,o).forEach(s=>{s>=u._values.length&&u._values.push(on(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Ke(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(on(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new cr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(H(t)){let r=ad(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(ae(t))if(n===0){let r=e.copy(),o=Wt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(on(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(on(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new cr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function WE(e,t,n,r,o){if(o=o||0,y(xe(r),"The first parameter to the `apply` method must be a function."),y(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,$(s)&&(s=c instanceof t||O(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return $(u)&&(u=c instanceof t||O(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function de(e){return typeof e=="string"}function GE(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if($(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(Mn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new cr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{y(de(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),y(O(o)&&!Bu(o)&&se(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function qE(e,t){if(t.isEmpty)return new e;let n=new e(st(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function HE(e,t,n,r,o){$(r)&&(r=[]),$(o)&&(o=[]),(de(r)||R(r))&&(r=[r]),(de(o)||R(o))&&(o=[o]),y(O(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),y(O(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),y(se(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),y(se(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function ld(e){return R(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function Fo(e){return ld(e)&&e>=0}function QE(e,t,n,r,o,u){r=r||0,y(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,y(Fo(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",y(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if($(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if($(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!$(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(se(l).length<2)return new e;i.values=l;let c=i.get(null,a);if($(c))return new e;de(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function Xl(e){if(ae(e)||H(e))return e.dropNaN(...Object.values(arguments).slice(1));y(O(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Xl(n))}catch{if(R(n))return t.push(n)}}),t}function ZE(e,t,n,r,o){n=n||0,y(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,y(Fo(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",y(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=Xl(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function Nm(e){let t={};return ln(e).forEach((n,r)=>{t[n]=r}),t}function po(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function XE(e,t,n,r,o){y(xe(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),$(o)&&(o=0),y(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=Nm(u.index),i=Nm(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=po(s)[0],c.index=po(i),c}u.values=l,u.index=po(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=po(i)[0],c.index=po(s),c}u.values=l,u.index=po(i),u=u.transpose()}return u}function xE(e,t,n){(de(t)||R(t))&&(t=[t]),(de(n)||R(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Wt((t||[]).concat(n||[]).map(o=>typeof o));return y(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&y(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(y(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),y(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),$(t)||(t=t.map(o=>{if(de(o))return y(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(R(o))return y(o>=0,`Index ${o} is out of bounds!`),y(Math.floor(o)===o,"Row numbers must be integers!"),y(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),$(n)||(n=n.map(o=>{if(de(o))return y(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(R(o))return y(o>=0,`Column ${o} is out of bounds!`),y(Math.floor(o)===o,"Column numbers must be integers!"),y(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function eD(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Tr(e,t){if($(t)&&(t=eD),ae(e)||H(e))return e.sort(...Object.values(arguments).slice(1));y(O(e),"The `sort` function only works on arrays, Series, and DataFrames!"),y(xe(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function tD(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function wm(e,t,n){$(n)?n=t.columns:de(n)&&(n=[n]);let r={};n.forEach(u=>{y(de(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);y(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Tr(Wt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+tD(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function nD(e,t,n){let r=e.shape;$(t)&&(t=Ke(0,r[0])),$(n)&&(n=Ke(0,r[1])),R(t)&&(t=[t]),R(n)&&(n=[n]),y(O(t)&&O(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),y(se(t).length===1&&se(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),y(t.length>0,"The `rowIndices` array must contain at least one index."),y(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{y(Fo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),y(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{y(Fo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),y(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function rD(e,t,n,r,o){$(r)&&(r=n.index),$(o)&&(o=n.columns),de(r)&&(r=[r]),de(o)&&(o=[o]),y(O(r)&&O(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),y(se(r).length===1&&se(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),y(r.length>0,"The `rows` array must contain at least one row name."),y(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{y(de(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),y(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{y(de(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),y(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function oD(e,t,n){function r(h,m){return de(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Ke(0,u).concat(Ke(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Ke(0,i).concat(Ke(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Ke(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function bo(e,t){y(R(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function uD(e,t){let n=t?e:e.copy();return n.index=Ke(0,e.shape[0]).map(r=>"row"+bo(r,(n.index.length-1).toString().length)),n}function Ru(e,t){if(ae(e)||H(e))return Ru(e.values,t);y(O(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=ln(e),r=!1,o=1;for(let u of n){if(!R(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function sD(e){return ld(e)&&e>0}function _u(e,t){if(ae(e)||H(e))return _u(e.values,t);if(y(O(e),"The first argument passed into the `reshape` function must be an array!"),R(t)&&(t=[t]),y(O(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),y(se(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),y(sD(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return ln(e);let n=ln(e);if(t.length===1&&t[0]===n.length)return n;y(Ru(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(_u(s,t.slice(1)))}return r}var cd=Math.pow(2,64),je=[];fd(Math.floor(Math.random()*cd));function iD(e,t){e=mt(e);function n(){e+=mt("0x9e3779b97f4a7c15");let o=st(e);return o=(o^o>>BigInt(30))*mt("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*mt("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function mt(e){return BigInt.asUintN(64,BigInt(e))}function Em(e,t){return e=mt(e),t=BigInt(t),mt(mt(e<<t)|mt(e>>mt(BigInt(64)-t)))}function fd(e){if(typeof e=="bigint"&&(e=Number(e)),$(e))return st(je);{y(R(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=iD(Math.floor(e),4);je[0]=t[0],je[1]=t[1],je[2]=t[2],je[3]=t[3]}}function Dm(){let e=mt(Em(je[0]+je[3],23)+je[0]),t=mt(je[1]<<BigInt(17));return je[2]=mt(je[2]^je[0]),je[3]=mt(je[3]^je[1]),je[1]=mt(je[1]^je[2]),je[0]=mt(je[0]^je[3]),je[2]=mt(je[2]^t),je[3]=Em(je[3],45),Math.floor(Number(e))/cd}function _o(e){return $(e)?Dm():(O(e)||(e=[e]),_u(on(Ru(e)).map(Dm),e))}function wi(e){if(ae(e)||H(e))return e.shuffle(...Object.values(arguments).slice(1));y(O(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(_o()*n.length);t.push(n.splice(o,1)[0])}return t}function aD(e,t){return $(t)&&(t=0),y(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?wi(e.index):null,t===1?wi(e.columns):null)}function Or(e){return typeof e=="boolean"}function lD(e,t,n){return xe(t)?cD(e,t,n):fD(e,t,n)}function cD(e,t,n){if(n=$(n)?0:n,y(xe(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),y(R(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Tr(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Tr(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function fD(e,t,n){let r=e.copy(),o=_o().toString();r=r.assign(o,r.index),$(t)&&(t=[o],n=[!0]),(R(t)||de(t))&&(t=[t],(Or(n)||de(n))&&(n=[n])),y(O(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),y(se(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),$(n)&&(n=Ke(0,t.length).map(()=>!0)),y(O(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),y(se(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),y(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(y(de(s)||R(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),de(s)){let i=r.columns.indexOf(s);return y(i>-1,`The column "${s}" does not exist!`),i}if(R(s))return y(Fo(s),"Column indices must be whole numbers!"),y(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(y(de(s)||Or(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),de(s)){let i=s.trim().toLowerCase();return y(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Or(s))return s}),r.values=Tr(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function hD(e,t){$(t)?t=0:y(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function hd(e,t){return JSON.stringify(e.toObject(t))}async function mD(e,t,n){let r=hd(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new cr(s):typeof module<"u"?new cr(i):new cr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function dD(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function Xn(e){if(ae(e)||H(e))return e.transpose();y(O(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=se(e);if(y(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return In(e);if(t.length===2){let n=on(In(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function md(e,t,n){if(H(n))return new e(t.values.concat(n.values));if(O(n)){let r=se(n);y(r.length===1&&!Ai(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return md(t,[n])}function gD(e,t){y(xe(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function pD(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>$(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function yD(e,t){let n=[],r=[];t.values.forEach((u,s)=>{R(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function bD(e,t,n){let r=t.copy(),o=st(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function vD(e,t){(de(t)||R(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Wt((t||[]).map(r=>typeof r));return y(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&y(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(y(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),y(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),$(t)||(t=t.map(r=>{if(typeof r=="string")return y(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return y(r>=0,`Index ${r} is out of bounds!`),y(Math.floor(r)===r,"Indices must be integers!"),y(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function ND(e,t){let n=e.shape;$(t)&&(t=Ke(0,n[0])),y(O(t),"The `indices` array must be 1-dimensional array of whole numbers."),y(se(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),y(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{y(Fo(o),"The `indices` array must be a 1-dimensional array of whole numbers."),y(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function wD(e,t,n){$(n)&&(n=t.index),y(O(n),"The `indices` array must be a 1-dimensional array of strings."),y(se(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),y(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{y(de(u),"The `indices` array must contain only strings."),y(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function ED(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Ke(0,n/2).concat(Ke(t.index.length-n/2,t.index.length)));let o=st(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function DD(e){let t=e.copy();return t.get(wi(t.index))}function SD(e,t,n){n=n||((a,l)=>a<l?-1:1),y($(n)||xe(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Xn([t.values,t.index]),o=Tr(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function OD(e,t){let n=Xn([t.values,t.index]);n=Xn(Tr(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function FD(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Sm=Symbol.for("@jrc03c/js-math-tools/series");function _D(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Sm}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Sm}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){y(O(o),"The new values must be a 1-dimensional array!");let u=se(o);y(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Ke(this._index.length,u[0]).map(s=>"item"+bo(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){y(O(o),"The new index must be a 1-dimensional array of strings!"),y(o.length===this.shape[0],"The new index must be the same length as the old index!"),y(se(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{y(de(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=st(r.values),this.index=st(r.index);else if(O(r)){let o=se(r);y(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());y(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];y(se(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return se(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!$(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return vD(this,r)}getSubsetByNames(r){return wD(t,this,r)}getSubsetByIndices(r){return ND(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(In(this.values));return r.index=In(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Ke(0,this.shape[0]).map(o=>"item"+bo(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=st(this.values),r._index=st(this.index),r.name=this.name,r}append(r){return md(t,this,r)}apply(r){return gD(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return pD(this,r,o)}dropNaN(){return yD(t,this)}toObject(){return FD(this)}print(){return ED(this)}shuffle(){return DD(this)}sort(r){return SD(t,this,r)}sortByIndex(){return OD(t,this)}filter(r){return bD(t,this,r)}toDataFrame(){let r=new e(Xn([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=In(r.values),r.index=In(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Om=Symbol.for("@jrc03c/js-math-tools/dataframe");function ui(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(_o()*t.length)];return n}var $e=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Om}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Om}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!$(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){y(O(t),"The new values must be a 2-dimensional array!");let n=se(t);y(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Ke(this._index.length,n[0]).map(r=>"row"+bo(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Ke(this._columns.length,n[1]).map(r=>"col"+bo(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){y(O(t),"The new columns list must be a 1-dimensional array of strings!"),y(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),y(se(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ui(8):r.trim()));let n=(()=>{let r=Ni(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+ui(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){y(O(t),"The new index must be a 1-dimensional array of strings!"),y(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),y(se(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ui(8):r.trim()));let n=(()=>{let r=Ni(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+ui(8):r),this._index=t}}),y($(e)||Mn(e)||O(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof $e)this.values=st(e.values),this.columns=st(e.columns),this.index=st(e.index);else if(O(e)){let t=se(e);y(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),y(!Bu(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{$(r)&&(n=u,r=e[u].length),y(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=Xn(t);let o=se(this.values);this._index=Ke(0,o[0]).map(u=>"row"+bo(u,(o[0]-1).toString().length))}}get shape(){return se(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new $e(on(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return xE(this,e,t)}getSubsetByNames(e,t){return rD($e,Nt,this,e,t)}getSubsetByIndices(e,t){return nD(this,e,t)}getDummies(e){return wm($e,this,e)}oneHotEncode(e){return wm($e,this,e)}transpose(){let e=new $e(Xn(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return uD(this,e)}copy(){return qE($e,this)}assign(e,t){return GE($e,Nt,this,e,t)}apply(e,t){return WE($e,Nt,this,e,t)}dropMissing(e,t,n){return QE($e,Nt,this,e,t,n)}dropNaN(e,t,n){return ZE($e,this,e,t,n)}drop(e,t){return HE($e,Nt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return hD(this,e)}toObject(){return dD(this)}toJSONString(e){return hd(this,e)}saveAsJSON(e,t){return mD(this,e,t)}print(){return oD($e,Nt,this)}sort(e,t){return lD(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return XE($e,Nt,this,e,t)}shuffle(e){return aD(this,e)}append(e,t){return ad(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},Nt=_D($e);function Ii(e,t){return kt(e,{shouldDropNaNs:t}).max}function we(e){return y(xe(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return O(a)?!0:H(a)?(n=!0,o.push(a),!0):ae(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{y(Bn(O(i)?se(i):i.shape,O(s[a+1])?se(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=Ii(s.map(l=>l.length?l.length:l.values.length)),a=Ke(0,i).map(l=>{let c=Object.keys(arguments).map(f=>O(arguments[f])?arguments[f][l]:H(arguments[f])||ae(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&Bn(se(u[0]),se(a))){let l=new $e(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new $e(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new Nt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new Nt(a)}catch{return a}return a}else return e(...arguments)}}function TD(e){try{return R(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var xl=we(TD);function AD(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!R(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Ei=we(AD);function ID(e,t){try{return t(e)}catch{return NaN}}var ji=we(ID);function jD(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var CD=we(jD);function MD(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var BD=we(MD);function PD(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var RD=we(PD);function Bl(e,t){if(ae(e)){let n=Bl(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(H(e)){let n=Bl(e.values,t);return e.index[n]}y(O(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=Oo(e,Ii(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function dd(e,t){return kt(e,{shouldDropNaNs:t}).min}function Pl(e,t){if(ae(e)){let n=Pl(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(H(e)){let n=Pl(e.values,t);return e.index[n]}y(O(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=Oo(e,dd(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Pt(e,t){if(ae(e)||H(e))return e.apply(n=>Pt(n,t));if(O(e))return e.map(n=>Pt(n,t));if(t==="null")return null;if(t==="number"){if($(e))return NaN;let n=Pt(e,"boolean");if(Or(n))return n?1:0;try{JSON.parse(e)}catch{let u=Pt(e,"date");if(un(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=Pt(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return Pt(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(Pt(e,"int"));if(t==="boolean"){if(Or(e))return e;if(R(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(un(e))return e;if($(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return un(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Mn(e))return e;let n=Pt(e,"boolean");if(Or(n))return null;try{let o=Pt(e,"number");if(R(o))return JSON.parse(e),null}catch{}let r=Pt(e,"date");if(r)return r;try{let o=JSON.parse(e);return O(o)?o.map(u=>Pt(u,t)):o}catch{return null}}if(t==="string")return $(e)?Bn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function kD(e){try{return R(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var YD=we(kD);function JD(e,t){try{if(!R(e))return NaN;if(typeof e=="bigint")return e;if($(t))t=1e-10;else if(!R(t))return NaN;return xl(e)<t?0:e}catch{return NaN}}var $D=we(JD);function Rl(e){if(ae(e)||H(e)){let t=e.copy();return t.values=Rl(t.values),t}if(O(e))return e.map(t=>Rl(t));try{let t=JSON.parse(e);return R(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var Pn=we(Rl);function gd(e,t,n){try{return R(e)?R(t)?R(n)?typeof e=="bigint"?BigInt(gd(Pn(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var KD=we(gd);function Di(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of Di(i,o-1))yield[s].concat(a)}}return ae(e)||H(e)?Di(e.values,t):(y(O(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),y(R(t)&&Pn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(ln(e),t))}function pd(e,t){let n=[];for(let r of Di(e,t))n.push(r.slice());return n}function yd(){let e=Object.values(arguments).map(n=>ae(n)||H(n)?Wt(n.values):(y(O(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Wt(n)));return Wt(e).filter(n=>e.every(r=>r.findIndex(o=>Bn(o,n))>-1))}var wu=class{constructor(e){y($(e)||e===wu.DROP_NAN_MODE||e===wu.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=$(e)?wu.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(O(t)){let n=se(t);if(n.length===1)t=new Nt(t);else if(n.length===2)t=new $e(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}y(ae(t)||H(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===wu.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=yd(...e),this}transform(){y(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(O(t)){let n=se(t);if(n.length===1)return new Nt(t).get(this.index).values;if(n.length===2)return new $e(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return y(ae(t)||H(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ci=wu;ud(Ci,"DROP_NAN_MODE","DROP_NAN_MODE");ud(Ci,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Su(e,t,n,r){if(H(e))return Su(e.values,t,n,r);if(H(t))return Su(e,t.values,n,r);if(y(O(e)&&O(t)&&se(e).length===1&&se(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),y(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Su(...new Ci().fitAndTransform(e,t),!1,r);try{let o=kt(e,{stdev:r}),u=kt(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!R(s)||!R(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!R(f))return NaN;if(!R(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function kl(e,t,n){if(H(e))return kl(e.values,t,n);if(H(t))return kl(e,t.values,n);y(O(e)&&O(t)&&se(e).length===1&&se(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),y(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Su(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function UD(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var LD=we(UD),VD=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Yl(e,t){if(ae(e)||H(e))return Yl(e.values,t);if(ae(t)||H(t))return Yl(e,t.values);y(O(e)&&O(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Wt(e),r=Wt(t),o=[];return n.forEach(u=>{r.findIndex(s=>Bn(s,u))<0&&o.push(u)}),o}function bd(e,t){try{if(!R(e))return NaN;if(!R(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=bd(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var ec=we(bd);function vd(e){try{if(!R(e))return NaN;if(typeof e=="bigint"){let t=vd(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Nd=we(vd);function zD(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!R(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var wd=we(zD);function To(){return wd(...arguments)}function Ed(e,t){return Ei(e,To(t,-1))}function tc(e,t){return kt(e,{shouldDropNaNs:t}).sum}function Jl(e,t){if(R(e)&&R(t))return xl(e-t);if(ae(e)||H(e))return Jl(e.values,t);if(ae(t)||H(t))return Jl(e,t.values);O(e)&&O(t)&&y(Bn(se(e),se(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Nd(tc(ec(Ed(e,t),2)))}catch{return NaN}}function WD(e,t){return To(e,ec(t,-1))}function Hn(e,t){if(ae(e)){let o=Hn(e.values,t);if(se(o).length===1){let u=new Nt(o);return u.name=H(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new $e(o);return u.index=e.index.slice(),ae(t)&&(u.columns=t.columns.slice()),u}}if(ae(t)){let o=Hn(e,t.values);if(se(o).length===1){let u=new Nt(o);return u.name=H(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new $e(o);return u.columns=t.columns.slice(),u}}if(H(e))return Hn(e.values,t);if(H(t))return Hn(e,t.values);y(O(e)&&O(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=se(e),r=se(t);if(y(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),y(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return tc(To(e,t));if(n.length===1&&r.length===2)return Xn(t).map(o=>Hn(e,o));if(n.length===2&&r.length===1)return e.map(o=>Hn(o,t));if(n.length===2&&r.length===2){let o=Xn(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(Hn(e[s],o[a]));u.push(i)}return u}}function nc(e){if(ae(e)||H(e))return e.dropMissing(...Object.values(arguments).slice(1));y(O(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(nc(n))}catch{$(n)||t.push(n)}}),t}function fi(e,t){if(ae(e)||H(e))return fi(e.values,t);if(ae(t)||H(t))return fi(e,t.values);y(O(e)&&O(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),y(Bn(se(e),se(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=fi(e[o],t[o]);n.push(u),r.push(s)}catch{!$(e[o])&&!$(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function hi(e,t){if(ae(e)||H(e))return hi(e.values,t);if(ae(t)||H(t))return hi(e,t.values);y(O(e)&&O(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),y(Bn(se(e),se(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=hi(e[o],t[o]);n.push(u),r.push(s)}catch{R(e[o])&&R(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function GD(e){return nc(e)}function Si(e,t){if(ae(e)||H(e))return Si(e.values,t);y(O(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),y(xe(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(O(n)){if(!Si(n,t))return!1}else if(!t(n))return!1;return!0}function qD(e){try{if(!R(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var HD=we(qD);function $l(e){try{return typeof e=="bigint"?BigInt($l(Pn(e))):e!==Pn(e)?NaN:e<=1?1:e*$l(e-1)}catch{return NaN}}var QD=we($l);function Kl(e,t){if(ae(e)||H(e))return Kl(e.values,t);if(y(Mn(e)||O(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!xe(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(Mn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(O(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function Ul(e,t){if(ae(e)||H(e))return Ul(e.values,t);if(y(Mn(e)||O(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!xe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Mn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(O(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function ZD(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return R(t)?t:NaN}catch{return NaN}}var XD=we(ZD);function xD(e){try{return R(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var eS=we(xD);function rc(e){R(e)&&(e=[e]);let t=[],n=Ru(e);for(let r=0;r<n;r++)t.push(0);return _u(t,e)}function tS(e){typeof e=="bigint"&&(e=Pn(e)),y(!$(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),y(R(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),y(Pn(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),y(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=rc([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var nS=["true","false","yes","no"],rS=["null","none","nan","na","n/a","","undefined"];function si(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=Pn(e.value)===e.value:e.isInteger=Si(e.values,t=>R(t)?Pn(t)===t:!0)),e}function mi(e){if(ae(e)){let u=e.copy(),s=mi(e.values);return u.values=s.values,si({type:s.type,values:u})}if(H(e)){let u=e.copy(),s=mi(e.values);return u.values=s.values,si({type:s.type,values:u})}if(!O(e)){let u=mi([e]);return u.value=u.values[0],delete u.values,si(u)}y(O(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=ln(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(un(a))return"date"}}catch{}de(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(rS.indexOf(i)>-1)return"null";if(nS.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return R(a)?"number":typeof a=="object"?O(a)?"string":"object":"string"}catch{let l=new Date(u);return un(l)?"date":"string"}}),n=Ni(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return si({type:o,values:ji(e,u=>Pt(u,o))})}function di(e){if(ae(e)){let n=e.copy();return n.values=di(n.values),n}y(O(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=se(e);if(y(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),y(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),y(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){y(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;y(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return To(i,1/s)}else if(t[0]>1){let n=(r,o)=>R(r)||R(o)?To(r,o):Hn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=di(o),l=di(Ei(i,n(-1,n(n(s,a),u)))),c=Ei(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}y(!1,"This matrix cannot be inverted!")}}var oS=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Dd(e,t,n){try{if(!R(e))return NaN;if(!R(t))return NaN;if(!R(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Dd(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var uS=we(Dd);function Sd(e,t){try{if(t=$(t)?Math.E:t,!R(e))return NaN;if(!R(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Sd(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var sS=we(Sd);function iS(e,t){return kt(e,{shouldDropNaNs:t}).mean}function aS(e,t){return kt(e,{shouldDropNaNs:t,median:!0}).median}function Od(e,t){try{if(!R(e))return NaN;if(!R(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Od(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var lS=we(Od);function cS(e,t){return kt(e,{shouldDropNaNs:t,mode:!0}).mode}function Fm(){let e=_o(),t=_o();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function fS(e){return $(e)?Fm():ji(on(e),Fm)}function hS(e){return ji(on(e),()=>1)}function oc(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of pd(r,o)){if(!u.slice)continue;let s=rc(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return ae(e)||H(e)?oc(e.values,t):(y(O(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),$(t)&&(t=e.length),y(R(t)&&Pn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(ln(e),t))}function mS(e,t){let n=[];for(let r of oc(e,t))n.push(r.slice());return n}function dS(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(O(t))if(Bu(t))console.log(t);else{let n=se(t);n.length===1?new Nt(t).print():n.length==2?new $e(t).print():console.log(t)}else ae(t)||H(t)?t.print():console.log(t)})}var gS=we((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!R(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function pS(e,t,n,r,o){if(O(e)&&$(r)&&$(o)){r=t,o=n;let u=kt(e);t=u.min,n=u.max}return gS(e,t,n,r,o)}function yS(e){try{return R(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var bS=we(yS);function Fd(e){try{return R(e)?typeof e=="bigint"?BigInt(Fd(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var vS=we(Fd);function NS(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var wS=we(NS);function Ll(e,t){if(ae(e)||H(e))return Ll(e.values,t);y(O(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),y(xe(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(O(n)){if(Ll(n,t))return!0}else if(t(n))return!0;return!1}function _d(e,t){return kt(e,{shouldDropNaNs:t,stdev:!0}).stdev}function ES(e){return _d(e)}function DS(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var SS=we(DS);function _m(e,t){y(xe(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function OS(e,t){y(xe(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function FS(){return Wt([...arguments].map(e=>O(e)?e:ae(e)||H(e)?e.values:[e]))}function _S(e,t){return kt(e,{shouldDropNaNs:t,variance:!0}).variance}function TS(){let e=[],t=Object.values(arguments).map(n=>((ae(n)||H(n))&&(n=n.values),y(O(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Ke(0,Ii(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push($(u)?void 0:u)}),e.push(r)}),e}var Eu={abs:xl,add:Ei,apply:ji,arccos:CD,arcsin:BD,arctan:RD,argmax:Bl,argmin:Pl,assert:y,cast:Pt,ceil:YD,chop:$D,clamp:KD,combinations:pd,combinationsIterator:Di,copy:st,correl:kl,cos:LD,count:Ni,covariance:Su,DataFrame:$e,dataTypes:VD,decycle:_r,diff:Yl,distance:Jl,divide:WD,dot:Hn,dropMissing:nc,dropMissingPairwise:fi,dropNaN:Xl,dropNaNPairwise:hi,dropUndefined:GD,every:Si,exp:HD,factorial:QD,find:Kl,findAll:Ul,flatten:ln,float:XD,floor:eS,identity:tS,IndexMatcher:Ci,indexOf:Oo,inferType:mi,int:Pn,intersect:yd,inverse:di,isArray:O,isBoolean:Or,isBrowser:oS,isDataFrame:ae,isDate:un,isEqual:Bn,isFunction:xe,isJagged:Bu,isNested:Ai,isNumber:R,isObject:Mn,isSeries:H,isString:de,isUndefined:$,lerp:uS,log:sS,MathError:cr,max:Ii,mean:iS,median:aS,min:dd,mod:lS,mode:cS,multiply:wd,ndarray:on,normal:fS,ones:hS,permutations:mS,permutationsIterator:oc,pow:ec,print:dS,product:Ru,random:_o,range:Ke,remap:pS,reshape:_u,reverse:In,round:bS,scale:To,seed:fd,Series:Nt,set:Wt,shape:se,shuffle:wi,sign:vS,sin:wS,some:Ll,sort:Tr,sqrt:Nd,stats:kt,std:_d,stdev:ES,subtract:Ed,sum:tc,tan:SS,timeAsync:OS,timeSync:_m,time:_m,transpose:Xn,union:FS,variance:_S,vectorize:we,zeros:rc,zip:TS,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Eu.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Eu).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Eu[t]})}catch{e[t]=Eu[t]}})}};typeof window<"u"&&(window.JSMathTools=Eu);var AS=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:void 0;function Vl(e){let t=Symbol.for("@TypedArrayConstructor"),n="Symbol(@TypedArrayConstructor)",r=t in e?t:n in e?n:void 0;if(r){if(!("values"in e))throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");return e[r]==="ArrayBuffer"?new Uint8Array(e.values).buffer:new AS[e[r]](e.values)}if(O(e)&&e.constructor.name==="Array")return e;throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!")}function vo(e){if(e instanceof ArrayBuffer||e instanceof BigInt64Array||e instanceof BigUint64Array||e instanceof Float32Array||e instanceof Float64Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Int8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:e.constructor.name,values:e instanceof ArrayBuffer?Array.from(new Uint8Array(e)):Array.from(e)};if(O(e))return e.map(t=>{try{return vo(t)}catch{return t}});if(typeof e=="object"&e!==null){if(un(e))return new Date(e.getTime());let t={};return Object.keys(e).forEach(n=>{try{t[n]=vo(e[n])}catch{t[n]=e[n]}}),t}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function Td(e){return e=e.trim(),!!(e.match(/^-?\d+(\.\d+)?$/g)||e.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g)||e.match(/^-?\.\d+$/g)||e==="NaN")}var Ad="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";function Id(e,t,n){if(typeof e!="string")throw new Error("`text` must be a string!");if(typeof t!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return e.split(t).join(n)}var Tm="  ",Am=" ";function uc(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t="";for(let n=0;n<e.length;n++){let r=e[n].toLowerCase();Ad.includes(r)?t+=Am:t+=r}for(;t.includes(Tm);)t=Id(t,Tm,Am);return t.trim()}function IS(e,t){return t=t||"",e.split(`
`).map(n=>n.trim().length>0?t+n:n).join(`
`)}function jS(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=uc(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("-")}var Im={"@Infinity":1/0,"@NegativeInfinity":-1/0,"@NaN":NaN,"@undefined":void 0};function Tu(e){if(typeof e=="object"){if(e===null)return e;if(O(e))for(let t=0;t<e.length;t++)e[t]=Tu(e[t]);else Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{e[t]=Tu(e[t])});return e}else return typeof e>"u"||e==="Symbol(@undefined)"?void 0:e}function CS(e){if(typeof e=="bigint")return e;if(typeof e=="string")if(e.match(/^\s*?-?\d+n\s*?$/g))try{return BigInt(e.split("n")[0])}catch{return NaN}else return NaN;else return NaN}function MS(e){if(typeof e!="string")return typeof e=="number"?e:void 0;if(Td(e))return parseFloat(e)}function BS(e){if(typeof e!="string")return;let t="@jrc03c/js-text-tools/newline-replacer";if(e=e.replaceAll(`
`,t),e.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)){let n=e.replace("Symbol(@String):","");if(n.match(/^".*?"$/g))try{return JSON.parse(n)}catch{n=n.substring(1,n.length-1)}return n=n.replaceAll(t,`
`),n}}function PS(e){if(typeof e!="string")return typeof e=="symbol"?{out:e,isASymbol:!0}:void 0;if(e.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)){let t=e.replace(/^.*?Symbol\(/g,"").replace(/\).*?$/g,"");return t in Im?{out:Im[t],isASymbol:!0}:{out:Symbol.for(t),isASymbol:!0}}}function RS(e){if(typeof e!="string")return e instanceof RegExp?e:void 0;let t=e.trim();if(t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g))try{let n=t.replace(/^\//g,"").replace(/\/(d|g|i|m|s|u|v|y)*?$/g,""),r=t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);return new RegExp(n,r)}catch{}}function kS(e){if(typeof e!="string")return typeof e=="object"?e:"Symbol(@undefined)";try{let t=JSON.parse(e,(n,r)=>{try{let o=fr(r);return typeof o>"u"?"Symbol(@undefined)":o}catch{return typeof r>"u"?"Symbol(@undefined)":r}});return O(t)&&(t=Tu(t)),t}catch{return e}}function YS(e){if(typeof e!="string")return e instanceof Date&&e.toString()!=="Invalid Date"?e:void 0;try{let t=new Date(Date.parse(e));if(t.toString()!=="Invalid Date")return t}catch{}}function JS(e){return typeof e=="object"?e!==null?Tu(e):void 0:(Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{try{let n=t;try{t=fr(t)}catch{}e[t]=fr(e[n]),t!==n&&delete e[n]}catch{}}),Tu(e))}function fr(e){function t(n){if(typeof n=="string"){let r=BS(n);if(typeof r=="string")return r;let o=PS(n);return r=o?o.out:void 0,o&&o.isASymbol||(r=RS(n),r instanceof RegExp)||(r=CS(n),typeof r=="bigint")||(r=MS(n),typeof r=="number")||(r=YS(n),r instanceof Date)?r:(r=kS(n),typeof r<"u"?r==="Symbol(@undefined)"?void 0:r:n)}if(typeof n=="object"){if(n===null)return null;let r;try{if(r=Vl(n),O(r))return r}catch{}if(r=JS(n),r)try{return Vl(r)}catch{return r}return n}return n}return t(e)}function $S(e){let t=od(e);return t[0].toUpperCase()+t.slice(1)}function KS(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=uc(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("_")}function ar(e,t){return!e||t<=0?"":Ke(0,t).map(()=>e).join("")}function Ao(e,t){y(de(t)||$(t),"The second parameter to the `stringify` function must be undefined or a string!");let n=t?`
`:"";function r(o,u,s){return s=s||0,typeof o=="bigint"?JSON.stringify(o.toString()+"n"):typeof o=="number"?o===1/0?'"Symbol(@Infinity)"':o===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(o)?'"Symbol(@NaN)"':o.toString():typeof o=="string"?JSON.stringify("Symbol(@String):"+o):typeof o=="boolean"?o.toString():typeof o>"u"?'"Symbol(@undefined)"':typeof o=="symbol"||typeof o=="function"?JSON.stringify(o.toString()):o instanceof RegExp?o.toString():typeof o=="object"?o===null?"null":un(o)?JSON.stringify(o.toJSON()):O(o)?o.length===0?ar(u,s-1)+"[]":o instanceof Array?ar(u,s-1)+"["+n+o.map(i=>{let a=(()=>{try{return r(vo(i),u,s+1)}catch{return r(i,u,s+1)}})();return de(a)&&(a=a.trim()),ar(u,s+1)+a}).join(","+n)+n+ar(u,s)+"]":r(vo(o),null,u):Object.keys(o).length+Object.getOwnPropertySymbols(o).length===0?ar(u,s-1)+"{}":ar(u,s-1)+"{"+n+Object.keys(o).concat(Object.getOwnPropertySymbols(o)).map(i=>{let a=(()=>{try{return r(vo(o[i]),u,s+1)}catch{return r(o[i],u,s+1)}})();de(a)&&(a=a.trim());let l=typeof i=="symbol"?r(i):JSON.stringify(i);return ar(u,s+1)+l+":"+(u?" ":"")+a}).join(","+n)+n+ar(u,s)+"}":"undefined"}return r(_r(e),t)}function US(e){let t=e.split(`
`),n=t.filter(o=>o.trim().length>0).map(o=>o.split("").findIndex(u=>!u.match(/\s/g))),r=Math.min(...n);return t.map(o=>o.substring(r)).join(`
`)}function LS(e,t){if(typeof e!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof t>"u"||t===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?t=process.stdout.columns>80?80:process.stdout.columns:t=80),isNaN(t)||typeof t!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return e.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let o=r.split(/[^\s]/g)[0],u=r.replace(o,"").split(" "),s=o;u.forEach(i=>{let a=s+(s.trim().length>0?" ":"")+i;a.length>t?(n.push(s),s=o+i):s=a}),s.length>0&&n.push(s)}),n.join(`
`)}typeof window<"u"&&(window.JSTextTools={camelify:od,convertObjectToTypedArray:Vl,convertTypedArrayToObject:vo,indent:IS,isANumberString:Td,kebabify:jS,parse:fr,pascalify:$S,punctuation:Ad,replaceAll:Id,snakeify:KS,stringify:Ao,strip:uc,unindent:US,wrap:LS});function jd(e){if(!fe(e))throw new Error("The value passed into the `base64Decode` must be a string!");try{let t=decodeURIComponent(atob(e)),n=t,r=!0;for(;r;)try{t=fr(t),sn(t,n)&&(r=!1),n=t}catch{r=!1}return t}catch(t){throw new jm(t.toString())}}function Cd(e){return fe(e)||(e=Ao(e)),btoa(encodeURIComponent(e))}function Ou(e){return j(e)&&e>0&&parseInt(e)===e}async function VS(e,t,n){n=n||{};let r=n.keyIterations||21e4;if(!fe(e))throw new Error("The first argument passed into the `decrypt` function must be a string (i.e., the same string returned from the `encrypt` function)!");if(!fe(t)||t.length===0)throw new Error("The second argument passed into the `decrypt` function must be a string representing the password with which to decrypt the encrypted data.");if(!Ou(r))throw new Error("The 'keyIterations' option passed into the `decrypt` function must be undefined or a natural number (i.e., a positive integer) representing the number of iterations used during the key derivation. NOTE: For decryption to be successful, this number must match the number of iterations that was used during the encryption of the data.");e=fr(jd(e));let{iv:o,salt:u,value:s}=e;if(!o||!u||!s)throw new Error("The first argument passed into the `decrypt` function must be an object with properties 'iv', 'salt', and 'value' (i.e., the same object returned from the `encrypt` function)!");let i,a;try{let l=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveBits","deriveKey"]);a=await crypto.subtle.deriveKey({name:"PBKDF2",salt:u,iterations:r,hash:"SHA-512"},l,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}catch(l){throw new wl(l.toString())}try{i=new TextDecoder().decode(await crypto.subtle.decrypt({name:"AES-GCM",iv:o},a,s))}catch{throw new wl("Invalid password!")}try{return fr(i)}catch{return i}}async function zS(e,t,n){n=n||{};let r=n.saltLength||32,o=n.ivLength||32,u=n.keyIterations||21e4;if(!fe(t)&&t.length>0)throw new Error("The second argument passed into the `encrypt` function must be a string representing the password with which the data will be encrypted!");if(!Ou(r))throw new Error("The 'saltLength' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the length of the new salt to be generated.");if(!Ou(o))throw new Error("The 'ivLength' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the length of the initialization vector to be generated.");if(!Ou(u))throw new Error("The 'keyIterations' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the number of iterations used during the key derivation.");let s,i,a;try{i=crypto.getRandomValues(new Uint8Array(r));let l=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveBits","deriveKey"]),c=await crypto.subtle.deriveKey({name:"PBKDF2",salt:i,iterations:u,hash:"SHA-512"},l,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);a=crypto.getRandomValues(new Uint8Array(o)),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},c,new TextEncoder().encode(Ao(e)))}catch(l){throw new Cm(l.toString())}return Cd(Ao({salt:i,iv:a,value:s}))}async function sc(e,t){if(k(t))t="";else if(!fe(t))throw new Error("The second value passed into the `hash` function must be undefined or a string representing a salt to be added to the first value before hashing!");fe(e)||(e=Ao(e));try{return Array.from(new Uint8Array(await crypto.subtle.digest("SHA-512",new TextEncoder().encode(e+t)))).map(n=>n.toString(16).padStart(2,"0")).join("")}catch(n){throw new Mm(n.toString())}}function WS(e,t){if(k(e))e=256;else if(!Ou(e))throw new Error("The first value passed into the `randomString` function must be undefined or a positive integer representing the length of the returned string! If no length is passed, then the default length will be 256.");if(k(t))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";else if(!fe(t)||t.length<=1)throw new Error("The second value passed into the `randomString` function must be undefined or a string representing the set of characters of which the returned string will be comprised! Note that a given character set must contain at least 2 characters in order to be secure. If the character set is undefined, then the default value is the lower- and upper-case Latin alphabet and the digits 0-9.");try{let n="";for(let r=0;r<e;r++){let o=crypto.getRandomValues(new Uint32Array(1))[0]%t.length;n+=t[o]}return n}catch(n){throw new Bm(n.toString())}}typeof window<"u"&&(window.JSCryptoHelpers={base64Decode:jd,Base64DecodingError:jm,base64Encode:Cd,Base64EncodingError:Cw,decrypt:VS,DecryptionError:wl,encrypt:zS,EncryptionError:Cm,hash:sc,HashingError:Mm,parse:fr,randomString:WS,RandomStringGenerationError:Bm,stringify:Ao});var GS=Object.defineProperty,qS=(e,t,n)=>t in e?GS(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Ud=(e,t,n)=>(qS(e,typeof t!="symbol"?t+"":t,n),n);function I(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var HS=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),hr=class extends Error{constructor(e){HS()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function d(e,t){if(!e)throw new hr(t)}var Ld=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function L(e){return e===null||typeof e>"u"}var QS=Ld.map(e=>e.name);function A(e){try{return e instanceof Array?!0:L(e.constructor)?!1:Ld.indexOf(e.constructor)>-1||QS.indexOf(e.constructor.name)>-1}catch{return!1}}function ce(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function et(e){return typeof e=="function"}function kn(e){return typeof e=="object"&&!L(e)&&!A(e)}function Q(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function Mo(e,t){if(ce(e)){let u=Mo(e.values,t);return u.length>0&&I(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&I(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(Q(e)){let u=Mo(e.values,t);return u.length>0&&I(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(d(kn(e)||A(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!et(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(kn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(A(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function it(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(A(n))return n instanceof Array?n.map(o=>it(o)):n.slice();if(Q(n)){let o=n.copy();return o.values=it(o.values),o}if(ce(n)){let o=n.copy();return o.values=it(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=Bo(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=it(n[o])}),r}else return n}return t(Bo(e))}function Bo(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+Mo(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),A(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(ce(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(Q(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function er(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var Md=["number","int","float","bigint"];function Yn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!Md.includes(u)&&!Md.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(er(r))return er(o)?r.getTime()===o.getTime():!1;if(er(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(A(r)!==A(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Bo(e),Bo(t))}}function Ku(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var ZS=Ku(16),XS=Ku(16),xS=Ku(16),eO=Ku(16),tO=Ku(16),nO=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)A(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?ZS:L(e)?XS:et(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+tO:e===1/0?xS:e===-1/0?eO:typeof e=="bigint"?e.toString():ce(e)?e.toJSONString():Q(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!L(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function fn(e){if(ce(e)||Q(e))return fn(e.values);d(A(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{A(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function $t(e,t){t=t||{};let n=new nO,r={},o=fn(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||I(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function Ji(e,t){let{counts:n}=$t(e);return L(t)||(et(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{Yn(r,t)||n.delete(r)})),n}function ic(e){if(ce(e)||Q(e))return ic(e.values);if(A(e)){let t=!1,n=!1,r=null;for(let o of e){if(ic(o))return!0;if(A(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function Uu(e){return ic(Bo(e))}function Vi(e){if(ce(e)||Q(e))return Vi(e.values);d(A(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(A(e[t]))return!0;return!1}var Io="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function cn(e){d(!L(e),Io),A(e)||(e=[e]),d(!Vi(e),Io),d(e.length>0,Io);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),d(I(t),Io),d(t>=0,Io),d(Math.floor(t)===t,Io),d(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(cn(e.slice(1)));return n}}function Rn(e){if(ce(e)||Q(e)){let n=e.copy();return n.values=Rn(n.values),n.index=Rn(n.index),n}d(A(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Ge(e,t,n=1){d(!L(e)&&!L(t)&&!L(n),"You must pass two numbers and optionally a step value to the `range` function!"),d(I(e)&&I(t)&&I(n),"You must pass two numbers and optionally a step value to the `range` function!"),d(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=Rn(u)),u}function Lu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var rO=Lu(256),oO=Lu(256),uO=Lu(256),sO=Lu(256),iO=Lu(256);function Gt(e){if(ce(e)||Q(e))return Gt(e.values);d(A(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return fn(e).forEach(r=>{let o=typeof r=="object"&&r===null?rO:L(r)?oO:et(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+iO:r===1/0?uO:r===-1/0?sO:typeof r=="bigint"?r.toString():ce(r)?r.toJSONString():Q(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function Vd(e){if(A(e)){let t=Vd(e[0]);return[e.length].concat(t||[])}else return}function le(e){return ce(e)||Q(e)?le(e.values):(d(A(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Vd(e))}function zd(e,t,n){if(L(n)&&(n=0),d(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),A(t)){d(!Uu(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=le(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Ge(0,o).forEach(s=>{s>=u._values.length&&u._values.push(cn(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Ge(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(cn(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new hr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(Q(t)){let r=zd(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(ce(t))if(n===0){let r=e.copy(),o=Gt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(cn(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(cn(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new hr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function aO(e,t,n,r,o){if(o=o||0,d(et(r),"The first parameter to the `apply` method must be a function."),d(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,L(s)&&(s=c instanceof t||A(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return L(u)&&(u=c instanceof t||A(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function Ee(e){return typeof e=="string"}function lO(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(L(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(kn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new hr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{d(Ee(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),d(A(o)&&!Uu(o)&&le(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function cO(e,t){if(t.isEmpty)return new e;let n=new e(it(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function fO(e,t,n,r,o){L(r)&&(r=[]),L(o)&&(o=[]),(Ee(r)||I(r))&&(r=[r]),(Ee(o)||I(o))&&(o=[o]),d(A(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),d(A(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),d(le(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),d(le(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function Wd(e){return I(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function Po(e){return Wd(e)&&e>=0}function hO(e,t,n,r,o,u){r=r||0,d(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,d(Po(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",d(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(L(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(L(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!L(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(le(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(L(c))return new e;Ee(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function bc(e){if(ce(e)||Q(e))return e.dropNaN(...Object.values(arguments).slice(1));d(A(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(bc(n))}catch{if(I(n))return t.push(n)}}),t}function mO(e,t,n,r,o){n=n||0,d(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,d(Po(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",d(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=bc(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function Bd(e){let t={};return fn(e).forEach((n,r)=>{t[n]=r}),t}function jo(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function dO(e,t,n,r,o){d(et(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),L(o)&&(o=0),d(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=Bd(u.index),i=Bd(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=jo(s)[0],c.index=jo(i),c}u.values=l,u.index=jo(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=jo(i)[0],c.index=jo(s),c}u.values=l,u.index=jo(i),u=u.transpose()}return u}function gO(e,t,n){(Ee(t)||I(t))&&(t=[t]),(Ee(n)||I(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Gt((t||[]).concat(n||[]).map(o=>typeof o));return d(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&d(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(d(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),d(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),L(t)||(t=t.map(o=>{if(Ee(o))return d(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(I(o))return d(o>=0,`Index ${o} is out of bounds!`),d(Math.floor(o)===o,"Row numbers must be integers!"),d(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),L(n)||(n=n.map(o=>{if(Ee(o))return d(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(I(o))return d(o>=0,`Column ${o} is out of bounds!`),d(Math.floor(o)===o,"Column numbers must be integers!"),d(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function pO(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Ir(e,t){if(L(t)&&(t=pO),ce(e)||Q(e))return e.sort(...Object.values(arguments).slice(1));d(A(e),"The `sort` function only works on arrays, Series, and DataFrames!"),d(et(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function yO(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function Pd(e,t,n){L(n)?n=t.columns:Ee(n)&&(n=[n]);let r={};n.forEach(u=>{d(Ee(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);d(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Ir(Gt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+yO(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function bO(e,t,n){let r=e.shape;L(t)&&(t=Ge(0,r[0])),L(n)&&(n=Ge(0,r[1])),I(t)&&(t=[t]),I(n)&&(n=[n]),d(A(t)&&A(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),d(le(t).length===1&&le(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),d(t.length>0,"The `rowIndices` array must contain at least one index."),d(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{d(Po(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),d(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{d(Po(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),d(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function vO(e,t,n,r,o){L(r)&&(r=n.index),L(o)&&(o=n.columns),Ee(r)&&(r=[r]),Ee(o)&&(o=[o]),d(A(r)&&A(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),d(le(r).length===1&&le(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),d(r.length>0,"The `rows` array must contain at least one row name."),d(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{d(Ee(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),d(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{d(Ee(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),d(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function NO(e,t,n){function r(h,m){return Ee(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Ge(0,u).concat(Ge(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Ge(0,i).concat(Ge(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Ge(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function Co(e,t){d(I(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function wO(e,t){let n=t?e:e.copy();return n.index=Ge(0,e.shape[0]).map(r=>"row"+Co(r,(n.index.length-1).toString().length)),n}function Vu(e,t){if(ce(e)||Q(e))return Vu(e.values,t);d(A(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=fn(e),r=!1,o=1;for(let u of n){if(!I(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function EO(e){return Wd(e)&&e>0}function $u(e,t){if(ce(e)||Q(e))return $u(e.values,t);if(d(A(e),"The first argument passed into the `reshape` function must be an array!"),I(t)&&(t=[t]),d(A(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),d(le(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),d(EO(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return fn(e);let n=fn(e);if(t.length===1&&t[0]===n.length)return n;d(Vu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push($u(s,t.slice(1)))}return r}var Gd=Math.pow(2,64),Ce=[];vc(Math.floor(Math.random()*Gd));function DO(e,t){e=dt(e);function n(){e+=dt("0x9e3779b97f4a7c15");let o=it(e);return o=(o^o>>BigInt(30))*dt("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*dt("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function dt(e){return BigInt.asUintN(64,BigInt(e))}function Rd(e,t){return e=dt(e),t=BigInt(t),dt(dt(e<<t)|dt(e>>dt(BigInt(64)-t)))}function vc(e){if(typeof e=="bigint"&&(e=Number(e)),L(e))return it(Ce);{d(I(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=DO(Math.floor(e),4);Ce[0]=t[0],Ce[1]=t[1],Ce[2]=t[2],Ce[3]=t[3]}}function kd(){let e=dt(Rd(Ce[0]+Ce[3],23)+Ce[0]),t=dt(Ce[1]<<BigInt(17));return Ce[2]=dt(Ce[2]^Ce[0]),Ce[3]=dt(Ce[3]^Ce[1]),Ce[1]=dt(Ce[1]^Ce[2]),Ce[0]=dt(Ce[0]^Ce[3]),Ce[2]=dt(Ce[2]^t),Ce[3]=Rd(Ce[3],45),Math.floor(Number(e))/Gd}function jr(e){return L(e)?kd():(A(e)||(e=[e]),$u(cn(Vu(e)).map(kd),e))}function $i(e){if(ce(e)||Q(e))return e.shuffle(...Object.values(arguments).slice(1));d(A(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(jr()*n.length);t.push(n.splice(o,1)[0])}return t}function SO(e,t){return L(t)&&(t=0),d(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?$i(e.index):null,t===1?$i(e.columns):null)}function Ar(e){return typeof e=="boolean"}function OO(e,t,n){return et(t)?FO(e,t,n):_O(e,t,n)}function FO(e,t,n){if(n=L(n)?0:n,d(et(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),d(I(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Ir(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Ir(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function _O(e,t,n){let r=e.copy(),o=jr().toString();r=r.assign(o,r.index),L(t)&&(t=[o],n=[!0]),(I(t)||Ee(t))&&(t=[t],(Ar(n)||Ee(n))&&(n=[n])),d(A(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),d(le(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),L(n)&&(n=Ge(0,t.length).map(()=>!0)),d(A(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),d(le(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),d(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(d(Ee(s)||I(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),Ee(s)){let i=r.columns.indexOf(s);return d(i>-1,`The column "${s}" does not exist!`),i}if(I(s))return d(Po(s),"Column indices must be whole numbers!"),d(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(d(Ee(s)||Ar(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),Ee(s)){let i=s.trim().toLowerCase();return d(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Ar(s))return s}),r.values=Ir(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function TO(e,t){L(t)?t=0:d(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function qd(e,t){return JSON.stringify(e.toObject(t))}async function AO(e,t,n){let r=qd(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new hr(s):typeof module<"u"?new hr(i):new hr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function IO(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function tr(e){if(ce(e)||Q(e))return e.transpose();d(A(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=le(e);if(d(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return Rn(e);if(t.length===2){let n=cn(Rn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function Hd(e,t,n){if(Q(n))return new e(t.values.concat(n.values));if(A(n)){let r=le(n);d(r.length===1&&!Vi(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return Hd(t,[n])}function jO(e,t){d(et(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function CO(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>L(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function MO(e,t){let n=[],r=[];t.values.forEach((u,s)=>{I(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function BO(e,t,n){let r=t.copy(),o=it(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function PO(e,t){(Ee(t)||I(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Gt((t||[]).map(r=>typeof r));return d(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&d(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(d(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),d(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),L(t)||(t=t.map(r=>{if(typeof r=="string")return d(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return d(r>=0,`Index ${r} is out of bounds!`),d(Math.floor(r)===r,"Indices must be integers!"),d(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function RO(e,t){let n=e.shape;L(t)&&(t=Ge(0,n[0])),d(A(t),"The `indices` array must be 1-dimensional array of whole numbers."),d(le(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),d(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{d(Po(o),"The `indices` array must be a 1-dimensional array of whole numbers."),d(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function kO(e,t,n){L(n)&&(n=t.index),d(A(n),"The `indices` array must be a 1-dimensional array of strings."),d(le(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),d(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{d(Ee(u),"The `indices` array must contain only strings."),d(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function YO(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Ge(0,n/2).concat(Ge(t.index.length-n/2,t.index.length)));let o=it(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function JO(e){let t=e.copy();return t.get($i(t.index))}function $O(e,t,n){n=n||((a,l)=>a<l?-1:1),d(L(n)||et(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=tr([t.values,t.index]),o=Ir(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function KO(e,t){let n=tr([t.values,t.index]);n=tr(Ir(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function UO(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Yd=Symbol.for("@jrc03c/js-math-tools/series");function LO(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Yd}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Yd}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){d(A(o),"The new values must be a 1-dimensional array!");let u=le(o);d(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Ge(this._index.length,u[0]).map(s=>"item"+Co(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){d(A(o),"The new index must be a 1-dimensional array of strings!"),d(o.length===this.shape[0],"The new index must be the same length as the old index!"),d(le(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{d(Ee(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=it(r.values),this.index=it(r.index);else if(A(r)){let o=le(r);d(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());d(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];d(le(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return le(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!L(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return PO(this,r)}getSubsetByNames(r){return kO(t,this,r)}getSubsetByIndices(r){return RO(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(Rn(this.values));return r.index=Rn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Ge(0,this.shape[0]).map(o=>"item"+Co(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=it(this.values),r._index=it(this.index),r.name=this.name,r}append(r){return Hd(t,this,r)}apply(r){return jO(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return CO(this,r,o)}dropNaN(){return MO(t,this)}toObject(){return UO(this)}print(){return YO(this)}shuffle(){return JO(this)}sort(r){return $O(t,this,r)}sortByIndex(){return KO(t,this)}filter(r){return BO(t,this,r)}toDataFrame(){let r=new e(tr([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=Rn(r.values),r.index=Rn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Jd=Symbol.for("@jrc03c/js-math-tools/dataframe");function Mi(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(jr()*t.length)];return n}var Ue=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Jd}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Jd}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!L(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){d(A(t),"The new values must be a 2-dimensional array!");let n=le(t);d(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Ge(this._index.length,n[0]).map(r=>"row"+Co(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Ge(this._columns.length,n[1]).map(r=>"col"+Co(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){d(A(t),"The new columns list must be a 1-dimensional array of strings!"),d(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),d(le(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Mi(8):r.trim()));let n=(()=>{let r=Ji(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+Mi(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){d(A(t),"The new index must be a 1-dimensional array of strings!"),d(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),d(le(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Mi(8):r.trim()));let n=(()=>{let r=Ji(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+Mi(8):r),this._index=t}}),d(L(e)||kn(e)||A(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Ue)this.values=it(e.values),this.columns=it(e.columns),this.index=it(e.index);else if(A(e)){let t=le(e);d(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),d(!Uu(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{L(r)&&(n=u,r=e[u].length),d(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=tr(t);let o=le(this.values);this._index=Ge(0,o[0]).map(u=>"row"+Co(u,(o[0]-1).toString().length))}}get shape(){return le(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Ue(cn(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return gO(this,e,t)}getSubsetByNames(e,t){return vO(Ue,wt,this,e,t)}getSubsetByIndices(e,t){return bO(this,e,t)}getDummies(e){return Pd(Ue,this,e)}oneHotEncode(e){return Pd(Ue,this,e)}transpose(){let e=new Ue(tr(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return wO(this,e)}copy(){return cO(Ue,this)}assign(e,t){return lO(Ue,wt,this,e,t)}apply(e,t){return aO(Ue,wt,this,e,t)}dropMissing(e,t,n){return hO(Ue,wt,this,e,t,n)}dropNaN(e,t,n){return mO(Ue,this,e,t,n)}drop(e,t){return fO(Ue,wt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return TO(this,e)}toObject(){return IO(this)}toJSONString(e){return qd(this,e)}saveAsJSON(e,t){return AO(this,e,t)}print(){return NO(Ue,wt,this)}sort(e,t){return OO(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return dO(Ue,wt,this,e,t)}shuffle(e){return SO(this,e)}append(e,t){return zd(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},wt=LO(Ue);function zi(e,t){return $t(e,{shouldDropNaNs:t}).max}function De(e){return d(et(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return A(a)?!0:Q(a)?(n=!0,o.push(a),!0):ce(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{d(Yn(A(i)?le(i):i.shape,A(s[a+1])?le(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=zi(s.map(l=>l.length?l.length:l.values.length)),a=Ge(0,i).map(l=>{let c=Object.keys(arguments).map(f=>A(arguments[f])?arguments[f][l]:Q(arguments[f])||ce(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&Yn(le(u[0]),le(a))){let l=new Ue(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Ue(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new wt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new wt(a)}catch{return a}return a}else return e(...arguments)}}function VO(e){try{return I(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var Nc=De(VO);function zO(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!I(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Ki=De(zO);function WO(e,t){try{return t(e)}catch{return NaN}}var Wi=De(WO);function GO(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var qO=De(GO);function HO(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var QO=De(HO);function ZO(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var XO=De(ZO);function ac(e,t){if(ce(e)){let n=ac(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(Q(e)){let n=ac(e.values,t);return e.index[n]}d(A(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=Mo(e,zi(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Qd(e,t){return $t(e,{shouldDropNaNs:t}).min}function lc(e,t){if(ce(e)){let n=lc(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(Q(e)){let n=lc(e.values,t);return e.index[n]}d(A(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=Mo(e,Qd(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Yt(e,t){if(ce(e)||Q(e))return e.apply(n=>Yt(n,t));if(A(e))return e.map(n=>Yt(n,t));if(t==="null")return null;if(t==="number"){if(L(e))return NaN;let n=Yt(e,"boolean");if(Ar(n))return n?1:0;try{JSON.parse(e)}catch{let u=Yt(e,"date");if(er(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=Yt(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return Yt(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(Yt(e,"int"));if(t==="boolean"){if(Ar(e))return e;if(I(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(er(e))return e;if(L(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return er(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(kn(e))return e;let n=Yt(e,"boolean");if(Ar(n))return null;try{let o=Yt(e,"number");if(I(o))return JSON.parse(e),null}catch{}let r=Yt(e,"date");if(r)return r;try{let o=JSON.parse(e);return A(o)?o.map(u=>Yt(u,t)):o}catch{return null}}if(t==="string")return L(e)?Yn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function xO(e){try{return I(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var eF=De(xO);function tF(e,t){try{if(!I(e))return NaN;if(typeof e=="bigint")return e;if(L(t))t=1e-10;else if(!I(t))return NaN;return Nc(e)<t?0:e}catch{return NaN}}var nF=De(tF);function cc(e){if(ce(e)||Q(e)){let t=e.copy();return t.values=cc(t.values),t}if(A(e))return e.map(t=>cc(t));try{let t=JSON.parse(e);return I(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var Jt=De(cc);function Zd(e,t,n){try{return I(e)?I(t)?I(n)?typeof e=="bigint"?BigInt(Zd(Jt(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var rF=De(Zd);function Ui(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of Ui(i,o-1))yield[s].concat(a)}}return ce(e)||Q(e)?Ui(e.values,t):(d(A(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),d(I(t)&&Jt(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(fn(e),t))}function Xd(e,t){let n=[];for(let r of Ui(e,t))n.push(r.slice());return n}function xd(){let e=Object.values(arguments).map(n=>ce(n)||Q(n)?Gt(n.values):(d(A(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Gt(n)));return Gt(e).filter(n=>e.every(r=>r.findIndex(o=>Yn(o,n))>-1))}var ku=class{constructor(e){d(L(e)||e===ku.DROP_NAN_MODE||e===ku.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=L(e)?ku.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(A(t)){let n=le(t);if(n.length===1)t=new wt(t);else if(n.length===2)t=new Ue(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}d(ce(t)||Q(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===ku.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=xd(...e),this}transform(){d(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(A(t)){let n=le(t);if(n.length===1)return new wt(t).get(this.index).values;if(n.length===2)return new Ue(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return d(ce(t)||Q(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Gi=ku;Ud(Gi,"DROP_NAN_MODE","DROP_NAN_MODE");Ud(Gi,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Ju(e,t,n,r){if(Q(e))return Ju(e.values,t,n,r);if(Q(t))return Ju(e,t.values,n,r);if(d(A(e)&&A(t)&&le(e).length===1&&le(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),d(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Ju(...new Gi().fitAndTransform(e,t),!1,r);try{let o=$t(e,{stdev:r}),u=$t(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!I(s)||!I(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!I(f))return NaN;if(!I(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function fc(e,t,n){if(Q(e))return fc(e.values,t,n);if(Q(t))return fc(e,t.values,n);d(A(e)&&A(t)&&le(e).length===1&&le(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),d(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Ju(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function oF(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var uF=De(oF),sF=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function hc(e,t){if(ce(e)||Q(e))return hc(e.values,t);if(ce(t)||Q(t))return hc(e,t.values);d(A(e)&&A(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Gt(e),r=Gt(t),o=[];return n.forEach(u=>{r.findIndex(s=>Yn(s,u))<0&&o.push(u)}),o}function eg(e,t){try{if(!I(e))return NaN;if(!I(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=eg(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var wc=De(eg);function tg(e){try{if(!I(e))return NaN;if(typeof e=="bigint"){let t=tg(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var ng=De(tg);function iF(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!I(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var rg=De(iF);function Ro(){return rg(...arguments)}function og(e,t){return Ki(e,Ro(t,-1))}function Ec(e,t){return $t(e,{shouldDropNaNs:t}).sum}function mc(e,t){if(I(e)&&I(t))return Nc(e-t);if(ce(e)||Q(e))return mc(e.values,t);if(ce(t)||Q(t))return mc(e,t.values);A(e)&&A(t)&&d(Yn(le(e),le(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return ng(Ec(wc(og(e,t),2)))}catch{return NaN}}function aF(e,t){return Ro(e,wc(t,-1))}function xn(e,t){if(ce(e)){let o=xn(e.values,t);if(le(o).length===1){let u=new wt(o);return u.name=Q(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Ue(o);return u.index=e.index.slice(),ce(t)&&(u.columns=t.columns.slice()),u}}if(ce(t)){let o=xn(e,t.values);if(le(o).length===1){let u=new wt(o);return u.name=Q(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Ue(o);return u.columns=t.columns.slice(),u}}if(Q(e))return xn(e.values,t);if(Q(t))return xn(e,t.values);d(A(e)&&A(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=le(e),r=le(t);if(d(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),d(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Ec(Ro(e,t));if(n.length===1&&r.length===2)return tr(t).map(o=>xn(e,o));if(n.length===2&&r.length===1)return e.map(o=>xn(o,t));if(n.length===2&&r.length===2){let o=tr(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(xn(e[s],o[a]));u.push(i)}return u}}function Dc(e){if(ce(e)||Q(e))return e.dropMissing(...Object.values(arguments).slice(1));d(A(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Dc(n))}catch{L(n)||t.push(n)}}),t}function Pi(e,t){if(ce(e)||Q(e))return Pi(e.values,t);if(ce(t)||Q(t))return Pi(e,t.values);d(A(e)&&A(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),d(Yn(le(e),le(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Pi(e[o],t[o]);n.push(u),r.push(s)}catch{!L(e[o])&&!L(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function Ri(e,t){if(ce(e)||Q(e))return Ri(e.values,t);if(ce(t)||Q(t))return Ri(e,t.values);d(A(e)&&A(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),d(Yn(le(e),le(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Ri(e[o],t[o]);n.push(u),r.push(s)}catch{I(e[o])&&I(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function lF(e){return Dc(e)}function Li(e,t){if(ce(e)||Q(e))return Li(e.values,t);d(A(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),d(et(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(A(n)){if(!Li(n,t))return!1}else if(!t(n))return!1;return!0}function cF(e){try{if(!I(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var fF=De(cF);function dc(e){try{return typeof e=="bigint"?BigInt(dc(Jt(e))):e!==Jt(e)?NaN:e<=1?1:e*dc(e-1)}catch{return NaN}}var hF=De(dc);function gc(e,t){if(ce(e)||Q(e))return gc(e.values,t);if(d(kn(e)||A(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!et(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(kn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(A(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function pc(e,t){if(ce(e)||Q(e))return pc(e.values,t);if(d(kn(e)||A(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!et(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(kn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(A(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function mF(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return I(t)?t:NaN}catch{return NaN}}var dF=De(mF);function gF(e){try{return I(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var pF=De(gF);function Sc(e){I(e)&&(e=[e]);let t=[],n=Vu(e);for(let r=0;r<n;r++)t.push(0);return $u(t,e)}function yF(e){typeof e=="bigint"&&(e=Jt(e)),d(!L(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),d(I(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),d(Jt(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),d(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Sc([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var bF=["true","false","yes","no"],vF=["null","none","nan","na","n/a","","undefined"];function Bi(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=Jt(e.value)===e.value:e.isInteger=Li(e.values,t=>I(t)?Jt(t)===t:!0)),e}function ki(e){if(ce(e)){let u=e.copy(),s=ki(e.values);return u.values=s.values,Bi({type:s.type,values:u})}if(Q(e)){let u=e.copy(),s=ki(e.values);return u.values=s.values,Bi({type:s.type,values:u})}if(!A(e)){let u=ki([e]);return u.value=u.values[0],delete u.values,Bi(u)}d(A(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=fn(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(er(a))return"date"}}catch{}Ee(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(vF.indexOf(i)>-1)return"null";if(bF.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return I(a)?"number":typeof a=="object"?A(a)?"string":"object":"string"}catch{let l=new Date(u);return er(l)?"date":"string"}}),n=Ji(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return Bi({type:o,values:Wi(e,u=>Yt(u,o))})}function Yi(e){if(ce(e)){let n=e.copy();return n.values=Yi(n.values),n}d(A(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=le(e);if(d(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),d(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),d(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){d(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;d(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return Ro(i,1/s)}else if(t[0]>1){let n=(r,o)=>I(r)||I(o)?Ro(r,o):xn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=Yi(o),l=Yi(Ki(i,n(-1,n(n(s,a),u)))),c=Ki(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}d(!1,"This matrix cannot be inverted!")}}var NF=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function ug(e,t,n){try{if(!I(e))return NaN;if(!I(t))return NaN;if(!I(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=ug(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var wF=De(ug);function sg(e,t){try{if(t=L(t)?Math.E:t,!I(e))return NaN;if(!I(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=sg(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var EF=De(sg);function DF(e,t){return $t(e,{shouldDropNaNs:t}).mean}function SF(e,t){return $t(e,{shouldDropNaNs:t,median:!0}).median}function ig(e,t){try{if(!I(e))return NaN;if(!I(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=ig(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var OF=De(ig);function FF(e,t){return $t(e,{shouldDropNaNs:t,mode:!0}).mode}function $d(){let e=jr(),t=jr();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function _F(e){return L(e)?$d():Wi(cn(e),$d)}function TF(e){return Wi(cn(e),()=>1)}function Oc(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of Xd(r,o)){if(!u.slice)continue;let s=Sc(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return ce(e)||Q(e)?Oc(e.values,t):(d(A(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),L(t)&&(t=e.length),d(I(t)&&Jt(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(fn(e),t))}function AF(e,t){let n=[];for(let r of Oc(e,t))n.push(r.slice());return n}function IF(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(A(t))if(Uu(t))console.log(t);else{let n=le(t);n.length===1?new wt(t).print():n.length==2?new Ue(t).print():console.log(t)}else ce(t)||Q(t)?t.print():console.log(t)})}var jF=De((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!I(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function CF(e,t,n,r,o){if(A(e)&&L(r)&&L(o)){r=t,o=n;let u=$t(e);t=u.min,n=u.max}return jF(e,t,n,r,o)}function MF(e){try{return I(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var BF=De(MF);function ag(e){try{return I(e)?typeof e=="bigint"?BigInt(ag(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var PF=De(ag);function RF(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var kF=De(RF);function yc(e,t){if(ce(e)||Q(e))return yc(e.values,t);d(A(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),d(et(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(A(n)){if(yc(n,t))return!0}else if(t(n))return!0;return!1}function lg(e,t){return $t(e,{shouldDropNaNs:t,stdev:!0}).stdev}function YF(e){return lg(e)}function JF(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var $F=De(JF);function Kd(e,t){d(et(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function KF(e,t){d(et(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function UF(){return Gt([...arguments].map(e=>A(e)?e:ce(e)||Q(e)?e.values:[e]))}function LF(e,t){return $t(e,{shouldDropNaNs:t,variance:!0}).variance}function VF(){let e=[],t=Object.values(arguments).map(n=>((ce(n)||Q(n))&&(n=n.values),d(A(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Ge(0,zi(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(L(u)?void 0:u)}),e.push(r)}),e}var Yu={abs:Nc,add:Ki,apply:Wi,arccos:qO,arcsin:QO,arctan:XO,argmax:ac,argmin:lc,assert:d,cast:Yt,ceil:eF,chop:nF,clamp:rF,combinations:Xd,combinationsIterator:Ui,copy:it,correl:fc,cos:uF,count:Ji,covariance:Ju,DataFrame:Ue,dataTypes:sF,decycle:Bo,diff:hc,distance:mc,divide:aF,dot:xn,dropMissing:Dc,dropMissingPairwise:Pi,dropNaN:bc,dropNaNPairwise:Ri,dropUndefined:lF,every:Li,exp:fF,factorial:hF,find:gc,findAll:pc,flatten:fn,float:dF,floor:pF,identity:yF,IndexMatcher:Gi,indexOf:Mo,inferType:ki,int:Jt,intersect:xd,inverse:Yi,isArray:A,isBoolean:Ar,isBrowser:NF,isDataFrame:ce,isDate:er,isEqual:Yn,isFunction:et,isJagged:Uu,isNested:Vi,isNumber:I,isObject:kn,isSeries:Q,isString:Ee,isUndefined:L,lerp:wF,log:EF,MathError:hr,max:zi,mean:DF,median:SF,min:Qd,mod:OF,mode:FF,multiply:rg,ndarray:cn,normal:_F,ones:TF,permutations:AF,permutationsIterator:Oc,pow:wc,print:IF,product:Vu,random:jr,range:Ge,remap:CF,reshape:$u,reverse:Rn,round:BF,scale:Ro,seed:vc,Series:wt,set:Gt,shape:le,shuffle:$i,sign:PF,sin:kF,some:yc,sort:Ir,sqrt:ng,stats:$t,std:lg,stdev:YF,subtract:og,sum:Ec,tan:$F,timeAsync:KF,timeSync:Kd,time:Kd,transpose:tr,union:UF,variance:LF,vectorize:De,zeros:Sc,zip:VF,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Yu.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Yu).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Yu[t]})}catch{e[t]=Yu[t]}})}};typeof window<"u"&&(window.JSMathTools=Yu);function Fc(e,t,n){arguments.length===2&&(I(arguments[1])?n=null:(n=t,t=null)),d(I(e)&&Jt(e)===e,"`keyLength` must be an integer!"),t&&(d(I(t)&&Jt(t)===t,"`keySeed` must be an integer!"),vc(t)),n&&d(Ee(n),"`charset` must be a string!");let r="";n=n||"abcdefg1234567890";for(let o=0;o<e;o++)r+=n[Jt(jr()*n.length)];return r}typeof window<"u"&&(window.makeKey=Fc);var zu=class extends Map{constructor(t){super(),t=t||{},Object.keys(t).forEach(n=>{this.set(n,t[n])})}delete(t){if(typeof t!="string")throw new Error("The `delete` method of a `WordCountMap` instance can only accept keys that are strings!");return super.delete(t)}get(t){if(typeof t!="string")throw new Error("The `get` method of a `WordCountMap` instance can only accept keys that are strings!");return super.get(t)}has(t){if(typeof t!="string")throw new Error("The `has` method of a `WordCountMap` instance can only accept keys that are strings!");return super.has(t)}set(t,n){if(typeof t!="string")throw new Error("The `set` method of a `WordCountMap` instance can only accept keys that are strings!");if(!yr(n))throw new Error("The `set` method of a `WordCountMap` instance can only accept values that are whole numbers (i.e., non-negative integers)!");return super.set(t,n)}stringify(){return JSON.stringify(this.toObject(),...arguments)}toObject(){let t={};return Array.from(this.keys()).forEach(n=>{t[n]=this.get(n)}),t}};var cg=Dr("WholeNumber",yr),Cr=class{constructor(t){t=t||{},ze(this,"cleaned","string"),this.cleaned=t.cleaned||"",ze(this,"hasBeenIndexed","boolean"),this.hasBeenIndexed=t.hasBeenIndexed||!1,ze(this,"id","string"),this.id=t.id||"",ze(this,"maxNgramLength",cg),this.maxNgramLength=typeof t.maxNgramLength>"u"?1/0:t.maxNgramLength,ze(this,"name","string"),this.name=t.name||Fc(32),ze(this,"ngrams",Dt),this.ngrams=new Dt(t.ngrams||[]),ze(this,"raw","string"),this.raw=t.raw||"",ze(this,"totalWordCount",cg),this.totalWordCount=t.totalWordCount||0,ze(this,"wordCounts",zu),this.wordCounts=new zu(t.wordCounts||{}),ze(this,"words",Dt),this.words=new Dt(t.words||[])}getWordCount(t){if(!this.hasBeenIndexed)throw new Error(`The document "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);return this.wordCounts.get(t)||0}async index(t){this.id=await sc(this.raw),this.cleaned=da(this.raw);let n=this.cleaned.split(" ");this.totalWordCount=n.length;let r=Et(n);this.words=new Dt(r),n.forEach((u,s)=>{let i=this.wordCounts.get(u);typeof i>"u"?this.wordCounts.set(u,1):this.wordCounts.set(u,i+1),t&&t(.5*s/n.length)});let o=Math.min(r.length,this.maxNgramLength);for(let u=2;u<=o;u++)for(let s=0;s<r.length-u;s++){let i=r.slice(s,s+u).join(" ");this.ngrams.add(i),t&&t(.5+.5*((u+s/(r.length-u))/o))}return t&&t(1),this.hasBeenIndexed=!0,this}stringify(){return JSON.stringify(this.toObject(),...arguments)}toObject(){return{cleaned:this.cleaned,hasBeenIndexed:this.hasBeenIndexed,id:this.id,maxNgramLength:this.maxNgramLength,name:this.name,ngrams:this.ngrams.toSortedArray(),raw:this.raw,totalWordCount:this.totalWordCount,wordCounts:this.wordCounts.toObject(),words:this.words.toSortedArray()}}};var zF=Dr("WholeNumber",yr),St={TF_BINARY:"TF_BINARY",TF_RAW_COUNT:"TF_RAW_COUNT",TF_TERM_FREQUENCY:"TF_TERM_FREQUENCY",TF_LOG_NORMALIZATION:"TF_LOG_NORMALIZATION",TF_DOUBLE_NORMALIZATION_K:"TF_DOUBLE_NORMALIZATION_K",IDF_UNARY:"IDF_UNARY",IDF_INVERSE_DOCUMENT_FREQUENCY:"IDF_INVERSE_DOCUMENT_FREQUENCY",IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH:"IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH",IDF_INVERSE_DOCUMENT_FREQUENCY_MAX:"IDF_INVERSE_DOCUMENT_FREQUENCY_MAX",IDF_PROBABILISTIC_INVERSE_DOCUMENT_FREQUENCY:"IDF_PROBABILISTIC_INVERSE_DOCUMENT_FREQUENCY"},fg=Dr("Scoring",e=>!!St[e]),WF=Dr("ZeroToOneNumber",e=>typeof e=="number"&&!isNaN(e)&&e>=0&&e<=1),qi=class{static Scoring=St;constructor(t){t=t||{};let n=ni(Cr).from(t.docs?t.docs.map(r=>new Cr(r)):[]);ze(this,"docs",n.constructor),this.docs=n,ze(this,"hasBeenIndexed","boolean"),this.hasBeenIndexed=t.hasBeenIndexed||!1,ze(this,"maxNgramLength",zF),this.maxNgramLength=typeof t.maxNgramLength>"u"?0:t.maxNgramLength,ze(this,"name","string"),this.name=t.name||"Untitled corpus",ze(this,"ngrams",Dt),this.ngrams=new Dt(t.ngrams||[]),ze(this,"words",Dt),this.words=new Dt(t.words||[]),ze(this,"tfScoringMethod",fg),this.tfScoringMethod=t.tfScoringMethod||St.TF_LOG_NORMALIZATION,ze(this,"tfScoringDoubleNormalizationK",WF),this.tfScoringDoubleNormalizationK=typeof t.tfScoringDoubleNormalizationK>"u"?.5:t.tfScoringDoubleNormalizationK,ze(this,"idfScoringMethod",fg),this.idfScoringMethod=t.idfScoringMethod||St.IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH}computeDocumentSimilarity(t,n){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);let r=[],o=[];return this.words.forEach(u=>{r.push(this.computeTFIDFScore(u,t)),o.push(this.computeTFIDFScore(u,n))}),Ba(r,o)}computeIDFScore(t){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);if(this.idfScoringMethod===St.IDF_UNARY)return 1;let n=this.docs.filter(r=>r.getWordCount(t)>0).length;if(this.idfScoringMethod===St.IDF_INVERSE_DOCUMENT_FREQUENCY)return Math.log(this.docs.length/(n+1));if(this.idfScoringMethod===St.IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH)return Math.log(this.docs.length/(n+1))+1;if(this.idfScoringMethod===St.IDF_INVERSE_DOCUMENT_FREQUENCY_MAX){let r=0;return this.words.toArray().forEach(o=>{let u=this.docs.filter(s=>s.getWordCount(o)>0).length;u>r&&(r=u)}),Math.log(r/(n+1))}if(this.idfScoringMethod===St.IDF_PROBABILISTIC_INVERSE_DOCUMENT_FREQUENCY)return Math.log((this.docs.length-n+1)/(n+1))}computeTFIDFScore(t,n){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);return this.computeTFScore(t,n)*this.computeIDFScore(t)}computeTFScore(t,n){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);if(this.tfScoringMethod===St.TF_BINARY)return n.getWordCount(t)>0?1:0;if(this.tfScoringMethod===St.TF_RAW_COUNT)return n.getWordCount(t);if(this.tfScoringMethod===St.TF_TERM_FREQUENCY)return n.getWordCount(t)/n.totalWordCount;if(this.tfScoringMethod===St.TF_LOG_NORMALIZATION)return Math.log(1+n.getWordCount(t));if(this.tfScoringMethod===St.TF_DOUBLE_NORMALIZATION_K){let r=0;return n.words.forEach(o=>{let u=n.getWordCount(o);u>r&&(r=u)}),this.tfScoringDoubleNormalizationK+(1-this.tfScoringDoubleNormalizationK)*n.getWordCount(t)/r}}getWordCounts(t){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);return this.docs.map(n=>({doc:{name:n.name,id:n.id},count:n.getWordCount(t)}))}async index(t){for(let n=0;n<this.docs.length;n++)await this.docs[n].index(t?o=>t((n+o)/this.docs.length):null);return this.hasBeenIndexed=!0,this}stringify(){return JSON.stringify(this.toObject(),...arguments)}toObject(){return{docs:this.docs.map(t=>t.toObject(...arguments)),hasBeenIndexed:this.hasBeenIndexed,idfScoringMethod:this.idfScoringMethod,maxNgramLength:this.maxNgramLength,name:this.name,ngrams:this.ngrams.toSortedArray(),tfScoringDoubleNormalizationK:this.tfScoringDoubleNormalizationK,tfScoringMethod:this.tfScoringMethod,words:this.words.toSortedArray()}}};typeof window<"u"&&(window.JSNLPTools={Corpus:qi,Document:Cr});export{qi as Corpus,Cr as Document};
