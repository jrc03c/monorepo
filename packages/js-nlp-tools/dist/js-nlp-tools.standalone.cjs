(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + x + '" is not supported');
  });
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod6, isNodeMode, target) => (target = mod6 != null ? __create(__getProtoOf(mod6)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod6 || !mod6.__esModule ? __defProp(target, "default", { value: mod6, enumerable: true }) : target,
    mod6
  ));

  // node_modules/@jrc03c/js-text-tools/dist/js-text-tools.import.mjs
  function camelify(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    text = text.trim();
    let out24 = "";
    let shouldCapitalizeNextCharacter = false;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (char.match(/[A-Za-z0-9]/g)) {
        if (out24.length === 0) {
          out24 += char.toLowerCase();
        } else if (shouldCapitalizeNextCharacter) {
          out24 += char.toUpperCase();
        } else {
          out24 += char;
        }
        shouldCapitalizeNextCharacter = false;
      } else if (!char.includes("'") && !char.includes("\u2019") && !char.includes("\u275C")) {
        shouldCapitalizeNextCharacter = true;
      }
    }
    return out24;
  }
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber(x) {
    return typeof x === "number" && !isNaN(x) || typeof x === "bigint";
  }
  var isBrowser = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError = class extends Error {
    constructor(message) {
      if (isBrowser()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert(isTrue, message) {
    if (!isTrue)
      throw new MathError(message);
  }
  var arrayTypes = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined(x) {
    return x === null || typeof x === "undefined";
  }
  var typeStrings = arrayTypes.map((s24) => s24.name);
  function isArray(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined(obj.constructor)) {
        return arrayTypes.indexOf(obj.constructor) > -1 || typeStrings.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function isDataFrame(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e) {
      return false;
    }
  }
  function isFunction(fn) {
    return typeof fn === "function";
  }
  function isObject(x) {
    return typeof x === "object" && !isUndefined(x) && !isArray(x);
  }
  function isSeries(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e) {
      return false;
    }
  }
  function indexOf(x, fn) {
    if (isDataFrame(x)) {
      const index = indexOf(x.values, fn);
      if (index.length > 0 && isNumber(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      if (index.length > 1 && isNumber(index[1]) && index[1] >= 0 && index[1] < x.columns.length) {
        index[1] = x.columns[index[1]];
      }
      return index;
    }
    if (isSeries(x)) {
      const index = indexOf(x.values, fn);
      if (index.length > 0 && isNumber(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      return index;
    }
    assert(isObject(x) || isArray(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper54(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return [key];
          }
          const results = helper54(value, fn2, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return [i];
          }
          const results = helper54(value, fn2, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn2(x2)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const paths = helper54(x, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy(x) {
    function helper54(x2) {
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        if (isArray(x2)) {
          if (!(x2 instanceof Array)) {
            return x2.slice();
          }
          return x2.map((v) => copy(v));
        }
        if (isSeries(x2)) {
          const out32 = x2.copy();
          out32.values = copy(out32.values);
          return out32;
        }
        if (isDataFrame(x2)) {
          const out32 = x2.copy();
          out32.values = copy(x2.values);
          return out32;
        }
        if (x2 instanceof Date) {
          return new Date(x2.getTime());
        }
        x2 = decycle(x2);
        const out24 = {};
        Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
          out24[key] = copy(x2[key]);
        });
        return out24;
      } else {
        return x2;
      }
    }
    return helper54(decycle(x));
  }
  function decycle(x) {
    function helper54(x2, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x2) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x2;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x2 ? "/" : "/" + indexOf(orig, x2).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x2 === "object") {
        if (x2 === null)
          return null;
        checked.push(x2);
        if (isArray(x2)) {
          if (typeof x2.constructor !== "undefined" && x2.constructor.name !== "Array") {
            return x2.slice();
          }
          return x2.map((v, i) => helper54(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
            x2[key] = helper54(x2[key], checked, currentPath + "/" + key.toString());
          });
          return x2;
        }
      } else {
        return x2;
      }
    }
    const orig = x;
    let out24 = helper54(orig);
    if (isDataFrame(x)) {
      const temp = x.copy();
      temp._values = out24.values;
      temp._columns = out24.columns;
      temp._index = out24.index;
      out24 = temp;
    }
    if (isSeries(x)) {
      const temp = x.copy();
      temp.name = out24.name;
      temp._values = out24.values;
      temp._index = out24.index;
      out24 = temp;
    }
    return out24;
  }
  function isDate(x) {
    return x instanceof Date && x.toString() !== "Invalid Date";
  }
  var numberTypes = ["number", "int", "float", "bigint"];
  function isEqual(a, b) {
    function helper54(a2, b2) {
      const aType = typeof a2;
      const bType = typeof b2;
      if (aType !== bType && !numberTypes.includes(aType) && !numberTypes.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a2 === b2;
      if (aType === "symbol")
        return a2 === b2;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a2.toString();
          const bString = b2.toString();
          return aString === bString;
        } catch (e) {
          return false;
        }
      }
      if (aType === "string")
        return a2 === b2;
      if (aType === "function")
        return a2 === b2;
      if (aType === "object") {
        if (a2 === null || b2 === null) {
          return a2 === null && b2 === null;
        } else {
          if (isDate(a2)) {
            if (isDate(b2)) {
              return a2.getTime() === b2.getTime();
            } else {
              return false;
            }
          } else if (isDate(b2)) {
            return false;
          }
          if (a2 instanceof RegExp && b2 instanceof RegExp) {
            return a2.toString() === b2.toString();
          }
          if (isArray(a2) !== isArray(b2)) {
            return false;
          }
          const aKeys = Object.keys(a2).concat(Object.getOwnPropertySymbols(a2));
          const bKeys = Object.keys(b2).concat(Object.getOwnPropertySymbols(b2));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper54(a2[key], b2[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper54(a, b);
    } catch (e) {
      return helper54(decycle(a), decycle(b));
    }
  }
  function makeKey(n) {
    const alpha = "abcdefg1234567890";
    let out24 = "";
    while (out24.length < n)
      out24 += alpha[Math.floor(Math.random() * alpha.length)];
    return out24;
  }
  var NULL_KEY = makeKey(16);
  var UNDEFINED_KEY = makeKey(16);
  var INFINITY_KEY = makeKey(16);
  var MINUS_INFINITY_KEY = makeKey(16);
  var SYMBOL_KEY = makeKey(16);
  var Counter = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x) {
      for (const v of x) {
        if (isArray(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY : isUndefined(value) ? UNDEFINED_KEY : isFunction(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY : value === Infinity ? INFINITY_KEY : value === -Infinity ? MINUS_INFINITY_KEY : typeof value === "bigint" ? value.toString() : isDataFrame(value) ? value.toJSONString() : isSeries(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count24) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count24;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out24 = {};
      this.values.forEach((value) => {
        out24[value] = this.get(value);
      });
      return out24;
    }
  };
  function flatten(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return flatten(arr.values);
    }
    assert(isArray(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper54(arr2) {
      let out24 = [];
      arr2.forEach((child) => {
        if (isArray(child)) {
          out24 = out24.concat(helper54(child));
        } else {
          out24.push(child);
        }
      });
      return out24;
    }
    return helper54(arr);
  }
  function stats(x, options) {
    options = options || {};
    const counts = new Counter();
    const out24 = {};
    const xflat = flatten(x);
    const xnums = [];
    let max24 = -Infinity;
    let min24 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum24 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber(v)) {
        try {
          if (v > max24) {
            max24 = v;
          }
          if (v < min24) {
            min24 = v;
          }
          sum24 += Number(v);
          xnums.push(v);
        } catch (e) {
          max24 = NaN;
          min24 = NaN;
          sum24 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean24 = sum24 / xnums.length;
    out24.counts = counts;
    out24.max = max24;
    out24.mean = mean24;
    out24.min = min24;
    out24.n = xflat.length;
    out24.sum = sum24;
    if (isNaN(out24.mean)) {
      out24.max = NaN;
      out24.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out24.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode24 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode24.push(pair[0]);
        } else {
          break;
        }
      }
      out24.mode = mode24.toSorted();
    }
    if (options.median) {
      if (isNaN(mean24)) {
        out24.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out24.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out24.median = BigInt(out24.median);
            } catch (e) {
            }
          }
        } else {
          out24.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance24 = 0;
      for (const v of xnums) {
        variance24 += Math.pow(Number(v) - mean24, 2);
      }
      variance24 /= xnums.length;
      const stdev24 = Math.sqrt(variance24);
      out24.stdev = stdev24;
      out24.variance = variance24;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out24.sum = BigInt(out24.sum);
      } catch (e) {
      }
      try {
        out24.mean = BigInt(out24.mean);
      } catch (e) {
      }
      if (options.mode) {
        out24.mode = out24.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e) {
            return v;
          }
        });
      }
    }
    return out24;
  }
  function count(arr, matcher) {
    const { counts } = stats(arr);
    if (!isUndefined(matcher)) {
      if (isFunction(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper(x) {
    if (isDataFrame(x) || isSeries(x)) {
      return helper(x.values);
    }
    if (isArray(x)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x) {
        if (helper(v)) {
          return true;
        }
        if (isArray(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged(x) {
    return helper(decycle(x));
  }
  function isNested(x) {
    if (isDataFrame(x) || isSeries(x)) {
      return isNested(x.values);
    }
    assert(isArray(x), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x.length; i++) {
      if (isArray(x[i])) {
        return true;
      }
    }
    return false;
  }
  var error = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray(shape24) {
    assert(!isUndefined(shape24), error);
    if (!isArray(shape24))
      shape24 = [shape24];
    assert(!isNested(shape24), error);
    assert(shape24.length > 0, error);
    let s24 = shape24[0];
    if (typeof s24 === "bigint")
      s24 = Number(s24);
    assert(isNumber(s24), error);
    assert(s24 >= 0, error);
    assert(Math.floor(s24) === s24, error);
    assert(s24 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape24.length === 1) {
      const out24 = [];
      for (let i = 0; i < s24; i++)
        out24.push(void 0);
      return out24;
    } else {
      const out24 = [];
      for (let i = 0; i < s24; i++) {
        out24.push(ndarray(shape24.slice(1)));
      }
      return out24;
    }
  }
  function reverse(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      const out32 = arr.copy();
      out32.values = reverse(out32.values);
      out32.index = reverse(out32.index);
      return out32;
    }
    assert(isArray(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out24.push(arr[i]);
    return out24;
  }
  function range(a, b, step = 1) {
    assert(!isUndefined(a) && !isUndefined(b) && !isUndefined(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert(isNumber(a) && isNumber(b) && isNumber(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out24 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out24.push(BigInt(i));
        } catch (e) {
          out24.push(i);
        }
      } else {
        out24.push(i);
      }
    }
    if (shouldReverse)
      out24 = reverse(out24);
    return out24;
  }
  function makeKey2(n) {
    const alpha = "abcdefg1234567890";
    let out24 = "";
    while (out24.length < n)
      out24 += alpha[Math.floor(Math.random() * alpha.length)];
    return out24;
  }
  var NULL_KEY2 = makeKey2(256);
  var UNDEFINED_KEY2 = makeKey2(256);
  var INFINITY_KEY2 = makeKey2(256);
  var MINUS_INFINITY_KEY2 = makeKey2(256);
  var SYMBOL_KEY2 = makeKey2(256);
  function set(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return set(arr.values);
    }
    assert(isArray(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    const temp = {};
    flatten(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY2 : isUndefined(item) ? UNDEFINED_KEY2 : isFunction(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY2 : item === Infinity ? INFINITY_KEY2 : item === -Infinity ? MINUS_INFINITY_KEY2 : typeof item === "bigint" ? item.toString() : isDataFrame(item) ? item.toJSONString() : isSeries(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out24.push(item);
      temp[key] = true;
    });
    return out24;
  }
  function helper2(x) {
    if (isArray(x)) {
      const childShapes = helper2(x[0]);
      return [x.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape(x) {
    if (isDataFrame(x) || isSeries(x)) {
      return shape(x.values);
    }
    assert(isArray(x), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper2(x);
  }
  function dfAppend(df, x, axis) {
    if (isUndefined(axis)) {
      axis = 0;
    }
    assert(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray(x)) {
      assert(!isJagged(x), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape(x);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out24 = df.copy();
          out24._values.push(x);
          const maxRowLength = Math.max(df.shape[1], xShape[0]);
          out24._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        } else {
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out24 = df.copy();
          range(0, maxColLength).forEach((i) => {
            if (i >= out24._values.length) {
              out24._values.push(ndarray(df.shape[1]));
            }
            out24._values[i].push(x[i]);
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < out24._values[0].length) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x.map((row) => row.length).concat([df.shape[1]]));
          const out24 = df.copy();
          out24._values = out24._values.concat(x).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        } else {
          const maxRowLength = Math.max(...x.map((row) => row.length)) + df.shape[1];
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out24 = df.copy();
          range(0, maxColLength).forEach((i) => {
            if (i >= out24._values.length) {
              out24._values.push(ndarray(df.shape[1]));
            }
            out24._values[i] = out24._values[i].concat(x[i]);
            while (out24._values[i].length < maxRowLength) {
              out24._values[i].push(void 0);
            }
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        }
      } else {
        throw new MathError("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries(x)) {
      const out24 = dfAppend(df, x.values, axis);
      if (axis === 0) {
        out24.index[out24.index.length - 1] = out24.index.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      } else {
        out24.columns[out24.columns.length - 1] = out24.columns.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      }
      return out24;
    } else if (isDataFrame(x)) {
      if (axis === 0) {
        const out24 = df.copy();
        const maxRowLength = set(out24._columns.concat(x._columns)).length;
        out24._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out24._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out24._values.push(temp.concat(rowCopy._values));
        }, 1);
        out24._columns = out24._columns.concat(x._columns.filter((c) => out24._columns.indexOf(c) < 0));
        while (out24._index.length < out24._values.length) {
          const newRowName = "row" + out24._index.length;
          out24._index.push(newRowName + (df._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out24;
      } else {
        const out24 = df.copy();
        out24._index.forEach((rowName, i) => {
          const xIndex = x._index.indexOf(rowName);
          if (xIndex > -1) {
            out24._values[i] = out24._values[i].concat(x._values[xIndex]);
          } else {
            out24._values[i] = out24._values[i].concat(ndarray(x.shape[1]));
          }
        });
        x._index.forEach((rowName, i) => {
          const outIndex = out24._index.indexOf(rowName);
          if (outIndex < 0) {
            out24._index.push(rowName);
            out24._values.push(ndarray(out24._columns.length).concat(x._values[i]));
          }
        });
        out24._columns = out24._columns.concat(x._columns.map((c) => c + (out24._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out24;
      }
    } else {
      throw new MathError("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply(DataFrame24, Series24, df, fn, axis) {
    axis = axis || 0;
    assert(isFunction(fn), "The first parameter to the `apply` method must be a function.");
    assert(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df.columns.forEach((colName, i) => {
        const series = new Series24(df.values.map((row) => row[i]));
        series.name = colName;
        series.index = df.index;
        const value = fn(series, i, df);
        if (value instanceof Series24) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series24 || isArray(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out24 = new DataFrame24(temp);
        out24.index = df.index;
        return out24;
      } else {
        const out24 = new Series24(df.columns.map((colName) => temp[colName]));
        out24.index = df.columns;
        return out24;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df.values.map((row, i) => {
        const series = new Series24(row);
        series.name = df.index[i];
        series.index = df.columns;
        const value = fn(series, i, df);
        if (isUndefined(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series24 || isArray(value);
        }
        if (value instanceof Series24) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out24 = new DataFrame24(temp);
        out24.index = df.index;
        out24.columns = df.columns;
        return out24;
      } else {
        const out24 = new Series24(temp);
        out24.index = df.index;
        return out24;
      }
    }
  }
  function isString(s24) {
    return typeof s24 === "string";
  }
  function dfAssign(DataFrame24, Series24, df, p1, p2) {
    const isDataFrame24 = (x) => x instanceof DataFrame24;
    const isSeries24 = (x) => x instanceof Series24;
    if (!isUndefined(p2)) {
      assert(isString(p1), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert(isArray(p2) && !isJagged(p2) && shape(p2).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out24 = df.append(p2, 1);
      out24.columns[out24.columns.length - 1] = p1;
      return out24;
    } else {
      if (isDataFrame24(p1)) {
        return df.append(p1, 1);
      } else if (isSeries24(p1)) {
        return df.append(p1, 1);
      } else if (isObject(p1)) {
        const maxColumnLength = Math.max(...Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).map((key) => p1[key].length));
        Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).forEach((key) => {
          while (p1[key].length < maxColumnLength) {
            p1[key].push(void 0);
          }
        });
        return df.append(new DataFrame24(p1), 1);
      } else {
        throw new MathError("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy(DataFrame24, df) {
    if (df.isEmpty)
      return new DataFrame24();
    const out24 = new DataFrame24(copy(df.values));
    out24.columns = df.columns.slice();
    out24.index = df.index.slice();
    return out24;
  }
  function dfDrop(DataFrame24, Series24, df, rows, cols) {
    if (isUndefined(rows))
      rows = [];
    if (isUndefined(cols))
      cols = [];
    if (isString(rows) || isNumber(rows))
      rows = [rows];
    if (isString(cols) || isNumber(cols))
      cols = [cols];
    assert(isArray(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert(isArray(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert(shape(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert(shape(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out24 = df.get(outIndex, outColumns);
    if (out24 instanceof Series24) {
      let temp = new DataFrame24();
      temp = temp.assign(out24);
      if (df.index.indexOf(out24.name) > -1)
        temp = temp.transpose();
      out24 = temp;
    }
    return out24;
  }
  function isInteger(x) {
    return isNumber(x) && (x >= 0 ? Math.floor(x) === x : Math.ceil(x) === x);
  }
  function isWholeNumber(x) {
    return isInteger(x) && x >= 0;
  }
  function dfDropMissing(DataFrame24, Series24, df, axis, condition, threshold) {
    axis = axis || 0;
    assert(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert(isWholeNumber(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper54(values) {
      if (threshold > 0) {
        let count24 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined(value))
            count24++;
          if (count24 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out24 = df.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out24 = out24.assign(tempID, out24.index);
      const newValues = out24.values.map(helper54).filter((row) => row.length > 0);
      if (shape(newValues).length < 2)
        return new DataFrame24();
      out24.values = newValues;
      let newIndex = out24.get(null, tempID);
      if (isUndefined(newIndex))
        return new DataFrame24();
      if (isString(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series24)
        newIndex = newIndex.values;
      out24.index = newIndex;
      out24 = out24.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out24.columns.forEach((colName, i) => {
        const values = out24.values.map((row) => row[i]);
        const newValues = helper54(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame24();
      }
      const newOut = new DataFrame24(temp);
      newOut.index = out24.index;
      return newOut;
    }
    return out24;
  }
  function dropNaN(x) {
    if (isDataFrame(x) || isSeries(x)) {
      return x.dropNaN(...Object.values(arguments).slice(1));
    }
    assert(isArray(x), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    x.forEach((v) => {
      try {
        return out24.push(dropNaN(v));
      } catch (e) {
        if (isNumber(v)) {
          return out24.push(v);
        }
      }
    });
    return out24;
  }
  function dfDropNaN(DataFrame24, df, axis, condition, threshold) {
    axis = axis || 0;
    assert(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert(isWholeNumber(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper54(values) {
      const numericalValues = dropNaN(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out24 = df.copy();
    if (axis === 0) {
      const rowsToKeep = out24.index.filter((row) => {
        const values = out24.get(row, null).values;
        return helper54(values);
      });
      if (rowsToKeep.length > 0)
        return out24.get(rowsToKeep, null);
      else
        return new DataFrame24();
    } else if (axis === 1) {
      const colsToKeep = out24.columns.filter((col) => {
        const values = out24.get(null, col).values;
        return helper54(values);
      });
      if (colsToKeep.length > 0)
        return out24.get(null, colsToKeep);
      else
        return new DataFrame24();
    }
    return out24;
  }
  function arrayToObject(x) {
    const out24 = {};
    flatten(x).forEach((value, i) => {
      out24[value] = i;
    });
    return out24;
  }
  function undoArrayToObject(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter(DataFrame24, Series24, df, fn, axis) {
    assert(isFunction(fn), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined(axis))
      axis = 0;
    assert(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out24 = df.copy();
    if (out24.isEmpty)
      return out24;
    const index = arrayToObject(out24.index);
    const columns = arrayToObject(out24.columns);
    if (axis === 0) {
      let count24 = 0;
      const newValues = out24.values.filter((row, i) => {
        const series = new Series24(row);
        series.name = df.index[i];
        series.index = df.columns;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count24++;
        } else {
          delete index[out24.index[i]];
        }
        return shouldKeep;
      });
      if (count24 === 0) {
        return new DataFrame24();
      }
      if (count24 === 1) {
        const temp = new Series24(newValues[0]);
        temp.name = undoArrayToObject(index)[0];
        temp.index = undoArrayToObject(columns);
        return temp;
      }
      out24.values = newValues;
      out24.index = undoArrayToObject(index);
    } else if (axis === 1) {
      out24 = out24.transpose();
      let count24 = 0;
      const newValues = out24.values.filter((row, i) => {
        const series = new Series24(row);
        series.name = df.columns[i];
        series.index = df.index;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count24++;
        } else {
          delete columns[out24.index[i]];
        }
        return shouldKeep;
      });
      if (count24 === 0) {
        return new DataFrame24();
      }
      if (count24 === 1) {
        const temp = new Series24(newValues[0]);
        temp.name = undoArrayToObject(columns)[0];
        temp.index = undoArrayToObject(index);
        return temp;
      }
      out24.values = newValues;
      out24.index = undoArrayToObject(columns);
      out24 = out24.transpose();
    }
    return out24;
  }
  function dfGet(df, rows, cols) {
    if (isString(rows) || isNumber(rows))
      rows = [rows];
    if (isString(cols) || isNumber(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set((rows || []).concat(cols || []).map((v) => typeof v));
    assert(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined(rows)) {
      rows = rows.map((r) => {
        if (isString(r)) {
          assert(df.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber(r)) {
          assert(r >= 0, `Index ${r} is out of bounds!`);
          assert(Math.floor(r) === r, `Row numbers must be integers!`);
          assert(r < df.index.length, `Index ${r} is out of bounds!`);
          return df.index[r];
        }
      });
    }
    if (!isUndefined(cols)) {
      cols = cols.map((c) => {
        if (isString(c)) {
          assert(df.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber(c)) {
          assert(c >= 0, `Column ${c} is out of bounds!`);
          assert(Math.floor(c) === c, `Column numbers must be integers!`);
          assert(c < df.columns.length, `Column ${c} is out of bounds!`);
          return df.columns[c];
        }
      });
    }
    return df.getSubsetByNames(rows, cols);
  }
  function alphaSort(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort(arr, fn) {
    if (isUndefined(fn))
      fn = alphaSort;
    if (isDataFrame(arr) || isSeries(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert(isArray(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert(isFunction(fn), "The second parameter of the `sort` function must be a comparison function!");
    const out24 = arr.slice();
    out24.sort(fn);
    return out24;
  }
  function camelify2(text) {
    const temp = text.toLowerCase();
    let out24 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out24 += char;
      } else {
        out24 += " ";
      }
    }
    const words = out24.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies(DataFrame24, df, columns) {
    if (isUndefined(columns)) {
      columns = df.columns;
    } else if (isString(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert(isString(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df.columns.indexOf(col);
      assert(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df.values.map((row) => row[colIndex]);
      const valuesSet = sort(set(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify2(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out24 = new DataFrame24(temp);
    out24.index = df.index;
    return out24;
  }
  function dfGetSubsetByIndices(df, rowIndices, colIndices) {
    const dataShape = df.shape;
    if (isUndefined(rowIndices))
      rowIndices = range(0, dataShape[0]);
    if (isUndefined(colIndices))
      colIndices = range(0, dataShape[1]);
    if (isNumber(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber(colIndices))
      colIndices = [colIndices];
    assert(isArray(rowIndices) && isArray(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert(shape(rowIndices).length === 1 && shape(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert(isWholeNumber(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert(rowIndex < df.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert(isWholeNumber(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert(colIndex < df.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df.index[i]);
    const cols = colIndices.map((i) => df.columns[i]);
    return df.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames(DataFrame24, Series24, df, rows, cols) {
    if (isUndefined(rows))
      rows = df.index;
    if (isUndefined(cols))
      cols = df.columns;
    if (isString(rows))
      rows = [rows];
    if (isString(cols))
      cols = [cols];
    assert(isArray(rows) && isArray(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert(shape(rows).length === 1 && shape(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert(isString(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert(df.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert(isString(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert(df.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df.values[df.index.indexOf(row)][df.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series24(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series24(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out24 = new DataFrame24(values);
    out24.columns = cols;
    out24.index = rows;
    return out24;
  }
  function dfPrint(DataFrame24, Series24, df) {
    function truncate(s24, maxLength2) {
      if (isString(s24)) {
        if (s24.length > maxLength2) {
          return s24.substring(0, maxLength2 - 3) + "...";
        } else {
          return s24;
        }
      } else {
        return s24;
      }
    }
    if (df.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df.index.length ? null : range(0, halfMaxRows).concat(range(df.index.length - halfMaxRows, df.index.length));
    const tempColumns = maxColumns > df.columns.length ? null : range(0, halfMaxColumns).concat(range(df.columns.length - halfMaxColumns, df.columns.length));
    let temp = df.get(tempRows, tempColumns);
    if (temp instanceof Series24) {
      if (df.shape[0] === 1) {
        temp = new DataFrame24([temp.values]);
        temp.index = df.index;
        temp.columns = new Series24(df.columns).get(tempColumns).values;
      } else if (df.shape[1] === 1) {
        temp = new DataFrame24([temp.values]).transpose();
        temp.index = new Series24(df.index).get(tempRows).values;
        temp.columns = df.columns;
      }
    }
    if (maxRows <= df.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series24) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df.shape, "\n");
    return df;
  }
  function leftPad(x, maxLength) {
    assert(isNumber(x), "The `leftPad` function only works on numbers!");
    let out24 = x.toString();
    while (out24.length < maxLength)
      out24 = "0" + out24;
    return out24;
  }
  function dfResetIndex(df, shouldSkipCopying) {
    const out24 = shouldSkipCopying ? df : df.copy();
    out24.index = range(0, df.shape[0]).map((i) => {
      return "row" + leftPad(i, (out24.index.length - 1).toString().length);
    });
    return out24;
  }
  function product(arr, shouldDropNaNs) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return product(arr.values, shouldDropNaNs);
    }
    assert(isArray(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten(arr);
      let resultShouldBeABigInt = false;
      let out24 = 1;
      for (let v of temp) {
        if (!isNumber(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  }
  function isNaturalNumber(x) {
    return isInteger(x) && x > 0;
  }
  function reshape(x, newShape) {
    if (isDataFrame(x) || isSeries(x)) {
      return reshape(x.values, newShape);
    }
    assert(isArray(x), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber(newShape))
      newShape = [newShape];
    assert(isArray(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert(shape(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert(isNaturalNumber(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten(x);
    }
    const temp = flatten(x);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert(product(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out24 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out24.push(reshape(row, newShape.slice(1)));
    }
    return out24;
  }
  var MAX = Math.pow(2, 64);
  var s = [];
  seed(Math.floor(Math.random() * MAX));
  function splitmix64(state, n) {
    state = uint(state);
    function helper54() {
      state += uint("0x9e3779b97f4a7c15");
      let z = copy(state);
      z = (z ^ z >> BigInt(30)) * uint("0xbf58476d1ce4e5b9");
      z = (z ^ z >> BigInt(27)) * uint("0x94d049bb133111eb");
      return z ^ z >> BigInt(31);
    }
    const out24 = [];
    for (let i = 0; i < n; i++)
      out24.push(helper54());
    return out24;
  }
  function uint(x) {
    return BigInt.asUintN(64, BigInt(x));
  }
  function rotl(x, k) {
    x = uint(x);
    k = BigInt(k);
    return uint(uint(x << k) | uint(x >> uint(BigInt(64) - k)));
  }
  function seed(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined(val)) {
      assert(isNumber(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix64(Math.floor(val), 4);
      s[0] = temp[0];
      s[1] = temp[1];
      s[2] = temp[2];
      s[3] = temp[3];
    } else {
      return copy(s);
    }
  }
  function next() {
    const result = uint(rotl(s[0] + s[3], 23) + s[0]);
    const t = uint(s[1] << BigInt(17));
    s[2] = uint(s[2] ^ s[0]);
    s[3] = uint(s[3] ^ s[1]);
    s[1] = uint(s[1] ^ s[2]);
    s[0] = uint(s[0] ^ s[3]);
    s[2] = uint(s[2] ^ t);
    s[3] = rotl(s[3], 45);
    return Math.floor(Number(result)) / MAX;
  }
  function random(shape24) {
    if (isUndefined(shape24))
      return next();
    if (!isArray(shape24))
      shape24 = [shape24];
    return reshape(ndarray(product(shape24)).map(next), shape24);
  }
  function shuffle(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert(isArray(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random() * temp.length);
      out24.push(temp.splice(index, 1)[0]);
    }
    return out24;
  }
  function dfShuffle(df, axis) {
    if (isUndefined(axis))
      axis = 0;
    assert(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df.get(axis === 0 ? shuffle(df.index) : null, axis === 1 ? shuffle(df.columns) : null);
  }
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  function dfSort(df, a, b) {
    if (isFunction(a)) {
      return dfSortByFunction(df, a, b);
    } else {
      return dfSortByColumns(df, a, b);
    }
  }
  function dfSortByFunction(df, fn, axis) {
    axis = isUndefined(axis) ? 0 : axis;
    assert(isFunction(fn), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert(isNumber(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort(df.index, (a, b) => {
        return fn(df.get(a, null), df.get(b, null));
      });
      return df.get(index, null);
    } else {
      const columns = sort(df.columns, (a, b) => {
        return fn(df.get(null, a), df.get(null, b));
      });
      return df.get(null, columns);
    }
  }
  function dfSortByColumns(df, cols, directions) {
    let out24 = df.copy();
    const indexID = random().toString();
    out24 = out24.assign(indexID, out24.index);
    if (isUndefined(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber(cols) || isString(cols)) {
      cols = [cols];
      if (isBoolean(directions) || isString(directions))
        directions = [directions];
    }
    assert(isArray(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert(shape(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined(directions))
      directions = range(0, cols.length).map(() => true);
    assert(isArray(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert(shape(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert(isString(col) || isNumber(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString(col)) {
        const index = out24.columns.indexOf(col);
        assert(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber(col)) {
        assert(isWholeNumber(col), "Column indices must be whole numbers!");
        assert(col < out24.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert(isString(dir) || isBoolean(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString(dir)) {
        const value = dir.trim().toLowerCase();
        assert(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean(dir)) {
        return dir;
      }
    });
    out24.values = sort(out24.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out24.columns.indexOf(indexID);
    out24.index = out24.values.map((row) => row[indexNumber]);
    out24 = out24.dropColumns(indexID);
    return out24;
  }
  function dfToDetailedObject(df, axis) {
    if (isUndefined(axis)) {
      axis = 0;
    } else {
      assert(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out24 = {};
    if (axis === 0) {
      df.index.forEach((rowName, i) => {
        const temp = {};
        df.columns.forEach((colName, j) => {
          temp[colName] = df.values[i][j];
        });
        out24[rowName] = temp;
      });
    } else {
      df.columns.forEach((colName, j) => {
        const temp = {};
        df.index.forEach((rowName, i) => {
          temp[rowName] = df.values[i][j];
        });
        out24[colName] = temp;
      });
    }
    return out24;
  }
  function dfToJSONString(df, axis) {
    return JSON.stringify(df.toObject(axis));
  }
  async function dfToJSON(df, filename, axis) {
    const out24 = dfToJSONString(df, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out24)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e) {
      browserError = e;
    }
    try {
      const fs = await import("node:fs");
      const path = await import("node:path");
      fs.writeFileSync(path.resolve(filename), out24, "utf8");
      wroteToDiskInNode = true;
    } catch (e) {
      nodeError = e;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError(nodeError);
      } else {
        throw new MathError("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df;
  }
  function dfToObject(df) {
    const out24 = {};
    df.columns.forEach((col) => {
      out24[col] = df.get(col).values;
    });
    return out24;
  }
  function transpose(arr) {
    if (isDataFrame(arr) || isSeries(arr)) {
      return arr.transpose();
    }
    assert(isArray(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape(arr);
    assert(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse(arr);
    } else if (theShape.length === 2) {
      const out24 = ndarray(reverse(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out24[col][row] = arr[row][col];
        }
      }
      return out24;
    }
  }
  function seriesAppend(Series24, series, x) {
    if (isSeries(x)) {
      return new Series24(series.values.concat(x.values));
    }
    if (isArray(x)) {
      const xShape = shape(x);
      assert(xShape.length === 1 && !isNested(xShape), "Only vectors can be appended to Series!");
      const out24 = series.copy();
      x.forEach((v, i) => {
        out24._values.push(v);
        out24._index.push("item" + (series.values.length + i));
      });
      return out24;
    }
    return seriesAppend(series, [x]);
  }
  function seriesApply(series, fn) {
    assert(isFunction(fn), "The parameter to the `apply` method must be a function.");
    const out24 = series.copy();
    out24._values = out24._values.map((v, i) => fn(v, i));
    return out24;
  }
  function seriesDropMissing(series) {
    const out24 = series.copy();
    const outIndex = [];
    out24._values = out24.values.filter((v, i) => {
      if (isUndefined(v)) {
        return false;
      } else {
        outIndex.push(out24.index[i]);
        return true;
      }
    });
    out24._index = outIndex;
    return out24;
  }
  function seriesDropNaN(Series24, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out24 = new Series24(values);
    out24.name = series.name;
    out24.index = index;
    return out24;
  }
  function seriesFilter(Series24, series, fn) {
    let out24 = series.copy();
    const index = copy(out24.index);
    const indicesToRemove = [];
    const newValues = out24.values.filter((value, i) => {
      const shouldKeep = fn(value, i, out24.values);
      if (!shouldKeep)
        indicesToRemove.push(out24.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out24 = new Series24();
      out24.name = series.name;
      return out24;
    }
    out24.values = newValues;
    out24.index = index;
    return out24;
  }
  function seriesGet(series, indices) {
    if (isString(indices) || isNumber(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set((indices || []).map((v) => typeof v));
    assert(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert(i >= 0, `Index ${i} is out of bounds!`);
          assert(Math.floor(i) === i, `Indices must be integers!`);
          assert(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices(series, indices) {
    const dataShape = series.shape;
    if (isUndefined(indices))
      indices = range(0, dataShape[0]);
    assert(isArray(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert(shape(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert(isWholeNumber(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames(Series24, series, indices) {
    if (isUndefined(indices))
      indices = series.index;
    assert(isArray(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert(shape(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert(isString(name), "The `indices` array must contain only strings.");
      assert(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out24 = new Series24(values);
    out24.index = indices;
    out24.name = series.name;
    return out24;
  }
  function seriesPrint(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range(0, maxRows / 2).concat(range(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out24 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out24[temp.index[i]] = obj;
    });
    console.table(out24);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle(series) {
    const out24 = series.copy();
    return out24.get(shuffle(out24.index));
  }
  function seriesSort(Series24, series, fn) {
    fn = fn || ((a, b) => a < b ? -1 : 1);
    assert(isUndefined(fn) || isFunction(fn), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose([series.values, series.index]);
    const temp = sort(pairs, (aPair, bPair) => {
      return fn(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out24 = new Series24();
    out24._values = newValues;
    out24._index = newIndex;
    out24.name = series.name;
    return out24;
  }
  function seriesSortByIndex(Series24, series) {
    let temp = transpose([series.values, series.index]);
    temp = transpose(sort(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out24 = new Series24(temp[0]);
    out24.index = temp[1];
    out24.name = series.name;
    return out24;
  }
  function seriesToObject(series) {
    const out24 = {};
    out24[series.name] = {};
    series.index.forEach((index, i) => {
      out24[series.name][index] = series.values[i];
    });
    return out24;
  }
  var SERIES_SYMBOL = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass(DataFrame24) {
    class Series24 {
      static [Symbol.hasInstance](x) {
        try {
          return !!x._symbol && x._symbol === SERIES_SYMBOL;
        } catch (e) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x) {
            assert(isArray(x), "The new values must be a 1-dimensional array!");
            const dataShape = shape(x);
            assert(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad(i, (x.length - 1).toString().length);
              }));
            }
            this._values = x;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x) {
            assert(isArray(x), "The new index must be a 1-dimensional array of strings!");
            assert(x.length === this.shape[0], "The new index must be the same length as the old index!");
            assert(shape(x).length === 1, "The new index must be a 1-dimensional array of strings!");
            x.forEach((value) => {
              assert(isString(value), "All of the row names must be strings!");
            });
            this._index = x;
          }
        });
        if (data) {
          if (data instanceof Series24) {
            this.name = data.name;
            this.values = copy(data.values);
            this.index = copy(data.index);
          } else if (isArray(data)) {
            const dataShape = shape(data);
            assert(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert(shape(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined(v)).length === 0;
      }
      clear() {
        const out24 = this.copy();
        out24.values.forEach((v, i) => {
          out24.values[i] = void 0;
        });
        return out24;
      }
      get(indices) {
        return seriesGet(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames(Series24, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out24 = new Series24(reverse(this.values));
        out24.index = reverse(this.index);
        out24.name = this.name;
        return out24;
      }
      resetIndex() {
        const out24 = this.copy();
        out24.index = range(0, this.shape[0]).map((i) => {
          return "item" + leftPad(i, (out24.index.length - 1).toString().length);
        });
        return out24;
      }
      copy() {
        const out24 = new Series24();
        out24._values = copy(this.values);
        out24._index = copy(this.index);
        out24.name = this.name;
        return out24;
      }
      append(x) {
        return seriesAppend(Series24, this, x);
      }
      apply(fn) {
        return seriesApply(this, fn);
      }
      concat(x) {
        return this.append(x);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN(Series24, this);
      }
      toObject() {
        return seriesToObject(this);
      }
      print() {
        return seriesPrint(this);
      }
      shuffle() {
        return seriesShuffle(this);
      }
      sort(direction) {
        return seriesSort(Series24, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex(Series24, this);
      }
      filter(fn) {
        return seriesFilter(Series24, this, fn);
      }
      toDataFrame() {
        const out24 = new DataFrame24(transpose([this.values]));
        out24.columns = [this.name];
        out24.index = this.index;
        return out24;
      }
      transpose() {
        const out24 = this.copy();
        out24.values = reverse(out24.values);
        out24.index = reverse(out24.index);
        return out24;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series24;
  }
  var DATAFRAME_SYMBOL = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey3(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out24 = "";
    for (let i = 0; i < n; i++)
      out24 += alpha[Math.floor(random() * alpha.length)];
    return out24;
  }
  var DataFrame = class {
    static [Symbol.hasInstance](x) {
      try {
        return !!x._symbol && x._symbol === DATAFRAME_SYMBOL;
      } catch (e) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x) {
          assert(isArray(x), "The new values must be a 2-dimensional array!");
          const dataShape = shape(x);
          assert(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x) {
          assert(isArray(x), "The new columns list must be a 1-dimensional array of strings!");
          assert(this.isEmpty || x.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert(shape(x).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey3(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count(x);
            const out24 = {};
            temp.values.forEach((v) => {
              out24[v] = temp.get(v);
            });
            return out24;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey3(8);
            }
            return v;
          });
          this._columns = x;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x) {
          assert(isArray(x), "The new index must be a 1-dimensional array of strings!");
          assert(this.isEmpty || x.length === this.shape[0], "The new index must be the same length as the old index!");
          assert(shape(x).length === 1, "The new index must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey3(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count(x);
            const out24 = {};
            temp.values.forEach((v) => {
              out24[v] = temp.get(v);
            });
            return out24;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey3(8);
            }
            return v;
          });
          this._index = x;
        }
      });
      assert(isUndefined(data) || isObject(data) || isArray(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame) {
          this.values = copy(data.values);
          this.columns = copy(data.columns);
          this.index = copy(data.index);
        } else if (isArray(data)) {
          const dataShape = shape(data);
          assert(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert(!isJagged(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose(temp);
          const dataShape = shape(this.values);
          this._index = range(0, dataShape[0]).map((i) => {
            return "row" + leftPad(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out24 = new DataFrame(ndarray(this.shape));
      out24.columns = this.columns.slice();
      out24.index = this.index.slice();
      return out24;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e) {
          return this.get(rows, null);
        }
      }
      return dfGet(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames(DataFrame, Series, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies(DataFrame, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies(DataFrame, this, columns);
    }
    transpose() {
      const out24 = new DataFrame(transpose(this.values));
      out24.columns = this.index.slice();
      out24.index = this.columns.slice();
      return out24;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy(DataFrame, this);
    }
    assign(p1, p2) {
      return dfAssign(DataFrame, Series, this, p1, p2);
    }
    apply(fn, axis) {
      return dfApply(DataFrame, Series, this, fn, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing(DataFrame, Series, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN(DataFrame, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop(DataFrame, Series, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject(this, axis);
    }
    toObject() {
      return dfToObject(this);
    }
    toJSONString(axis) {
      return dfToJSONString(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON(this, filename, axis);
    }
    print() {
      return dfPrint(DataFrame, Series, this);
    }
    sort(cols, directions) {
      return dfSort(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn, axis) {
      return dfFilter(DataFrame, Series, this, fn, axis);
    }
    shuffle(axis) {
      return dfShuffle(this, axis);
    }
    append(x, axis) {
      return dfAppend(this, x, axis);
    }
    concat(x, axis) {
      return this.append(x, axis);
    }
    join(x, axis) {
      return this.append(x, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series = createSeriesClass(DataFrame);
  function max(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs }).max;
  }
  function vectorize(fn) {
    assert(isFunction(fn), "You must pass a function into the `vectorize` function!");
    return function helper54() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray(arg)) {
          return true;
        } else if (isSeries(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s24, i) => {
        assert(isEqual(isArray(s24) ? shape(s24) : s24.shape, isArray(childArrays[i + 1]) ? shape(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out24 = range(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper54(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual(shape(dataframes[0]), shape(out24))) {
              const temp = new DataFrame(out24);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame(out24);
            }
          } catch (e) {
            return out24;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out24.length) {
              const temp = new Series(out24);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series(out24);
            }
          } catch (e) {
            return out24;
          }
        }
        return out24;
      } else {
        return fn(...arguments);
      }
    };
  }
  function abs(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        return x < 0 ? -x : x;
      } else {
        return Math.abs(x);
      }
    } catch (e) {
      return NaN;
    }
  }
  var vabs = vectorize(abs);
  function add() {
    try {
      let out24 = 0;
      let resultShouldBeABigInt = false;
      const x = Object.values(arguments);
      for (let v of x) {
        if (!isNumber(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  }
  var vadd = vectorize(add);
  function apply(x, fn) {
    try {
      return fn(x);
    } catch (e) {
      return NaN;
    }
  }
  var vapply = vectorize(apply);
  function arccos(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.acos(x);
    } catch (e) {
      return NaN;
    }
  }
  var varccos = vectorize(arccos);
  function arcsin(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.asin(x);
    } catch (e) {
      return NaN;
    }
  }
  var varcsin = vectorize(arcsin);
  function arctan(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.atan(x);
    } catch (e) {
      return NaN;
    }
  }
  var varctan = vectorize(arctan);
  function argmax(x, shouldDropNaNs) {
    if (isDataFrame(x)) {
      const index = argmax(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries(x)) {
      const index = argmax(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert(isArray(x), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out24 = indexOf(x, max(x, shouldDropNaNs));
      if (out24) {
        if (out24.length === 0) {
          return void 0;
        } else if (out24.length === 1) {
          return out24[0];
        } else {
          return out24;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function min(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs }).min;
  }
  function argmin(x, shouldDropNaNs) {
    if (isDataFrame(x)) {
      const index = argmin(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries(x)) {
      const index = argmin(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert(isArray(x), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out24 = indexOf(x, min(x, shouldDropNaNs));
      if (out24) {
        if (out24.length === 0) {
          return void 0;
        } else if (out24.length === 1) {
          return out24[0];
        } else {
          return out24;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function cast(value, type) {
    if (isDataFrame(value) || isSeries(value)) {
      return value.apply((item) => cast(item, type));
    }
    if (isArray(value)) {
      return value.map((v) => cast(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined(value)) {
        return NaN;
      }
      const booleanValue = cast(value, "boolean");
      if (isBoolean(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e) {
        const dateValue = cast(value, "date");
        if (isDate(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out24 = parseFloat(value);
      if (isNaN(out24))
        return NaN;
      return out24;
    }
    if (type === "int") {
      const out24 = cast(value, "number");
      return out24 >= 0 ? Math.floor(out24) : Math.ceil(out24);
    }
    if (type === "float") {
      return cast(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean(value)) {
        return value;
      }
      if (isNumber(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate(value)) {
        return value;
      }
      if (isUndefined(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out24 = new Date(value);
        if (!isDate(out24))
          return null;
        return out24;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject(value)) {
        return value;
      }
      const booleanValue = cast(value, "boolean");
      if (isBoolean(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast(value, "number");
        if (isNumber(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e) {
      }
      const dateValue = cast(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out24 = JSON.parse(value);
        if (isArray(out24)) {
          return out24.map((v) => cast(v, type));
        } else {
          return out24;
        }
      } catch (e) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined(value)) {
        if (isEqual(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.ceil(x);
    } catch (e) {
      return NaN;
    }
  }
  var vceil = vectorize(ceil);
  function chop(x, threshold) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      if (isUndefined(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber(threshold)) {
        return NaN;
      }
      return vabs(x) < threshold ? 0 : x;
    } catch (e) {
      return NaN;
    }
  }
  var vchop = vectorize(chop);
  function int(x) {
    if (isDataFrame(x) || isSeries(x)) {
      const out24 = x.copy();
      out24.values = int(out24.values);
      return out24;
    }
    if (isArray(x)) {
      return x.map((v) => int(v));
    } else {
      try {
        const out24 = JSON.parse(x);
        if (isNumber(out24)) {
          return typeof out24 === "bigint" ? Number(out24) : out24 >= 0 ? Math.floor(out24) : Math.ceil(out24);
        }
        return NaN;
      } catch (e) {
        return NaN;
      }
    }
  }
  var vint = vectorize(int);
  function clamp(x, a, b) {
    try {
      if (!isNumber(x))
        return NaN;
      if (!isNumber(a))
        return NaN;
      if (!isNumber(b))
        return NaN;
      if (typeof x === "bigint") {
        return BigInt(clamp(vint(x), a, b));
      }
      if (x < a)
        return a;
      if (x > b)
        return b;
      return x;
    } catch (e) {
      return NaN;
    }
  }
  var vclamp = vectorize(clamp);
  function combinationsIterator(x, r) {
    function* helper54(x2, r2) {
      if (r2 > x2.length) {
        yield x2;
      } else if (r2 <= 0) {
        yield [];
      } else if (x2.length < 2) {
        yield x2;
      } else {
        for (let i = 0; i < x2.length; i++) {
          const item = x2[i];
          const after = x2.slice(i + 1);
          if (after.length < r2 - 1) {
            continue;
          }
          if (r2 - 1 >= 0) {
            for (const child of combinationsIterator(after, r2 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame(x) || isSeries(x)) {
      return combinationsIterator(x.values, r);
    }
    assert(isArray(x), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert(isNumber(r) && vint(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper54(flatten(x), r);
  }
  function combinations(x, r) {
    const out24 = [];
    for (const combo of combinationsIterator(x, r)) {
      out24.push(combo.slice());
    }
    return out24;
  }
  function intersect() {
    const arrays = Object.values(arguments).map((x) => {
      if (isDataFrame(x) || isSeries(x)) {
        return set(x.values);
      }
      assert(isArray(x), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set(x);
    });
    const all = set(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual(other, v)) > -1);
    });
  }
  var _IndexMatcher = class {
    constructor(mode24) {
      assert(isUndefined(mode24) || mode24 === _IndexMatcher.DROP_NAN_MODE || mode24 === _IndexMatcher.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined(mode24) ? mode24 : _IndexMatcher.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x) => {
        if (isArray(x)) {
          const xshape = shape(x);
          if (xshape.length === 1) {
            x = new Series(x);
          } else if (xshape.length === 2) {
            x = new DataFrame(x);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert(isDataFrame(x) || isSeries(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher.DROP_MISSING_MODE) {
          indices.push(x.dropMissing().index);
        } else {
          indices.push(x.dropNaN().index);
        }
      });
      this.index = intersect(...indices);
      return this;
    }
    transform() {
      assert(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out24 = Object.values(arguments).map((x) => {
        if (isArray(x)) {
          const xshape = shape(x);
          if (xshape.length === 1) {
            return new Series(x).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame(x).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert(isDataFrame(x) || isSeries(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x.get(this.index, null);
      });
      return out24.length === 1 ? out24[0] : out24;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher = _IndexMatcher;
  __publicField(IndexMatcher, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField(IndexMatcher, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries(x)) {
      return covariance(x.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries(y)) {
      return covariance(x, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert(isArray(x) && isArray(y) && shape(x).length === 1 && shape(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert(x.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance(...new IndexMatcher().fitAndTransform(x, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats(x, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx = Number(xstats.mean);
      const my = Number(ystats.mean);
      if (!isNumber(mx) || !isNumber(my)) {
        return NaN;
      }
      const n = Math.max(x.length, y.length);
      let out24 = 0;
      for (let i = 0; i < n; i++) {
        let vx = x[i];
        let vy = y[i];
        if (!isNumber(vx))
          return NaN;
        if (!isNumber(vy))
          return NaN;
        if (typeof vx === "bigint") {
          vx = Number(vx);
        }
        if (typeof vy === "bigint") {
          vy = Number(vy);
        }
        out24 += (vx - mx) * (vy - my);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out24 / x.length, xstats, ystats];
      } else {
        return out24 / x.length;
      }
    } catch (e) {
      return NaN;
    }
  }
  function correl(x, y, shouldDropNaNs) {
    if (isSeries(x)) {
      return correl(x.values, y, shouldDropNaNs);
    }
    if (isSeries(y)) {
      return correl(x, y.values, shouldDropNaNs);
    }
    assert(isArray(x) && isArray(y) && shape(x).length === 1 && shape(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert(x.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e) {
      return NaN;
    }
  }
  function cos(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.cos(x);
    } catch (e) {
      return NaN;
    }
  }
  var vcos = vectorize(cos);
  var dataTypes = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff(a, b) {
    if (isDataFrame(a) || isSeries(a)) {
      return diff(a.values, b);
    }
    if (isDataFrame(b) || isSeries(b)) {
      return diff(a, b.values);
    }
    assert(isArray(a) && isArray(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set(a);
    const bTemp = set(b);
    const out24 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual(other, item)) < 0) {
        out24.push(item);
      }
    });
    return out24;
  }
  function pow(x, p) {
    try {
      if (!isNumber(x))
        return NaN;
      if (!isNumber(p))
        return NaN;
      if (typeof x === "bigint" || typeof p === "bigint") {
        const out24 = pow(Number(x), Number(p));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return Math.pow(x, p);
    } catch (e) {
      return NaN;
    }
  }
  var vpow = vectorize(pow);
  function sqrt(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        const out24 = sqrt(Number(x));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return Math.sqrt(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsqrt = vectorize(sqrt);
  function multiply() {
    try {
      const x = Object.values(arguments);
      if (x.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out24 = 1;
      for (let v of x) {
        if (!isNumber(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  }
  var vmultiply = vectorize(multiply);
  function scale() {
    return vmultiply(...arguments);
  }
  function subtract(a, b) {
    return vadd(a, scale(b, -1));
  }
  function sum(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs }).sum;
  }
  function distance(a, b) {
    if (isNumber(a) && isNumber(b)) {
      return vabs(a - b);
    }
    if (isDataFrame(a) || isSeries(a)) {
      return distance(a.values, b);
    }
    if (isDataFrame(b) || isSeries(b)) {
      return distance(a, b.values);
    }
    if (isArray(a) && isArray(b)) {
      assert(isEqual(shape(a), shape(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt(sum(vpow(subtract(a, b), 2)));
    } catch (e) {
      return NaN;
    }
  }
  function divide(a, b) {
    return scale(a, vpow(b, -1));
  }
  function dot(a, b) {
    if (isDataFrame(a)) {
      const temp = dot(a.values, b);
      if (shape(temp).length === 1) {
        const out24 = new Series(temp);
        out24.name = isSeries(b) ? b.name : out24.name;
        out24.index = a.index.slice();
        return out24;
      } else {
        const out24 = new DataFrame(temp);
        out24.index = a.index.slice();
        if (isDataFrame(b)) {
          out24.columns = b.columns.slice();
        }
        return out24;
      }
    }
    if (isDataFrame(b)) {
      const temp = dot(a, b.values);
      if (shape(temp).length === 1) {
        const out24 = new Series(temp);
        out24.name = isSeries(a) ? a.name : out24.name;
        out24.index = b.columns.slice();
        return out24;
      } else {
        const out24 = new DataFrame(temp);
        out24.columns = b.columns.slice();
        return out24;
      }
    }
    if (isSeries(a)) {
      return dot(a.values, b);
    }
    if (isSeries(b)) {
      return dot(a, b.values);
    }
    assert(isArray(a) && isArray(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape(a);
    const bShape = shape(b);
    assert(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum(scale(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose(b).map((col) => dot(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose(b);
      const out24 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot(a[i], bTranspose[j]));
        }
        out24.push(row);
      }
      return out24;
    }
  }
  function dropMissing(x) {
    if (isDataFrame(x) || isSeries(x)) {
      return x.dropMissing(...Object.values(arguments).slice(1));
    }
    assert(isArray(x), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    x.forEach((v) => {
      try {
        return out24.push(dropMissing(v));
      } catch (e) {
        if (!isUndefined(v)) {
          out24.push(v);
        }
      }
    });
    return out24;
  }
  function dropMissingPairwise(a, b) {
    if (isDataFrame(a) || isSeries(a)) {
      return dropMissingPairwise(a.values, b);
    }
    if (isDataFrame(b) || isSeries(b)) {
      return dropMissingPairwise(a, b.values);
    }
    assert(isArray(a) && isArray(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert(isEqual(shape(a), shape(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (!isUndefined(a[i]) && !isUndefined(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise(a, b) {
    if (isDataFrame(a) || isSeries(a)) {
      return dropNaNPairwise(a.values, b);
    }
    if (isDataFrame(b) || isSeries(b)) {
      return dropNaNPairwise(a, b.values);
    }
    assert(isArray(a) && isArray(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert(isEqual(shape(a), shape(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (isNumber(a[i]) && isNumber(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined(x) {
    return dropMissing(x);
  }
  function every(x, fn) {
    if (isDataFrame(x) || isSeries(x)) {
      return every(x.values, fn);
    }
    assert(isArray(x), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert(isFunction(fn), "The second argument passed into the `every` function must be a function!");
    for (const v of x) {
      if (isArray(v)) {
        if (!every(v, fn)) {
          return false;
        }
      } else {
        if (!fn(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        if (x === 0n) {
          return 1n;
        } else {
          x = Number(x);
        }
      }
      return Math.exp(x);
    } catch (e) {
      return NaN;
    }
  }
  var vexp = vectorize(exp);
  function factorial(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial(vint(n)));
      }
      if (n !== vint(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial(n - 1);
    } catch (e) {
      return NaN;
    }
  }
  var vfactorial = vectorize(factorial);
  function find(x, fn) {
    if (isDataFrame(x)) {
      return find(x.values, fn);
    }
    if (isSeries(x)) {
      return find(x.values, fn);
    }
    assert(isObject(x) || isArray(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper54(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return value;
          }
          const result = helper54(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return value;
          }
          const result = helper54(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn2(x2)) {
          return x2;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    return helper54(x, safeFn);
  }
  function findAll(x, fn) {
    if (isDataFrame(x)) {
      return findAll(x.values, fn);
    }
    if (isSeries(x)) {
      return findAll(x.values, fn);
    }
    assert(isObject(x) || isArray(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper54(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        const out24 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out24.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper54(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out24.push(r));
          }
        }
        return out24;
      } else if (isArray(x2)) {
        checked.push(x2);
        const out24 = [];
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out24.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper54(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out24.push(r));
          }
        }
        return out24;
      } else {
        if (fn2(x2)) {
          return [x2];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const results = helper54(x, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float(x) {
    try {
      if (x === "Infinity") {
        return Infinity;
      }
      if (x === "-Infinity") {
        return -Infinity;
      }
      const out24 = JSON.parse(x);
      if (isNumber(out24))
        return out24;
      return NaN;
    } catch (e) {
      return NaN;
    }
  }
  var vfloat = vectorize(float);
  function floor(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        return x;
      }
      return Math.floor(x);
    } catch (e) {
      return NaN;
    }
  }
  var vfloor = vectorize(floor);
  function zeros(shape24) {
    if (isNumber(shape24))
      shape24 = [shape24];
    const out24 = [];
    const n = product(shape24);
    for (let i = 0; i < n; i++)
      out24.push(0);
    return reshape(out24, shape24);
  }
  function identity(size) {
    if (typeof size === "bigint") {
      size = vint(size);
    }
    assert(!isUndefined(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert(isNumber(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert(vint(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out24 = zeros([size, size]);
    for (let i = 0; i < size; i++)
      out24[i][i] = 1;
    return out24;
  }
  var booleanValues = ["true", "false", "yes", "no"];
  var nullValues = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint(results.value) === results.value;
      } else {
        results.isInteger = every(results.values, (v) => isNumber(v) ? vint(v) === v : true);
      }
    }
    return results;
  }
  function inferType(arr) {
    if (isDataFrame(arr)) {
      const out24 = arr.copy();
      const results = inferType(arr.values);
      out24.values = results.values;
      return checkIfInteger({ type: results.type, values: out24 });
    }
    if (isSeries(arr)) {
      const out24 = arr.copy();
      const results = inferType(arr.values);
      out24.values = results.values;
      return checkIfInteger({ type: results.type, values: out24 });
    }
    if (!isArray(arr)) {
      const out24 = inferType([arr]);
      out24.value = out24.values[0];
      delete out24.values;
      return checkIfInteger(out24);
    }
    assert(isArray(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate(temp)) {
            return "date";
          }
        }
      } catch (e) {
      }
      if (!isString(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e) {
        const vDate = new Date(v);
        if (isDate(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger({
      type: primaryType,
      values: vapply(arr, (v) => cast(v, primaryType))
    });
  }
  function inverse(x) {
    if (isDataFrame(x)) {
      const out24 = x.copy();
      out24.values = inverse(out24.values);
      return out24;
    }
    assert(isArray(x), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape(x);
    assert(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x;
    } else if (xShape[0] === 1) {
      assert(x[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x[0][0];
      let b = x[0][1];
      let c = x[1][0];
      let d = x[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det = a * d - b * c;
      assert(det !== 0, "This matrix cannot be inverted!");
      const out24 = [
        [d, -b],
        [-c, a]
      ];
      return scale(out24, 1 / det);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber(a) || isNumber(b) ? scale(a, b) : dot(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x.slice(0, divider).map((row) => row.slice(0, divider));
          const B = x.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C = x.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse(A);
          const CompInv = inverse(vadd(D, times(-1, times(times(C, AInv), B))));
          const topLeft = vadd(AInv, times(times(times(times(AInv, B), CompInv), C), AInv));
          const topRight = times(-1, times(times(AInv, B), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C), AInv));
          const bottomRight = CompInv;
          const out24 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out24;
        } catch (e) {
        }
      }
      assert(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser2 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp(a, b, f) {
    try {
      if (!isNumber(a))
        return NaN;
      if (!isNumber(b))
        return NaN;
      if (!isNumber(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out24 = lerp(Number(a), Number(b), f);
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return f * (b - a) + a;
    } catch (e) {
      return NaN;
    }
  }
  var vlerp = vectorize(lerp);
  function log(x, base) {
    try {
      base = isUndefined(base) ? Math.E : base;
      if (!isNumber(x))
        return NaN;
      if (!isNumber(base))
        return NaN;
      if (typeof x === "bigint" || typeof base === "bigint") {
        const out24 = log(Number(x), Number(base));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return Math.log(x) / Math.log(base);
    } catch (e) {
      return NaN;
    }
  }
  var vlog = vectorize(log);
  function mean(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs }).mean;
  }
  function median(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod(a, b) {
    try {
      if (!isNumber(a))
        return NaN;
      if (!isNumber(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out24 = mod(Number(a), Number(b));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return a % b;
    } catch (e) {
      return NaN;
    }
  }
  var vmod = vectorize(mod);
  function mode(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper3() {
    const u1 = random();
    const u2 = random();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
  function normal(shape24) {
    if (isUndefined(shape24))
      return helper3();
    return vapply(ndarray(shape24), helper3);
  }
  function ones(shape24) {
    return vapply(ndarray(shape24), () => 1);
  }
  function permutationsIterator(x, r) {
    function* helper54(x2, r2) {
      r2 = r2 || x2.length;
      if (x2.length === 1) {
        yield [x2];
        return;
      }
      for (const c of combinations(x2, r2)) {
        if (!c.slice)
          continue;
        const state = zeros(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame(x) || isSeries(x)) {
      return permutationsIterator(x.values, r);
    }
    assert(isArray(x), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined(r)) {
      r = x.length;
    }
    assert(isNumber(r) && vint(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper54(flatten(x), r);
  }
  function permutations(x, r) {
    const out24 = [];
    for (const perm of permutationsIterator(x, r)) {
      out24.push(perm.slice());
    }
    return out24;
  }
  function print() {
    Object.keys(arguments).forEach((key) => {
      const x = arguments[key];
      if (isArray(x)) {
        if (!isJagged(x)) {
          const xShape = shape(x);
          if (xShape.length === 1) {
            new Series(x).print();
          } else if (xShape.length == 2) {
            new DataFrame(x).print();
          } else {
            console.log(x);
          }
        } else {
          console.log(x);
        }
      } else if (isDataFrame(x) || isSeries(x)) {
        x.print();
      } else {
        console.log(x);
      }
    });
  }
  var helper4 = vectorize((x, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x, a, b, c, d]) {
        if (!isNumber(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x = Number(x);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out24 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  });
  function remap(x, a, b, c, d) {
    if (isArray(x) && isUndefined(c) && isUndefined(d)) {
      c = a;
      d = b;
      const results = stats(x);
      a = results.min;
      b = results.max;
    }
    return helper4(x, a, b, c, d);
  }
  function round(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.round(x);
    } catch (e) {
      return NaN;
    }
  }
  var vround = vectorize(round);
  function sign(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint")
        return BigInt(sign(Number(x)));
      if (x < 0)
        return -1;
      if (x > 0)
        return 1;
      return 0;
    } catch (e) {
      return NaN;
    }
  }
  var vsign = vectorize(sign);
  function sin(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.sin(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsin = vectorize(sin);
  function some(x, fn) {
    if (isDataFrame(x) || isSeries(x)) {
      return some(x.values, fn);
    }
    assert(isArray(x), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert(isFunction(fn), "The second argument passed into the `some` function must be a function!");
    for (const v of x) {
      if (isArray(v)) {
        if (some(v, fn)) {
          return true;
        }
      } else {
        if (fn(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev(x) {
    return std(x);
  }
  function tan(x) {
    try {
      if (!isNumber(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.tan(x);
    } catch (e) {
      return NaN;
    }
  }
  var vtan = vectorize(tan);
  function timeSync(fn, args) {
    assert(isFunction(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn(...args);
    } else {
      fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync(fn, args) {
    assert(isFunction(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn(...args);
    } else {
      await fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union() {
    return set([...arguments].map((v) => {
      if (isArray(v))
        return v;
      if (isDataFrame(v))
        return v.values;
      if (isSeries(v))
        return v.values;
      return [v];
    }));
  }
  function variance(arr, shouldDropNaNs) {
    return stats(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip() {
    const out24 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame(arr) || isSeries(arr)) {
        arr = arr.values;
      }
      assert(isArray(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range(0, max(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined(value) ? void 0 : value);
      });
      out24.push(row);
    });
    return out24;
  }
  var out = {
    abs: vabs,
    add: vadd,
    apply: vapply,
    arccos: varccos,
    arcsin: varcsin,
    arctan: varctan,
    argmax,
    argmin,
    assert,
    cast,
    ceil: vceil,
    chop: vchop,
    clamp: vclamp,
    combinations,
    combinationsIterator,
    copy,
    correl,
    cos: vcos,
    count,
    covariance,
    DataFrame,
    dataTypes,
    decycle,
    diff,
    distance,
    divide,
    dot,
    dropMissing,
    dropMissingPairwise,
    dropNaN,
    dropNaNPairwise,
    dropUndefined,
    every,
    exp: vexp,
    factorial: vfactorial,
    find,
    findAll,
    flatten,
    float: vfloat,
    floor: vfloor,
    identity,
    IndexMatcher,
    indexOf,
    inferType,
    int: vint,
    intersect,
    inverse,
    isArray,
    isBoolean,
    isBrowser: isBrowser2,
    isDataFrame,
    isDate,
    isEqual,
    isFunction,
    isJagged,
    isNested,
    isNumber,
    isObject,
    isSeries,
    isString,
    isUndefined,
    lerp: vlerp,
    log: vlog,
    MathError,
    max,
    mean,
    median,
    min,
    mod: vmod,
    mode,
    multiply: vmultiply,
    ndarray,
    normal,
    ones,
    permutations,
    permutationsIterator,
    pow: vpow,
    print,
    product,
    random,
    range,
    remap,
    reshape,
    reverse,
    round: vround,
    scale,
    seed,
    Series,
    set,
    shape,
    shuffle,
    sign: vsign,
    sin: vsin,
    some,
    sort,
    sqrt: vsqrt,
    stats,
    std,
    stdev,
    subtract,
    sum,
    tan: vtan,
    timeAsync,
    timeSync,
    time: timeSync,
    transpose,
    union,
    variance,
    vectorize,
    zeros,
    zip,
    dump() {
      const context22 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context22) {
        throw new out.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out).forEach((key) => {
        try {
          Object.defineProperty(context22, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out[key]
          });
        } catch (e) {
          context22[key] = out[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out;
  }
  var context = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : void 0;
  function convertObjectToTypedArray(x) {
    const typedArrayConstructorSymbol = Symbol.for("@TypedArrayConstructor");
    const typedArrayConstructorString = "Symbol(@TypedArrayConstructor)";
    const typedArrayConstructorKey = typedArrayConstructorSymbol in x ? typedArrayConstructorSymbol : typedArrayConstructorString in x ? typedArrayConstructorString : void 0;
    if (typedArrayConstructorKey) {
      if (!("values" in x)) {
        throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");
      }
      if (x[typedArrayConstructorKey] === "ArrayBuffer") {
        return new Uint8Array(x.values).buffer;
      }
      return new context[x[typedArrayConstructorKey]](x.values);
    }
    if (isArray(x) && x.constructor.name === "Array") {
      return x;
    }
    throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!");
  }
  function convertTypedArrayToObject(x) {
    if (x instanceof ArrayBuffer || x instanceof BigInt64Array || x instanceof BigUint64Array || x instanceof Float32Array || x instanceof Float64Array || x instanceof Int16Array || x instanceof Int32Array || x instanceof Int8Array || x instanceof Uint16Array || x instanceof Uint32Array || x instanceof Uint8Array || x instanceof Uint8ClampedArray) {
      return {
        [Symbol.for("@TypedArrayConstructor")]: x.constructor.name,
        values: x instanceof ArrayBuffer ? Array.from(new Uint8Array(x)) : Array.from(x)
      };
    }
    if (isArray(x)) {
      return x.map((v) => {
        try {
          return convertTypedArrayToObject(v);
        } catch (e) {
          return v;
        }
      });
    }
    if (typeof x === "object" & x !== null) {
      if (isDate(x)) {
        return new Date(x.getTime());
      }
      const out24 = {};
      Object.keys(x).forEach((key) => {
        try {
          out24[key] = convertTypedArrayToObject(x[key]);
        } catch (e) {
          out24[key] = x[key];
        }
      });
      return out24;
    }
    throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.");
  }
  function isANumberString(x) {
    x = x.trim();
    return !!(x.match(/^-?\d+(\.\d+)?$/g) || x.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g) || x.match(/^-?\.\d+$/g) || x === "NaN");
  }
  var punctuation = "!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";
  function replaceAll(text, a, b) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    if (typeof a !== "string") {
      throw new Error("`a` must be a string!");
    }
    if (typeof b !== "string") {
      throw new Error("`b` must be a string!");
    }
    return text.split(a).join(b);
  }
  var doubleSpace = "  ";
  var singleSpace = " ";
  function strip(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    let out24 = "";
    for (let i = 0; i < text.length; i++) {
      const char = text[i].toLowerCase();
      if (punctuation.includes(char)) {
        out24 += singleSpace;
      } else {
        out24 += char;
      }
    }
    while (out24.includes(doubleSpace)) {
      out24 = replaceAll(out24, doubleSpace, singleSpace);
    }
    return out24.trim();
  }
  function indent(text, chars) {
    chars = chars || "";
    return text.split("\n").map((line) => {
      if (line.trim().length > 0) {
        return chars + line;
      } else {
        return line;
      }
    }).join("\n");
  }
  function kebabify(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("-");
  }
  var specials = {
    "@Infinity": Infinity,
    "@NegativeInfinity": -Infinity,
    "@NaN": NaN,
    "@undefined": void 0
  };
  function fixUndefineds(x) {
    if (typeof x === "object") {
      if (x === null) {
        return x;
      }
      if (isArray(x)) {
        for (let i = 0; i < x.length; i++) {
          x[i] = fixUndefineds(x[i]);
        }
      } else {
        Object.keys(x).concat(Object.getOwnPropertySymbols(x)).forEach((key) => {
          x[key] = fixUndefineds(x[key]);
        });
      }
      return x;
    } else {
      if (typeof x === "undefined") {
        return void 0;
      }
      if (x === "Symbol(@undefined)") {
        return void 0;
      }
      return x;
    }
  }
  function parseAsBigInt(x) {
    if (typeof x === "bigint") {
      return x;
    } else if (typeof x === "string") {
      if (x.match(/^\s*?-?\d+n\s*?$/g)) {
        try {
          return BigInt(x.split("n")[0]);
        } catch (e) {
          return NaN;
        }
      } else {
        return NaN;
      }
    } else {
      return NaN;
    }
  }
  function parseAsNumber(x) {
    if (typeof x !== "string") {
      if (typeof x === "number") {
        return x;
      } else {
        return;
      }
    }
    if (isANumberString(x)) {
      return parseFloat(x);
    }
  }
  function parseAsString(x) {
    if (typeof x !== "string") {
      return;
    }
    const replacement = "@jrc03c/js-text-tools/newline-replacer";
    x = x.replaceAll("\n", replacement);
    if (x.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)) {
      let out24 = x.replace("Symbol(@String):", "");
      if (out24.match(/^".*?"$/g)) {
        try {
          return JSON.parse(out24);
        } catch (e) {
          out24 = out24.substring(1, out24.length - 1);
        }
      }
      out24 = out24.replaceAll(replacement, "\n");
      return out24;
    }
  }
  function parseAsSymbol(x) {
    if (typeof x !== "string") {
      if (typeof x === "symbol") {
        return { out: x, isASymbol: true };
      } else {
        return;
      }
    }
    if (x.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)) {
      const xTemp = x.replace(/^.*?Symbol\(/g, "").replace(/\).*?$/g, "");
      if (xTemp in specials) {
        return { out: specials[xTemp], isASymbol: true };
      }
      return { out: Symbol.for(xTemp), isASymbol: true };
    }
  }
  function parseAsRegex(x) {
    if (typeof x !== "string") {
      if (x instanceof RegExp) {
        return x;
      } else {
        return;
      }
    }
    const xTrimmed = x.trim();
    if (xTrimmed.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g)) {
      try {
        const pattern = xTrimmed.replace(/^\//g, "").replace(/\/(d|g|i|m|s|u|v|y)*?$/g, "");
        const flags = xTrimmed.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);
        return new RegExp(pattern, flags);
      } catch (e) {
      }
    }
  }
  function parseWithJSONParse(x) {
    if (typeof x !== "string") {
      if (typeof x === "object") {
        return x;
      } else {
        return "Symbol(@undefined)";
      }
    }
    try {
      let out24 = JSON.parse(x, (key, value) => {
        try {
          const out32 = parse(value);
          return typeof out32 === "undefined" ? "Symbol(@undefined)" : out32;
        } catch (e) {
          return typeof value === "undefined" ? "Symbol(@undefined)" : value;
        }
      });
      if (isArray(out24)) {
        out24 = fixUndefineds(out24);
      }
      return out24;
    } catch (e) {
      return x;
    }
  }
  function parseAsDate(x) {
    if (typeof x !== "string") {
      if (x instanceof Date && x.toString() !== "Invalid Date") {
        return x;
      } else {
        return;
      }
    }
    try {
      const d = new Date(Date.parse(x));
      if (d.toString() !== "Invalid Date") {
        return d;
      }
    } catch (e) {
    }
  }
  function parseObjectKeysAndValues(x) {
    if (typeof x === "object") {
      if (x !== null) {
        return fixUndefineds(x);
      }
      return;
    }
    Object.keys(x).concat(Object.getOwnPropertySymbols(x)).forEach((key) => {
      try {
        let origKey = key;
        try {
          key = parse(key);
        } catch (e) {
        }
        x[key] = parse(x[origKey]);
        if (key !== origKey) {
          delete x[origKey];
        }
      } catch (e) {
      }
    });
    return fixUndefineds(x);
  }
  function parse(x) {
    function helper54(x2) {
      if (typeof x2 === "string") {
        let out24 = parseAsString(x2);
        if (typeof out24 === "string") {
          return out24;
        }
        const results = parseAsSymbol(x2);
        out24 = results ? results.out : void 0;
        if (results && results.isASymbol) {
          return out24;
        }
        out24 = parseAsRegex(x2);
        if (out24 instanceof RegExp) {
          return out24;
        }
        out24 = parseAsBigInt(x2);
        if (typeof out24 === "bigint") {
          return out24;
        }
        out24 = parseAsNumber(x2);
        if (typeof out24 === "number") {
          return out24;
        }
        out24 = parseAsDate(x2);
        if (out24 instanceof Date) {
          return out24;
        }
        out24 = parseWithJSONParse(x2);
        if (typeof out24 !== "undefined") {
          if (out24 === "Symbol(@undefined)") {
            return void 0;
          } else {
            return out24;
          }
        }
        return x2;
      }
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        let out24;
        try {
          out24 = convertObjectToTypedArray(x2);
          if (isArray(out24))
            return out24;
        } catch (e) {
        }
        out24 = parseObjectKeysAndValues(x2);
        if (out24) {
          try {
            return convertObjectToTypedArray(out24);
          } catch (e) {
            return out24;
          }
        }
        return x2;
      }
      return x2;
    }
    return helper54(x);
  }
  function pascalify(text) {
    const out24 = camelify(text);
    return out24[0].toUpperCase() + out24.slice(1);
  }
  function snakeify(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("_");
  }
  function prefix(s24, n) {
    if (!s24 || n <= 0)
      return "";
    return range(0, n).map(() => s24).join("");
  }
  function stringify(x, indent22) {
    assert(isString(indent22) || isUndefined(indent22), "The second parameter to the `stringify` function must be undefined or a string!");
    const newline = indent22 ? "\n" : "";
    function helper54(x2, indent32, depth) {
      depth = depth || 0;
      if (typeof x2 === "bigint") {
        return JSON.stringify(x2.toString() + "n");
      }
      if (typeof x2 === "number") {
        if (x2 === Infinity) {
          return '"Symbol(@Infinity)"';
        }
        if (x2 === -Infinity) {
          return '"Symbol(@NegativeInfinity)"';
        }
        if (isNaN(x2)) {
          return '"Symbol(@NaN)"';
        }
        return x2.toString();
      }
      if (typeof x2 === "string") {
        return JSON.stringify("Symbol(@String):" + x2);
      }
      if (typeof x2 === "boolean") {
        return x2.toString();
      }
      if (typeof x2 === "undefined") {
        return '"Symbol(@undefined)"';
      }
      if (typeof x2 === "symbol") {
        return JSON.stringify(x2.toString());
      }
      if (typeof x2 === "function") {
        return JSON.stringify(x2.toString());
      }
      if (x2 instanceof RegExp) {
        return x2.toString();
      }
      if (typeof x2 === "object") {
        if (x2 === null) {
          return "null";
        }
        if (isDate(x2)) {
          return JSON.stringify(x2.toJSON());
        }
        if (isArray(x2)) {
          if (x2.length === 0) {
            return prefix(indent32, depth - 1) + "[]";
          }
          if (!(x2 instanceof Array)) {
            return helper54(convertTypedArrayToObject(x2), null, indent32);
          }
          return prefix(indent32, depth - 1) + "[" + newline + x2.map((v) => {
            let child = (() => {
              try {
                return helper54(convertTypedArrayToObject(v), indent32, depth + 1);
              } catch (e) {
                return helper54(v, indent32, depth + 1);
              }
            })();
            if (isString(child))
              child = child.trim();
            return prefix(indent32, depth + 1) + child;
          }).join("," + newline) + newline + prefix(indent32, depth) + "]";
        }
        if (Object.keys(x2).length + Object.getOwnPropertySymbols(x2).length === 0) {
          return prefix(indent32, depth - 1) + "{}";
        }
        return prefix(indent32, depth - 1) + "{" + newline + Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).map((key) => {
          let child = (() => {
            try {
              return helper54(convertTypedArrayToObject(x2[key]), indent32, depth + 1);
            } catch (e) {
              return helper54(x2[key], indent32, depth + 1);
            }
          })();
          if (isString(child))
            child = child.trim();
          const stringifiedKey = typeof key === "symbol" ? helper54(key) : JSON.stringify(key);
          return prefix(indent32, depth + 1) + stringifiedKey + ":" + (indent32 ? " " : "") + child;
        }).join("," + newline) + newline + prefix(indent32, depth) + "}";
      }
      return "undefined";
    }
    return helper54(decycle(x), indent22);
  }
  function unindent(text) {
    const lines = text.split("\n");
    const indentations = lines.filter((line) => line.trim().length > 0).map((line) => line.split("").findIndex((char) => !char.match(/\s/g)));
    const minIndentation = Math.min(...indentations);
    return lines.map((line) => line.substring(minIndentation)).join("\n");
  }
  function wrap(raw, maxLineLength) {
    if (typeof raw !== "string") {
      throw new Error("The first argument to the `wrap` function must be a string!");
    }
    if (typeof maxLineLength === "undefined" || maxLineLength === null) {
      if (typeof process !== "undefined" && typeof process.stdout !== "undefined" && typeof process.stdout.columns === "number") {
        maxLineLength = process.stdout.columns > 80 ? 80 : process.stdout.columns;
      } else {
        maxLineLength = 80;
      }
    }
    if (isNaN(maxLineLength) || typeof maxLineLength !== "number") {
      throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");
    }
    const out24 = [];
    raw.split("\n").forEach((line) => {
      if (line.trim().length === 0) {
        return out24.push("");
      }
      const indentation = line.split(/[^\s]/g)[0];
      const words = line.replace(indentation, "").split(" ");
      let temp = indentation;
      words.forEach((word) => {
        const newLine = temp + (temp.trim().length > 0 ? " " : "") + word;
        if (newLine.length > maxLineLength) {
          out24.push(temp);
          temp = indentation + word;
        } else {
          temp = newLine;
        }
      });
      if (temp.length > 0) {
        out24.push(temp);
      }
    });
    return out24.join("\n");
  }
  if (typeof window !== "undefined") {
    window.JSTextTools = {
      camelify,
      convertObjectToTypedArray,
      convertTypedArrayToObject,
      indent,
      isANumberString,
      kebabify,
      parse,
      pascalify,
      punctuation,
      replaceAll,
      snakeify,
      stringify,
      strip,
      unindent,
      wrap
    };
  }

  // src/utils/clean.mjs
  function clean(s6) {
    let matches = s6.match(/[A-Za-z]'([A-Za-z]|\s)/g);
    while (matches) {
      matches.forEach((match) => {
        s6 = s6.replaceAll(match, match.replaceAll("'", ""));
      });
      matches = s6.match(/[A-Za-z]'([A-Za-z]|\s)/g);
    }
    let out6 = strip(s6.toLowerCase()).replaceAll(/\s/g, " ");
    while (out6.includes("  ")) {
      out6 = out6.replaceAll("  ", " ");
    }
    return out6.trim();
  }

  // node_modules/@jrc03c/js-math-tools/dist/js-math-tools.import.mjs
  var __defProp3 = Object.defineProperty;
  var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField2 = (obj, key, value) => {
    __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber2(x) {
    return typeof x === "number" && !isNaN(x) || typeof x === "bigint";
  }
  var isBrowser3 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError2 = class extends Error {
    constructor(message) {
      if (isBrowser3()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert2(isTrue, message) {
    if (!isTrue)
      throw new MathError2(message);
  }
  var arrayTypes2 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined2(x) {
    return x === null || typeof x === "undefined";
  }
  var typeStrings2 = arrayTypes2.map((s24) => s24.name);
  function isArray2(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined2(obj.constructor)) {
        return arrayTypes2.indexOf(obj.constructor) > -1 || typeStrings2.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function isDataFrame2(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e) {
      return false;
    }
  }
  function isFunction2(fn) {
    return typeof fn === "function";
  }
  function isObject2(x) {
    return typeof x === "object" && !isUndefined2(x) && !isArray2(x);
  }
  function isSeries2(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e) {
      return false;
    }
  }
  function indexOf2(x, fn) {
    if (isDataFrame2(x)) {
      const index = indexOf2(x.values, fn);
      if (index.length > 0 && isNumber2(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      if (index.length > 1 && isNumber2(index[1]) && index[1] >= 0 && index[1] < x.columns.length) {
        index[1] = x.columns[index[1]];
      }
      return index;
    }
    if (isSeries2(x)) {
      const index = indexOf2(x.values, fn);
      if (index.length > 0 && isNumber2(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      return index;
    }
    assert2(isObject2(x) || isArray2(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction2(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper54(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject2(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return [key];
          }
          const results = helper54(value, fn2, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray2(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return [i];
          }
          const results = helper54(value, fn2, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn2(x2)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const paths = helper54(x, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy2(x) {
    function helper54(x2) {
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        if (isArray2(x2)) {
          if (!(x2 instanceof Array)) {
            return x2.slice();
          }
          return x2.map((v) => copy2(v));
        }
        if (isSeries2(x2)) {
          const out32 = x2.copy();
          out32.values = copy2(out32.values);
          return out32;
        }
        if (isDataFrame2(x2)) {
          const out32 = x2.copy();
          out32.values = copy2(x2.values);
          return out32;
        }
        if (x2 instanceof Date) {
          return new Date(x2.getTime());
        }
        x2 = decycle2(x2);
        const out24 = {};
        Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
          out24[key] = copy2(x2[key]);
        });
        return out24;
      } else {
        return x2;
      }
    }
    return helper54(decycle2(x));
  }
  function decycle2(x) {
    function helper54(x2, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x2) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x2;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x2 ? "/" : "/" + indexOf2(orig, x2).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x2 === "object") {
        if (x2 === null)
          return null;
        checked.push(x2);
        if (isArray2(x2)) {
          if (typeof x2.constructor !== "undefined" && x2.constructor.name !== "Array") {
            return x2.slice();
          }
          return x2.map((v, i) => helper54(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
            x2[key] = helper54(x2[key], checked, currentPath + "/" + key.toString());
          });
          return x2;
        }
      } else {
        return x2;
      }
    }
    const orig = x;
    let out24 = helper54(orig);
    if (isDataFrame2(x)) {
      const temp = x.copy();
      temp._values = out24.values;
      temp._columns = out24.columns;
      temp._index = out24.index;
      out24 = temp;
    }
    if (isSeries2(x)) {
      const temp = x.copy();
      temp.name = out24.name;
      temp._values = out24.values;
      temp._index = out24.index;
      out24 = temp;
    }
    return out24;
  }
  function isDate2(x) {
    return x instanceof Date && x.toString() !== "Invalid Date";
  }
  var numberTypes2 = ["number", "int", "float", "bigint"];
  function isEqual2(a, b) {
    function helper54(a2, b2) {
      const aType = typeof a2;
      const bType = typeof b2;
      if (aType !== bType && !numberTypes2.includes(aType) && !numberTypes2.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a2 === b2;
      if (aType === "symbol")
        return a2 === b2;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a2.toString();
          const bString = b2.toString();
          return aString === bString;
        } catch (e) {
          return false;
        }
      }
      if (aType === "string")
        return a2 === b2;
      if (aType === "function")
        return a2 === b2;
      if (aType === "object") {
        if (a2 === null || b2 === null) {
          return a2 === null && b2 === null;
        } else {
          if (isDate2(a2)) {
            if (isDate2(b2)) {
              return a2.getTime() === b2.getTime();
            } else {
              return false;
            }
          } else if (isDate2(b2)) {
            return false;
          }
          if (a2 instanceof RegExp && b2 instanceof RegExp) {
            return a2.toString() === b2.toString();
          }
          if (isArray2(a2) !== isArray2(b2)) {
            return false;
          }
          const aKeys = Object.keys(a2).concat(Object.getOwnPropertySymbols(a2));
          const bKeys = Object.keys(b2).concat(Object.getOwnPropertySymbols(b2));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper54(a2[key], b2[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper54(a, b);
    } catch (e) {
      return helper54(decycle2(a), decycle2(b));
    }
  }
  function makeKey4(n) {
    const alpha = "abcdefg1234567890";
    let out24 = "";
    while (out24.length < n)
      out24 += alpha[Math.floor(Math.random() * alpha.length)];
    return out24;
  }
  var NULL_KEY3 = makeKey4(16);
  var UNDEFINED_KEY3 = makeKey4(16);
  var INFINITY_KEY3 = makeKey4(16);
  var MINUS_INFINITY_KEY3 = makeKey4(16);
  var SYMBOL_KEY3 = makeKey4(16);
  var Counter2 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x) {
      for (const v of x) {
        if (isArray2(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY3 : isUndefined2(value) ? UNDEFINED_KEY3 : isFunction2(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY3 : value === Infinity ? INFINITY_KEY3 : value === -Infinity ? MINUS_INFINITY_KEY3 : typeof value === "bigint" ? value.toString() : isDataFrame2(value) ? value.toJSONString() : isSeries2(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined2(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count24) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count24;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out24 = {};
      this.values.forEach((value) => {
        out24[value] = this.get(value);
      });
      return out24;
    }
  };
  function flatten2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return flatten2(arr.values);
    }
    assert2(isArray2(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper54(arr2) {
      let out24 = [];
      arr2.forEach((child) => {
        if (isArray2(child)) {
          out24 = out24.concat(helper54(child));
        } else {
          out24.push(child);
        }
      });
      return out24;
    }
    return helper54(arr);
  }
  function stats2(x, options) {
    options = options || {};
    const counts = new Counter2();
    const out24 = {};
    const xflat = flatten2(x);
    const xnums = [];
    let max24 = -Infinity;
    let min24 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum24 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber2(v)) {
        try {
          if (v > max24) {
            max24 = v;
          }
          if (v < min24) {
            min24 = v;
          }
          sum24 += Number(v);
          xnums.push(v);
        } catch (e) {
          max24 = NaN;
          min24 = NaN;
          sum24 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean24 = sum24 / xnums.length;
    out24.counts = counts;
    out24.max = max24;
    out24.mean = mean24;
    out24.min = min24;
    out24.n = xflat.length;
    out24.sum = sum24;
    if (isNaN(out24.mean)) {
      out24.max = NaN;
      out24.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out24.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode24 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode24.push(pair[0]);
        } else {
          break;
        }
      }
      out24.mode = mode24.toSorted();
    }
    if (options.median) {
      if (isNaN(mean24)) {
        out24.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out24.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out24.median = BigInt(out24.median);
            } catch (e) {
            }
          }
        } else {
          out24.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance24 = 0;
      for (const v of xnums) {
        variance24 += Math.pow(Number(v) - mean24, 2);
      }
      variance24 /= xnums.length;
      const stdev24 = Math.sqrt(variance24);
      out24.stdev = stdev24;
      out24.variance = variance24;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out24.sum = BigInt(out24.sum);
      } catch (e) {
      }
      try {
        out24.mean = BigInt(out24.mean);
      } catch (e) {
      }
      if (options.mode) {
        out24.mode = out24.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e) {
            return v;
          }
        });
      }
    }
    return out24;
  }
  function count2(arr, matcher) {
    const { counts } = stats2(arr);
    if (!isUndefined2(matcher)) {
      if (isFunction2(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual2(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper5(x) {
    if (isDataFrame2(x) || isSeries2(x)) {
      return helper5(x.values);
    }
    if (isArray2(x)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x) {
        if (helper5(v)) {
          return true;
        }
        if (isArray2(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged2(x) {
    return helper5(decycle2(x));
  }
  function isNested2(x) {
    if (isDataFrame2(x) || isSeries2(x)) {
      return isNested2(x.values);
    }
    assert2(isArray2(x), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x.length; i++) {
      if (isArray2(x[i])) {
        return true;
      }
    }
    return false;
  }
  var error2 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray2(shape24) {
    assert2(!isUndefined2(shape24), error2);
    if (!isArray2(shape24))
      shape24 = [shape24];
    assert2(!isNested2(shape24), error2);
    assert2(shape24.length > 0, error2);
    let s24 = shape24[0];
    if (typeof s24 === "bigint")
      s24 = Number(s24);
    assert2(isNumber2(s24), error2);
    assert2(s24 >= 0, error2);
    assert2(Math.floor(s24) === s24, error2);
    assert2(s24 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape24.length === 1) {
      const out24 = [];
      for (let i = 0; i < s24; i++)
        out24.push(void 0);
      return out24;
    } else {
      const out24 = [];
      for (let i = 0; i < s24; i++) {
        out24.push(ndarray2(shape24.slice(1)));
      }
      return out24;
    }
  }
  function reverse2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      const out32 = arr.copy();
      out32.values = reverse2(out32.values);
      out32.index = reverse2(out32.index);
      return out32;
    }
    assert2(isArray2(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out24.push(arr[i]);
    return out24;
  }
  function range2(a, b, step = 1) {
    assert2(!isUndefined2(a) && !isUndefined2(b) && !isUndefined2(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert2(isNumber2(a) && isNumber2(b) && isNumber2(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert2(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out24 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out24.push(BigInt(i));
        } catch (e) {
          out24.push(i);
        }
      } else {
        out24.push(i);
      }
    }
    if (shouldReverse)
      out24 = reverse2(out24);
    return out24;
  }
  function makeKey22(n) {
    const alpha = "abcdefg1234567890";
    let out24 = "";
    while (out24.length < n)
      out24 += alpha[Math.floor(Math.random() * alpha.length)];
    return out24;
  }
  var NULL_KEY22 = makeKey22(256);
  var UNDEFINED_KEY22 = makeKey22(256);
  var INFINITY_KEY22 = makeKey22(256);
  var MINUS_INFINITY_KEY22 = makeKey22(256);
  var SYMBOL_KEY22 = makeKey22(256);
  function set2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return set2(arr.values);
    }
    assert2(isArray2(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    const temp = {};
    flatten2(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY22 : isUndefined2(item) ? UNDEFINED_KEY22 : isFunction2(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY22 : item === Infinity ? INFINITY_KEY22 : item === -Infinity ? MINUS_INFINITY_KEY22 : typeof item === "bigint" ? item.toString() : isDataFrame2(item) ? item.toJSONString() : isSeries2(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out24.push(item);
      temp[key] = true;
    });
    return out24;
  }
  function helper22(x) {
    if (isArray2(x)) {
      const childShapes = helper22(x[0]);
      return [x.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape2(x) {
    if (isDataFrame2(x) || isSeries2(x)) {
      return shape2(x.values);
    }
    assert2(isArray2(x), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper22(x);
  }
  function dfAppend2(df, x, axis) {
    if (isUndefined2(axis)) {
      axis = 0;
    }
    assert2(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray2(x)) {
      assert2(!isJagged2(x), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape2(x);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out24 = df.copy();
          out24._values.push(x);
          const maxRowLength = Math.max(df.shape[1], xShape[0]);
          out24._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        } else {
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out24 = df.copy();
          range2(0, maxColLength).forEach((i) => {
            if (i >= out24._values.length) {
              out24._values.push(ndarray2(df.shape[1]));
            }
            out24._values[i].push(x[i]);
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < out24._values[0].length) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x.map((row) => row.length).concat([df.shape[1]]));
          const out24 = df.copy();
          out24._values = out24._values.concat(x).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        } else {
          const maxRowLength = Math.max(...x.map((row) => row.length)) + df.shape[1];
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out24 = df.copy();
          range2(0, maxColLength).forEach((i) => {
            if (i >= out24._values.length) {
              out24._values.push(ndarray2(df.shape[1]));
            }
            out24._values[i] = out24._values[i].concat(x[i]);
            while (out24._values[i].length < maxRowLength) {
              out24._values[i].push(void 0);
            }
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        }
      } else {
        throw new MathError2("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries2(x)) {
      const out24 = dfAppend2(df, x.values, axis);
      if (axis === 0) {
        out24.index[out24.index.length - 1] = out24.index.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      } else {
        out24.columns[out24.columns.length - 1] = out24.columns.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      }
      return out24;
    } else if (isDataFrame2(x)) {
      if (axis === 0) {
        const out24 = df.copy();
        const maxRowLength = set2(out24._columns.concat(x._columns)).length;
        out24._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out24._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out24._values.push(temp.concat(rowCopy._values));
        }, 1);
        out24._columns = out24._columns.concat(x._columns.filter((c) => out24._columns.indexOf(c) < 0));
        while (out24._index.length < out24._values.length) {
          const newRowName = "row" + out24._index.length;
          out24._index.push(newRowName + (df._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out24;
      } else {
        const out24 = df.copy();
        out24._index.forEach((rowName, i) => {
          const xIndex = x._index.indexOf(rowName);
          if (xIndex > -1) {
            out24._values[i] = out24._values[i].concat(x._values[xIndex]);
          } else {
            out24._values[i] = out24._values[i].concat(ndarray2(x.shape[1]));
          }
        });
        x._index.forEach((rowName, i) => {
          const outIndex = out24._index.indexOf(rowName);
          if (outIndex < 0) {
            out24._index.push(rowName);
            out24._values.push(ndarray2(out24._columns.length).concat(x._values[i]));
          }
        });
        out24._columns = out24._columns.concat(x._columns.map((c) => c + (out24._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out24;
      }
    } else {
      throw new MathError2("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply2(DataFrame24, Series24, df, fn, axis) {
    axis = axis || 0;
    assert2(isFunction2(fn), "The first parameter to the `apply` method must be a function.");
    assert2(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df.columns.forEach((colName, i) => {
        const series = new Series24(df.values.map((row) => row[i]));
        series.name = colName;
        series.index = df.index;
        const value = fn(series, i, df);
        if (value instanceof Series24) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined2(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series24 || isArray2(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out24 = new DataFrame24(temp);
        out24.index = df.index;
        return out24;
      } else {
        const out24 = new Series24(df.columns.map((colName) => temp[colName]));
        out24.index = df.columns;
        return out24;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df.values.map((row, i) => {
        const series = new Series24(row);
        series.name = df.index[i];
        series.index = df.columns;
        const value = fn(series, i, df);
        if (isUndefined2(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series24 || isArray2(value);
        }
        if (value instanceof Series24) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out24 = new DataFrame24(temp);
        out24.index = df.index;
        out24.columns = df.columns;
        return out24;
      } else {
        const out24 = new Series24(temp);
        out24.index = df.index;
        return out24;
      }
    }
  }
  function isString2(s24) {
    return typeof s24 === "string";
  }
  function dfAssign2(DataFrame24, Series24, df, p1, p2) {
    const isDataFrame24 = (x) => x instanceof DataFrame24;
    const isSeries24 = (x) => x instanceof Series24;
    if (!isUndefined2(p2)) {
      assert2(isString2(p1), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert2(isArray2(p2) && !isJagged2(p2) && shape2(p2).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out24 = df.append(p2, 1);
      out24.columns[out24.columns.length - 1] = p1;
      return out24;
    } else {
      if (isDataFrame24(p1)) {
        return df.append(p1, 1);
      } else if (isSeries24(p1)) {
        return df.append(p1, 1);
      } else if (isObject2(p1)) {
        const maxColumnLength = Math.max(...Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).map((key) => p1[key].length));
        Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).forEach((key) => {
          while (p1[key].length < maxColumnLength) {
            p1[key].push(void 0);
          }
        });
        return df.append(new DataFrame24(p1), 1);
      } else {
        throw new MathError2("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy2(DataFrame24, df) {
    if (df.isEmpty)
      return new DataFrame24();
    const out24 = new DataFrame24(copy2(df.values));
    out24.columns = df.columns.slice();
    out24.index = df.index.slice();
    return out24;
  }
  function dfDrop2(DataFrame24, Series24, df, rows, cols) {
    if (isUndefined2(rows))
      rows = [];
    if (isUndefined2(cols))
      cols = [];
    if (isString2(rows) || isNumber2(rows))
      rows = [rows];
    if (isString2(cols) || isNumber2(cols))
      cols = [cols];
    assert2(isArray2(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert2(isArray2(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert2(shape2(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert2(shape2(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out24 = df.get(outIndex, outColumns);
    if (out24 instanceof Series24) {
      let temp = new DataFrame24();
      temp = temp.assign(out24);
      if (df.index.indexOf(out24.name) > -1)
        temp = temp.transpose();
      out24 = temp;
    }
    return out24;
  }
  function isInteger2(x) {
    return isNumber2(x) && (x >= 0 ? Math.floor(x) === x : Math.ceil(x) === x);
  }
  function isWholeNumber2(x) {
    return isInteger2(x) && x >= 0;
  }
  function dfDropMissing2(DataFrame24, Series24, df, axis, condition, threshold) {
    axis = axis || 0;
    assert2(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert2(isWholeNumber2(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert2(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper54(values) {
      if (threshold > 0) {
        let count24 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined2(value))
            count24++;
          if (count24 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined2(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined2(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out24 = df.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out24 = out24.assign(tempID, out24.index);
      const newValues = out24.values.map(helper54).filter((row) => row.length > 0);
      if (shape2(newValues).length < 2)
        return new DataFrame24();
      out24.values = newValues;
      let newIndex = out24.get(null, tempID);
      if (isUndefined2(newIndex))
        return new DataFrame24();
      if (isString2(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series24)
        newIndex = newIndex.values;
      out24.index = newIndex;
      out24 = out24.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out24.columns.forEach((colName, i) => {
        const values = out24.values.map((row) => row[i]);
        const newValues = helper54(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame24();
      }
      const newOut = new DataFrame24(temp);
      newOut.index = out24.index;
      return newOut;
    }
    return out24;
  }
  function dropNaN2(x) {
    if (isDataFrame2(x) || isSeries2(x)) {
      return x.dropNaN(...Object.values(arguments).slice(1));
    }
    assert2(isArray2(x), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    x.forEach((v) => {
      try {
        return out24.push(dropNaN2(v));
      } catch (e) {
        if (isNumber2(v)) {
          return out24.push(v);
        }
      }
    });
    return out24;
  }
  function dfDropNaN2(DataFrame24, df, axis, condition, threshold) {
    axis = axis || 0;
    assert2(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert2(isWholeNumber2(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert2(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper54(values) {
      const numericalValues = dropNaN2(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out24 = df.copy();
    if (axis === 0) {
      const rowsToKeep = out24.index.filter((row) => {
        const values = out24.get(row, null).values;
        return helper54(values);
      });
      if (rowsToKeep.length > 0)
        return out24.get(rowsToKeep, null);
      else
        return new DataFrame24();
    } else if (axis === 1) {
      const colsToKeep = out24.columns.filter((col) => {
        const values = out24.get(null, col).values;
        return helper54(values);
      });
      if (colsToKeep.length > 0)
        return out24.get(null, colsToKeep);
      else
        return new DataFrame24();
    }
    return out24;
  }
  function arrayToObject2(x) {
    const out24 = {};
    flatten2(x).forEach((value, i) => {
      out24[value] = i;
    });
    return out24;
  }
  function undoArrayToObject2(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter2(DataFrame24, Series24, df, fn, axis) {
    assert2(isFunction2(fn), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined2(axis))
      axis = 0;
    assert2(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out24 = df.copy();
    if (out24.isEmpty)
      return out24;
    const index = arrayToObject2(out24.index);
    const columns = arrayToObject2(out24.columns);
    if (axis === 0) {
      let count24 = 0;
      const newValues = out24.values.filter((row, i) => {
        const series = new Series24(row);
        series.name = df.index[i];
        series.index = df.columns;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count24++;
        } else {
          delete index[out24.index[i]];
        }
        return shouldKeep;
      });
      if (count24 === 0) {
        return new DataFrame24();
      }
      if (count24 === 1) {
        const temp = new Series24(newValues[0]);
        temp.name = undoArrayToObject2(index)[0];
        temp.index = undoArrayToObject2(columns);
        return temp;
      }
      out24.values = newValues;
      out24.index = undoArrayToObject2(index);
    } else if (axis === 1) {
      out24 = out24.transpose();
      let count24 = 0;
      const newValues = out24.values.filter((row, i) => {
        const series = new Series24(row);
        series.name = df.columns[i];
        series.index = df.index;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count24++;
        } else {
          delete columns[out24.index[i]];
        }
        return shouldKeep;
      });
      if (count24 === 0) {
        return new DataFrame24();
      }
      if (count24 === 1) {
        const temp = new Series24(newValues[0]);
        temp.name = undoArrayToObject2(columns)[0];
        temp.index = undoArrayToObject2(index);
        return temp;
      }
      out24.values = newValues;
      out24.index = undoArrayToObject2(columns);
      out24 = out24.transpose();
    }
    return out24;
  }
  function dfGet2(df, rows, cols) {
    if (isString2(rows) || isNumber2(rows))
      rows = [rows];
    if (isString2(cols) || isNumber2(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set2((rows || []).concat(cols || []).map((v) => typeof v));
    assert2(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert2(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert2(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert2(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined2(rows)) {
      rows = rows.map((r) => {
        if (isString2(r)) {
          assert2(df.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber2(r)) {
          assert2(r >= 0, `Index ${r} is out of bounds!`);
          assert2(Math.floor(r) === r, `Row numbers must be integers!`);
          assert2(r < df.index.length, `Index ${r} is out of bounds!`);
          return df.index[r];
        }
      });
    }
    if (!isUndefined2(cols)) {
      cols = cols.map((c) => {
        if (isString2(c)) {
          assert2(df.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber2(c)) {
          assert2(c >= 0, `Column ${c} is out of bounds!`);
          assert2(Math.floor(c) === c, `Column numbers must be integers!`);
          assert2(c < df.columns.length, `Column ${c} is out of bounds!`);
          return df.columns[c];
        }
      });
    }
    return df.getSubsetByNames(rows, cols);
  }
  function alphaSort2(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort2(arr, fn) {
    if (isUndefined2(fn))
      fn = alphaSort2;
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert2(isArray2(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert2(isFunction2(fn), "The second parameter of the `sort` function must be a comparison function!");
    const out24 = arr.slice();
    out24.sort(fn);
    return out24;
  }
  function camelify3(text) {
    const temp = text.toLowerCase();
    let out24 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out24 += char;
      } else {
        out24 += " ";
      }
    }
    const words = out24.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies2(DataFrame24, df, columns) {
    if (isUndefined2(columns)) {
      columns = df.columns;
    } else if (isString2(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert2(isString2(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df.columns.indexOf(col);
      assert2(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df.values.map((row) => row[colIndex]);
      const valuesSet = sort2(set2(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify3(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out24 = new DataFrame24(temp);
    out24.index = df.index;
    return out24;
  }
  function dfGetSubsetByIndices2(df, rowIndices, colIndices) {
    const dataShape = df.shape;
    if (isUndefined2(rowIndices))
      rowIndices = range2(0, dataShape[0]);
    if (isUndefined2(colIndices))
      colIndices = range2(0, dataShape[1]);
    if (isNumber2(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber2(colIndices))
      colIndices = [colIndices];
    assert2(isArray2(rowIndices) && isArray2(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert2(shape2(rowIndices).length === 1 && shape2(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert2(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert2(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert2(isWholeNumber2(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert2(rowIndex < df.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert2(isWholeNumber2(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert2(colIndex < df.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df.index[i]);
    const cols = colIndices.map((i) => df.columns[i]);
    return df.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames2(DataFrame24, Series24, df, rows, cols) {
    if (isUndefined2(rows))
      rows = df.index;
    if (isUndefined2(cols))
      cols = df.columns;
    if (isString2(rows))
      rows = [rows];
    if (isString2(cols))
      cols = [cols];
    assert2(isArray2(rows) && isArray2(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert2(shape2(rows).length === 1 && shape2(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert2(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert2(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert2(isString2(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert2(df.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert2(isString2(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert2(df.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df.values[df.index.indexOf(row)][df.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series24(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series24(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out24 = new DataFrame24(values);
    out24.columns = cols;
    out24.index = rows;
    return out24;
  }
  function dfPrint2(DataFrame24, Series24, df) {
    function truncate(s24, maxLength2) {
      if (isString2(s24)) {
        if (s24.length > maxLength2) {
          return s24.substring(0, maxLength2 - 3) + "...";
        } else {
          return s24;
        }
      } else {
        return s24;
      }
    }
    if (df.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df.index.length ? null : range2(0, halfMaxRows).concat(range2(df.index.length - halfMaxRows, df.index.length));
    const tempColumns = maxColumns > df.columns.length ? null : range2(0, halfMaxColumns).concat(range2(df.columns.length - halfMaxColumns, df.columns.length));
    let temp = df.get(tempRows, tempColumns);
    if (temp instanceof Series24) {
      if (df.shape[0] === 1) {
        temp = new DataFrame24([temp.values]);
        temp.index = df.index;
        temp.columns = new Series24(df.columns).get(tempColumns).values;
      } else if (df.shape[1] === 1) {
        temp = new DataFrame24([temp.values]).transpose();
        temp.index = new Series24(df.index).get(tempRows).values;
        temp.columns = df.columns;
      }
    }
    if (maxRows <= df.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range2(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series24) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df.shape, "\n");
    return df;
  }
  function leftPad2(x, maxLength) {
    assert2(isNumber2(x), "The `leftPad` function only works on numbers!");
    let out24 = x.toString();
    while (out24.length < maxLength)
      out24 = "0" + out24;
    return out24;
  }
  function dfResetIndex2(df, shouldSkipCopying) {
    const out24 = shouldSkipCopying ? df : df.copy();
    out24.index = range2(0, df.shape[0]).map((i) => {
      return "row" + leftPad2(i, (out24.index.length - 1).toString().length);
    });
    return out24;
  }
  function product2(arr, shouldDropNaNs) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return product2(arr.values, shouldDropNaNs);
    }
    assert2(isArray2(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten2(arr);
      let resultShouldBeABigInt = false;
      let out24 = 1;
      for (let v of temp) {
        if (!isNumber2(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  }
  function isNaturalNumber2(x) {
    return isInteger2(x) && x > 0;
  }
  function reshape2(x, newShape) {
    if (isDataFrame2(x) || isSeries2(x)) {
      return reshape2(x.values, newShape);
    }
    assert2(isArray2(x), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber2(newShape))
      newShape = [newShape];
    assert2(isArray2(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert2(shape2(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert2(isNaturalNumber2(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten2(x);
    }
    const temp = flatten2(x);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert2(product2(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out24 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out24.push(reshape2(row, newShape.slice(1)));
    }
    return out24;
  }
  var MAX2 = Math.pow(2, 64);
  var s2 = [];
  seed2(Math.floor(Math.random() * MAX2));
  function splitmix642(state, n) {
    state = uint2(state);
    function helper54() {
      state += uint2("0x9e3779b97f4a7c15");
      let z = copy2(state);
      z = (z ^ z >> BigInt(30)) * uint2("0xbf58476d1ce4e5b9");
      z = (z ^ z >> BigInt(27)) * uint2("0x94d049bb133111eb");
      return z ^ z >> BigInt(31);
    }
    const out24 = [];
    for (let i = 0; i < n; i++)
      out24.push(helper54());
    return out24;
  }
  function uint2(x) {
    return BigInt.asUintN(64, BigInt(x));
  }
  function rotl2(x, k) {
    x = uint2(x);
    k = BigInt(k);
    return uint2(uint2(x << k) | uint2(x >> uint2(BigInt(64) - k)));
  }
  function seed2(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined2(val)) {
      assert2(isNumber2(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix642(Math.floor(val), 4);
      s2[0] = temp[0];
      s2[1] = temp[1];
      s2[2] = temp[2];
      s2[3] = temp[3];
    } else {
      return copy2(s2);
    }
  }
  function next2() {
    const result = uint2(rotl2(s2[0] + s2[3], 23) + s2[0]);
    const t = uint2(s2[1] << BigInt(17));
    s2[2] = uint2(s2[2] ^ s2[0]);
    s2[3] = uint2(s2[3] ^ s2[1]);
    s2[1] = uint2(s2[1] ^ s2[2]);
    s2[0] = uint2(s2[0] ^ s2[3]);
    s2[2] = uint2(s2[2] ^ t);
    s2[3] = rotl2(s2[3], 45);
    return Math.floor(Number(result)) / MAX2;
  }
  function random2(shape24) {
    if (isUndefined2(shape24))
      return next2();
    if (!isArray2(shape24))
      shape24 = [shape24];
    return reshape2(ndarray2(product2(shape24)).map(next2), shape24);
  }
  function shuffle2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert2(isArray2(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random2() * temp.length);
      out24.push(temp.splice(index, 1)[0]);
    }
    return out24;
  }
  function dfShuffle2(df, axis) {
    if (isUndefined2(axis))
      axis = 0;
    assert2(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df.get(axis === 0 ? shuffle2(df.index) : null, axis === 1 ? shuffle2(df.columns) : null);
  }
  function isBoolean2(x) {
    return typeof x === "boolean";
  }
  function dfSort2(df, a, b) {
    if (isFunction2(a)) {
      return dfSortByFunction2(df, a, b);
    } else {
      return dfSortByColumns2(df, a, b);
    }
  }
  function dfSortByFunction2(df, fn, axis) {
    axis = isUndefined2(axis) ? 0 : axis;
    assert2(isFunction2(fn), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert2(isNumber2(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort2(df.index, (a, b) => {
        return fn(df.get(a, null), df.get(b, null));
      });
      return df.get(index, null);
    } else {
      const columns = sort2(df.columns, (a, b) => {
        return fn(df.get(null, a), df.get(null, b));
      });
      return df.get(null, columns);
    }
  }
  function dfSortByColumns2(df, cols, directions) {
    let out24 = df.copy();
    const indexID = random2().toString();
    out24 = out24.assign(indexID, out24.index);
    if (isUndefined2(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber2(cols) || isString2(cols)) {
      cols = [cols];
      if (isBoolean2(directions) || isString2(directions))
        directions = [directions];
    }
    assert2(isArray2(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert2(shape2(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined2(directions))
      directions = range2(0, cols.length).map(() => true);
    assert2(isArray2(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert2(shape2(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert2(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert2(isString2(col) || isNumber2(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString2(col)) {
        const index = out24.columns.indexOf(col);
        assert2(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber2(col)) {
        assert2(isWholeNumber2(col), "Column indices must be whole numbers!");
        assert2(col < out24.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert2(isString2(dir) || isBoolean2(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString2(dir)) {
        const value = dir.trim().toLowerCase();
        assert2(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean2(dir)) {
        return dir;
      }
    });
    out24.values = sort2(out24.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out24.columns.indexOf(indexID);
    out24.index = out24.values.map((row) => row[indexNumber]);
    out24 = out24.dropColumns(indexID);
    return out24;
  }
  function dfToDetailedObject2(df, axis) {
    if (isUndefined2(axis)) {
      axis = 0;
    } else {
      assert2(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out24 = {};
    if (axis === 0) {
      df.index.forEach((rowName, i) => {
        const temp = {};
        df.columns.forEach((colName, j) => {
          temp[colName] = df.values[i][j];
        });
        out24[rowName] = temp;
      });
    } else {
      df.columns.forEach((colName, j) => {
        const temp = {};
        df.index.forEach((rowName, i) => {
          temp[rowName] = df.values[i][j];
        });
        out24[colName] = temp;
      });
    }
    return out24;
  }
  function dfToJSONString2(df, axis) {
    return JSON.stringify(df.toObject(axis));
  }
  async function dfToJSON2(df, filename, axis) {
    const out24 = dfToJSONString2(df, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out24)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e) {
      browserError = e;
    }
    try {
      const fs = await import("node:fs");
      const path = await import("node:path");
      fs.writeFileSync(path.resolve(filename), out24, "utf8");
      wroteToDiskInNode = true;
    } catch (e) {
      nodeError = e;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError2(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError2(nodeError);
      } else {
        throw new MathError2("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df;
  }
  function dfToObject2(df) {
    const out24 = {};
    df.columns.forEach((col) => {
      out24[col] = df.get(col).values;
    });
    return out24;
  }
  function transpose2(arr) {
    if (isDataFrame2(arr) || isSeries2(arr)) {
      return arr.transpose();
    }
    assert2(isArray2(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape2(arr);
    assert2(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse2(arr);
    } else if (theShape.length === 2) {
      const out24 = ndarray2(reverse2(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out24[col][row] = arr[row][col];
        }
      }
      return out24;
    }
  }
  function seriesAppend2(Series24, series, x) {
    if (isSeries2(x)) {
      return new Series24(series.values.concat(x.values));
    }
    if (isArray2(x)) {
      const xShape = shape2(x);
      assert2(xShape.length === 1 && !isNested2(xShape), "Only vectors can be appended to Series!");
      const out24 = series.copy();
      x.forEach((v, i) => {
        out24._values.push(v);
        out24._index.push("item" + (series.values.length + i));
      });
      return out24;
    }
    return seriesAppend2(series, [x]);
  }
  function seriesApply2(series, fn) {
    assert2(isFunction2(fn), "The parameter to the `apply` method must be a function.");
    const out24 = series.copy();
    out24._values = out24._values.map((v, i) => fn(v, i));
    return out24;
  }
  function seriesDropMissing2(series) {
    const out24 = series.copy();
    const outIndex = [];
    out24._values = out24.values.filter((v, i) => {
      if (isUndefined2(v)) {
        return false;
      } else {
        outIndex.push(out24.index[i]);
        return true;
      }
    });
    out24._index = outIndex;
    return out24;
  }
  function seriesDropNaN2(Series24, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber2(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out24 = new Series24(values);
    out24.name = series.name;
    out24.index = index;
    return out24;
  }
  function seriesFilter2(Series24, series, fn) {
    let out24 = series.copy();
    const index = copy2(out24.index);
    const indicesToRemove = [];
    const newValues = out24.values.filter((value, i) => {
      const shouldKeep = fn(value, i, out24.values);
      if (!shouldKeep)
        indicesToRemove.push(out24.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out24 = new Series24();
      out24.name = series.name;
      return out24;
    }
    out24.values = newValues;
    out24.index = index;
    return out24;
  }
  function seriesGet2(series, indices) {
    if (isString2(indices) || isNumber2(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set2((indices || []).map((v) => typeof v));
    assert2(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert2(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert2(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert2(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined2(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert2(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert2(i >= 0, `Index ${i} is out of bounds!`);
          assert2(Math.floor(i) === i, `Indices must be integers!`);
          assert2(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices2(series, indices) {
    const dataShape = series.shape;
    if (isUndefined2(indices))
      indices = range2(0, dataShape[0]);
    assert2(isArray2(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert2(shape2(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert2(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert2(isWholeNumber2(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert2(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames2(Series24, series, indices) {
    if (isUndefined2(indices))
      indices = series.index;
    assert2(isArray2(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert2(shape2(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert2(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert2(isString2(name), "The `indices` array must contain only strings.");
      assert2(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out24 = new Series24(values);
    out24.index = indices;
    out24.name = series.name;
    return out24;
  }
  function seriesPrint2(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range2(0, maxRows / 2).concat(range2(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy2(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out24 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out24[temp.index[i]] = obj;
    });
    console.table(out24);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle2(series) {
    const out24 = series.copy();
    return out24.get(shuffle2(out24.index));
  }
  function seriesSort2(Series24, series, fn) {
    fn = fn || ((a, b) => a < b ? -1 : 1);
    assert2(isUndefined2(fn) || isFunction2(fn), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose2([series.values, series.index]);
    const temp = sort2(pairs, (aPair, bPair) => {
      return fn(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out24 = new Series24();
    out24._values = newValues;
    out24._index = newIndex;
    out24.name = series.name;
    return out24;
  }
  function seriesSortByIndex2(Series24, series) {
    let temp = transpose2([series.values, series.index]);
    temp = transpose2(sort2(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out24 = new Series24(temp[0]);
    out24.index = temp[1];
    out24.name = series.name;
    return out24;
  }
  function seriesToObject2(series) {
    const out24 = {};
    out24[series.name] = {};
    series.index.forEach((index, i) => {
      out24[series.name][index] = series.values[i];
    });
    return out24;
  }
  var SERIES_SYMBOL2 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass2(DataFrame24) {
    class Series24 {
      static [Symbol.hasInstance](x) {
        try {
          return !!x._symbol && x._symbol === SERIES_SYMBOL2;
        } catch (e) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL2
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x) {
            assert2(isArray2(x), "The new values must be a 1-dimensional array!");
            const dataShape = shape2(x);
            assert2(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range2(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad2(i, (x.length - 1).toString().length);
              }));
            }
            this._values = x;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x) {
            assert2(isArray2(x), "The new index must be a 1-dimensional array of strings!");
            assert2(x.length === this.shape[0], "The new index must be the same length as the old index!");
            assert2(shape2(x).length === 1, "The new index must be a 1-dimensional array of strings!");
            x.forEach((value) => {
              assert2(isString2(value), "All of the row names must be strings!");
            });
            this._index = x;
          }
        });
        if (data) {
          if (data instanceof Series24) {
            this.name = data.name;
            this.values = copy2(data.values);
            this.index = copy2(data.index);
          } else if (isArray2(data)) {
            const dataShape = shape2(data);
            assert2(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert2(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert2(shape2(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape2(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined2(v)).length === 0;
      }
      clear() {
        const out24 = this.copy();
        out24.values.forEach((v, i) => {
          out24.values[i] = void 0;
        });
        return out24;
      }
      get(indices) {
        return seriesGet2(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames2(Series24, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices2(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out24 = new Series24(reverse2(this.values));
        out24.index = reverse2(this.index);
        out24.name = this.name;
        return out24;
      }
      resetIndex() {
        const out24 = this.copy();
        out24.index = range2(0, this.shape[0]).map((i) => {
          return "item" + leftPad2(i, (out24.index.length - 1).toString().length);
        });
        return out24;
      }
      copy() {
        const out24 = new Series24();
        out24._values = copy2(this.values);
        out24._index = copy2(this.index);
        out24.name = this.name;
        return out24;
      }
      append(x) {
        return seriesAppend2(Series24, this, x);
      }
      apply(fn) {
        return seriesApply2(this, fn);
      }
      concat(x) {
        return this.append(x);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing2(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN2(Series24, this);
      }
      toObject() {
        return seriesToObject2(this);
      }
      print() {
        return seriesPrint2(this);
      }
      shuffle() {
        return seriesShuffle2(this);
      }
      sort(direction) {
        return seriesSort2(Series24, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex2(Series24, this);
      }
      filter(fn) {
        return seriesFilter2(Series24, this, fn);
      }
      toDataFrame() {
        const out24 = new DataFrame24(transpose2([this.values]));
        out24.columns = [this.name];
        out24.index = this.index;
        return out24;
      }
      transpose() {
        const out24 = this.copy();
        out24.values = reverse2(out24.values);
        out24.index = reverse2(out24.index);
        return out24;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series24;
  }
  var DATAFRAME_SYMBOL2 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey32(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out24 = "";
    for (let i = 0; i < n; i++)
      out24 += alpha[Math.floor(random2() * alpha.length)];
    return out24;
  }
  var DataFrame2 = class {
    static [Symbol.hasInstance](x) {
      try {
        return !!x._symbol && x._symbol === DATAFRAME_SYMBOL2;
      } catch (e) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL2
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined2(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x) {
          assert2(isArray2(x), "The new values must be a 2-dimensional array!");
          const dataShape = shape2(x);
          assert2(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range2(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad2(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range2(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad2(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x) {
          assert2(isArray2(x), "The new columns list must be a 1-dimensional array of strings!");
          assert2(this.isEmpty || x.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert2(shape2(x).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey32(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count2(x);
            const out24 = {};
            temp.values.forEach((v) => {
              out24[v] = temp.get(v);
            });
            return out24;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey32(8);
            }
            return v;
          });
          this._columns = x;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x) {
          assert2(isArray2(x), "The new index must be a 1-dimensional array of strings!");
          assert2(this.isEmpty || x.length === this.shape[0], "The new index must be the same length as the old index!");
          assert2(shape2(x).length === 1, "The new index must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey32(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count2(x);
            const out24 = {};
            temp.values.forEach((v) => {
              out24[v] = temp.get(v);
            });
            return out24;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey32(8);
            }
            return v;
          });
          this._index = x;
        }
      });
      assert2(isUndefined2(data) || isObject2(data) || isArray2(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame2) {
          this.values = copy2(data.values);
          this.columns = copy2(data.columns);
          this.index = copy2(data.index);
        } else if (isArray2(data)) {
          const dataShape = shape2(data);
          assert2(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert2(!isJagged2(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined2(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert2(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose2(temp);
          const dataShape = shape2(this.values);
          this._index = range2(0, dataShape[0]).map((i) => {
            return "row" + leftPad2(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape2(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out24 = new DataFrame2(ndarray2(this.shape));
      out24.columns = this.columns.slice();
      out24.index = this.index.slice();
      return out24;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e) {
          return this.get(rows, null);
        }
      }
      return dfGet2(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames2(DataFrame2, Series2, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices2(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies2(DataFrame2, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies2(DataFrame2, this, columns);
    }
    transpose() {
      const out24 = new DataFrame2(transpose2(this.values));
      out24.columns = this.index.slice();
      out24.index = this.columns.slice();
      return out24;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex2(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy2(DataFrame2, this);
    }
    assign(p1, p2) {
      return dfAssign2(DataFrame2, Series2, this, p1, p2);
    }
    apply(fn, axis) {
      return dfApply2(DataFrame2, Series2, this, fn, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing2(DataFrame2, Series2, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN2(DataFrame2, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop2(DataFrame2, Series2, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject2(this, axis);
    }
    toObject() {
      return dfToObject2(this);
    }
    toJSONString(axis) {
      return dfToJSONString2(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON2(this, filename, axis);
    }
    print() {
      return dfPrint2(DataFrame2, Series2, this);
    }
    sort(cols, directions) {
      return dfSort2(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn, axis) {
      return dfFilter2(DataFrame2, Series2, this, fn, axis);
    }
    shuffle(axis) {
      return dfShuffle2(this, axis);
    }
    append(x, axis) {
      return dfAppend2(this, x, axis);
    }
    concat(x, axis) {
      return this.append(x, axis);
    }
    join(x, axis) {
      return this.append(x, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series2 = createSeriesClass2(DataFrame2);
  function max2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs }).max;
  }
  function vectorize2(fn) {
    assert2(isFunction2(fn), "You must pass a function into the `vectorize` function!");
    return function helper54() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray2(arg)) {
          return true;
        } else if (isSeries2(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame2(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s24, i) => {
        assert2(isEqual2(isArray2(s24) ? shape2(s24) : s24.shape, isArray2(childArrays[i + 1]) ? shape2(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max2(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out24 = range2(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray2(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries2(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame2(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper54(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual2(shape2(dataframes[0]), shape2(out24))) {
              const temp = new DataFrame2(out24);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame2(out24);
            }
          } catch (e) {
            return out24;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out24.length) {
              const temp = new Series2(out24);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series2(out24);
            }
          } catch (e) {
            return out24;
          }
        }
        return out24;
      } else {
        return fn(...arguments);
      }
    };
  }
  function abs2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        return x < 0 ? -x : x;
      } else {
        return Math.abs(x);
      }
    } catch (e) {
      return NaN;
    }
  }
  var vabs2 = vectorize2(abs2);
  function add2() {
    try {
      let out24 = 0;
      let resultShouldBeABigInt = false;
      const x = Object.values(arguments);
      for (let v of x) {
        if (!isNumber2(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  }
  var vadd2 = vectorize2(add2);
  function apply2(x, fn) {
    try {
      return fn(x);
    } catch (e) {
      return NaN;
    }
  }
  var vapply2 = vectorize2(apply2);
  function arccos2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.acos(x);
    } catch (e) {
      return NaN;
    }
  }
  var varccos2 = vectorize2(arccos2);
  function arcsin2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.asin(x);
    } catch (e) {
      return NaN;
    }
  }
  var varcsin2 = vectorize2(arcsin2);
  function arctan2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.atan(x);
    } catch (e) {
      return NaN;
    }
  }
  var varctan2 = vectorize2(arctan2);
  function argmax2(x, shouldDropNaNs) {
    if (isDataFrame2(x)) {
      const index = argmax2(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries2(x)) {
      const index = argmax2(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert2(isArray2(x), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out24 = indexOf2(x, max2(x, shouldDropNaNs));
      if (out24) {
        if (out24.length === 0) {
          return void 0;
        } else if (out24.length === 1) {
          return out24[0];
        } else {
          return out24;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function min2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs }).min;
  }
  function argmin2(x, shouldDropNaNs) {
    if (isDataFrame2(x)) {
      const index = argmin2(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries2(x)) {
      const index = argmin2(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert2(isArray2(x), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out24 = indexOf2(x, min2(x, shouldDropNaNs));
      if (out24) {
        if (out24.length === 0) {
          return void 0;
        } else if (out24.length === 1) {
          return out24[0];
        } else {
          return out24;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function cast2(value, type) {
    if (isDataFrame2(value) || isSeries2(value)) {
      return value.apply((item) => cast2(item, type));
    }
    if (isArray2(value)) {
      return value.map((v) => cast2(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined2(value)) {
        return NaN;
      }
      const booleanValue = cast2(value, "boolean");
      if (isBoolean2(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e) {
        const dateValue = cast2(value, "date");
        if (isDate2(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out24 = parseFloat(value);
      if (isNaN(out24))
        return NaN;
      return out24;
    }
    if (type === "int") {
      const out24 = cast2(value, "number");
      return out24 >= 0 ? Math.floor(out24) : Math.ceil(out24);
    }
    if (type === "float") {
      return cast2(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast2(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean2(value)) {
        return value;
      }
      if (isNumber2(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate2(value)) {
        return value;
      }
      if (isUndefined2(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out24 = new Date(value);
        if (!isDate2(out24))
          return null;
        return out24;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject2(value)) {
        return value;
      }
      const booleanValue = cast2(value, "boolean");
      if (isBoolean2(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast2(value, "number");
        if (isNumber2(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e) {
      }
      const dateValue = cast2(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out24 = JSON.parse(value);
        if (isArray2(out24)) {
          return out24.map((v) => cast2(v, type));
        } else {
          return out24;
        }
      } catch (e) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined2(value)) {
        if (isEqual2(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.ceil(x);
    } catch (e) {
      return NaN;
    }
  }
  var vceil2 = vectorize2(ceil2);
  function chop2(x, threshold) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      if (isUndefined2(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber2(threshold)) {
        return NaN;
      }
      return vabs2(x) < threshold ? 0 : x;
    } catch (e) {
      return NaN;
    }
  }
  var vchop2 = vectorize2(chop2);
  function int2(x) {
    if (isDataFrame2(x) || isSeries2(x)) {
      const out24 = x.copy();
      out24.values = int2(out24.values);
      return out24;
    }
    if (isArray2(x)) {
      return x.map((v) => int2(v));
    } else {
      try {
        const out24 = JSON.parse(x);
        if (isNumber2(out24)) {
          return typeof out24 === "bigint" ? Number(out24) : out24 >= 0 ? Math.floor(out24) : Math.ceil(out24);
        }
        return NaN;
      } catch (e) {
        return NaN;
      }
    }
  }
  var vint2 = vectorize2(int2);
  function clamp2(x, a, b) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (!isNumber2(a))
        return NaN;
      if (!isNumber2(b))
        return NaN;
      if (typeof x === "bigint") {
        return BigInt(clamp2(vint2(x), a, b));
      }
      if (x < a)
        return a;
      if (x > b)
        return b;
      return x;
    } catch (e) {
      return NaN;
    }
  }
  var vclamp2 = vectorize2(clamp2);
  function combinationsIterator2(x, r) {
    function* helper54(x2, r2) {
      if (r2 > x2.length) {
        yield x2;
      } else if (r2 <= 0) {
        yield [];
      } else if (x2.length < 2) {
        yield x2;
      } else {
        for (let i = 0; i < x2.length; i++) {
          const item = x2[i];
          const after = x2.slice(i + 1);
          if (after.length < r2 - 1) {
            continue;
          }
          if (r2 - 1 >= 0) {
            for (const child of combinationsIterator2(after, r2 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame2(x) || isSeries2(x)) {
      return combinationsIterator2(x.values, r);
    }
    assert2(isArray2(x), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert2(isNumber2(r) && vint2(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper54(flatten2(x), r);
  }
  function combinations2(x, r) {
    const out24 = [];
    for (const combo of combinationsIterator2(x, r)) {
      out24.push(combo.slice());
    }
    return out24;
  }
  function intersect2() {
    const arrays = Object.values(arguments).map((x) => {
      if (isDataFrame2(x) || isSeries2(x)) {
        return set2(x.values);
      }
      assert2(isArray2(x), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set2(x);
    });
    const all = set2(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual2(other, v)) > -1);
    });
  }
  var _IndexMatcher2 = class {
    constructor(mode24) {
      assert2(isUndefined2(mode24) || mode24 === _IndexMatcher2.DROP_NAN_MODE || mode24 === _IndexMatcher2.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined2(mode24) ? mode24 : _IndexMatcher2.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x) => {
        if (isArray2(x)) {
          const xshape = shape2(x);
          if (xshape.length === 1) {
            x = new Series2(x);
          } else if (xshape.length === 2) {
            x = new DataFrame2(x);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert2(isDataFrame2(x) || isSeries2(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher2.DROP_MISSING_MODE) {
          indices.push(x.dropMissing().index);
        } else {
          indices.push(x.dropNaN().index);
        }
      });
      this.index = intersect2(...indices);
      return this;
    }
    transform() {
      assert2(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out24 = Object.values(arguments).map((x) => {
        if (isArray2(x)) {
          const xshape = shape2(x);
          if (xshape.length === 1) {
            return new Series2(x).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame2(x).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert2(isDataFrame2(x) || isSeries2(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x.get(this.index, null);
      });
      return out24.length === 1 ? out24[0] : out24;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher2 = _IndexMatcher2;
  __publicField2(IndexMatcher2, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField2(IndexMatcher2, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance2(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries2(x)) {
      return covariance2(x.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries2(y)) {
      return covariance2(x, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert2(isArray2(x) && isArray2(y) && shape2(x).length === 1 && shape2(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert2(x.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance2(...new IndexMatcher2().fitAndTransform(x, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats2(x, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats2(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx = Number(xstats.mean);
      const my = Number(ystats.mean);
      if (!isNumber2(mx) || !isNumber2(my)) {
        return NaN;
      }
      const n = Math.max(x.length, y.length);
      let out24 = 0;
      for (let i = 0; i < n; i++) {
        let vx = x[i];
        let vy = y[i];
        if (!isNumber2(vx))
          return NaN;
        if (!isNumber2(vy))
          return NaN;
        if (typeof vx === "bigint") {
          vx = Number(vx);
        }
        if (typeof vy === "bigint") {
          vy = Number(vy);
        }
        out24 += (vx - mx) * (vy - my);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out24 / x.length, xstats, ystats];
      } else {
        return out24 / x.length;
      }
    } catch (e) {
      return NaN;
    }
  }
  function correl2(x, y, shouldDropNaNs) {
    if (isSeries2(x)) {
      return correl2(x.values, y, shouldDropNaNs);
    }
    if (isSeries2(y)) {
      return correl2(x, y.values, shouldDropNaNs);
    }
    assert2(isArray2(x) && isArray2(y) && shape2(x).length === 1 && shape2(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert2(x.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance2(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e) {
      return NaN;
    }
  }
  function cos2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.cos(x);
    } catch (e) {
      return NaN;
    }
  }
  var vcos2 = vectorize2(cos2);
  var dataTypes2 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff2(a, b) {
    if (isDataFrame2(a) || isSeries2(a)) {
      return diff2(a.values, b);
    }
    if (isDataFrame2(b) || isSeries2(b)) {
      return diff2(a, b.values);
    }
    assert2(isArray2(a) && isArray2(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set2(a);
    const bTemp = set2(b);
    const out24 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual2(other, item)) < 0) {
        out24.push(item);
      }
    });
    return out24;
  }
  function pow2(x, p) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (!isNumber2(p))
        return NaN;
      if (typeof x === "bigint" || typeof p === "bigint") {
        const out24 = pow2(Number(x), Number(p));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return Math.pow(x, p);
    } catch (e) {
      return NaN;
    }
  }
  var vpow2 = vectorize2(pow2);
  function sqrt2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        const out24 = sqrt2(Number(x));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return Math.sqrt(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsqrt2 = vectorize2(sqrt2);
  function multiply2() {
    try {
      const x = Object.values(arguments);
      if (x.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out24 = 1;
      for (let v of x) {
        if (!isNumber2(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  }
  var vmultiply2 = vectorize2(multiply2);
  function scale2() {
    return vmultiply2(...arguments);
  }
  function subtract2(a, b) {
    return vadd2(a, scale2(b, -1));
  }
  function sum2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs }).sum;
  }
  function distance2(a, b) {
    if (isNumber2(a) && isNumber2(b)) {
      return vabs2(a - b);
    }
    if (isDataFrame2(a) || isSeries2(a)) {
      return distance2(a.values, b);
    }
    if (isDataFrame2(b) || isSeries2(b)) {
      return distance2(a, b.values);
    }
    if (isArray2(a) && isArray2(b)) {
      assert2(isEqual2(shape2(a), shape2(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt2(sum2(vpow2(subtract2(a, b), 2)));
    } catch (e) {
      return NaN;
    }
  }
  function divide2(a, b) {
    return scale2(a, vpow2(b, -1));
  }
  function dot2(a, b) {
    if (isDataFrame2(a)) {
      const temp = dot2(a.values, b);
      if (shape2(temp).length === 1) {
        const out24 = new Series2(temp);
        out24.name = isSeries2(b) ? b.name : out24.name;
        out24.index = a.index.slice();
        return out24;
      } else {
        const out24 = new DataFrame2(temp);
        out24.index = a.index.slice();
        if (isDataFrame2(b)) {
          out24.columns = b.columns.slice();
        }
        return out24;
      }
    }
    if (isDataFrame2(b)) {
      const temp = dot2(a, b.values);
      if (shape2(temp).length === 1) {
        const out24 = new Series2(temp);
        out24.name = isSeries2(a) ? a.name : out24.name;
        out24.index = b.columns.slice();
        return out24;
      } else {
        const out24 = new DataFrame2(temp);
        out24.columns = b.columns.slice();
        return out24;
      }
    }
    if (isSeries2(a)) {
      return dot2(a.values, b);
    }
    if (isSeries2(b)) {
      return dot2(a, b.values);
    }
    assert2(isArray2(a) && isArray2(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape2(a);
    const bShape = shape2(b);
    assert2(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert2(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum2(scale2(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose2(b).map((col) => dot2(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot2(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose2(b);
      const out24 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot2(a[i], bTranspose[j]));
        }
        out24.push(row);
      }
      return out24;
    }
  }
  function dropMissing2(x) {
    if (isDataFrame2(x) || isSeries2(x)) {
      return x.dropMissing(...Object.values(arguments).slice(1));
    }
    assert2(isArray2(x), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    x.forEach((v) => {
      try {
        return out24.push(dropMissing2(v));
      } catch (e) {
        if (!isUndefined2(v)) {
          out24.push(v);
        }
      }
    });
    return out24;
  }
  function dropMissingPairwise2(a, b) {
    if (isDataFrame2(a) || isSeries2(a)) {
      return dropMissingPairwise2(a.values, b);
    }
    if (isDataFrame2(b) || isSeries2(b)) {
      return dropMissingPairwise2(a, b.values);
    }
    assert2(isArray2(a) && isArray2(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert2(isEqual2(shape2(a), shape2(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise2(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (!isUndefined2(a[i]) && !isUndefined2(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise2(a, b) {
    if (isDataFrame2(a) || isSeries2(a)) {
      return dropNaNPairwise2(a.values, b);
    }
    if (isDataFrame2(b) || isSeries2(b)) {
      return dropNaNPairwise2(a, b.values);
    }
    assert2(isArray2(a) && isArray2(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert2(isEqual2(shape2(a), shape2(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise2(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (isNumber2(a[i]) && isNumber2(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined2(x) {
    return dropMissing2(x);
  }
  function every2(x, fn) {
    if (isDataFrame2(x) || isSeries2(x)) {
      return every2(x.values, fn);
    }
    assert2(isArray2(x), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert2(isFunction2(fn), "The second argument passed into the `every` function must be a function!");
    for (const v of x) {
      if (isArray2(v)) {
        if (!every2(v, fn)) {
          return false;
        }
      } else {
        if (!fn(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        if (x === 0n) {
          return 1n;
        } else {
          x = Number(x);
        }
      }
      return Math.exp(x);
    } catch (e) {
      return NaN;
    }
  }
  var vexp2 = vectorize2(exp2);
  function factorial2(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial2(vint2(n)));
      }
      if (n !== vint2(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial2(n - 1);
    } catch (e) {
      return NaN;
    }
  }
  var vfactorial2 = vectorize2(factorial2);
  function find2(x, fn) {
    if (isDataFrame2(x)) {
      return find2(x.values, fn);
    }
    if (isSeries2(x)) {
      return find2(x.values, fn);
    }
    assert2(isObject2(x) || isArray2(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction2(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper54(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject2(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return value;
          }
          const result = helper54(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray2(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return value;
          }
          const result = helper54(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn2(x2)) {
          return x2;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    return helper54(x, safeFn);
  }
  function findAll2(x, fn) {
    if (isDataFrame2(x)) {
      return findAll2(x.values, fn);
    }
    if (isSeries2(x)) {
      return findAll2(x.values, fn);
    }
    assert2(isObject2(x) || isArray2(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction2(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper54(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject2(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        const out24 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out24.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper54(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out24.push(r));
          }
        }
        return out24;
      } else if (isArray2(x2)) {
        checked.push(x2);
        const out24 = [];
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out24.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper54(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out24.push(r));
          }
        }
        return out24;
      } else {
        if (fn2(x2)) {
          return [x2];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const results = helper54(x, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float2(x) {
    try {
      if (x === "Infinity") {
        return Infinity;
      }
      if (x === "-Infinity") {
        return -Infinity;
      }
      const out24 = JSON.parse(x);
      if (isNumber2(out24))
        return out24;
      return NaN;
    } catch (e) {
      return NaN;
    }
  }
  var vfloat2 = vectorize2(float2);
  function floor2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        return x;
      }
      return Math.floor(x);
    } catch (e) {
      return NaN;
    }
  }
  var vfloor2 = vectorize2(floor2);
  function zeros2(shape24) {
    if (isNumber2(shape24))
      shape24 = [shape24];
    const out24 = [];
    const n = product2(shape24);
    for (let i = 0; i < n; i++)
      out24.push(0);
    return reshape2(out24, shape24);
  }
  function identity2(size) {
    if (typeof size === "bigint") {
      size = vint2(size);
    }
    assert2(!isUndefined2(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert2(isNumber2(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert2(vint2(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert2(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out24 = zeros2([size, size]);
    for (let i = 0; i < size; i++)
      out24[i][i] = 1;
    return out24;
  }
  var booleanValues2 = ["true", "false", "yes", "no"];
  var nullValues2 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger2(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint2(results.value) === results.value;
      } else {
        results.isInteger = every2(results.values, (v) => isNumber2(v) ? vint2(v) === v : true);
      }
    }
    return results;
  }
  function inferType2(arr) {
    if (isDataFrame2(arr)) {
      const out24 = arr.copy();
      const results = inferType2(arr.values);
      out24.values = results.values;
      return checkIfInteger2({ type: results.type, values: out24 });
    }
    if (isSeries2(arr)) {
      const out24 = arr.copy();
      const results = inferType2(arr.values);
      out24.values = results.values;
      return checkIfInteger2({ type: results.type, values: out24 });
    }
    if (!isArray2(arr)) {
      const out24 = inferType2([arr]);
      out24.value = out24.values[0];
      delete out24.values;
      return checkIfInteger2(out24);
    }
    assert2(isArray2(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten2(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate2(temp)) {
            return "date";
          }
        }
      } catch (e) {
      }
      if (!isString2(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues2.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues2.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber2(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray2(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e) {
        const vDate = new Date(v);
        if (isDate2(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count2(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger2({
      type: primaryType,
      values: vapply2(arr, (v) => cast2(v, primaryType))
    });
  }
  function inverse2(x) {
    if (isDataFrame2(x)) {
      const out24 = x.copy();
      out24.values = inverse2(out24.values);
      return out24;
    }
    assert2(isArray2(x), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape2(x);
    assert2(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert2(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert2(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x;
    } else if (xShape[0] === 1) {
      assert2(x[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x[0][0];
      let b = x[0][1];
      let c = x[1][0];
      let d = x[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det = a * d - b * c;
      assert2(det !== 0, "This matrix cannot be inverted!");
      const out24 = [
        [d, -b],
        [-c, a]
      ];
      return scale2(out24, 1 / det);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber2(a) || isNumber2(b) ? scale2(a, b) : dot2(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x.slice(0, divider).map((row) => row.slice(0, divider));
          const B = x.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C = x.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse2(A);
          const CompInv = inverse2(vadd2(D, times(-1, times(times(C, AInv), B))));
          const topLeft = vadd2(AInv, times(times(times(times(AInv, B), CompInv), C), AInv));
          const topRight = times(-1, times(times(AInv, B), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C), AInv));
          const bottomRight = CompInv;
          const out24 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out24;
        } catch (e) {
        }
      }
      assert2(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser22 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp2(a, b, f) {
    try {
      if (!isNumber2(a))
        return NaN;
      if (!isNumber2(b))
        return NaN;
      if (!isNumber2(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out24 = lerp2(Number(a), Number(b), f);
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return f * (b - a) + a;
    } catch (e) {
      return NaN;
    }
  }
  var vlerp2 = vectorize2(lerp2);
  function log2(x, base) {
    try {
      base = isUndefined2(base) ? Math.E : base;
      if (!isNumber2(x))
        return NaN;
      if (!isNumber2(base))
        return NaN;
      if (typeof x === "bigint" || typeof base === "bigint") {
        const out24 = log2(Number(x), Number(base));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return Math.log(x) / Math.log(base);
    } catch (e) {
      return NaN;
    }
  }
  var vlog2 = vectorize2(log2);
  function mean2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs }).mean;
  }
  function median2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod2(a, b) {
    try {
      if (!isNumber2(a))
        return NaN;
      if (!isNumber2(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out24 = mod2(Number(a), Number(b));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return a % b;
    } catch (e) {
      return NaN;
    }
  }
  var vmod2 = vectorize2(mod2);
  function mode2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper32() {
    const u1 = random2();
    const u2 = random2();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
  function normal2(shape24) {
    if (isUndefined2(shape24))
      return helper32();
    return vapply2(ndarray2(shape24), helper32);
  }
  function ones2(shape24) {
    return vapply2(ndarray2(shape24), () => 1);
  }
  function permutationsIterator2(x, r) {
    function* helper54(x2, r2) {
      r2 = r2 || x2.length;
      if (x2.length === 1) {
        yield [x2];
        return;
      }
      for (const c of combinations2(x2, r2)) {
        if (!c.slice)
          continue;
        const state = zeros2(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame2(x) || isSeries2(x)) {
      return permutationsIterator2(x.values, r);
    }
    assert2(isArray2(x), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined2(r)) {
      r = x.length;
    }
    assert2(isNumber2(r) && vint2(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper54(flatten2(x), r);
  }
  function permutations2(x, r) {
    const out24 = [];
    for (const perm of permutationsIterator2(x, r)) {
      out24.push(perm.slice());
    }
    return out24;
  }
  function print2() {
    Object.keys(arguments).forEach((key) => {
      const x = arguments[key];
      if (isArray2(x)) {
        if (!isJagged2(x)) {
          const xShape = shape2(x);
          if (xShape.length === 1) {
            new Series2(x).print();
          } else if (xShape.length == 2) {
            new DataFrame2(x).print();
          } else {
            console.log(x);
          }
        } else {
          console.log(x);
        }
      } else if (isDataFrame2(x) || isSeries2(x)) {
        x.print();
      } else {
        console.log(x);
      }
    });
  }
  var helper42 = vectorize2((x, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x, a, b, c, d]) {
        if (!isNumber2(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x = Number(x);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out24 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  });
  function remap2(x, a, b, c, d) {
    if (isArray2(x) && isUndefined2(c) && isUndefined2(d)) {
      c = a;
      d = b;
      const results = stats2(x);
      a = results.min;
      b = results.max;
    }
    return helper42(x, a, b, c, d);
  }
  function round2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.round(x);
    } catch (e) {
      return NaN;
    }
  }
  var vround2 = vectorize2(round2);
  function sign2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint")
        return BigInt(sign2(Number(x)));
      if (x < 0)
        return -1;
      if (x > 0)
        return 1;
      return 0;
    } catch (e) {
      return NaN;
    }
  }
  var vsign2 = vectorize2(sign2);
  function sin2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.sin(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsin2 = vectorize2(sin2);
  function some2(x, fn) {
    if (isDataFrame2(x) || isSeries2(x)) {
      return some2(x.values, fn);
    }
    assert2(isArray2(x), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert2(isFunction2(fn), "The second argument passed into the `some` function must be a function!");
    for (const v of x) {
      if (isArray2(v)) {
        if (some2(v, fn)) {
          return true;
        }
      } else {
        if (fn(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev2(x) {
    return std2(x);
  }
  function tan2(x) {
    try {
      if (!isNumber2(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.tan(x);
    } catch (e) {
      return NaN;
    }
  }
  var vtan2 = vectorize2(tan2);
  function timeSync2(fn, args) {
    assert2(isFunction2(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn(...args);
    } else {
      fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync2(fn, args) {
    assert2(isFunction2(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn(...args);
    } else {
      await fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union2() {
    return set2([...arguments].map((v) => {
      if (isArray2(v))
        return v;
      if (isDataFrame2(v))
        return v.values;
      if (isSeries2(v))
        return v.values;
      return [v];
    }));
  }
  function variance2(arr, shouldDropNaNs) {
    return stats2(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip2() {
    const out24 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame2(arr) || isSeries2(arr)) {
        arr = arr.values;
      }
      assert2(isArray2(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range2(0, max2(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined2(value) ? void 0 : value);
      });
      out24.push(row);
    });
    return out24;
  }
  var out2 = {
    abs: vabs2,
    add: vadd2,
    apply: vapply2,
    arccos: varccos2,
    arcsin: varcsin2,
    arctan: varctan2,
    argmax: argmax2,
    argmin: argmin2,
    assert: assert2,
    cast: cast2,
    ceil: vceil2,
    chop: vchop2,
    clamp: vclamp2,
    combinations: combinations2,
    combinationsIterator: combinationsIterator2,
    copy: copy2,
    correl: correl2,
    cos: vcos2,
    count: count2,
    covariance: covariance2,
    DataFrame: DataFrame2,
    dataTypes: dataTypes2,
    decycle: decycle2,
    diff: diff2,
    distance: distance2,
    divide: divide2,
    dot: dot2,
    dropMissing: dropMissing2,
    dropMissingPairwise: dropMissingPairwise2,
    dropNaN: dropNaN2,
    dropNaNPairwise: dropNaNPairwise2,
    dropUndefined: dropUndefined2,
    every: every2,
    exp: vexp2,
    factorial: vfactorial2,
    find: find2,
    findAll: findAll2,
    flatten: flatten2,
    float: vfloat2,
    floor: vfloor2,
    identity: identity2,
    IndexMatcher: IndexMatcher2,
    indexOf: indexOf2,
    inferType: inferType2,
    int: vint2,
    intersect: intersect2,
    inverse: inverse2,
    isArray: isArray2,
    isBoolean: isBoolean2,
    isBrowser: isBrowser22,
    isDataFrame: isDataFrame2,
    isDate: isDate2,
    isEqual: isEqual2,
    isFunction: isFunction2,
    isJagged: isJagged2,
    isNested: isNested2,
    isNumber: isNumber2,
    isObject: isObject2,
    isSeries: isSeries2,
    isString: isString2,
    isUndefined: isUndefined2,
    lerp: vlerp2,
    log: vlog2,
    MathError: MathError2,
    max: max2,
    mean: mean2,
    median: median2,
    min: min2,
    mod: vmod2,
    mode: mode2,
    multiply: vmultiply2,
    ndarray: ndarray2,
    normal: normal2,
    ones: ones2,
    permutations: permutations2,
    permutationsIterator: permutationsIterator2,
    pow: vpow2,
    print: print2,
    product: product2,
    random: random2,
    range: range2,
    remap: remap2,
    reshape: reshape2,
    reverse: reverse2,
    round: vround2,
    scale: scale2,
    seed: seed2,
    Series: Series2,
    set: set2,
    shape: shape2,
    shuffle: shuffle2,
    sign: vsign2,
    sin: vsin2,
    some: some2,
    sort: sort2,
    sqrt: vsqrt2,
    stats: stats2,
    std: std2,
    stdev: stdev2,
    subtract: subtract2,
    sum: sum2,
    tan: vtan2,
    timeAsync: timeAsync2,
    timeSync: timeSync2,
    time: timeSync2,
    transpose: transpose2,
    union: union2,
    variance: variance2,
    vectorize: vectorize2,
    zeros: zeros2,
    zip: zip2,
    dump() {
      const context4 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context4) {
        throw new out2.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out2).forEach((key) => {
        try {
          Object.defineProperty(context4, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out2[key]
          });
        } catch (e) {
          context4[key] = out2[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out2;
  }

  // src/utils/two-norm.mjs
  function twoNorm(x) {
    return Math.sqrt(dot2(x, x));
  }

  // src/utils/cosine-similarity.mjs
  function cosineSimilarity(a, b) {
    return vclamp2(dot2(a, b) / (twoNorm(a) * twoNorm(b)), 0, 1);
  }

  // src/utils/is-whole-number.mjs
  function isWholeNumber3(x) {
    return typeof x === "number" && !isNaN(x) && x >= 0 && Math.floor(x) === x && x < Infinity;
  }

  // src/utils/string-set.mjs
  var StringSet = class extends Set {
    add(x) {
      if (typeof x !== "string") {
        throw new Error(`\`StringSet\` instances can only contain strings!`);
      }
      return super.add(x);
    }
    addAll(x) {
      x.forEach((v) => this.add(v));
      return this;
    }
    delete(x) {
      if (typeof x !== "string") {
        throw new Error(`\`StringSet\` instances can only contain strings!`);
      }
      return super.delete(x);
    }
    deleteAll(x) {
      x.forEach((v) => this.delete(v));
      return this;
    }
    has(x) {
      if (typeof x !== "string") {
        throw new Error(`\`StringSet\` instances can only contain strings!`);
      }
      return super.has(x);
    }
    hasAll(x) {
      return x.every((v) => this.has(v));
    }
    toArray() {
      return Array.from(this);
    }
    toSortedArray() {
      return sort2(this.toArray());
    }
  };

  // node_modules/@jrc03c/js-type-experiments/dist/js-type-experiments.import.mjs
  function camelify4(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    text = text.trim();
    let out222 = "";
    let shouldCapitalizeNextCharacter = false;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (char.match(/[A-Za-z0-9]/g)) {
        if (out222.length === 0) {
          out222 += char.toLowerCase();
        } else if (shouldCapitalizeNextCharacter) {
          out222 += char.toUpperCase();
        } else {
          out222 += char;
        }
        shouldCapitalizeNextCharacter = false;
      } else if (!char.includes("'") && !char.includes("\u2019") && !char.includes("\u275C")) {
        shouldCapitalizeNextCharacter = true;
      }
    }
    return out222;
  }
  var __defProp4 = Object.defineProperty;
  var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField3 = (obj, key, value) => {
    __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber3(x) {
    return typeof x === "number" && !isNaN(x) || typeof x === "bigint";
  }
  var isBrowser4 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError3 = class extends Error {
    constructor(message) {
      if (isBrowser4()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert3(isTrue, message) {
    if (!isTrue)
      throw new MathError3(message);
  }
  var arrayTypes3 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined3(x) {
    return x === null || typeof x === "undefined";
  }
  var typeStrings3 = arrayTypes3.map((s222) => s222.name);
  function isArray3(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined3(obj.constructor)) {
        return arrayTypes3.indexOf(obj.constructor) > -1 || typeStrings3.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function isDataFrame3(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e) {
      return false;
    }
  }
  function isFunction3(fn) {
    return typeof fn === "function";
  }
  function isObject3(x) {
    return typeof x === "object" && !isUndefined3(x) && !isArray3(x);
  }
  function isSeries3(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e) {
      return false;
    }
  }
  function indexOf3(x, fn) {
    if (isDataFrame3(x)) {
      const index = indexOf3(x.values, fn);
      if (index.length > 0 && isNumber3(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      if (index.length > 1 && isNumber3(index[1]) && index[1] >= 0 && index[1] < x.columns.length) {
        index[1] = x.columns[index[1]];
      }
      return index;
    }
    if (isSeries3(x)) {
      const index = indexOf3(x.values, fn);
      if (index.length > 0 && isNumber3(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      return index;
    }
    assert3(isObject3(x) || isArray3(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction3(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject3(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return [key];
          }
          const results = helper522(value, fn2, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray3(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return [i];
          }
          const results = helper522(value, fn2, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn2(x2)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const paths = helper522(x, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy3(x) {
    function helper522(x2) {
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        if (isArray3(x2)) {
          if (!(x2 instanceof Array)) {
            return x2.slice();
          }
          return x2.map((v) => copy3(v));
        }
        if (isSeries3(x2)) {
          const out32 = x2.copy();
          out32.values = copy3(out32.values);
          return out32;
        }
        if (isDataFrame3(x2)) {
          const out32 = x2.copy();
          out32.values = copy3(x2.values);
          return out32;
        }
        if (x2 instanceof Date) {
          return new Date(x2.getTime());
        }
        x2 = decycle3(x2);
        const out222 = {};
        Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
          out222[key] = copy3(x2[key]);
        });
        return out222;
      } else {
        return x2;
      }
    }
    return helper522(decycle3(x));
  }
  function decycle3(x) {
    function helper522(x2, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x2) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x2;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x2 ? "/" : "/" + indexOf3(orig, x2).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x2 === "object") {
        if (x2 === null)
          return null;
        checked.push(x2);
        if (isArray3(x2)) {
          if (typeof x2.constructor !== "undefined" && x2.constructor.name !== "Array") {
            return x2.slice();
          }
          return x2.map((v, i) => helper522(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
            x2[key] = helper522(x2[key], checked, currentPath + "/" + key.toString());
          });
          return x2;
        }
      } else {
        return x2;
      }
    }
    const orig = x;
    let out222 = helper522(orig);
    if (isDataFrame3(x)) {
      const temp = x.copy();
      temp._values = out222.values;
      temp._columns = out222.columns;
      temp._index = out222.index;
      out222 = temp;
    }
    if (isSeries3(x)) {
      const temp = x.copy();
      temp.name = out222.name;
      temp._values = out222.values;
      temp._index = out222.index;
      out222 = temp;
    }
    return out222;
  }
  function isDate3(x) {
    return x instanceof Date && x.toString() !== "Invalid Date";
  }
  var numberTypes3 = ["number", "int", "float", "bigint"];
  function isEqual3(a, b) {
    function helper522(a2, b2) {
      const aType = typeof a2;
      const bType = typeof b2;
      if (aType !== bType && !numberTypes3.includes(aType) && !numberTypes3.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a2 === b2;
      if (aType === "symbol")
        return a2 === b2;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a2.toString();
          const bString = b2.toString();
          return aString === bString;
        } catch (e) {
          return false;
        }
      }
      if (aType === "string")
        return a2 === b2;
      if (aType === "function")
        return a2 === b2;
      if (aType === "object") {
        if (a2 === null || b2 === null) {
          return a2 === null && b2 === null;
        } else {
          if (isDate3(a2)) {
            if (isDate3(b2)) {
              return a2.getTime() === b2.getTime();
            } else {
              return false;
            }
          } else if (isDate3(b2)) {
            return false;
          }
          if (a2 instanceof RegExp && b2 instanceof RegExp) {
            return a2.toString() === b2.toString();
          }
          if (isArray3(a2) !== isArray3(b2)) {
            return false;
          }
          const aKeys = Object.keys(a2).concat(Object.getOwnPropertySymbols(a2));
          const bKeys = Object.keys(b2).concat(Object.getOwnPropertySymbols(b2));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper522(a2[key], b2[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper522(a, b);
    } catch (e) {
      return helper522(decycle3(a), decycle3(b));
    }
  }
  function makeKey5(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY4 = makeKey5(16);
  var UNDEFINED_KEY4 = makeKey5(16);
  var INFINITY_KEY4 = makeKey5(16);
  var MINUS_INFINITY_KEY4 = makeKey5(16);
  var SYMBOL_KEY4 = makeKey5(16);
  var Counter3 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x) {
      for (const v of x) {
        if (isArray3(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY4 : isUndefined3(value) ? UNDEFINED_KEY4 : isFunction3(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY4 : value === Infinity ? INFINITY_KEY4 : value === -Infinity ? MINUS_INFINITY_KEY4 : typeof value === "bigint" ? value.toString() : isDataFrame3(value) ? value.toJSONString() : isSeries3(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined3(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count222) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count222;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out222 = {};
      this.values.forEach((value) => {
        out222[value] = this.get(value);
      });
      return out222;
    }
  };
  function flatten3(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return flatten3(arr.values);
    }
    assert3(isArray3(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper522(arr2) {
      let out222 = [];
      arr2.forEach((child) => {
        if (isArray3(child)) {
          out222 = out222.concat(helper522(child));
        } else {
          out222.push(child);
        }
      });
      return out222;
    }
    return helper522(arr);
  }
  function stats3(x, options) {
    options = options || {};
    const counts = new Counter3();
    const out222 = {};
    const xflat = flatten3(x);
    const xnums = [];
    let max222 = -Infinity;
    let min222 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum222 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber3(v)) {
        try {
          if (v > max222) {
            max222 = v;
          }
          if (v < min222) {
            min222 = v;
          }
          sum222 += Number(v);
          xnums.push(v);
        } catch (e) {
          max222 = NaN;
          min222 = NaN;
          sum222 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean222 = sum222 / xnums.length;
    out222.counts = counts;
    out222.max = max222;
    out222.mean = mean222;
    out222.min = min222;
    out222.n = xflat.length;
    out222.sum = sum222;
    if (isNaN(out222.mean)) {
      out222.max = NaN;
      out222.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out222.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode222 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode222.push(pair[0]);
        } else {
          break;
        }
      }
      out222.mode = mode222.toSorted();
    }
    if (options.median) {
      if (isNaN(mean222)) {
        out222.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out222.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out222.median = BigInt(out222.median);
            } catch (e) {
            }
          }
        } else {
          out222.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance222 = 0;
      for (const v of xnums) {
        variance222 += Math.pow(Number(v) - mean222, 2);
      }
      variance222 /= xnums.length;
      const stdev222 = Math.sqrt(variance222);
      out222.stdev = stdev222;
      out222.variance = variance222;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out222.sum = BigInt(out222.sum);
      } catch (e) {
      }
      try {
        out222.mean = BigInt(out222.mean);
      } catch (e) {
      }
      if (options.mode) {
        out222.mode = out222.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e) {
            return v;
          }
        });
      }
    }
    return out222;
  }
  function count3(arr, matcher) {
    const { counts } = stats3(arr);
    if (!isUndefined3(matcher)) {
      if (isFunction3(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual3(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper6(x) {
    if (isDataFrame3(x) || isSeries3(x)) {
      return helper6(x.values);
    }
    if (isArray3(x)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x) {
        if (helper6(v)) {
          return true;
        }
        if (isArray3(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged3(x) {
    return helper6(decycle3(x));
  }
  function isNested3(x) {
    if (isDataFrame3(x) || isSeries3(x)) {
      return isNested3(x.values);
    }
    assert3(isArray3(x), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x.length; i++) {
      if (isArray3(x[i])) {
        return true;
      }
    }
    return false;
  }
  var error3 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray3(shape222) {
    assert3(!isUndefined3(shape222), error3);
    if (!isArray3(shape222))
      shape222 = [shape222];
    assert3(!isNested3(shape222), error3);
    assert3(shape222.length > 0, error3);
    let s222 = shape222[0];
    if (typeof s222 === "bigint")
      s222 = Number(s222);
    assert3(isNumber3(s222), error3);
    assert3(s222 >= 0, error3);
    assert3(Math.floor(s222) === s222, error3);
    assert3(s222 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape222.length === 1) {
      const out222 = [];
      for (let i = 0; i < s222; i++)
        out222.push(void 0);
      return out222;
    } else {
      const out222 = [];
      for (let i = 0; i < s222; i++) {
        out222.push(ndarray3(shape222.slice(1)));
      }
      return out222;
    }
  }
  function reverse3(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      const out32 = arr.copy();
      out32.values = reverse3(out32.values);
      out32.index = reverse3(out32.index);
      return out32;
    }
    assert3(isArray3(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out222.push(arr[i]);
    return out222;
  }
  function range3(a, b, step = 1) {
    assert3(!isUndefined3(a) && !isUndefined3(b) && !isUndefined3(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert3(isNumber3(a) && isNumber3(b) && isNumber3(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert3(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out222 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out222.push(BigInt(i));
        } catch (e) {
          out222.push(i);
        }
      } else {
        out222.push(i);
      }
    }
    if (shouldReverse)
      out222 = reverse3(out222);
    return out222;
  }
  function makeKey23(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY23 = makeKey23(256);
  var UNDEFINED_KEY23 = makeKey23(256);
  var INFINITY_KEY23 = makeKey23(256);
  var MINUS_INFINITY_KEY23 = makeKey23(256);
  var SYMBOL_KEY23 = makeKey23(256);
  function set3(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return set3(arr.values);
    }
    assert3(isArray3(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = {};
    flatten3(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY23 : isUndefined3(item) ? UNDEFINED_KEY23 : isFunction3(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY23 : item === Infinity ? INFINITY_KEY23 : item === -Infinity ? MINUS_INFINITY_KEY23 : typeof item === "bigint" ? item.toString() : isDataFrame3(item) ? item.toJSONString() : isSeries3(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out222.push(item);
      temp[key] = true;
    });
    return out222;
  }
  function helper23(x) {
    if (isArray3(x)) {
      const childShapes = helper23(x[0]);
      return [x.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape3(x) {
    if (isDataFrame3(x) || isSeries3(x)) {
      return shape3(x.values);
    }
    assert3(isArray3(x), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper23(x);
  }
  function dfAppend3(df, x, axis) {
    if (isUndefined3(axis)) {
      axis = 0;
    }
    assert3(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray3(x)) {
      assert3(!isJagged3(x), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape3(x);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out222 = df.copy();
          out222._values.push(x);
          const maxRowLength = Math.max(df.shape[1], xShape[0]);
          out222._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out222 = df.copy();
          range3(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray3(df.shape[1]));
            }
            out222._values[i].push(x[i]);
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < out222._values[0].length) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x.map((row) => row.length).concat([df.shape[1]]));
          const out222 = df.copy();
          out222._values = out222._values.concat(x).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxRowLength = Math.max(...x.map((row) => row.length)) + df.shape[1];
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out222 = df.copy();
          range3(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray3(df.shape[1]));
            }
            out222._values[i] = out222._values[i].concat(x[i]);
            while (out222._values[i].length < maxRowLength) {
              out222._values[i].push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else {
        throw new MathError3("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries3(x)) {
      const out222 = dfAppend3(df, x.values, axis);
      if (axis === 0) {
        out222.index[out222.index.length - 1] = out222.index.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      } else {
        out222.columns[out222.columns.length - 1] = out222.columns.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      }
      return out222;
    } else if (isDataFrame3(x)) {
      if (axis === 0) {
        const out222 = df.copy();
        const maxRowLength = set3(out222._columns.concat(x._columns)).length;
        out222._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out222._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out222._values.push(temp.concat(rowCopy._values));
        }, 1);
        out222._columns = out222._columns.concat(x._columns.filter((c) => out222._columns.indexOf(c) < 0));
        while (out222._index.length < out222._values.length) {
          const newRowName = "row" + out222._index.length;
          out222._index.push(newRowName + (df._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out222;
      } else {
        const out222 = df.copy();
        out222._index.forEach((rowName, i) => {
          const xIndex = x._index.indexOf(rowName);
          if (xIndex > -1) {
            out222._values[i] = out222._values[i].concat(x._values[xIndex]);
          } else {
            out222._values[i] = out222._values[i].concat(ndarray3(x.shape[1]));
          }
        });
        x._index.forEach((rowName, i) => {
          const outIndex = out222._index.indexOf(rowName);
          if (outIndex < 0) {
            out222._index.push(rowName);
            out222._values.push(ndarray3(out222._columns.length).concat(x._values[i]));
          }
        });
        out222._columns = out222._columns.concat(x._columns.map((c) => c + (out222._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out222;
      }
    } else {
      throw new MathError3("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply3(DataFrame222, Series222, df, fn, axis) {
    axis = axis || 0;
    assert3(isFunction3(fn), "The first parameter to the `apply` method must be a function.");
    assert3(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df.columns.forEach((colName, i) => {
        const series = new Series222(df.values.map((row) => row[i]));
        series.name = colName;
        series.index = df.index;
        const value = fn(series, i, df);
        if (value instanceof Series222) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined3(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray3(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df.index;
        return out222;
      } else {
        const out222 = new Series222(df.columns.map((colName) => temp[colName]));
        out222.index = df.columns;
        return out222;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df.values.map((row, i) => {
        const series = new Series222(row);
        series.name = df.index[i];
        series.index = df.columns;
        const value = fn(series, i, df);
        if (isUndefined3(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray3(value);
        }
        if (value instanceof Series222) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df.index;
        out222.columns = df.columns;
        return out222;
      } else {
        const out222 = new Series222(temp);
        out222.index = df.index;
        return out222;
      }
    }
  }
  function isString3(s222) {
    return typeof s222 === "string";
  }
  function dfAssign3(DataFrame222, Series222, df, p1, p2) {
    const isDataFrame222 = (x) => x instanceof DataFrame222;
    const isSeries222 = (x) => x instanceof Series222;
    if (!isUndefined3(p2)) {
      assert3(isString3(p1), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert3(isArray3(p2) && !isJagged3(p2) && shape3(p2).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out222 = df.append(p2, 1);
      out222.columns[out222.columns.length - 1] = p1;
      return out222;
    } else {
      if (isDataFrame222(p1)) {
        return df.append(p1, 1);
      } else if (isSeries222(p1)) {
        return df.append(p1, 1);
      } else if (isObject3(p1)) {
        const maxColumnLength = Math.max(...Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).map((key) => p1[key].length));
        Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).forEach((key) => {
          while (p1[key].length < maxColumnLength) {
            p1[key].push(void 0);
          }
        });
        return df.append(new DataFrame222(p1), 1);
      } else {
        throw new MathError3("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy3(DataFrame222, df) {
    if (df.isEmpty)
      return new DataFrame222();
    const out222 = new DataFrame222(copy3(df.values));
    out222.columns = df.columns.slice();
    out222.index = df.index.slice();
    return out222;
  }
  function dfDrop3(DataFrame222, Series222, df, rows, cols) {
    if (isUndefined3(rows))
      rows = [];
    if (isUndefined3(cols))
      cols = [];
    if (isString3(rows) || isNumber3(rows))
      rows = [rows];
    if (isString3(cols) || isNumber3(cols))
      cols = [cols];
    assert3(isArray3(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert3(isArray3(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert3(shape3(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert3(shape3(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out222 = df.get(outIndex, outColumns);
    if (out222 instanceof Series222) {
      let temp = new DataFrame222();
      temp = temp.assign(out222);
      if (df.index.indexOf(out222.name) > -1)
        temp = temp.transpose();
      out222 = temp;
    }
    return out222;
  }
  function isInteger3(x) {
    return isNumber3(x) && (x >= 0 ? Math.floor(x) === x : Math.ceil(x) === x);
  }
  function isWholeNumber4(x) {
    return isInteger3(x) && x >= 0;
  }
  function dfDropMissing3(DataFrame222, Series222, df, axis, condition, threshold) {
    axis = axis || 0;
    assert3(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert3(isWholeNumber4(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert3(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper522(values) {
      if (threshold > 0) {
        let count222 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined3(value))
            count222++;
          if (count222 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined3(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined3(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out222 = df.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out222 = out222.assign(tempID, out222.index);
      const newValues = out222.values.map(helper522).filter((row) => row.length > 0);
      if (shape3(newValues).length < 2)
        return new DataFrame222();
      out222.values = newValues;
      let newIndex = out222.get(null, tempID);
      if (isUndefined3(newIndex))
        return new DataFrame222();
      if (isString3(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series222)
        newIndex = newIndex.values;
      out222.index = newIndex;
      out222 = out222.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out222.columns.forEach((colName, i) => {
        const values = out222.values.map((row) => row[i]);
        const newValues = helper522(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame222();
      }
      const newOut = new DataFrame222(temp);
      newOut.index = out222.index;
      return newOut;
    }
    return out222;
  }
  function dropNaN3(x) {
    if (isDataFrame3(x) || isSeries3(x)) {
      return x.dropNaN(...Object.values(arguments).slice(1));
    }
    assert3(isArray3(x), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x.forEach((v) => {
      try {
        return out222.push(dropNaN3(v));
      } catch (e) {
        if (isNumber3(v)) {
          return out222.push(v);
        }
      }
    });
    return out222;
  }
  function dfDropNaN3(DataFrame222, df, axis, condition, threshold) {
    axis = axis || 0;
    assert3(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert3(isWholeNumber4(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert3(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper522(values) {
      const numericalValues = dropNaN3(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out222 = df.copy();
    if (axis === 0) {
      const rowsToKeep = out222.index.filter((row) => {
        const values = out222.get(row, null).values;
        return helper522(values);
      });
      if (rowsToKeep.length > 0)
        return out222.get(rowsToKeep, null);
      else
        return new DataFrame222();
    } else if (axis === 1) {
      const colsToKeep = out222.columns.filter((col) => {
        const values = out222.get(null, col).values;
        return helper522(values);
      });
      if (colsToKeep.length > 0)
        return out222.get(null, colsToKeep);
      else
        return new DataFrame222();
    }
    return out222;
  }
  function arrayToObject3(x) {
    const out222 = {};
    flatten3(x).forEach((value, i) => {
      out222[value] = i;
    });
    return out222;
  }
  function undoArrayToObject3(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter3(DataFrame222, Series222, df, fn, axis) {
    assert3(isFunction3(fn), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined3(axis))
      axis = 0;
    assert3(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out222 = df.copy();
    if (out222.isEmpty)
      return out222;
    const index = arrayToObject3(out222.index);
    const columns = arrayToObject3(out222.columns);
    if (axis === 0) {
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df.index[i];
        series.index = df.columns;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count222++;
        } else {
          delete index[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject3(index)[0];
        temp.index = undoArrayToObject3(columns);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject3(index);
    } else if (axis === 1) {
      out222 = out222.transpose();
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df.columns[i];
        series.index = df.index;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count222++;
        } else {
          delete columns[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject3(columns)[0];
        temp.index = undoArrayToObject3(index);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject3(columns);
      out222 = out222.transpose();
    }
    return out222;
  }
  function dfGet3(df, rows, cols) {
    if (isString3(rows) || isNumber3(rows))
      rows = [rows];
    if (isString3(cols) || isNumber3(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set3((rows || []).concat(cols || []).map((v) => typeof v));
    assert3(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert3(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert3(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert3(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined3(rows)) {
      rows = rows.map((r) => {
        if (isString3(r)) {
          assert3(df.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber3(r)) {
          assert3(r >= 0, `Index ${r} is out of bounds!`);
          assert3(Math.floor(r) === r, `Row numbers must be integers!`);
          assert3(r < df.index.length, `Index ${r} is out of bounds!`);
          return df.index[r];
        }
      });
    }
    if (!isUndefined3(cols)) {
      cols = cols.map((c) => {
        if (isString3(c)) {
          assert3(df.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber3(c)) {
          assert3(c >= 0, `Column ${c} is out of bounds!`);
          assert3(Math.floor(c) === c, `Column numbers must be integers!`);
          assert3(c < df.columns.length, `Column ${c} is out of bounds!`);
          return df.columns[c];
        }
      });
    }
    return df.getSubsetByNames(rows, cols);
  }
  function alphaSort3(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort3(arr, fn) {
    if (isUndefined3(fn))
      fn = alphaSort3;
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert3(isArray3(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert3(isFunction3(fn), "The second parameter of the `sort` function must be a comparison function!");
    const out222 = arr.slice();
    out222.sort(fn);
    return out222;
  }
  function camelify22(text) {
    const temp = text.toLowerCase();
    let out222 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out222 += char;
      } else {
        out222 += " ";
      }
    }
    const words = out222.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies3(DataFrame222, df, columns) {
    if (isUndefined3(columns)) {
      columns = df.columns;
    } else if (isString3(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert3(isString3(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df.columns.indexOf(col);
      assert3(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df.values.map((row) => row[colIndex]);
      const valuesSet = sort3(set3(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify22(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out222 = new DataFrame222(temp);
    out222.index = df.index;
    return out222;
  }
  function dfGetSubsetByIndices3(df, rowIndices, colIndices) {
    const dataShape = df.shape;
    if (isUndefined3(rowIndices))
      rowIndices = range3(0, dataShape[0]);
    if (isUndefined3(colIndices))
      colIndices = range3(0, dataShape[1]);
    if (isNumber3(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber3(colIndices))
      colIndices = [colIndices];
    assert3(isArray3(rowIndices) && isArray3(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert3(shape3(rowIndices).length === 1 && shape3(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert3(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert3(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert3(isWholeNumber4(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert3(rowIndex < df.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert3(isWholeNumber4(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert3(colIndex < df.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df.index[i]);
    const cols = colIndices.map((i) => df.columns[i]);
    return df.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames3(DataFrame222, Series222, df, rows, cols) {
    if (isUndefined3(rows))
      rows = df.index;
    if (isUndefined3(cols))
      cols = df.columns;
    if (isString3(rows))
      rows = [rows];
    if (isString3(cols))
      cols = [cols];
    assert3(isArray3(rows) && isArray3(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert3(shape3(rows).length === 1 && shape3(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert3(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert3(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert3(isString3(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert3(df.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert3(isString3(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert3(df.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df.values[df.index.indexOf(row)][df.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series222(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series222(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out222 = new DataFrame222(values);
    out222.columns = cols;
    out222.index = rows;
    return out222;
  }
  function dfPrint3(DataFrame222, Series222, df) {
    function truncate(s222, maxLength2) {
      if (isString3(s222)) {
        if (s222.length > maxLength2) {
          return s222.substring(0, maxLength2 - 3) + "...";
        } else {
          return s222;
        }
      } else {
        return s222;
      }
    }
    if (df.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df.index.length ? null : range3(0, halfMaxRows).concat(range3(df.index.length - halfMaxRows, df.index.length));
    const tempColumns = maxColumns > df.columns.length ? null : range3(0, halfMaxColumns).concat(range3(df.columns.length - halfMaxColumns, df.columns.length));
    let temp = df.get(tempRows, tempColumns);
    if (temp instanceof Series222) {
      if (df.shape[0] === 1) {
        temp = new DataFrame222([temp.values]);
        temp.index = df.index;
        temp.columns = new Series222(df.columns).get(tempColumns).values;
      } else if (df.shape[1] === 1) {
        temp = new DataFrame222([temp.values]).transpose();
        temp.index = new Series222(df.index).get(tempRows).values;
        temp.columns = df.columns;
      }
    }
    if (maxRows <= df.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range3(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series222) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df.shape, "\n");
    return df;
  }
  function leftPad3(x, maxLength) {
    assert3(isNumber3(x), "The `leftPad` function only works on numbers!");
    let out222 = x.toString();
    while (out222.length < maxLength)
      out222 = "0" + out222;
    return out222;
  }
  function dfResetIndex3(df, shouldSkipCopying) {
    const out222 = shouldSkipCopying ? df : df.copy();
    out222.index = range3(0, df.shape[0]).map((i) => {
      return "row" + leftPad3(i, (out222.index.length - 1).toString().length);
    });
    return out222;
  }
  function product3(arr, shouldDropNaNs) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return product3(arr.values, shouldDropNaNs);
    }
    assert3(isArray3(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten3(arr);
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of temp) {
        if (!isNumber3(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  function isNaturalNumber3(x) {
    return isInteger3(x) && x > 0;
  }
  function reshape3(x, newShape) {
    if (isDataFrame3(x) || isSeries3(x)) {
      return reshape3(x.values, newShape);
    }
    assert3(isArray3(x), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber3(newShape))
      newShape = [newShape];
    assert3(isArray3(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert3(shape3(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert3(isNaturalNumber3(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten3(x);
    }
    const temp = flatten3(x);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert3(product3(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out222 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out222.push(reshape3(row, newShape.slice(1)));
    }
    return out222;
  }
  var MAX3 = Math.pow(2, 64);
  var s3 = [];
  seed3(Math.floor(Math.random() * MAX3));
  function splitmix643(state, n) {
    state = uint3(state);
    function helper522() {
      state += uint3("0x9e3779b97f4a7c15");
      let z = copy3(state);
      z = (z ^ z >> BigInt(30)) * uint3("0xbf58476d1ce4e5b9");
      z = (z ^ z >> BigInt(27)) * uint3("0x94d049bb133111eb");
      return z ^ z >> BigInt(31);
    }
    const out222 = [];
    for (let i = 0; i < n; i++)
      out222.push(helper522());
    return out222;
  }
  function uint3(x) {
    return BigInt.asUintN(64, BigInt(x));
  }
  function rotl3(x, k) {
    x = uint3(x);
    k = BigInt(k);
    return uint3(uint3(x << k) | uint3(x >> uint3(BigInt(64) - k)));
  }
  function seed3(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined3(val)) {
      assert3(isNumber3(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix643(Math.floor(val), 4);
      s3[0] = temp[0];
      s3[1] = temp[1];
      s3[2] = temp[2];
      s3[3] = temp[3];
    } else {
      return copy3(s3);
    }
  }
  function next3() {
    const result = uint3(rotl3(s3[0] + s3[3], 23) + s3[0]);
    const t = uint3(s3[1] << BigInt(17));
    s3[2] = uint3(s3[2] ^ s3[0]);
    s3[3] = uint3(s3[3] ^ s3[1]);
    s3[1] = uint3(s3[1] ^ s3[2]);
    s3[0] = uint3(s3[0] ^ s3[3]);
    s3[2] = uint3(s3[2] ^ t);
    s3[3] = rotl3(s3[3], 45);
    return Math.floor(Number(result)) / MAX3;
  }
  function random3(shape222) {
    if (isUndefined3(shape222))
      return next3();
    if (!isArray3(shape222))
      shape222 = [shape222];
    return reshape3(ndarray3(product3(shape222)).map(next3), shape222);
  }
  function shuffle3(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert3(isArray3(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random3() * temp.length);
      out222.push(temp.splice(index, 1)[0]);
    }
    return out222;
  }
  function dfShuffle3(df, axis) {
    if (isUndefined3(axis))
      axis = 0;
    assert3(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df.get(axis === 0 ? shuffle3(df.index) : null, axis === 1 ? shuffle3(df.columns) : null);
  }
  function isBoolean3(x) {
    return typeof x === "boolean";
  }
  function dfSort3(df, a, b) {
    if (isFunction3(a)) {
      return dfSortByFunction3(df, a, b);
    } else {
      return dfSortByColumns3(df, a, b);
    }
  }
  function dfSortByFunction3(df, fn, axis) {
    axis = isUndefined3(axis) ? 0 : axis;
    assert3(isFunction3(fn), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert3(isNumber3(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort3(df.index, (a, b) => {
        return fn(df.get(a, null), df.get(b, null));
      });
      return df.get(index, null);
    } else {
      const columns = sort3(df.columns, (a, b) => {
        return fn(df.get(null, a), df.get(null, b));
      });
      return df.get(null, columns);
    }
  }
  function dfSortByColumns3(df, cols, directions) {
    let out222 = df.copy();
    const indexID = random3().toString();
    out222 = out222.assign(indexID, out222.index);
    if (isUndefined3(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber3(cols) || isString3(cols)) {
      cols = [cols];
      if (isBoolean3(directions) || isString3(directions))
        directions = [directions];
    }
    assert3(isArray3(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert3(shape3(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined3(directions))
      directions = range3(0, cols.length).map(() => true);
    assert3(isArray3(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert3(shape3(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert3(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert3(isString3(col) || isNumber3(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString3(col)) {
        const index = out222.columns.indexOf(col);
        assert3(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber3(col)) {
        assert3(isWholeNumber4(col), "Column indices must be whole numbers!");
        assert3(col < out222.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert3(isString3(dir) || isBoolean3(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString3(dir)) {
        const value = dir.trim().toLowerCase();
        assert3(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean3(dir)) {
        return dir;
      }
    });
    out222.values = sort3(out222.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out222.columns.indexOf(indexID);
    out222.index = out222.values.map((row) => row[indexNumber]);
    out222 = out222.dropColumns(indexID);
    return out222;
  }
  function dfToDetailedObject3(df, axis) {
    if (isUndefined3(axis)) {
      axis = 0;
    } else {
      assert3(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out222 = {};
    if (axis === 0) {
      df.index.forEach((rowName, i) => {
        const temp = {};
        df.columns.forEach((colName, j) => {
          temp[colName] = df.values[i][j];
        });
        out222[rowName] = temp;
      });
    } else {
      df.columns.forEach((colName, j) => {
        const temp = {};
        df.index.forEach((rowName, i) => {
          temp[rowName] = df.values[i][j];
        });
        out222[colName] = temp;
      });
    }
    return out222;
  }
  function dfToJSONString3(df, axis) {
    return JSON.stringify(df.toObject(axis));
  }
  async function dfToJSON3(df, filename, axis) {
    const out222 = dfToJSONString3(df, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out222)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e) {
      browserError = e;
    }
    try {
      const fs = await import("node:fs");
      const path = await import("node:path");
      fs.writeFileSync(path.resolve(filename), out222, "utf8");
      wroteToDiskInNode = true;
    } catch (e) {
      nodeError = e;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError3(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError3(nodeError);
      } else {
        throw new MathError3("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df;
  }
  function dfToObject3(df) {
    const out222 = {};
    df.columns.forEach((col) => {
      out222[col] = df.get(col).values;
    });
    return out222;
  }
  function transpose3(arr) {
    if (isDataFrame3(arr) || isSeries3(arr)) {
      return arr.transpose();
    }
    assert3(isArray3(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape3(arr);
    assert3(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse3(arr);
    } else if (theShape.length === 2) {
      const out222 = ndarray3(reverse3(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out222[col][row] = arr[row][col];
        }
      }
      return out222;
    }
  }
  function seriesAppend3(Series222, series, x) {
    if (isSeries3(x)) {
      return new Series222(series.values.concat(x.values));
    }
    if (isArray3(x)) {
      const xShape = shape3(x);
      assert3(xShape.length === 1 && !isNested3(xShape), "Only vectors can be appended to Series!");
      const out222 = series.copy();
      x.forEach((v, i) => {
        out222._values.push(v);
        out222._index.push("item" + (series.values.length + i));
      });
      return out222;
    }
    return seriesAppend3(series, [x]);
  }
  function seriesApply3(series, fn) {
    assert3(isFunction3(fn), "The parameter to the `apply` method must be a function.");
    const out222 = series.copy();
    out222._values = out222._values.map((v, i) => fn(v, i));
    return out222;
  }
  function seriesDropMissing3(series) {
    const out222 = series.copy();
    const outIndex = [];
    out222._values = out222.values.filter((v, i) => {
      if (isUndefined3(v)) {
        return false;
      } else {
        outIndex.push(out222.index[i]);
        return true;
      }
    });
    out222._index = outIndex;
    return out222;
  }
  function seriesDropNaN3(Series222, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber3(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out222 = new Series222(values);
    out222.name = series.name;
    out222.index = index;
    return out222;
  }
  function seriesFilter3(Series222, series, fn) {
    let out222 = series.copy();
    const index = copy3(out222.index);
    const indicesToRemove = [];
    const newValues = out222.values.filter((value, i) => {
      const shouldKeep = fn(value, i, out222.values);
      if (!shouldKeep)
        indicesToRemove.push(out222.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out222 = new Series222();
      out222.name = series.name;
      return out222;
    }
    out222.values = newValues;
    out222.index = index;
    return out222;
  }
  function seriesGet3(series, indices) {
    if (isString3(indices) || isNumber3(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set3((indices || []).map((v) => typeof v));
    assert3(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert3(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert3(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert3(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined3(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert3(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert3(i >= 0, `Index ${i} is out of bounds!`);
          assert3(Math.floor(i) === i, `Indices must be integers!`);
          assert3(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices3(series, indices) {
    const dataShape = series.shape;
    if (isUndefined3(indices))
      indices = range3(0, dataShape[0]);
    assert3(isArray3(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert3(shape3(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert3(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert3(isWholeNumber4(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert3(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames3(Series222, series, indices) {
    if (isUndefined3(indices))
      indices = series.index;
    assert3(isArray3(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert3(shape3(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert3(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert3(isString3(name), "The `indices` array must contain only strings.");
      assert3(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out222 = new Series222(values);
    out222.index = indices;
    out222.name = series.name;
    return out222;
  }
  function seriesPrint3(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range3(0, maxRows / 2).concat(range3(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy3(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out222 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out222[temp.index[i]] = obj;
    });
    console.table(out222);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle3(series) {
    const out222 = series.copy();
    return out222.get(shuffle3(out222.index));
  }
  function seriesSort3(Series222, series, fn) {
    fn = fn || ((a, b) => a < b ? -1 : 1);
    assert3(isUndefined3(fn) || isFunction3(fn), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose3([series.values, series.index]);
    const temp = sort3(pairs, (aPair, bPair) => {
      return fn(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out222 = new Series222();
    out222._values = newValues;
    out222._index = newIndex;
    out222.name = series.name;
    return out222;
  }
  function seriesSortByIndex3(Series222, series) {
    let temp = transpose3([series.values, series.index]);
    temp = transpose3(sort3(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out222 = new Series222(temp[0]);
    out222.index = temp[1];
    out222.name = series.name;
    return out222;
  }
  function seriesToObject3(series) {
    const out222 = {};
    out222[series.name] = {};
    series.index.forEach((index, i) => {
      out222[series.name][index] = series.values[i];
    });
    return out222;
  }
  var SERIES_SYMBOL3 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass3(DataFrame222) {
    class Series222 {
      static [Symbol.hasInstance](x) {
        try {
          return !!x._symbol && x._symbol === SERIES_SYMBOL3;
        } catch (e) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL3
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x) {
            assert3(isArray3(x), "The new values must be a 1-dimensional array!");
            const dataShape = shape3(x);
            assert3(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range3(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad3(i, (x.length - 1).toString().length);
              }));
            }
            this._values = x;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x) {
            assert3(isArray3(x), "The new index must be a 1-dimensional array of strings!");
            assert3(x.length === this.shape[0], "The new index must be the same length as the old index!");
            assert3(shape3(x).length === 1, "The new index must be a 1-dimensional array of strings!");
            x.forEach((value) => {
              assert3(isString3(value), "All of the row names must be strings!");
            });
            this._index = x;
          }
        });
        if (data) {
          if (data instanceof Series222) {
            this.name = data.name;
            this.values = copy3(data.values);
            this.index = copy3(data.index);
          } else if (isArray3(data)) {
            const dataShape = shape3(data);
            assert3(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert3(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert3(shape3(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape3(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined3(v)).length === 0;
      }
      clear() {
        const out222 = this.copy();
        out222.values.forEach((v, i) => {
          out222.values[i] = void 0;
        });
        return out222;
      }
      get(indices) {
        return seriesGet3(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames3(Series222, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices3(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out222 = new Series222(reverse3(this.values));
        out222.index = reverse3(this.index);
        out222.name = this.name;
        return out222;
      }
      resetIndex() {
        const out222 = this.copy();
        out222.index = range3(0, this.shape[0]).map((i) => {
          return "item" + leftPad3(i, (out222.index.length - 1).toString().length);
        });
        return out222;
      }
      copy() {
        const out222 = new Series222();
        out222._values = copy3(this.values);
        out222._index = copy3(this.index);
        out222.name = this.name;
        return out222;
      }
      append(x) {
        return seriesAppend3(Series222, this, x);
      }
      apply(fn) {
        return seriesApply3(this, fn);
      }
      concat(x) {
        return this.append(x);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing3(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN3(Series222, this);
      }
      toObject() {
        return seriesToObject3(this);
      }
      print() {
        return seriesPrint3(this);
      }
      shuffle() {
        return seriesShuffle3(this);
      }
      sort(direction) {
        return seriesSort3(Series222, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex3(Series222, this);
      }
      filter(fn) {
        return seriesFilter3(Series222, this, fn);
      }
      toDataFrame() {
        const out222 = new DataFrame222(transpose3([this.values]));
        out222.columns = [this.name];
        out222.index = this.index;
        return out222;
      }
      transpose() {
        const out222 = this.copy();
        out222.values = reverse3(out222.values);
        out222.index = reverse3(out222.index);
        return out222;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series222;
  }
  var DATAFRAME_SYMBOL3 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey33(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out222 = "";
    for (let i = 0; i < n; i++)
      out222 += alpha[Math.floor(random3() * alpha.length)];
    return out222;
  }
  var DataFrame3 = class {
    static [Symbol.hasInstance](x) {
      try {
        return !!x._symbol && x._symbol === DATAFRAME_SYMBOL3;
      } catch (e) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL3
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined3(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x) {
          assert3(isArray3(x), "The new values must be a 2-dimensional array!");
          const dataShape = shape3(x);
          assert3(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range3(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad3(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range3(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad3(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x) {
          assert3(isArray3(x), "The new columns list must be a 1-dimensional array of strings!");
          assert3(this.isEmpty || x.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert3(shape3(x).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey33(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count3(x);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey33(8);
            }
            return v;
          });
          this._columns = x;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x) {
          assert3(isArray3(x), "The new index must be a 1-dimensional array of strings!");
          assert3(this.isEmpty || x.length === this.shape[0], "The new index must be the same length as the old index!");
          assert3(shape3(x).length === 1, "The new index must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey33(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count3(x);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey33(8);
            }
            return v;
          });
          this._index = x;
        }
      });
      assert3(isUndefined3(data) || isObject3(data) || isArray3(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame3) {
          this.values = copy3(data.values);
          this.columns = copy3(data.columns);
          this.index = copy3(data.index);
        } else if (isArray3(data)) {
          const dataShape = shape3(data);
          assert3(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert3(!isJagged3(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined3(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert3(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose3(temp);
          const dataShape = shape3(this.values);
          this._index = range3(0, dataShape[0]).map((i) => {
            return "row" + leftPad3(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape3(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out222 = new DataFrame3(ndarray3(this.shape));
      out222.columns = this.columns.slice();
      out222.index = this.index.slice();
      return out222;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e) {
          return this.get(rows, null);
        }
      }
      return dfGet3(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames3(DataFrame3, Series3, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices3(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies3(DataFrame3, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies3(DataFrame3, this, columns);
    }
    transpose() {
      const out222 = new DataFrame3(transpose3(this.values));
      out222.columns = this.index.slice();
      out222.index = this.columns.slice();
      return out222;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex3(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy3(DataFrame3, this);
    }
    assign(p1, p2) {
      return dfAssign3(DataFrame3, Series3, this, p1, p2);
    }
    apply(fn, axis) {
      return dfApply3(DataFrame3, Series3, this, fn, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing3(DataFrame3, Series3, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN3(DataFrame3, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop3(DataFrame3, Series3, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject3(this, axis);
    }
    toObject() {
      return dfToObject3(this);
    }
    toJSONString(axis) {
      return dfToJSONString3(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON3(this, filename, axis);
    }
    print() {
      return dfPrint3(DataFrame3, Series3, this);
    }
    sort(cols, directions) {
      return dfSort3(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn, axis) {
      return dfFilter3(DataFrame3, Series3, this, fn, axis);
    }
    shuffle(axis) {
      return dfShuffle3(this, axis);
    }
    append(x, axis) {
      return dfAppend3(this, x, axis);
    }
    concat(x, axis) {
      return this.append(x, axis);
    }
    join(x, axis) {
      return this.append(x, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series3 = createSeriesClass3(DataFrame3);
  function max3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs }).max;
  }
  function vectorize3(fn) {
    assert3(isFunction3(fn), "You must pass a function into the `vectorize` function!");
    return function helper522() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray3(arg)) {
          return true;
        } else if (isSeries3(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame3(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s222, i) => {
        assert3(isEqual3(isArray3(s222) ? shape3(s222) : s222.shape, isArray3(childArrays[i + 1]) ? shape3(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max3(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out222 = range3(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray3(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries3(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame3(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper522(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual3(shape3(dataframes[0]), shape3(out222))) {
              const temp = new DataFrame3(out222);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame3(out222);
            }
          } catch (e) {
            return out222;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out222.length) {
              const temp = new Series3(out222);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series3(out222);
            }
          } catch (e) {
            return out222;
          }
        }
        return out222;
      } else {
        return fn(...arguments);
      }
    };
  }
  function abs3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        return x < 0 ? -x : x;
      } else {
        return Math.abs(x);
      }
    } catch (e) {
      return NaN;
    }
  }
  var vabs3 = vectorize3(abs3);
  function add3() {
    try {
      let out222 = 0;
      let resultShouldBeABigInt = false;
      const x = Object.values(arguments);
      for (let v of x) {
        if (!isNumber3(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  var vadd3 = vectorize3(add3);
  function apply3(x, fn) {
    try {
      return fn(x);
    } catch (e) {
      return NaN;
    }
  }
  var vapply3 = vectorize3(apply3);
  function arccos3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.acos(x);
    } catch (e) {
      return NaN;
    }
  }
  var varccos3 = vectorize3(arccos3);
  function arcsin3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.asin(x);
    } catch (e) {
      return NaN;
    }
  }
  var varcsin3 = vectorize3(arcsin3);
  function arctan3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.atan(x);
    } catch (e) {
      return NaN;
    }
  }
  var varctan3 = vectorize3(arctan3);
  function argmax3(x, shouldDropNaNs) {
    if (isDataFrame3(x)) {
      const index = argmax3(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries3(x)) {
      const index = argmax3(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert3(isArray3(x), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf3(x, max3(x, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function min3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs }).min;
  }
  function argmin3(x, shouldDropNaNs) {
    if (isDataFrame3(x)) {
      const index = argmin3(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries3(x)) {
      const index = argmin3(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert3(isArray3(x), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf3(x, min3(x, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function cast3(value, type) {
    if (isDataFrame3(value) || isSeries3(value)) {
      return value.apply((item) => cast3(item, type));
    }
    if (isArray3(value)) {
      return value.map((v) => cast3(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined3(value)) {
        return NaN;
      }
      const booleanValue = cast3(value, "boolean");
      if (isBoolean3(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e) {
        const dateValue = cast3(value, "date");
        if (isDate3(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out222 = parseFloat(value);
      if (isNaN(out222))
        return NaN;
      return out222;
    }
    if (type === "int") {
      const out222 = cast3(value, "number");
      return out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
    }
    if (type === "float") {
      return cast3(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast3(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean3(value)) {
        return value;
      }
      if (isNumber3(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate3(value)) {
        return value;
      }
      if (isUndefined3(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out222 = new Date(value);
        if (!isDate3(out222))
          return null;
        return out222;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject3(value)) {
        return value;
      }
      const booleanValue = cast3(value, "boolean");
      if (isBoolean3(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast3(value, "number");
        if (isNumber3(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e) {
      }
      const dateValue = cast3(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out222 = JSON.parse(value);
        if (isArray3(out222)) {
          return out222.map((v) => cast3(v, type));
        } else {
          return out222;
        }
      } catch (e) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined3(value)) {
        if (isEqual3(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.ceil(x);
    } catch (e) {
      return NaN;
    }
  }
  var vceil3 = vectorize3(ceil3);
  function chop3(x, threshold) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      if (isUndefined3(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber3(threshold)) {
        return NaN;
      }
      return vabs3(x) < threshold ? 0 : x;
    } catch (e) {
      return NaN;
    }
  }
  var vchop3 = vectorize3(chop3);
  function int3(x) {
    if (isDataFrame3(x) || isSeries3(x)) {
      const out222 = x.copy();
      out222.values = int3(out222.values);
      return out222;
    }
    if (isArray3(x)) {
      return x.map((v) => int3(v));
    } else {
      try {
        const out222 = JSON.parse(x);
        if (isNumber3(out222)) {
          return typeof out222 === "bigint" ? Number(out222) : out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
        }
        return NaN;
      } catch (e) {
        return NaN;
      }
    }
  }
  var vint3 = vectorize3(int3);
  function clamp3(x, a, b) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (!isNumber3(a))
        return NaN;
      if (!isNumber3(b))
        return NaN;
      if (typeof x === "bigint") {
        return BigInt(clamp3(vint3(x), a, b));
      }
      if (x < a)
        return a;
      if (x > b)
        return b;
      return x;
    } catch (e) {
      return NaN;
    }
  }
  var vclamp3 = vectorize3(clamp3);
  function combinationsIterator3(x, r) {
    function* helper522(x2, r2) {
      if (r2 > x2.length) {
        yield x2;
      } else if (r2 <= 0) {
        yield [];
      } else if (x2.length < 2) {
        yield x2;
      } else {
        for (let i = 0; i < x2.length; i++) {
          const item = x2[i];
          const after = x2.slice(i + 1);
          if (after.length < r2 - 1) {
            continue;
          }
          if (r2 - 1 >= 0) {
            for (const child of combinationsIterator3(after, r2 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame3(x) || isSeries3(x)) {
      return combinationsIterator3(x.values, r);
    }
    assert3(isArray3(x), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert3(isNumber3(r) && vint3(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten3(x), r);
  }
  function combinations3(x, r) {
    const out222 = [];
    for (const combo of combinationsIterator3(x, r)) {
      out222.push(combo.slice());
    }
    return out222;
  }
  function intersect3() {
    const arrays = Object.values(arguments).map((x) => {
      if (isDataFrame3(x) || isSeries3(x)) {
        return set3(x.values);
      }
      assert3(isArray3(x), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set3(x);
    });
    const all = set3(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual3(other, v)) > -1);
    });
  }
  var _IndexMatcher3 = class {
    constructor(mode222) {
      assert3(isUndefined3(mode222) || mode222 === _IndexMatcher3.DROP_NAN_MODE || mode222 === _IndexMatcher3.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined3(mode222) ? mode222 : _IndexMatcher3.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x) => {
        if (isArray3(x)) {
          const xshape = shape3(x);
          if (xshape.length === 1) {
            x = new Series3(x);
          } else if (xshape.length === 2) {
            x = new DataFrame3(x);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert3(isDataFrame3(x) || isSeries3(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher3.DROP_MISSING_MODE) {
          indices.push(x.dropMissing().index);
        } else {
          indices.push(x.dropNaN().index);
        }
      });
      this.index = intersect3(...indices);
      return this;
    }
    transform() {
      assert3(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out222 = Object.values(arguments).map((x) => {
        if (isArray3(x)) {
          const xshape = shape3(x);
          if (xshape.length === 1) {
            return new Series3(x).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame3(x).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert3(isDataFrame3(x) || isSeries3(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x.get(this.index, null);
      });
      return out222.length === 1 ? out222[0] : out222;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher3 = _IndexMatcher3;
  __publicField3(IndexMatcher3, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField3(IndexMatcher3, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance3(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries3(x)) {
      return covariance3(x.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries3(y)) {
      return covariance3(x, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert3(isArray3(x) && isArray3(y) && shape3(x).length === 1 && shape3(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert3(x.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance3(...new IndexMatcher3().fitAndTransform(x, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats3(x, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats3(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx = Number(xstats.mean);
      const my = Number(ystats.mean);
      if (!isNumber3(mx) || !isNumber3(my)) {
        return NaN;
      }
      const n = Math.max(x.length, y.length);
      let out222 = 0;
      for (let i = 0; i < n; i++) {
        let vx = x[i];
        let vy = y[i];
        if (!isNumber3(vx))
          return NaN;
        if (!isNumber3(vy))
          return NaN;
        if (typeof vx === "bigint") {
          vx = Number(vx);
        }
        if (typeof vy === "bigint") {
          vy = Number(vy);
        }
        out222 += (vx - mx) * (vy - my);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out222 / x.length, xstats, ystats];
      } else {
        return out222 / x.length;
      }
    } catch (e) {
      return NaN;
    }
  }
  function correl3(x, y, shouldDropNaNs) {
    if (isSeries3(x)) {
      return correl3(x.values, y, shouldDropNaNs);
    }
    if (isSeries3(y)) {
      return correl3(x, y.values, shouldDropNaNs);
    }
    assert3(isArray3(x) && isArray3(y) && shape3(x).length === 1 && shape3(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert3(x.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance3(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e) {
      return NaN;
    }
  }
  function cos3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.cos(x);
    } catch (e) {
      return NaN;
    }
  }
  var vcos3 = vectorize3(cos3);
  var dataTypes3 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff3(a, b) {
    if (isDataFrame3(a) || isSeries3(a)) {
      return diff3(a.values, b);
    }
    if (isDataFrame3(b) || isSeries3(b)) {
      return diff3(a, b.values);
    }
    assert3(isArray3(a) && isArray3(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set3(a);
    const bTemp = set3(b);
    const out222 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual3(other, item)) < 0) {
        out222.push(item);
      }
    });
    return out222;
  }
  function pow3(x, p) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (!isNumber3(p))
        return NaN;
      if (typeof x === "bigint" || typeof p === "bigint") {
        const out222 = pow3(Number(x), Number(p));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.pow(x, p);
    } catch (e) {
      return NaN;
    }
  }
  var vpow3 = vectorize3(pow3);
  function sqrt3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        const out222 = sqrt3(Number(x));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.sqrt(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsqrt3 = vectorize3(sqrt3);
  function multiply3() {
    try {
      const x = Object.values(arguments);
      if (x.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of x) {
        if (!isNumber3(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  var vmultiply3 = vectorize3(multiply3);
  function scale3() {
    return vmultiply3(...arguments);
  }
  function subtract3(a, b) {
    return vadd3(a, scale3(b, -1));
  }
  function sum3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs }).sum;
  }
  function distance3(a, b) {
    if (isNumber3(a) && isNumber3(b)) {
      return vabs3(a - b);
    }
    if (isDataFrame3(a) || isSeries3(a)) {
      return distance3(a.values, b);
    }
    if (isDataFrame3(b) || isSeries3(b)) {
      return distance3(a, b.values);
    }
    if (isArray3(a) && isArray3(b)) {
      assert3(isEqual3(shape3(a), shape3(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt3(sum3(vpow3(subtract3(a, b), 2)));
    } catch (e) {
      return NaN;
    }
  }
  function divide3(a, b) {
    return scale3(a, vpow3(b, -1));
  }
  function dot3(a, b) {
    if (isDataFrame3(a)) {
      const temp = dot3(a.values, b);
      if (shape3(temp).length === 1) {
        const out222 = new Series3(temp);
        out222.name = isSeries3(b) ? b.name : out222.name;
        out222.index = a.index.slice();
        return out222;
      } else {
        const out222 = new DataFrame3(temp);
        out222.index = a.index.slice();
        if (isDataFrame3(b)) {
          out222.columns = b.columns.slice();
        }
        return out222;
      }
    }
    if (isDataFrame3(b)) {
      const temp = dot3(a, b.values);
      if (shape3(temp).length === 1) {
        const out222 = new Series3(temp);
        out222.name = isSeries3(a) ? a.name : out222.name;
        out222.index = b.columns.slice();
        return out222;
      } else {
        const out222 = new DataFrame3(temp);
        out222.columns = b.columns.slice();
        return out222;
      }
    }
    if (isSeries3(a)) {
      return dot3(a.values, b);
    }
    if (isSeries3(b)) {
      return dot3(a, b.values);
    }
    assert3(isArray3(a) && isArray3(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape3(a);
    const bShape = shape3(b);
    assert3(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert3(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum3(scale3(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose3(b).map((col) => dot3(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot3(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose3(b);
      const out222 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot3(a[i], bTranspose[j]));
        }
        out222.push(row);
      }
      return out222;
    }
  }
  function dropMissing3(x) {
    if (isDataFrame3(x) || isSeries3(x)) {
      return x.dropMissing(...Object.values(arguments).slice(1));
    }
    assert3(isArray3(x), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x.forEach((v) => {
      try {
        return out222.push(dropMissing3(v));
      } catch (e) {
        if (!isUndefined3(v)) {
          out222.push(v);
        }
      }
    });
    return out222;
  }
  function dropMissingPairwise3(a, b) {
    if (isDataFrame3(a) || isSeries3(a)) {
      return dropMissingPairwise3(a.values, b);
    }
    if (isDataFrame3(b) || isSeries3(b)) {
      return dropMissingPairwise3(a, b.values);
    }
    assert3(isArray3(a) && isArray3(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert3(isEqual3(shape3(a), shape3(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise3(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (!isUndefined3(a[i]) && !isUndefined3(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise3(a, b) {
    if (isDataFrame3(a) || isSeries3(a)) {
      return dropNaNPairwise3(a.values, b);
    }
    if (isDataFrame3(b) || isSeries3(b)) {
      return dropNaNPairwise3(a, b.values);
    }
    assert3(isArray3(a) && isArray3(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert3(isEqual3(shape3(a), shape3(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise3(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (isNumber3(a[i]) && isNumber3(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined3(x) {
    return dropMissing3(x);
  }
  function every3(x, fn) {
    if (isDataFrame3(x) || isSeries3(x)) {
      return every3(x.values, fn);
    }
    assert3(isArray3(x), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert3(isFunction3(fn), "The second argument passed into the `every` function must be a function!");
    for (const v of x) {
      if (isArray3(v)) {
        if (!every3(v, fn)) {
          return false;
        }
      } else {
        if (!fn(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        if (x === 0n) {
          return 1n;
        } else {
          x = Number(x);
        }
      }
      return Math.exp(x);
    } catch (e) {
      return NaN;
    }
  }
  var vexp3 = vectorize3(exp3);
  function factorial3(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial3(vint3(n)));
      }
      if (n !== vint3(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial3(n - 1);
    } catch (e) {
      return NaN;
    }
  }
  var vfactorial3 = vectorize3(factorial3);
  function find3(x, fn) {
    if (isDataFrame3(x)) {
      return find3(x.values, fn);
    }
    if (isSeries3(x)) {
      return find3(x.values, fn);
    }
    assert3(isObject3(x) || isArray3(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction3(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject3(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return value;
          }
          const result = helper522(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray3(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return value;
          }
          const result = helper522(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn2(x2)) {
          return x2;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    return helper522(x, safeFn);
  }
  function findAll3(x, fn) {
    if (isDataFrame3(x)) {
      return findAll3(x.values, fn);
    }
    if (isSeries3(x)) {
      return findAll3(x.values, fn);
    }
    assert3(isObject3(x) || isArray3(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction3(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject3(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        const out222 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else if (isArray3(x2)) {
        checked.push(x2);
        const out222 = [];
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else {
        if (fn2(x2)) {
          return [x2];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const results = helper522(x, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float3(x) {
    try {
      if (x === "Infinity") {
        return Infinity;
      }
      if (x === "-Infinity") {
        return -Infinity;
      }
      const out222 = JSON.parse(x);
      if (isNumber3(out222))
        return out222;
      return NaN;
    } catch (e) {
      return NaN;
    }
  }
  var vfloat3 = vectorize3(float3);
  function floor3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        return x;
      }
      return Math.floor(x);
    } catch (e) {
      return NaN;
    }
  }
  var vfloor3 = vectorize3(floor3);
  function zeros3(shape222) {
    if (isNumber3(shape222))
      shape222 = [shape222];
    const out222 = [];
    const n = product3(shape222);
    for (let i = 0; i < n; i++)
      out222.push(0);
    return reshape3(out222, shape222);
  }
  function identity3(size) {
    if (typeof size === "bigint") {
      size = vint3(size);
    }
    assert3(!isUndefined3(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert3(isNumber3(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert3(vint3(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert3(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out222 = zeros3([size, size]);
    for (let i = 0; i < size; i++)
      out222[i][i] = 1;
    return out222;
  }
  var booleanValues3 = ["true", "false", "yes", "no"];
  var nullValues3 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger3(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint3(results.value) === results.value;
      } else {
        results.isInteger = every3(results.values, (v) => isNumber3(v) ? vint3(v) === v : true);
      }
    }
    return results;
  }
  function inferType3(arr) {
    if (isDataFrame3(arr)) {
      const out222 = arr.copy();
      const results = inferType3(arr.values);
      out222.values = results.values;
      return checkIfInteger3({ type: results.type, values: out222 });
    }
    if (isSeries3(arr)) {
      const out222 = arr.copy();
      const results = inferType3(arr.values);
      out222.values = results.values;
      return checkIfInteger3({ type: results.type, values: out222 });
    }
    if (!isArray3(arr)) {
      const out222 = inferType3([arr]);
      out222.value = out222.values[0];
      delete out222.values;
      return checkIfInteger3(out222);
    }
    assert3(isArray3(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten3(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate3(temp)) {
            return "date";
          }
        }
      } catch (e) {
      }
      if (!isString3(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues3.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues3.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber3(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray3(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e) {
        const vDate = new Date(v);
        if (isDate3(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count3(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger3({
      type: primaryType,
      values: vapply3(arr, (v) => cast3(v, primaryType))
    });
  }
  function inverse3(x) {
    if (isDataFrame3(x)) {
      const out222 = x.copy();
      out222.values = inverse3(out222.values);
      return out222;
    }
    assert3(isArray3(x), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape3(x);
    assert3(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert3(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert3(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x;
    } else if (xShape[0] === 1) {
      assert3(x[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x[0][0];
      let b = x[0][1];
      let c = x[1][0];
      let d = x[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det = a * d - b * c;
      assert3(det !== 0, "This matrix cannot be inverted!");
      const out222 = [
        [d, -b],
        [-c, a]
      ];
      return scale3(out222, 1 / det);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber3(a) || isNumber3(b) ? scale3(a, b) : dot3(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x.slice(0, divider).map((row) => row.slice(0, divider));
          const B = x.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C = x.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse3(A);
          const CompInv = inverse3(vadd3(D, times(-1, times(times(C, AInv), B))));
          const topLeft = vadd3(AInv, times(times(times(times(AInv, B), CompInv), C), AInv));
          const topRight = times(-1, times(times(AInv, B), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C), AInv));
          const bottomRight = CompInv;
          const out222 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out222;
        } catch (e) {
        }
      }
      assert3(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser23 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp3(a, b, f) {
    try {
      if (!isNumber3(a))
        return NaN;
      if (!isNumber3(b))
        return NaN;
      if (!isNumber3(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = lerp3(Number(a), Number(b), f);
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return f * (b - a) + a;
    } catch (e) {
      return NaN;
    }
  }
  var vlerp3 = vectorize3(lerp3);
  function log3(x, base) {
    try {
      base = isUndefined3(base) ? Math.E : base;
      if (!isNumber3(x))
        return NaN;
      if (!isNumber3(base))
        return NaN;
      if (typeof x === "bigint" || typeof base === "bigint") {
        const out222 = log3(Number(x), Number(base));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.log(x) / Math.log(base);
    } catch (e) {
      return NaN;
    }
  }
  var vlog3 = vectorize3(log3);
  function mean3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs }).mean;
  }
  function median3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod3(a, b) {
    try {
      if (!isNumber3(a))
        return NaN;
      if (!isNumber3(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = mod3(Number(a), Number(b));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return a % b;
    } catch (e) {
      return NaN;
    }
  }
  var vmod3 = vectorize3(mod3);
  function mode3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper33() {
    const u1 = random3();
    const u2 = random3();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
  function normal3(shape222) {
    if (isUndefined3(shape222))
      return helper33();
    return vapply3(ndarray3(shape222), helper33);
  }
  function ones3(shape222) {
    return vapply3(ndarray3(shape222), () => 1);
  }
  function permutationsIterator3(x, r) {
    function* helper522(x2, r2) {
      r2 = r2 || x2.length;
      if (x2.length === 1) {
        yield [x2];
        return;
      }
      for (const c of combinations3(x2, r2)) {
        if (!c.slice)
          continue;
        const state = zeros3(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame3(x) || isSeries3(x)) {
      return permutationsIterator3(x.values, r);
    }
    assert3(isArray3(x), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined3(r)) {
      r = x.length;
    }
    assert3(isNumber3(r) && vint3(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten3(x), r);
  }
  function permutations3(x, r) {
    const out222 = [];
    for (const perm of permutationsIterator3(x, r)) {
      out222.push(perm.slice());
    }
    return out222;
  }
  function print3() {
    Object.keys(arguments).forEach((key) => {
      const x = arguments[key];
      if (isArray3(x)) {
        if (!isJagged3(x)) {
          const xShape = shape3(x);
          if (xShape.length === 1) {
            new Series3(x).print();
          } else if (xShape.length == 2) {
            new DataFrame3(x).print();
          } else {
            console.log(x);
          }
        } else {
          console.log(x);
        }
      } else if (isDataFrame3(x) || isSeries3(x)) {
        x.print();
      } else {
        console.log(x);
      }
    });
  }
  var helper43 = vectorize3((x, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x, a, b, c, d]) {
        if (!isNumber3(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x = Number(x);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out222 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  });
  function remap3(x, a, b, c, d) {
    if (isArray3(x) && isUndefined3(c) && isUndefined3(d)) {
      c = a;
      d = b;
      const results = stats3(x);
      a = results.min;
      b = results.max;
    }
    return helper43(x, a, b, c, d);
  }
  function round3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.round(x);
    } catch (e) {
      return NaN;
    }
  }
  var vround3 = vectorize3(round3);
  function sign3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint")
        return BigInt(sign3(Number(x)));
      if (x < 0)
        return -1;
      if (x > 0)
        return 1;
      return 0;
    } catch (e) {
      return NaN;
    }
  }
  var vsign3 = vectorize3(sign3);
  function sin3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.sin(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsin3 = vectorize3(sin3);
  function some3(x, fn) {
    if (isDataFrame3(x) || isSeries3(x)) {
      return some3(x.values, fn);
    }
    assert3(isArray3(x), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert3(isFunction3(fn), "The second argument passed into the `some` function must be a function!");
    for (const v of x) {
      if (isArray3(v)) {
        if (some3(v, fn)) {
          return true;
        }
      } else {
        if (fn(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev3(x) {
    return std3(x);
  }
  function tan3(x) {
    try {
      if (!isNumber3(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.tan(x);
    } catch (e) {
      return NaN;
    }
  }
  var vtan3 = vectorize3(tan3);
  function timeSync3(fn, args) {
    assert3(isFunction3(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn(...args);
    } else {
      fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync3(fn, args) {
    assert3(isFunction3(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn(...args);
    } else {
      await fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union3() {
    return set3([...arguments].map((v) => {
      if (isArray3(v))
        return v;
      if (isDataFrame3(v))
        return v.values;
      if (isSeries3(v))
        return v.values;
      return [v];
    }));
  }
  function variance3(arr, shouldDropNaNs) {
    return stats3(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip3() {
    const out222 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame3(arr) || isSeries3(arr)) {
        arr = arr.values;
      }
      assert3(isArray3(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range3(0, max3(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined3(value) ? void 0 : value);
      });
      out222.push(row);
    });
    return out222;
  }
  var out3 = {
    abs: vabs3,
    add: vadd3,
    apply: vapply3,
    arccos: varccos3,
    arcsin: varcsin3,
    arctan: varctan3,
    argmax: argmax3,
    argmin: argmin3,
    assert: assert3,
    cast: cast3,
    ceil: vceil3,
    chop: vchop3,
    clamp: vclamp3,
    combinations: combinations3,
    combinationsIterator: combinationsIterator3,
    copy: copy3,
    correl: correl3,
    cos: vcos3,
    count: count3,
    covariance: covariance3,
    DataFrame: DataFrame3,
    dataTypes: dataTypes3,
    decycle: decycle3,
    diff: diff3,
    distance: distance3,
    divide: divide3,
    dot: dot3,
    dropMissing: dropMissing3,
    dropMissingPairwise: dropMissingPairwise3,
    dropNaN: dropNaN3,
    dropNaNPairwise: dropNaNPairwise3,
    dropUndefined: dropUndefined3,
    every: every3,
    exp: vexp3,
    factorial: vfactorial3,
    find: find3,
    findAll: findAll3,
    flatten: flatten3,
    float: vfloat3,
    floor: vfloor3,
    identity: identity3,
    IndexMatcher: IndexMatcher3,
    indexOf: indexOf3,
    inferType: inferType3,
    int: vint3,
    intersect: intersect3,
    inverse: inverse3,
    isArray: isArray3,
    isBoolean: isBoolean3,
    isBrowser: isBrowser23,
    isDataFrame: isDataFrame3,
    isDate: isDate3,
    isEqual: isEqual3,
    isFunction: isFunction3,
    isJagged: isJagged3,
    isNested: isNested3,
    isNumber: isNumber3,
    isObject: isObject3,
    isSeries: isSeries3,
    isString: isString3,
    isUndefined: isUndefined3,
    lerp: vlerp3,
    log: vlog3,
    MathError: MathError3,
    max: max3,
    mean: mean3,
    median: median3,
    min: min3,
    mod: vmod3,
    mode: mode3,
    multiply: vmultiply3,
    ndarray: ndarray3,
    normal: normal3,
    ones: ones3,
    permutations: permutations3,
    permutationsIterator: permutationsIterator3,
    pow: vpow3,
    print: print3,
    product: product3,
    random: random3,
    range: range3,
    remap: remap3,
    reshape: reshape3,
    reverse: reverse3,
    round: vround3,
    scale: scale3,
    seed: seed3,
    Series: Series3,
    set: set3,
    shape: shape3,
    shuffle: shuffle3,
    sign: vsign3,
    sin: vsin3,
    some: some3,
    sort: sort3,
    sqrt: vsqrt3,
    stats: stats3,
    std: std3,
    stdev: stdev3,
    subtract: subtract3,
    sum: sum3,
    tan: vtan3,
    timeAsync: timeAsync3,
    timeSync: timeSync3,
    time: timeSync3,
    transpose: transpose3,
    union: union3,
    variance: variance3,
    vectorize: vectorize3,
    zeros: zeros3,
    zip: zip3,
    dump() {
      const context22 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context22) {
        throw new out3.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out3).forEach((key) => {
        try {
          Object.defineProperty(context22, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out3[key]
          });
        } catch (e) {
          context22[key] = out3[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out3;
  }
  var context2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : void 0;
  function convertObjectToTypedArray2(x) {
    const typedArrayConstructorSymbol = Symbol.for("@TypedArrayConstructor");
    const typedArrayConstructorString = "Symbol(@TypedArrayConstructor)";
    const typedArrayConstructorKey = typedArrayConstructorSymbol in x ? typedArrayConstructorSymbol : typedArrayConstructorString in x ? typedArrayConstructorString : void 0;
    if (typedArrayConstructorKey) {
      if (!("values" in x)) {
        throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");
      }
      if (x[typedArrayConstructorKey] === "ArrayBuffer") {
        return new Uint8Array(x.values).buffer;
      }
      return new context2[x[typedArrayConstructorKey]](x.values);
    }
    if (isArray3(x) && x.constructor.name === "Array") {
      return x;
    }
    throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!");
  }
  function convertTypedArrayToObject2(x) {
    if (x instanceof ArrayBuffer || x instanceof BigInt64Array || x instanceof BigUint64Array || x instanceof Float32Array || x instanceof Float64Array || x instanceof Int16Array || x instanceof Int32Array || x instanceof Int8Array || x instanceof Uint16Array || x instanceof Uint32Array || x instanceof Uint8Array || x instanceof Uint8ClampedArray) {
      return {
        [Symbol.for("@TypedArrayConstructor")]: x.constructor.name,
        values: x instanceof ArrayBuffer ? Array.from(new Uint8Array(x)) : Array.from(x)
      };
    }
    if (isArray3(x)) {
      return x.map((v) => {
        try {
          return convertTypedArrayToObject2(v);
        } catch (e) {
          return v;
        }
      });
    }
    if (typeof x === "object" & x !== null) {
      if (isDate3(x)) {
        return new Date(x.getTime());
      }
      const out222 = {};
      Object.keys(x).forEach((key) => {
        try {
          out222[key] = convertTypedArrayToObject2(x[key]);
        } catch (e) {
          out222[key] = x[key];
        }
      });
      return out222;
    }
    throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.");
  }
  function isANumberString2(x) {
    x = x.trim();
    return !!(x.match(/^-?\d+(\.\d+)?$/g) || x.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g) || x.match(/^-?\.\d+$/g) || x === "NaN");
  }
  var punctuation2 = "!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";
  function replaceAll2(text, a, b) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    if (typeof a !== "string") {
      throw new Error("`a` must be a string!");
    }
    if (typeof b !== "string") {
      throw new Error("`b` must be a string!");
    }
    return text.split(a).join(b);
  }
  var doubleSpace2 = "  ";
  var singleSpace2 = " ";
  function strip2(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    let out222 = "";
    for (let i = 0; i < text.length; i++) {
      const char = text[i].toLowerCase();
      if (punctuation2.includes(char)) {
        out222 += singleSpace2;
      } else {
        out222 += char;
      }
    }
    while (out222.includes(doubleSpace2)) {
      out222 = replaceAll2(out222, doubleSpace2, singleSpace2);
    }
    return out222.trim();
  }
  function indent2(text, chars) {
    chars = chars || "";
    return text.split("\n").map((line) => {
      if (line.trim().length > 0) {
        return chars + line;
      } else {
        return line;
      }
    }).join("\n");
  }
  function kebabify2(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip2(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("-");
  }
  var specials2 = {
    "@Infinity": Infinity,
    "@NegativeInfinity": -Infinity,
    "@NaN": NaN,
    "@undefined": void 0
  };
  function fixUndefineds2(x) {
    if (typeof x === "object") {
      if (x === null) {
        return x;
      }
      if (isArray3(x)) {
        for (let i = 0; i < x.length; i++) {
          x[i] = fixUndefineds2(x[i]);
        }
      } else {
        Object.keys(x).concat(Object.getOwnPropertySymbols(x)).forEach((key) => {
          x[key] = fixUndefineds2(x[key]);
        });
      }
      return x;
    } else {
      if (typeof x === "undefined") {
        return void 0;
      }
      if (x === "Symbol(@undefined)") {
        return void 0;
      }
      return x;
    }
  }
  function parseAsBigInt2(x) {
    if (typeof x === "bigint") {
      return x;
    } else if (typeof x === "string") {
      if (x.match(/^\s*?-?\d+n\s*?$/g)) {
        try {
          return BigInt(x.split("n")[0]);
        } catch (e) {
          return NaN;
        }
      } else {
        return NaN;
      }
    } else {
      return NaN;
    }
  }
  function parseAsNumber2(x) {
    if (typeof x !== "string") {
      if (typeof x === "number") {
        return x;
      } else {
        return;
      }
    }
    if (isANumberString2(x)) {
      return parseFloat(x);
    }
  }
  function parseAsString2(x) {
    if (typeof x !== "string") {
      return;
    }
    const replacement = "@jrc03c/js-text-tools/newline-replacer";
    x = x.replaceAll("\n", replacement);
    if (x.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)) {
      let out222 = x.replace("Symbol(@String):", "");
      if (out222.match(/^".*?"$/g)) {
        try {
          return JSON.parse(out222);
        } catch (e) {
          out222 = out222.substring(1, out222.length - 1);
        }
      }
      out222 = out222.replaceAll(replacement, "\n");
      return out222;
    }
  }
  function parseAsSymbol2(x) {
    if (typeof x !== "string") {
      if (typeof x === "symbol") {
        return { out: x, isASymbol: true };
      } else {
        return;
      }
    }
    if (x.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)) {
      const xTemp = x.replace(/^.*?Symbol\(/g, "").replace(/\).*?$/g, "");
      if (xTemp in specials2) {
        return { out: specials2[xTemp], isASymbol: true };
      }
      return { out: Symbol.for(xTemp), isASymbol: true };
    }
  }
  function parseAsRegex2(x) {
    if (typeof x !== "string") {
      if (x instanceof RegExp) {
        return x;
      } else {
        return;
      }
    }
    const xTrimmed = x.trim();
    if (xTrimmed.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g)) {
      try {
        const pattern = xTrimmed.replace(/^\//g, "").replace(/\/(d|g|i|m|s|u|v|y)*?$/g, "");
        const flags = xTrimmed.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);
        return new RegExp(pattern, flags);
      } catch (e) {
      }
    }
  }
  function parseWithJSONParse2(x) {
    if (typeof x !== "string") {
      if (typeof x === "object") {
        return x;
      } else {
        return "Symbol(@undefined)";
      }
    }
    try {
      let out222 = JSON.parse(x, (key, value) => {
        try {
          const out32 = parse2(value);
          return typeof out32 === "undefined" ? "Symbol(@undefined)" : out32;
        } catch (e) {
          return typeof value === "undefined" ? "Symbol(@undefined)" : value;
        }
      });
      if (isArray3(out222)) {
        out222 = fixUndefineds2(out222);
      }
      return out222;
    } catch (e) {
      return x;
    }
  }
  function parseAsDate2(x) {
    if (typeof x !== "string") {
      if (x instanceof Date && x.toString() !== "Invalid Date") {
        return x;
      } else {
        return;
      }
    }
    try {
      const d = new Date(Date.parse(x));
      if (d.toString() !== "Invalid Date") {
        return d;
      }
    } catch (e) {
    }
  }
  function parseObjectKeysAndValues2(x) {
    if (typeof x === "object") {
      if (x !== null) {
        return fixUndefineds2(x);
      }
      return;
    }
    Object.keys(x).concat(Object.getOwnPropertySymbols(x)).forEach((key) => {
      try {
        let origKey = key;
        try {
          key = parse2(key);
        } catch (e) {
        }
        x[key] = parse2(x[origKey]);
        if (key !== origKey) {
          delete x[origKey];
        }
      } catch (e) {
      }
    });
    return fixUndefineds2(x);
  }
  function parse2(x) {
    function helper522(x2) {
      if (typeof x2 === "string") {
        let out222 = parseAsString2(x2);
        if (typeof out222 === "string") {
          return out222;
        }
        const results = parseAsSymbol2(x2);
        out222 = results ? results.out : void 0;
        if (results && results.isASymbol) {
          return out222;
        }
        out222 = parseAsRegex2(x2);
        if (out222 instanceof RegExp) {
          return out222;
        }
        out222 = parseAsBigInt2(x2);
        if (typeof out222 === "bigint") {
          return out222;
        }
        out222 = parseAsNumber2(x2);
        if (typeof out222 === "number") {
          return out222;
        }
        out222 = parseAsDate2(x2);
        if (out222 instanceof Date) {
          return out222;
        }
        out222 = parseWithJSONParse2(x2);
        if (typeof out222 !== "undefined") {
          if (out222 === "Symbol(@undefined)") {
            return void 0;
          } else {
            return out222;
          }
        }
        return x2;
      }
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        let out222;
        try {
          out222 = convertObjectToTypedArray2(x2);
          if (isArray3(out222))
            return out222;
        } catch (e) {
        }
        out222 = parseObjectKeysAndValues2(x2);
        if (out222) {
          try {
            return convertObjectToTypedArray2(out222);
          } catch (e) {
            return out222;
          }
        }
        return x2;
      }
      return x2;
    }
    return helper522(x);
  }
  function pascalify2(text) {
    const out222 = camelify4(text);
    return out222[0].toUpperCase() + out222.slice(1);
  }
  function snakeify2(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip2(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("_");
  }
  function prefix2(s222, n) {
    if (!s222 || n <= 0)
      return "";
    return range3(0, n).map(() => s222).join("");
  }
  function stringify2(x, indent22) {
    assert3(isString3(indent22) || isUndefined3(indent22), "The second parameter to the `stringify` function must be undefined or a string!");
    const newline = indent22 ? "\n" : "";
    function helper522(x2, indent32, depth) {
      depth = depth || 0;
      if (typeof x2 === "bigint") {
        return JSON.stringify(x2.toString() + "n");
      }
      if (typeof x2 === "number") {
        if (x2 === Infinity) {
          return '"Symbol(@Infinity)"';
        }
        if (x2 === -Infinity) {
          return '"Symbol(@NegativeInfinity)"';
        }
        if (isNaN(x2)) {
          return '"Symbol(@NaN)"';
        }
        return x2.toString();
      }
      if (typeof x2 === "string") {
        return JSON.stringify("Symbol(@String):" + x2);
      }
      if (typeof x2 === "boolean") {
        return x2.toString();
      }
      if (typeof x2 === "undefined") {
        return '"Symbol(@undefined)"';
      }
      if (typeof x2 === "symbol") {
        return JSON.stringify(x2.toString());
      }
      if (typeof x2 === "function") {
        return JSON.stringify(x2.toString());
      }
      if (x2 instanceof RegExp) {
        return x2.toString();
      }
      if (typeof x2 === "object") {
        if (x2 === null) {
          return "null";
        }
        if (isDate3(x2)) {
          return JSON.stringify(x2.toJSON());
        }
        if (isArray3(x2)) {
          if (x2.length === 0) {
            return prefix2(indent32, depth - 1) + "[]";
          }
          if (!(x2 instanceof Array)) {
            return helper522(convertTypedArrayToObject2(x2), null, indent32);
          }
          return prefix2(indent32, depth - 1) + "[" + newline + x2.map((v) => {
            let child = (() => {
              try {
                return helper522(convertTypedArrayToObject2(v), indent32, depth + 1);
              } catch (e) {
                return helper522(v, indent32, depth + 1);
              }
            })();
            if (isString3(child))
              child = child.trim();
            return prefix2(indent32, depth + 1) + child;
          }).join("," + newline) + newline + prefix2(indent32, depth) + "]";
        }
        if (Object.keys(x2).length + Object.getOwnPropertySymbols(x2).length === 0) {
          return prefix2(indent32, depth - 1) + "{}";
        }
        return prefix2(indent32, depth - 1) + "{" + newline + Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).map((key) => {
          let child = (() => {
            try {
              return helper522(convertTypedArrayToObject2(x2[key]), indent32, depth + 1);
            } catch (e) {
              return helper522(x2[key], indent32, depth + 1);
            }
          })();
          if (isString3(child))
            child = child.trim();
          const stringifiedKey = typeof key === "symbol" ? helper522(key) : JSON.stringify(key);
          return prefix2(indent32, depth + 1) + stringifiedKey + ":" + (indent32 ? " " : "") + child;
        }).join("," + newline) + newline + prefix2(indent32, depth) + "}";
      }
      return "undefined";
    }
    return helper522(decycle3(x), indent22);
  }
  function unindent2(text) {
    const lines = text.split("\n");
    const indentations = lines.filter((line) => line.trim().length > 0).map((line) => line.split("").findIndex((char) => !char.match(/\s/g)));
    const minIndentation = Math.min(...indentations);
    return lines.map((line) => line.substring(minIndentation)).join("\n");
  }
  function wrap2(raw, maxLineLength) {
    if (typeof raw !== "string") {
      throw new Error("The first argument to the `wrap` function must be a string!");
    }
    if (typeof maxLineLength === "undefined" || maxLineLength === null) {
      if (typeof process !== "undefined" && typeof process.stdout !== "undefined" && typeof process.stdout.columns === "number") {
        maxLineLength = process.stdout.columns > 80 ? 80 : process.stdout.columns;
      } else {
        maxLineLength = 80;
      }
    }
    if (isNaN(maxLineLength) || typeof maxLineLength !== "number") {
      throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");
    }
    const out222 = [];
    raw.split("\n").forEach((line) => {
      if (line.trim().length === 0) {
        return out222.push("");
      }
      const indentation = line.split(/[^\s]/g)[0];
      const words = line.replace(indentation, "").split(" ");
      let temp = indentation;
      words.forEach((word) => {
        const newLine = temp + (temp.trim().length > 0 ? " " : "") + word;
        if (newLine.length > maxLineLength) {
          out222.push(temp);
          temp = indentation + word;
        } else {
          temp = newLine;
        }
      });
      if (temp.length > 0) {
        out222.push(temp);
      }
    });
    return out222.join("\n");
  }
  if (typeof window !== "undefined") {
    window.JSTextTools = {
      camelify: camelify4,
      convertObjectToTypedArray: convertObjectToTypedArray2,
      convertTypedArrayToObject: convertTypedArrayToObject2,
      indent: indent2,
      isANumberString: isANumberString2,
      kebabify: kebabify2,
      parse: parse2,
      pascalify: pascalify2,
      punctuation: punctuation2,
      replaceAll: replaceAll2,
      snakeify: snakeify2,
      stringify: stringify2,
      strip: strip2,
      unindent: unindent2,
      wrap: wrap2
    };
  }
  function createType(name, fn) {
    if (typeof name !== "string") {
      throw new Error(
        "The first argument passed into the `createType` function must be a string representing the type's name!"
      );
    }
    if (typeof fn !== "function") {
      throw new Error(
        "The second argument passed into the `createType` function must be a function that tests a single value and returns true or false depending on whether or not the value 'matches' the type!"
      );
    }
    const out32 = class {
      constructor() {
        throw new Error(
          "This class is not meant to be instantiated or subclassed! Its only purpose is type checking."
        );
      }
      static [Symbol.hasInstance](value) {
        try {
          return !!fn(value);
        } catch (e) {
          try {
            return value instanceof fn;
          } catch (e2) {
            return false;
          }
        }
      }
    };
    Object.defineProperty(out32, "name", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: pascalify2(name)
    });
    return out32;
  }
  var __defProp22 = Object.defineProperty;
  var __defNormalProp22 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField22 = (obj, key, value) => {
    __defNormalProp22(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber22(x) {
    return typeof x === "number" && !isNaN(x) || typeof x === "bigint";
  }
  var isBrowser32 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError22 = class extends Error {
    constructor(message) {
      if (isBrowser32()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert22(isTrue, message) {
    if (!isTrue)
      throw new MathError22(message);
  }
  var arrayTypes22 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined22(x) {
    return x === null || typeof x === "undefined";
  }
  var typeStrings22 = arrayTypes22.map((s222) => s222.name);
  function isArray22(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined22(obj.constructor)) {
        return arrayTypes22.indexOf(obj.constructor) > -1 || typeStrings22.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function isDataFrame22(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e) {
      return false;
    }
  }
  function isFunction22(fn) {
    return typeof fn === "function";
  }
  function isObject22(x) {
    return typeof x === "object" && !isUndefined22(x) && !isArray22(x);
  }
  function isSeries22(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e) {
      return false;
    }
  }
  function indexOf22(x, fn) {
    if (isDataFrame22(x)) {
      const index = indexOf22(x.values, fn);
      if (index.length > 0 && isNumber22(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      if (index.length > 1 && isNumber22(index[1]) && index[1] >= 0 && index[1] < x.columns.length) {
        index[1] = x.columns[index[1]];
      }
      return index;
    }
    if (isSeries22(x)) {
      const index = indexOf22(x.values, fn);
      if (index.length > 0 && isNumber22(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      return index;
    }
    assert22(isObject22(x) || isArray22(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction22(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject22(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return [key];
          }
          const results = helper522(value, fn2, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray22(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return [i];
          }
          const results = helper522(value, fn2, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn2(x2)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const paths = helper522(x, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy22(x) {
    function helper522(x2) {
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        if (isArray22(x2)) {
          if (!(x2 instanceof Array)) {
            return x2.slice();
          }
          return x2.map((v) => copy22(v));
        }
        if (isSeries22(x2)) {
          const out32 = x2.copy();
          out32.values = copy22(out32.values);
          return out32;
        }
        if (isDataFrame22(x2)) {
          const out32 = x2.copy();
          out32.values = copy22(x2.values);
          return out32;
        }
        if (x2 instanceof Date) {
          return new Date(x2.getTime());
        }
        x2 = decycle22(x2);
        const out222 = {};
        Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
          out222[key] = copy22(x2[key]);
        });
        return out222;
      } else {
        return x2;
      }
    }
    return helper522(decycle22(x));
  }
  function decycle22(x) {
    function helper522(x2, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x2) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x2;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x2 ? "/" : "/" + indexOf22(orig, x2).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x2 === "object") {
        if (x2 === null)
          return null;
        checked.push(x2);
        if (isArray22(x2)) {
          if (typeof x2.constructor !== "undefined" && x2.constructor.name !== "Array") {
            return x2.slice();
          }
          return x2.map((v, i) => helper522(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
            x2[key] = helper522(x2[key], checked, currentPath + "/" + key.toString());
          });
          return x2;
        }
      } else {
        return x2;
      }
    }
    const orig = x;
    let out222 = helper522(orig);
    if (isDataFrame22(x)) {
      const temp = x.copy();
      temp._values = out222.values;
      temp._columns = out222.columns;
      temp._index = out222.index;
      out222 = temp;
    }
    if (isSeries22(x)) {
      const temp = x.copy();
      temp.name = out222.name;
      temp._values = out222.values;
      temp._index = out222.index;
      out222 = temp;
    }
    return out222;
  }
  function isDate22(x) {
    return x instanceof Date && x.toString() !== "Invalid Date";
  }
  var numberTypes22 = ["number", "int", "float", "bigint"];
  function isEqual22(a, b) {
    function helper522(a2, b2) {
      const aType = typeof a2;
      const bType = typeof b2;
      if (aType !== bType && !numberTypes22.includes(aType) && !numberTypes22.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a2 === b2;
      if (aType === "symbol")
        return a2 === b2;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a2.toString();
          const bString = b2.toString();
          return aString === bString;
        } catch (e) {
          return false;
        }
      }
      if (aType === "string")
        return a2 === b2;
      if (aType === "function")
        return a2 === b2;
      if (aType === "object") {
        if (a2 === null || b2 === null) {
          return a2 === null && b2 === null;
        } else {
          if (isDate22(a2)) {
            if (isDate22(b2)) {
              return a2.getTime() === b2.getTime();
            } else {
              return false;
            }
          } else if (isDate22(b2)) {
            return false;
          }
          if (a2 instanceof RegExp && b2 instanceof RegExp) {
            return a2.toString() === b2.toString();
          }
          if (isArray22(a2) !== isArray22(b2)) {
            return false;
          }
          const aKeys = Object.keys(a2).concat(Object.getOwnPropertySymbols(a2));
          const bKeys = Object.keys(b2).concat(Object.getOwnPropertySymbols(b2));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper522(a2[key], b2[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper522(a, b);
    } catch (e) {
      return helper522(decycle22(a), decycle22(b));
    }
  }
  function makeKey42(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY32 = makeKey42(16);
  var UNDEFINED_KEY32 = makeKey42(16);
  var INFINITY_KEY32 = makeKey42(16);
  var MINUS_INFINITY_KEY32 = makeKey42(16);
  var SYMBOL_KEY32 = makeKey42(16);
  var Counter22 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x) {
      for (const v of x) {
        if (isArray22(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY32 : isUndefined22(value) ? UNDEFINED_KEY32 : isFunction22(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY32 : value === Infinity ? INFINITY_KEY32 : value === -Infinity ? MINUS_INFINITY_KEY32 : typeof value === "bigint" ? value.toString() : isDataFrame22(value) ? value.toJSONString() : isSeries22(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined22(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count222) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count222;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out222 = {};
      this.values.forEach((value) => {
        out222[value] = this.get(value);
      });
      return out222;
    }
  };
  function flatten22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return flatten22(arr.values);
    }
    assert22(isArray22(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper522(arr2) {
      let out222 = [];
      arr2.forEach((child) => {
        if (isArray22(child)) {
          out222 = out222.concat(helper522(child));
        } else {
          out222.push(child);
        }
      });
      return out222;
    }
    return helper522(arr);
  }
  function stats22(x, options) {
    options = options || {};
    const counts = new Counter22();
    const out222 = {};
    const xflat = flatten22(x);
    const xnums = [];
    let max222 = -Infinity;
    let min222 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum222 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber22(v)) {
        try {
          if (v > max222) {
            max222 = v;
          }
          if (v < min222) {
            min222 = v;
          }
          sum222 += Number(v);
          xnums.push(v);
        } catch (e) {
          max222 = NaN;
          min222 = NaN;
          sum222 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean222 = sum222 / xnums.length;
    out222.counts = counts;
    out222.max = max222;
    out222.mean = mean222;
    out222.min = min222;
    out222.n = xflat.length;
    out222.sum = sum222;
    if (isNaN(out222.mean)) {
      out222.max = NaN;
      out222.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out222.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode222 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode222.push(pair[0]);
        } else {
          break;
        }
      }
      out222.mode = mode222.toSorted();
    }
    if (options.median) {
      if (isNaN(mean222)) {
        out222.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out222.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out222.median = BigInt(out222.median);
            } catch (e) {
            }
          }
        } else {
          out222.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance222 = 0;
      for (const v of xnums) {
        variance222 += Math.pow(Number(v) - mean222, 2);
      }
      variance222 /= xnums.length;
      const stdev222 = Math.sqrt(variance222);
      out222.stdev = stdev222;
      out222.variance = variance222;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out222.sum = BigInt(out222.sum);
      } catch (e) {
      }
      try {
        out222.mean = BigInt(out222.mean);
      } catch (e) {
      }
      if (options.mode) {
        out222.mode = out222.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e) {
            return v;
          }
        });
      }
    }
    return out222;
  }
  function count22(arr, matcher) {
    const { counts } = stats22(arr);
    if (!isUndefined22(matcher)) {
      if (isFunction22(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual22(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper52(x) {
    if (isDataFrame22(x) || isSeries22(x)) {
      return helper52(x.values);
    }
    if (isArray22(x)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x) {
        if (helper52(v)) {
          return true;
        }
        if (isArray22(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged22(x) {
    return helper52(decycle22(x));
  }
  function isNested22(x) {
    if (isDataFrame22(x) || isSeries22(x)) {
      return isNested22(x.values);
    }
    assert22(isArray22(x), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x.length; i++) {
      if (isArray22(x[i])) {
        return true;
      }
    }
    return false;
  }
  var error22 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray22(shape222) {
    assert22(!isUndefined22(shape222), error22);
    if (!isArray22(shape222))
      shape222 = [shape222];
    assert22(!isNested22(shape222), error22);
    assert22(shape222.length > 0, error22);
    let s222 = shape222[0];
    if (typeof s222 === "bigint")
      s222 = Number(s222);
    assert22(isNumber22(s222), error22);
    assert22(s222 >= 0, error22);
    assert22(Math.floor(s222) === s222, error22);
    assert22(s222 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape222.length === 1) {
      const out222 = [];
      for (let i = 0; i < s222; i++)
        out222.push(void 0);
      return out222;
    } else {
      const out222 = [];
      for (let i = 0; i < s222; i++) {
        out222.push(ndarray22(shape222.slice(1)));
      }
      return out222;
    }
  }
  function reverse22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      const out32 = arr.copy();
      out32.values = reverse22(out32.values);
      out32.index = reverse22(out32.index);
      return out32;
    }
    assert22(isArray22(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out222.push(arr[i]);
    return out222;
  }
  function range22(a, b, step = 1) {
    assert22(!isUndefined22(a) && !isUndefined22(b) && !isUndefined22(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert22(isNumber22(a) && isNumber22(b) && isNumber22(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert22(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out222 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out222.push(BigInt(i));
        } catch (e) {
          out222.push(i);
        }
      } else {
        out222.push(i);
      }
    }
    if (shouldReverse)
      out222 = reverse22(out222);
    return out222;
  }
  function makeKey222(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY222 = makeKey222(256);
  var UNDEFINED_KEY222 = makeKey222(256);
  var INFINITY_KEY222 = makeKey222(256);
  var MINUS_INFINITY_KEY222 = makeKey222(256);
  var SYMBOL_KEY222 = makeKey222(256);
  function set22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return set22(arr.values);
    }
    assert22(isArray22(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = {};
    flatten22(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY222 : isUndefined22(item) ? UNDEFINED_KEY222 : isFunction22(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY222 : item === Infinity ? INFINITY_KEY222 : item === -Infinity ? MINUS_INFINITY_KEY222 : typeof item === "bigint" ? item.toString() : isDataFrame22(item) ? item.toJSONString() : isSeries22(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out222.push(item);
      temp[key] = true;
    });
    return out222;
  }
  function helper222(x) {
    if (isArray22(x)) {
      const childShapes = helper222(x[0]);
      return [x.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape22(x) {
    if (isDataFrame22(x) || isSeries22(x)) {
      return shape22(x.values);
    }
    assert22(isArray22(x), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper222(x);
  }
  function dfAppend22(df, x, axis) {
    if (isUndefined22(axis)) {
      axis = 0;
    }
    assert22(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray22(x)) {
      assert22(!isJagged22(x), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape22(x);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out222 = df.copy();
          out222._values.push(x);
          const maxRowLength = Math.max(df.shape[1], xShape[0]);
          out222._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out222 = df.copy();
          range22(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray22(df.shape[1]));
            }
            out222._values[i].push(x[i]);
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < out222._values[0].length) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x.map((row) => row.length).concat([df.shape[1]]));
          const out222 = df.copy();
          out222._values = out222._values.concat(x).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxRowLength = Math.max(...x.map((row) => row.length)) + df.shape[1];
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out222 = df.copy();
          range22(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray22(df.shape[1]));
            }
            out222._values[i] = out222._values[i].concat(x[i]);
            while (out222._values[i].length < maxRowLength) {
              out222._values[i].push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else {
        throw new MathError22("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries22(x)) {
      const out222 = dfAppend22(df, x.values, axis);
      if (axis === 0) {
        out222.index[out222.index.length - 1] = out222.index.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      } else {
        out222.columns[out222.columns.length - 1] = out222.columns.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      }
      return out222;
    } else if (isDataFrame22(x)) {
      if (axis === 0) {
        const out222 = df.copy();
        const maxRowLength = set22(out222._columns.concat(x._columns)).length;
        out222._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out222._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out222._values.push(temp.concat(rowCopy._values));
        }, 1);
        out222._columns = out222._columns.concat(x._columns.filter((c) => out222._columns.indexOf(c) < 0));
        while (out222._index.length < out222._values.length) {
          const newRowName = "row" + out222._index.length;
          out222._index.push(newRowName + (df._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out222;
      } else {
        const out222 = df.copy();
        out222._index.forEach((rowName, i) => {
          const xIndex = x._index.indexOf(rowName);
          if (xIndex > -1) {
            out222._values[i] = out222._values[i].concat(x._values[xIndex]);
          } else {
            out222._values[i] = out222._values[i].concat(ndarray22(x.shape[1]));
          }
        });
        x._index.forEach((rowName, i) => {
          const outIndex = out222._index.indexOf(rowName);
          if (outIndex < 0) {
            out222._index.push(rowName);
            out222._values.push(ndarray22(out222._columns.length).concat(x._values[i]));
          }
        });
        out222._columns = out222._columns.concat(x._columns.map((c) => c + (out222._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out222;
      }
    } else {
      throw new MathError22("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply22(DataFrame222, Series222, df, fn, axis) {
    axis = axis || 0;
    assert22(isFunction22(fn), "The first parameter to the `apply` method must be a function.");
    assert22(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df.columns.forEach((colName, i) => {
        const series = new Series222(df.values.map((row) => row[i]));
        series.name = colName;
        series.index = df.index;
        const value = fn(series, i, df);
        if (value instanceof Series222) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined22(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray22(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df.index;
        return out222;
      } else {
        const out222 = new Series222(df.columns.map((colName) => temp[colName]));
        out222.index = df.columns;
        return out222;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df.values.map((row, i) => {
        const series = new Series222(row);
        series.name = df.index[i];
        series.index = df.columns;
        const value = fn(series, i, df);
        if (isUndefined22(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray22(value);
        }
        if (value instanceof Series222) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df.index;
        out222.columns = df.columns;
        return out222;
      } else {
        const out222 = new Series222(temp);
        out222.index = df.index;
        return out222;
      }
    }
  }
  function isString22(s222) {
    return typeof s222 === "string";
  }
  function dfAssign22(DataFrame222, Series222, df, p1, p2) {
    const isDataFrame222 = (x) => x instanceof DataFrame222;
    const isSeries222 = (x) => x instanceof Series222;
    if (!isUndefined22(p2)) {
      assert22(isString22(p1), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert22(isArray22(p2) && !isJagged22(p2) && shape22(p2).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out222 = df.append(p2, 1);
      out222.columns[out222.columns.length - 1] = p1;
      return out222;
    } else {
      if (isDataFrame222(p1)) {
        return df.append(p1, 1);
      } else if (isSeries222(p1)) {
        return df.append(p1, 1);
      } else if (isObject22(p1)) {
        const maxColumnLength = Math.max(...Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).map((key) => p1[key].length));
        Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).forEach((key) => {
          while (p1[key].length < maxColumnLength) {
            p1[key].push(void 0);
          }
        });
        return df.append(new DataFrame222(p1), 1);
      } else {
        throw new MathError22("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy22(DataFrame222, df) {
    if (df.isEmpty)
      return new DataFrame222();
    const out222 = new DataFrame222(copy22(df.values));
    out222.columns = df.columns.slice();
    out222.index = df.index.slice();
    return out222;
  }
  function dfDrop22(DataFrame222, Series222, df, rows, cols) {
    if (isUndefined22(rows))
      rows = [];
    if (isUndefined22(cols))
      cols = [];
    if (isString22(rows) || isNumber22(rows))
      rows = [rows];
    if (isString22(cols) || isNumber22(cols))
      cols = [cols];
    assert22(isArray22(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert22(isArray22(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert22(shape22(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert22(shape22(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out222 = df.get(outIndex, outColumns);
    if (out222 instanceof Series222) {
      let temp = new DataFrame222();
      temp = temp.assign(out222);
      if (df.index.indexOf(out222.name) > -1)
        temp = temp.transpose();
      out222 = temp;
    }
    return out222;
  }
  function isInteger22(x) {
    return isNumber22(x) && (x >= 0 ? Math.floor(x) === x : Math.ceil(x) === x);
  }
  function isWholeNumber22(x) {
    return isInteger22(x) && x >= 0;
  }
  function dfDropMissing22(DataFrame222, Series222, df, axis, condition, threshold) {
    axis = axis || 0;
    assert22(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert22(isWholeNumber22(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert22(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper522(values) {
      if (threshold > 0) {
        let count222 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined22(value))
            count222++;
          if (count222 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined22(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined22(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out222 = df.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out222 = out222.assign(tempID, out222.index);
      const newValues = out222.values.map(helper522).filter((row) => row.length > 0);
      if (shape22(newValues).length < 2)
        return new DataFrame222();
      out222.values = newValues;
      let newIndex = out222.get(null, tempID);
      if (isUndefined22(newIndex))
        return new DataFrame222();
      if (isString22(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series222)
        newIndex = newIndex.values;
      out222.index = newIndex;
      out222 = out222.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out222.columns.forEach((colName, i) => {
        const values = out222.values.map((row) => row[i]);
        const newValues = helper522(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame222();
      }
      const newOut = new DataFrame222(temp);
      newOut.index = out222.index;
      return newOut;
    }
    return out222;
  }
  function dropNaN22(x) {
    if (isDataFrame22(x) || isSeries22(x)) {
      return x.dropNaN(...Object.values(arguments).slice(1));
    }
    assert22(isArray22(x), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x.forEach((v) => {
      try {
        return out222.push(dropNaN22(v));
      } catch (e) {
        if (isNumber22(v)) {
          return out222.push(v);
        }
      }
    });
    return out222;
  }
  function dfDropNaN22(DataFrame222, df, axis, condition, threshold) {
    axis = axis || 0;
    assert22(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert22(isWholeNumber22(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert22(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper522(values) {
      const numericalValues = dropNaN22(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out222 = df.copy();
    if (axis === 0) {
      const rowsToKeep = out222.index.filter((row) => {
        const values = out222.get(row, null).values;
        return helper522(values);
      });
      if (rowsToKeep.length > 0)
        return out222.get(rowsToKeep, null);
      else
        return new DataFrame222();
    } else if (axis === 1) {
      const colsToKeep = out222.columns.filter((col) => {
        const values = out222.get(null, col).values;
        return helper522(values);
      });
      if (colsToKeep.length > 0)
        return out222.get(null, colsToKeep);
      else
        return new DataFrame222();
    }
    return out222;
  }
  function arrayToObject22(x) {
    const out222 = {};
    flatten22(x).forEach((value, i) => {
      out222[value] = i;
    });
    return out222;
  }
  function undoArrayToObject22(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter22(DataFrame222, Series222, df, fn, axis) {
    assert22(isFunction22(fn), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined22(axis))
      axis = 0;
    assert22(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out222 = df.copy();
    if (out222.isEmpty)
      return out222;
    const index = arrayToObject22(out222.index);
    const columns = arrayToObject22(out222.columns);
    if (axis === 0) {
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df.index[i];
        series.index = df.columns;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count222++;
        } else {
          delete index[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject22(index)[0];
        temp.index = undoArrayToObject22(columns);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject22(index);
    } else if (axis === 1) {
      out222 = out222.transpose();
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df.columns[i];
        series.index = df.index;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count222++;
        } else {
          delete columns[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject22(columns)[0];
        temp.index = undoArrayToObject22(index);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject22(columns);
      out222 = out222.transpose();
    }
    return out222;
  }
  function dfGet22(df, rows, cols) {
    if (isString22(rows) || isNumber22(rows))
      rows = [rows];
    if (isString22(cols) || isNumber22(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set22((rows || []).concat(cols || []).map((v) => typeof v));
    assert22(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert22(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert22(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert22(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined22(rows)) {
      rows = rows.map((r) => {
        if (isString22(r)) {
          assert22(df.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber22(r)) {
          assert22(r >= 0, `Index ${r} is out of bounds!`);
          assert22(Math.floor(r) === r, `Row numbers must be integers!`);
          assert22(r < df.index.length, `Index ${r} is out of bounds!`);
          return df.index[r];
        }
      });
    }
    if (!isUndefined22(cols)) {
      cols = cols.map((c) => {
        if (isString22(c)) {
          assert22(df.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber22(c)) {
          assert22(c >= 0, `Column ${c} is out of bounds!`);
          assert22(Math.floor(c) === c, `Column numbers must be integers!`);
          assert22(c < df.columns.length, `Column ${c} is out of bounds!`);
          return df.columns[c];
        }
      });
    }
    return df.getSubsetByNames(rows, cols);
  }
  function alphaSort22(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort22(arr, fn) {
    if (isUndefined22(fn))
      fn = alphaSort22;
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert22(isArray22(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert22(isFunction22(fn), "The second parameter of the `sort` function must be a comparison function!");
    const out222 = arr.slice();
    out222.sort(fn);
    return out222;
  }
  function camelify32(text) {
    const temp = text.toLowerCase();
    let out222 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out222 += char;
      } else {
        out222 += " ";
      }
    }
    const words = out222.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies22(DataFrame222, df, columns) {
    if (isUndefined22(columns)) {
      columns = df.columns;
    } else if (isString22(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert22(isString22(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df.columns.indexOf(col);
      assert22(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df.values.map((row) => row[colIndex]);
      const valuesSet = sort22(set22(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify32(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out222 = new DataFrame222(temp);
    out222.index = df.index;
    return out222;
  }
  function dfGetSubsetByIndices22(df, rowIndices, colIndices) {
    const dataShape = df.shape;
    if (isUndefined22(rowIndices))
      rowIndices = range22(0, dataShape[0]);
    if (isUndefined22(colIndices))
      colIndices = range22(0, dataShape[1]);
    if (isNumber22(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber22(colIndices))
      colIndices = [colIndices];
    assert22(isArray22(rowIndices) && isArray22(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert22(shape22(rowIndices).length === 1 && shape22(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert22(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert22(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert22(isWholeNumber22(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert22(rowIndex < df.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert22(isWholeNumber22(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert22(colIndex < df.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df.index[i]);
    const cols = colIndices.map((i) => df.columns[i]);
    return df.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames22(DataFrame222, Series222, df, rows, cols) {
    if (isUndefined22(rows))
      rows = df.index;
    if (isUndefined22(cols))
      cols = df.columns;
    if (isString22(rows))
      rows = [rows];
    if (isString22(cols))
      cols = [cols];
    assert22(isArray22(rows) && isArray22(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert22(shape22(rows).length === 1 && shape22(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert22(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert22(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert22(isString22(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert22(df.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert22(isString22(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert22(df.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df.values[df.index.indexOf(row)][df.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series222(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series222(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out222 = new DataFrame222(values);
    out222.columns = cols;
    out222.index = rows;
    return out222;
  }
  function dfPrint22(DataFrame222, Series222, df) {
    function truncate(s222, maxLength2) {
      if (isString22(s222)) {
        if (s222.length > maxLength2) {
          return s222.substring(0, maxLength2 - 3) + "...";
        } else {
          return s222;
        }
      } else {
        return s222;
      }
    }
    if (df.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df.index.length ? null : range22(0, halfMaxRows).concat(range22(df.index.length - halfMaxRows, df.index.length));
    const tempColumns = maxColumns > df.columns.length ? null : range22(0, halfMaxColumns).concat(range22(df.columns.length - halfMaxColumns, df.columns.length));
    let temp = df.get(tempRows, tempColumns);
    if (temp instanceof Series222) {
      if (df.shape[0] === 1) {
        temp = new DataFrame222([temp.values]);
        temp.index = df.index;
        temp.columns = new Series222(df.columns).get(tempColumns).values;
      } else if (df.shape[1] === 1) {
        temp = new DataFrame222([temp.values]).transpose();
        temp.index = new Series222(df.index).get(tempRows).values;
        temp.columns = df.columns;
      }
    }
    if (maxRows <= df.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range22(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series222) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df.shape, "\n");
    return df;
  }
  function leftPad22(x, maxLength) {
    assert22(isNumber22(x), "The `leftPad` function only works on numbers!");
    let out222 = x.toString();
    while (out222.length < maxLength)
      out222 = "0" + out222;
    return out222;
  }
  function dfResetIndex22(df, shouldSkipCopying) {
    const out222 = shouldSkipCopying ? df : df.copy();
    out222.index = range22(0, df.shape[0]).map((i) => {
      return "row" + leftPad22(i, (out222.index.length - 1).toString().length);
    });
    return out222;
  }
  function product22(arr, shouldDropNaNs) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return product22(arr.values, shouldDropNaNs);
    }
    assert22(isArray22(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten22(arr);
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of temp) {
        if (!isNumber22(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  function isNaturalNumber22(x) {
    return isInteger22(x) && x > 0;
  }
  function reshape22(x, newShape) {
    if (isDataFrame22(x) || isSeries22(x)) {
      return reshape22(x.values, newShape);
    }
    assert22(isArray22(x), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber22(newShape))
      newShape = [newShape];
    assert22(isArray22(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert22(shape22(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert22(isNaturalNumber22(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten22(x);
    }
    const temp = flatten22(x);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert22(product22(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out222 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out222.push(reshape22(row, newShape.slice(1)));
    }
    return out222;
  }
  var MAX22 = Math.pow(2, 64);
  var s22 = [];
  seed22(Math.floor(Math.random() * MAX22));
  function splitmix6422(state, n) {
    state = uint22(state);
    function helper522() {
      state += uint22("0x9e3779b97f4a7c15");
      let z = copy22(state);
      z = (z ^ z >> BigInt(30)) * uint22("0xbf58476d1ce4e5b9");
      z = (z ^ z >> BigInt(27)) * uint22("0x94d049bb133111eb");
      return z ^ z >> BigInt(31);
    }
    const out222 = [];
    for (let i = 0; i < n; i++)
      out222.push(helper522());
    return out222;
  }
  function uint22(x) {
    return BigInt.asUintN(64, BigInt(x));
  }
  function rotl22(x, k) {
    x = uint22(x);
    k = BigInt(k);
    return uint22(uint22(x << k) | uint22(x >> uint22(BigInt(64) - k)));
  }
  function seed22(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined22(val)) {
      assert22(isNumber22(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix6422(Math.floor(val), 4);
      s22[0] = temp[0];
      s22[1] = temp[1];
      s22[2] = temp[2];
      s22[3] = temp[3];
    } else {
      return copy22(s22);
    }
  }
  function next22() {
    const result = uint22(rotl22(s22[0] + s22[3], 23) + s22[0]);
    const t = uint22(s22[1] << BigInt(17));
    s22[2] = uint22(s22[2] ^ s22[0]);
    s22[3] = uint22(s22[3] ^ s22[1]);
    s22[1] = uint22(s22[1] ^ s22[2]);
    s22[0] = uint22(s22[0] ^ s22[3]);
    s22[2] = uint22(s22[2] ^ t);
    s22[3] = rotl22(s22[3], 45);
    return Math.floor(Number(result)) / MAX22;
  }
  function random22(shape222) {
    if (isUndefined22(shape222))
      return next22();
    if (!isArray22(shape222))
      shape222 = [shape222];
    return reshape22(ndarray22(product22(shape222)).map(next22), shape222);
  }
  function shuffle22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert22(isArray22(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random22() * temp.length);
      out222.push(temp.splice(index, 1)[0]);
    }
    return out222;
  }
  function dfShuffle22(df, axis) {
    if (isUndefined22(axis))
      axis = 0;
    assert22(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df.get(axis === 0 ? shuffle22(df.index) : null, axis === 1 ? shuffle22(df.columns) : null);
  }
  function isBoolean22(x) {
    return typeof x === "boolean";
  }
  function dfSort22(df, a, b) {
    if (isFunction22(a)) {
      return dfSortByFunction22(df, a, b);
    } else {
      return dfSortByColumns22(df, a, b);
    }
  }
  function dfSortByFunction22(df, fn, axis) {
    axis = isUndefined22(axis) ? 0 : axis;
    assert22(isFunction22(fn), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert22(isNumber22(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort22(df.index, (a, b) => {
        return fn(df.get(a, null), df.get(b, null));
      });
      return df.get(index, null);
    } else {
      const columns = sort22(df.columns, (a, b) => {
        return fn(df.get(null, a), df.get(null, b));
      });
      return df.get(null, columns);
    }
  }
  function dfSortByColumns22(df, cols, directions) {
    let out222 = df.copy();
    const indexID = random22().toString();
    out222 = out222.assign(indexID, out222.index);
    if (isUndefined22(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber22(cols) || isString22(cols)) {
      cols = [cols];
      if (isBoolean22(directions) || isString22(directions))
        directions = [directions];
    }
    assert22(isArray22(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert22(shape22(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined22(directions))
      directions = range22(0, cols.length).map(() => true);
    assert22(isArray22(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert22(shape22(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert22(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert22(isString22(col) || isNumber22(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString22(col)) {
        const index = out222.columns.indexOf(col);
        assert22(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber22(col)) {
        assert22(isWholeNumber22(col), "Column indices must be whole numbers!");
        assert22(col < out222.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert22(isString22(dir) || isBoolean22(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString22(dir)) {
        const value = dir.trim().toLowerCase();
        assert22(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean22(dir)) {
        return dir;
      }
    });
    out222.values = sort22(out222.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out222.columns.indexOf(indexID);
    out222.index = out222.values.map((row) => row[indexNumber]);
    out222 = out222.dropColumns(indexID);
    return out222;
  }
  function dfToDetailedObject22(df, axis) {
    if (isUndefined22(axis)) {
      axis = 0;
    } else {
      assert22(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out222 = {};
    if (axis === 0) {
      df.index.forEach((rowName, i) => {
        const temp = {};
        df.columns.forEach((colName, j) => {
          temp[colName] = df.values[i][j];
        });
        out222[rowName] = temp;
      });
    } else {
      df.columns.forEach((colName, j) => {
        const temp = {};
        df.index.forEach((rowName, i) => {
          temp[rowName] = df.values[i][j];
        });
        out222[colName] = temp;
      });
    }
    return out222;
  }
  function dfToJSONString22(df, axis) {
    return JSON.stringify(df.toObject(axis));
  }
  async function dfToJSON22(df, filename, axis) {
    const out222 = dfToJSONString22(df, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out222)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e) {
      browserError = e;
    }
    try {
      const fs = await import("node:fs");
      const path = await import("node:path");
      fs.writeFileSync(path.resolve(filename), out222, "utf8");
      wroteToDiskInNode = true;
    } catch (e) {
      nodeError = e;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError22(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError22(nodeError);
      } else {
        throw new MathError22("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df;
  }
  function dfToObject22(df) {
    const out222 = {};
    df.columns.forEach((col) => {
      out222[col] = df.get(col).values;
    });
    return out222;
  }
  function transpose22(arr) {
    if (isDataFrame22(arr) || isSeries22(arr)) {
      return arr.transpose();
    }
    assert22(isArray22(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape22(arr);
    assert22(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse22(arr);
    } else if (theShape.length === 2) {
      const out222 = ndarray22(reverse22(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out222[col][row] = arr[row][col];
        }
      }
      return out222;
    }
  }
  function seriesAppend22(Series222, series, x) {
    if (isSeries22(x)) {
      return new Series222(series.values.concat(x.values));
    }
    if (isArray22(x)) {
      const xShape = shape22(x);
      assert22(xShape.length === 1 && !isNested22(xShape), "Only vectors can be appended to Series!");
      const out222 = series.copy();
      x.forEach((v, i) => {
        out222._values.push(v);
        out222._index.push("item" + (series.values.length + i));
      });
      return out222;
    }
    return seriesAppend22(series, [x]);
  }
  function seriesApply22(series, fn) {
    assert22(isFunction22(fn), "The parameter to the `apply` method must be a function.");
    const out222 = series.copy();
    out222._values = out222._values.map((v, i) => fn(v, i));
    return out222;
  }
  function seriesDropMissing22(series) {
    const out222 = series.copy();
    const outIndex = [];
    out222._values = out222.values.filter((v, i) => {
      if (isUndefined22(v)) {
        return false;
      } else {
        outIndex.push(out222.index[i]);
        return true;
      }
    });
    out222._index = outIndex;
    return out222;
  }
  function seriesDropNaN22(Series222, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber22(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out222 = new Series222(values);
    out222.name = series.name;
    out222.index = index;
    return out222;
  }
  function seriesFilter22(Series222, series, fn) {
    let out222 = series.copy();
    const index = copy22(out222.index);
    const indicesToRemove = [];
    const newValues = out222.values.filter((value, i) => {
      const shouldKeep = fn(value, i, out222.values);
      if (!shouldKeep)
        indicesToRemove.push(out222.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out222 = new Series222();
      out222.name = series.name;
      return out222;
    }
    out222.values = newValues;
    out222.index = index;
    return out222;
  }
  function seriesGet22(series, indices) {
    if (isString22(indices) || isNumber22(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set22((indices || []).map((v) => typeof v));
    assert22(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert22(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert22(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert22(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined22(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert22(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert22(i >= 0, `Index ${i} is out of bounds!`);
          assert22(Math.floor(i) === i, `Indices must be integers!`);
          assert22(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices22(series, indices) {
    const dataShape = series.shape;
    if (isUndefined22(indices))
      indices = range22(0, dataShape[0]);
    assert22(isArray22(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert22(shape22(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert22(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert22(isWholeNumber22(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert22(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames22(Series222, series, indices) {
    if (isUndefined22(indices))
      indices = series.index;
    assert22(isArray22(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert22(shape22(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert22(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert22(isString22(name), "The `indices` array must contain only strings.");
      assert22(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out222 = new Series222(values);
    out222.index = indices;
    out222.name = series.name;
    return out222;
  }
  function seriesPrint22(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range22(0, maxRows / 2).concat(range22(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy22(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out222 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out222[temp.index[i]] = obj;
    });
    console.table(out222);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle22(series) {
    const out222 = series.copy();
    return out222.get(shuffle22(out222.index));
  }
  function seriesSort22(Series222, series, fn) {
    fn = fn || ((a, b) => a < b ? -1 : 1);
    assert22(isUndefined22(fn) || isFunction22(fn), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose22([series.values, series.index]);
    const temp = sort22(pairs, (aPair, bPair) => {
      return fn(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out222 = new Series222();
    out222._values = newValues;
    out222._index = newIndex;
    out222.name = series.name;
    return out222;
  }
  function seriesSortByIndex22(Series222, series) {
    let temp = transpose22([series.values, series.index]);
    temp = transpose22(sort22(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out222 = new Series222(temp[0]);
    out222.index = temp[1];
    out222.name = series.name;
    return out222;
  }
  function seriesToObject22(series) {
    const out222 = {};
    out222[series.name] = {};
    series.index.forEach((index, i) => {
      out222[series.name][index] = series.values[i];
    });
    return out222;
  }
  var SERIES_SYMBOL22 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass22(DataFrame222) {
    class Series222 {
      static [Symbol.hasInstance](x) {
        try {
          return !!x._symbol && x._symbol === SERIES_SYMBOL22;
        } catch (e) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL22
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x) {
            assert22(isArray22(x), "The new values must be a 1-dimensional array!");
            const dataShape = shape22(x);
            assert22(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range22(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad22(i, (x.length - 1).toString().length);
              }));
            }
            this._values = x;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x) {
            assert22(isArray22(x), "The new index must be a 1-dimensional array of strings!");
            assert22(x.length === this.shape[0], "The new index must be the same length as the old index!");
            assert22(shape22(x).length === 1, "The new index must be a 1-dimensional array of strings!");
            x.forEach((value) => {
              assert22(isString22(value), "All of the row names must be strings!");
            });
            this._index = x;
          }
        });
        if (data) {
          if (data instanceof Series222) {
            this.name = data.name;
            this.values = copy22(data.values);
            this.index = copy22(data.index);
          } else if (isArray22(data)) {
            const dataShape = shape22(data);
            assert22(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert22(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert22(shape22(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape22(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined22(v)).length === 0;
      }
      clear() {
        const out222 = this.copy();
        out222.values.forEach((v, i) => {
          out222.values[i] = void 0;
        });
        return out222;
      }
      get(indices) {
        return seriesGet22(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames22(Series222, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices22(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out222 = new Series222(reverse22(this.values));
        out222.index = reverse22(this.index);
        out222.name = this.name;
        return out222;
      }
      resetIndex() {
        const out222 = this.copy();
        out222.index = range22(0, this.shape[0]).map((i) => {
          return "item" + leftPad22(i, (out222.index.length - 1).toString().length);
        });
        return out222;
      }
      copy() {
        const out222 = new Series222();
        out222._values = copy22(this.values);
        out222._index = copy22(this.index);
        out222.name = this.name;
        return out222;
      }
      append(x) {
        return seriesAppend22(Series222, this, x);
      }
      apply(fn) {
        return seriesApply22(this, fn);
      }
      concat(x) {
        return this.append(x);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing22(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN22(Series222, this);
      }
      toObject() {
        return seriesToObject22(this);
      }
      print() {
        return seriesPrint22(this);
      }
      shuffle() {
        return seriesShuffle22(this);
      }
      sort(direction) {
        return seriesSort22(Series222, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex22(Series222, this);
      }
      filter(fn) {
        return seriesFilter22(Series222, this, fn);
      }
      toDataFrame() {
        const out222 = new DataFrame222(transpose22([this.values]));
        out222.columns = [this.name];
        out222.index = this.index;
        return out222;
      }
      transpose() {
        const out222 = this.copy();
        out222.values = reverse22(out222.values);
        out222.index = reverse22(out222.index);
        return out222;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series222;
  }
  var DATAFRAME_SYMBOL22 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey322(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out222 = "";
    for (let i = 0; i < n; i++)
      out222 += alpha[Math.floor(random22() * alpha.length)];
    return out222;
  }
  var DataFrame22 = class {
    static [Symbol.hasInstance](x) {
      try {
        return !!x._symbol && x._symbol === DATAFRAME_SYMBOL22;
      } catch (e) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL22
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined22(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x) {
          assert22(isArray22(x), "The new values must be a 2-dimensional array!");
          const dataShape = shape22(x);
          assert22(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range22(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad22(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range22(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad22(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x) {
          assert22(isArray22(x), "The new columns list must be a 1-dimensional array of strings!");
          assert22(this.isEmpty || x.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert22(shape22(x).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey322(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count22(x);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey322(8);
            }
            return v;
          });
          this._columns = x;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x) {
          assert22(isArray22(x), "The new index must be a 1-dimensional array of strings!");
          assert22(this.isEmpty || x.length === this.shape[0], "The new index must be the same length as the old index!");
          assert22(shape22(x).length === 1, "The new index must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey322(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count22(x);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey322(8);
            }
            return v;
          });
          this._index = x;
        }
      });
      assert22(isUndefined22(data) || isObject22(data) || isArray22(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame22) {
          this.values = copy22(data.values);
          this.columns = copy22(data.columns);
          this.index = copy22(data.index);
        } else if (isArray22(data)) {
          const dataShape = shape22(data);
          assert22(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert22(!isJagged22(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined22(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert22(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose22(temp);
          const dataShape = shape22(this.values);
          this._index = range22(0, dataShape[0]).map((i) => {
            return "row" + leftPad22(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape22(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out222 = new DataFrame22(ndarray22(this.shape));
      out222.columns = this.columns.slice();
      out222.index = this.index.slice();
      return out222;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e) {
          return this.get(rows, null);
        }
      }
      return dfGet22(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames22(DataFrame22, Series22, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices22(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies22(DataFrame22, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies22(DataFrame22, this, columns);
    }
    transpose() {
      const out222 = new DataFrame22(transpose22(this.values));
      out222.columns = this.index.slice();
      out222.index = this.columns.slice();
      return out222;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex22(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy22(DataFrame22, this);
    }
    assign(p1, p2) {
      return dfAssign22(DataFrame22, Series22, this, p1, p2);
    }
    apply(fn, axis) {
      return dfApply22(DataFrame22, Series22, this, fn, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing22(DataFrame22, Series22, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN22(DataFrame22, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop22(DataFrame22, Series22, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject22(this, axis);
    }
    toObject() {
      return dfToObject22(this);
    }
    toJSONString(axis) {
      return dfToJSONString22(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON22(this, filename, axis);
    }
    print() {
      return dfPrint22(DataFrame22, Series22, this);
    }
    sort(cols, directions) {
      return dfSort22(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn, axis) {
      return dfFilter22(DataFrame22, Series22, this, fn, axis);
    }
    shuffle(axis) {
      return dfShuffle22(this, axis);
    }
    append(x, axis) {
      return dfAppend22(this, x, axis);
    }
    concat(x, axis) {
      return this.append(x, axis);
    }
    join(x, axis) {
      return this.append(x, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series22 = createSeriesClass22(DataFrame22);
  function max22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs }).max;
  }
  function vectorize22(fn) {
    assert22(isFunction22(fn), "You must pass a function into the `vectorize` function!");
    return function helper522() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray22(arg)) {
          return true;
        } else if (isSeries22(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame22(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s222, i) => {
        assert22(isEqual22(isArray22(s222) ? shape22(s222) : s222.shape, isArray22(childArrays[i + 1]) ? shape22(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max22(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out222 = range22(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray22(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries22(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame22(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper522(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual22(shape22(dataframes[0]), shape22(out222))) {
              const temp = new DataFrame22(out222);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame22(out222);
            }
          } catch (e) {
            return out222;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out222.length) {
              const temp = new Series22(out222);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series22(out222);
            }
          } catch (e) {
            return out222;
          }
        }
        return out222;
      } else {
        return fn(...arguments);
      }
    };
  }
  function abs22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        return x < 0 ? -x : x;
      } else {
        return Math.abs(x);
      }
    } catch (e) {
      return NaN;
    }
  }
  var vabs22 = vectorize22(abs22);
  function add22() {
    try {
      let out222 = 0;
      let resultShouldBeABigInt = false;
      const x = Object.values(arguments);
      for (let v of x) {
        if (!isNumber22(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  var vadd22 = vectorize22(add22);
  function apply22(x, fn) {
    try {
      return fn(x);
    } catch (e) {
      return NaN;
    }
  }
  var vapply22 = vectorize22(apply22);
  function arccos22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.acos(x);
    } catch (e) {
      return NaN;
    }
  }
  var varccos22 = vectorize22(arccos22);
  function arcsin22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.asin(x);
    } catch (e) {
      return NaN;
    }
  }
  var varcsin22 = vectorize22(arcsin22);
  function arctan22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.atan(x);
    } catch (e) {
      return NaN;
    }
  }
  var varctan22 = vectorize22(arctan22);
  function argmax22(x, shouldDropNaNs) {
    if (isDataFrame22(x)) {
      const index = argmax22(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries22(x)) {
      const index = argmax22(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert22(isArray22(x), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf22(x, max22(x, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function min22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs }).min;
  }
  function argmin22(x, shouldDropNaNs) {
    if (isDataFrame22(x)) {
      const index = argmin22(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries22(x)) {
      const index = argmin22(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert22(isArray22(x), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf22(x, min22(x, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function cast22(value, type) {
    if (isDataFrame22(value) || isSeries22(value)) {
      return value.apply((item) => cast22(item, type));
    }
    if (isArray22(value)) {
      return value.map((v) => cast22(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined22(value)) {
        return NaN;
      }
      const booleanValue = cast22(value, "boolean");
      if (isBoolean22(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e) {
        const dateValue = cast22(value, "date");
        if (isDate22(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out222 = parseFloat(value);
      if (isNaN(out222))
        return NaN;
      return out222;
    }
    if (type === "int") {
      const out222 = cast22(value, "number");
      return out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
    }
    if (type === "float") {
      return cast22(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast22(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean22(value)) {
        return value;
      }
      if (isNumber22(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate22(value)) {
        return value;
      }
      if (isUndefined22(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out222 = new Date(value);
        if (!isDate22(out222))
          return null;
        return out222;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject22(value)) {
        return value;
      }
      const booleanValue = cast22(value, "boolean");
      if (isBoolean22(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast22(value, "number");
        if (isNumber22(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e) {
      }
      const dateValue = cast22(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out222 = JSON.parse(value);
        if (isArray22(out222)) {
          return out222.map((v) => cast22(v, type));
        } else {
          return out222;
        }
      } catch (e) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined22(value)) {
        if (isEqual22(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.ceil(x);
    } catch (e) {
      return NaN;
    }
  }
  var vceil22 = vectorize22(ceil22);
  function chop22(x, threshold) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      if (isUndefined22(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber22(threshold)) {
        return NaN;
      }
      return vabs22(x) < threshold ? 0 : x;
    } catch (e) {
      return NaN;
    }
  }
  var vchop22 = vectorize22(chop22);
  function int22(x) {
    if (isDataFrame22(x) || isSeries22(x)) {
      const out222 = x.copy();
      out222.values = int22(out222.values);
      return out222;
    }
    if (isArray22(x)) {
      return x.map((v) => int22(v));
    } else {
      try {
        const out222 = JSON.parse(x);
        if (isNumber22(out222)) {
          return typeof out222 === "bigint" ? Number(out222) : out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
        }
        return NaN;
      } catch (e) {
        return NaN;
      }
    }
  }
  var vint22 = vectorize22(int22);
  function clamp22(x, a, b) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (!isNumber22(a))
        return NaN;
      if (!isNumber22(b))
        return NaN;
      if (typeof x === "bigint") {
        return BigInt(clamp22(vint22(x), a, b));
      }
      if (x < a)
        return a;
      if (x > b)
        return b;
      return x;
    } catch (e) {
      return NaN;
    }
  }
  var vclamp22 = vectorize22(clamp22);
  function combinationsIterator22(x, r) {
    function* helper522(x2, r2) {
      if (r2 > x2.length) {
        yield x2;
      } else if (r2 <= 0) {
        yield [];
      } else if (x2.length < 2) {
        yield x2;
      } else {
        for (let i = 0; i < x2.length; i++) {
          const item = x2[i];
          const after = x2.slice(i + 1);
          if (after.length < r2 - 1) {
            continue;
          }
          if (r2 - 1 >= 0) {
            for (const child of combinationsIterator22(after, r2 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame22(x) || isSeries22(x)) {
      return combinationsIterator22(x.values, r);
    }
    assert22(isArray22(x), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert22(isNumber22(r) && vint22(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten22(x), r);
  }
  function combinations22(x, r) {
    const out222 = [];
    for (const combo of combinationsIterator22(x, r)) {
      out222.push(combo.slice());
    }
    return out222;
  }
  function intersect22() {
    const arrays = Object.values(arguments).map((x) => {
      if (isDataFrame22(x) || isSeries22(x)) {
        return set22(x.values);
      }
      assert22(isArray22(x), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set22(x);
    });
    const all = set22(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual22(other, v)) > -1);
    });
  }
  var _IndexMatcher22 = class {
    constructor(mode222) {
      assert22(isUndefined22(mode222) || mode222 === _IndexMatcher22.DROP_NAN_MODE || mode222 === _IndexMatcher22.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined22(mode222) ? mode222 : _IndexMatcher22.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x) => {
        if (isArray22(x)) {
          const xshape = shape22(x);
          if (xshape.length === 1) {
            x = new Series22(x);
          } else if (xshape.length === 2) {
            x = new DataFrame22(x);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert22(isDataFrame22(x) || isSeries22(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher22.DROP_MISSING_MODE) {
          indices.push(x.dropMissing().index);
        } else {
          indices.push(x.dropNaN().index);
        }
      });
      this.index = intersect22(...indices);
      return this;
    }
    transform() {
      assert22(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out222 = Object.values(arguments).map((x) => {
        if (isArray22(x)) {
          const xshape = shape22(x);
          if (xshape.length === 1) {
            return new Series22(x).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame22(x).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert22(isDataFrame22(x) || isSeries22(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x.get(this.index, null);
      });
      return out222.length === 1 ? out222[0] : out222;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher22 = _IndexMatcher22;
  __publicField22(IndexMatcher22, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField22(IndexMatcher22, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance22(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries22(x)) {
      return covariance22(x.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries22(y)) {
      return covariance22(x, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert22(isArray22(x) && isArray22(y) && shape22(x).length === 1 && shape22(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert22(x.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance22(...new IndexMatcher22().fitAndTransform(x, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats22(x, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats22(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx = Number(xstats.mean);
      const my = Number(ystats.mean);
      if (!isNumber22(mx) || !isNumber22(my)) {
        return NaN;
      }
      const n = Math.max(x.length, y.length);
      let out222 = 0;
      for (let i = 0; i < n; i++) {
        let vx = x[i];
        let vy = y[i];
        if (!isNumber22(vx))
          return NaN;
        if (!isNumber22(vy))
          return NaN;
        if (typeof vx === "bigint") {
          vx = Number(vx);
        }
        if (typeof vy === "bigint") {
          vy = Number(vy);
        }
        out222 += (vx - mx) * (vy - my);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out222 / x.length, xstats, ystats];
      } else {
        return out222 / x.length;
      }
    } catch (e) {
      return NaN;
    }
  }
  function correl22(x, y, shouldDropNaNs) {
    if (isSeries22(x)) {
      return correl22(x.values, y, shouldDropNaNs);
    }
    if (isSeries22(y)) {
      return correl22(x, y.values, shouldDropNaNs);
    }
    assert22(isArray22(x) && isArray22(y) && shape22(x).length === 1 && shape22(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert22(x.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance22(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e) {
      return NaN;
    }
  }
  function cos22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.cos(x);
    } catch (e) {
      return NaN;
    }
  }
  var vcos22 = vectorize22(cos22);
  var dataTypes22 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff22(a, b) {
    if (isDataFrame22(a) || isSeries22(a)) {
      return diff22(a.values, b);
    }
    if (isDataFrame22(b) || isSeries22(b)) {
      return diff22(a, b.values);
    }
    assert22(isArray22(a) && isArray22(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set22(a);
    const bTemp = set22(b);
    const out222 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual22(other, item)) < 0) {
        out222.push(item);
      }
    });
    return out222;
  }
  function pow22(x, p) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (!isNumber22(p))
        return NaN;
      if (typeof x === "bigint" || typeof p === "bigint") {
        const out222 = pow22(Number(x), Number(p));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.pow(x, p);
    } catch (e) {
      return NaN;
    }
  }
  var vpow22 = vectorize22(pow22);
  function sqrt22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        const out222 = sqrt22(Number(x));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.sqrt(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsqrt22 = vectorize22(sqrt22);
  function multiply22() {
    try {
      const x = Object.values(arguments);
      if (x.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of x) {
        if (!isNumber22(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  var vmultiply22 = vectorize22(multiply22);
  function scale22() {
    return vmultiply22(...arguments);
  }
  function subtract22(a, b) {
    return vadd22(a, scale22(b, -1));
  }
  function sum22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs }).sum;
  }
  function distance22(a, b) {
    if (isNumber22(a) && isNumber22(b)) {
      return vabs22(a - b);
    }
    if (isDataFrame22(a) || isSeries22(a)) {
      return distance22(a.values, b);
    }
    if (isDataFrame22(b) || isSeries22(b)) {
      return distance22(a, b.values);
    }
    if (isArray22(a) && isArray22(b)) {
      assert22(isEqual22(shape22(a), shape22(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt22(sum22(vpow22(subtract22(a, b), 2)));
    } catch (e) {
      return NaN;
    }
  }
  function divide22(a, b) {
    return scale22(a, vpow22(b, -1));
  }
  function dot22(a, b) {
    if (isDataFrame22(a)) {
      const temp = dot22(a.values, b);
      if (shape22(temp).length === 1) {
        const out222 = new Series22(temp);
        out222.name = isSeries22(b) ? b.name : out222.name;
        out222.index = a.index.slice();
        return out222;
      } else {
        const out222 = new DataFrame22(temp);
        out222.index = a.index.slice();
        if (isDataFrame22(b)) {
          out222.columns = b.columns.slice();
        }
        return out222;
      }
    }
    if (isDataFrame22(b)) {
      const temp = dot22(a, b.values);
      if (shape22(temp).length === 1) {
        const out222 = new Series22(temp);
        out222.name = isSeries22(a) ? a.name : out222.name;
        out222.index = b.columns.slice();
        return out222;
      } else {
        const out222 = new DataFrame22(temp);
        out222.columns = b.columns.slice();
        return out222;
      }
    }
    if (isSeries22(a)) {
      return dot22(a.values, b);
    }
    if (isSeries22(b)) {
      return dot22(a, b.values);
    }
    assert22(isArray22(a) && isArray22(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape22(a);
    const bShape = shape22(b);
    assert22(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert22(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum22(scale22(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose22(b).map((col) => dot22(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot22(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose22(b);
      const out222 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot22(a[i], bTranspose[j]));
        }
        out222.push(row);
      }
      return out222;
    }
  }
  function dropMissing22(x) {
    if (isDataFrame22(x) || isSeries22(x)) {
      return x.dropMissing(...Object.values(arguments).slice(1));
    }
    assert22(isArray22(x), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x.forEach((v) => {
      try {
        return out222.push(dropMissing22(v));
      } catch (e) {
        if (!isUndefined22(v)) {
          out222.push(v);
        }
      }
    });
    return out222;
  }
  function dropMissingPairwise22(a, b) {
    if (isDataFrame22(a) || isSeries22(a)) {
      return dropMissingPairwise22(a.values, b);
    }
    if (isDataFrame22(b) || isSeries22(b)) {
      return dropMissingPairwise22(a, b.values);
    }
    assert22(isArray22(a) && isArray22(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert22(isEqual22(shape22(a), shape22(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise22(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (!isUndefined22(a[i]) && !isUndefined22(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise22(a, b) {
    if (isDataFrame22(a) || isSeries22(a)) {
      return dropNaNPairwise22(a.values, b);
    }
    if (isDataFrame22(b) || isSeries22(b)) {
      return dropNaNPairwise22(a, b.values);
    }
    assert22(isArray22(a) && isArray22(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert22(isEqual22(shape22(a), shape22(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise22(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (isNumber22(a[i]) && isNumber22(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined22(x) {
    return dropMissing22(x);
  }
  function every22(x, fn) {
    if (isDataFrame22(x) || isSeries22(x)) {
      return every22(x.values, fn);
    }
    assert22(isArray22(x), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert22(isFunction22(fn), "The second argument passed into the `every` function must be a function!");
    for (const v of x) {
      if (isArray22(v)) {
        if (!every22(v, fn)) {
          return false;
        }
      } else {
        if (!fn(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        if (x === 0n) {
          return 1n;
        } else {
          x = Number(x);
        }
      }
      return Math.exp(x);
    } catch (e) {
      return NaN;
    }
  }
  var vexp22 = vectorize22(exp22);
  function factorial22(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial22(vint22(n)));
      }
      if (n !== vint22(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial22(n - 1);
    } catch (e) {
      return NaN;
    }
  }
  var vfactorial22 = vectorize22(factorial22);
  function find22(x, fn) {
    if (isDataFrame22(x)) {
      return find22(x.values, fn);
    }
    if (isSeries22(x)) {
      return find22(x.values, fn);
    }
    assert22(isObject22(x) || isArray22(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction22(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject22(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return value;
          }
          const result = helper522(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray22(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return value;
          }
          const result = helper522(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn2(x2)) {
          return x2;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    return helper522(x, safeFn);
  }
  function findAll22(x, fn) {
    if (isDataFrame22(x)) {
      return findAll22(x.values, fn);
    }
    if (isSeries22(x)) {
      return findAll22(x.values, fn);
    }
    assert22(isObject22(x) || isArray22(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction22(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject22(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        const out222 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else if (isArray22(x2)) {
        checked.push(x2);
        const out222 = [];
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else {
        if (fn2(x2)) {
          return [x2];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const results = helper522(x, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float22(x) {
    try {
      if (x === "Infinity") {
        return Infinity;
      }
      if (x === "-Infinity") {
        return -Infinity;
      }
      const out222 = JSON.parse(x);
      if (isNumber22(out222))
        return out222;
      return NaN;
    } catch (e) {
      return NaN;
    }
  }
  var vfloat22 = vectorize22(float22);
  function floor22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        return x;
      }
      return Math.floor(x);
    } catch (e) {
      return NaN;
    }
  }
  var vfloor22 = vectorize22(floor22);
  function zeros22(shape222) {
    if (isNumber22(shape222))
      shape222 = [shape222];
    const out222 = [];
    const n = product22(shape222);
    for (let i = 0; i < n; i++)
      out222.push(0);
    return reshape22(out222, shape222);
  }
  function identity22(size) {
    if (typeof size === "bigint") {
      size = vint22(size);
    }
    assert22(!isUndefined22(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert22(isNumber22(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert22(vint22(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert22(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out222 = zeros22([size, size]);
    for (let i = 0; i < size; i++)
      out222[i][i] = 1;
    return out222;
  }
  var booleanValues22 = ["true", "false", "yes", "no"];
  var nullValues22 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger22(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint22(results.value) === results.value;
      } else {
        results.isInteger = every22(results.values, (v) => isNumber22(v) ? vint22(v) === v : true);
      }
    }
    return results;
  }
  function inferType22(arr) {
    if (isDataFrame22(arr)) {
      const out222 = arr.copy();
      const results = inferType22(arr.values);
      out222.values = results.values;
      return checkIfInteger22({ type: results.type, values: out222 });
    }
    if (isSeries22(arr)) {
      const out222 = arr.copy();
      const results = inferType22(arr.values);
      out222.values = results.values;
      return checkIfInteger22({ type: results.type, values: out222 });
    }
    if (!isArray22(arr)) {
      const out222 = inferType22([arr]);
      out222.value = out222.values[0];
      delete out222.values;
      return checkIfInteger22(out222);
    }
    assert22(isArray22(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten22(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate22(temp)) {
            return "date";
          }
        }
      } catch (e) {
      }
      if (!isString22(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues22.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues22.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber22(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray22(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e) {
        const vDate = new Date(v);
        if (isDate22(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count22(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger22({
      type: primaryType,
      values: vapply22(arr, (v) => cast22(v, primaryType))
    });
  }
  function inverse22(x) {
    if (isDataFrame22(x)) {
      const out222 = x.copy();
      out222.values = inverse22(out222.values);
      return out222;
    }
    assert22(isArray22(x), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape22(x);
    assert22(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert22(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert22(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x;
    } else if (xShape[0] === 1) {
      assert22(x[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x[0][0];
      let b = x[0][1];
      let c = x[1][0];
      let d = x[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det = a * d - b * c;
      assert22(det !== 0, "This matrix cannot be inverted!");
      const out222 = [
        [d, -b],
        [-c, a]
      ];
      return scale22(out222, 1 / det);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber22(a) || isNumber22(b) ? scale22(a, b) : dot22(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x.slice(0, divider).map((row) => row.slice(0, divider));
          const B = x.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C = x.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse22(A);
          const CompInv = inverse22(vadd22(D, times(-1, times(times(C, AInv), B))));
          const topLeft = vadd22(AInv, times(times(times(times(AInv, B), CompInv), C), AInv));
          const topRight = times(-1, times(times(AInv, B), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C), AInv));
          const bottomRight = CompInv;
          const out222 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out222;
        } catch (e) {
        }
      }
      assert22(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser222 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp22(a, b, f) {
    try {
      if (!isNumber22(a))
        return NaN;
      if (!isNumber22(b))
        return NaN;
      if (!isNumber22(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = lerp22(Number(a), Number(b), f);
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return f * (b - a) + a;
    } catch (e) {
      return NaN;
    }
  }
  var vlerp22 = vectorize22(lerp22);
  function log22(x, base) {
    try {
      base = isUndefined22(base) ? Math.E : base;
      if (!isNumber22(x))
        return NaN;
      if (!isNumber22(base))
        return NaN;
      if (typeof x === "bigint" || typeof base === "bigint") {
        const out222 = log22(Number(x), Number(base));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.log(x) / Math.log(base);
    } catch (e) {
      return NaN;
    }
  }
  var vlog22 = vectorize22(log22);
  function mean22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs }).mean;
  }
  function median22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod22(a, b) {
    try {
      if (!isNumber22(a))
        return NaN;
      if (!isNumber22(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = mod22(Number(a), Number(b));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return a % b;
    } catch (e) {
      return NaN;
    }
  }
  var vmod22 = vectorize22(mod22);
  function mode22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper322() {
    const u1 = random22();
    const u2 = random22();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
  function normal22(shape222) {
    if (isUndefined22(shape222))
      return helper322();
    return vapply22(ndarray22(shape222), helper322);
  }
  function ones22(shape222) {
    return vapply22(ndarray22(shape222), () => 1);
  }
  function permutationsIterator22(x, r) {
    function* helper522(x2, r2) {
      r2 = r2 || x2.length;
      if (x2.length === 1) {
        yield [x2];
        return;
      }
      for (const c of combinations22(x2, r2)) {
        if (!c.slice)
          continue;
        const state = zeros22(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame22(x) || isSeries22(x)) {
      return permutationsIterator22(x.values, r);
    }
    assert22(isArray22(x), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined22(r)) {
      r = x.length;
    }
    assert22(isNumber22(r) && vint22(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten22(x), r);
  }
  function permutations22(x, r) {
    const out222 = [];
    for (const perm of permutationsIterator22(x, r)) {
      out222.push(perm.slice());
    }
    return out222;
  }
  function print22() {
    Object.keys(arguments).forEach((key) => {
      const x = arguments[key];
      if (isArray22(x)) {
        if (!isJagged22(x)) {
          const xShape = shape22(x);
          if (xShape.length === 1) {
            new Series22(x).print();
          } else if (xShape.length == 2) {
            new DataFrame22(x).print();
          } else {
            console.log(x);
          }
        } else {
          console.log(x);
        }
      } else if (isDataFrame22(x) || isSeries22(x)) {
        x.print();
      } else {
        console.log(x);
      }
    });
  }
  var helper422 = vectorize22((x, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x, a, b, c, d]) {
        if (!isNumber22(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x = Number(x);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out222 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  });
  function remap22(x, a, b, c, d) {
    if (isArray22(x) && isUndefined22(c) && isUndefined22(d)) {
      c = a;
      d = b;
      const results = stats22(x);
      a = results.min;
      b = results.max;
    }
    return helper422(x, a, b, c, d);
  }
  function round22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.round(x);
    } catch (e) {
      return NaN;
    }
  }
  var vround22 = vectorize22(round22);
  function sign22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint")
        return BigInt(sign22(Number(x)));
      if (x < 0)
        return -1;
      if (x > 0)
        return 1;
      return 0;
    } catch (e) {
      return NaN;
    }
  }
  var vsign22 = vectorize22(sign22);
  function sin22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.sin(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsin22 = vectorize22(sin22);
  function some22(x, fn) {
    if (isDataFrame22(x) || isSeries22(x)) {
      return some22(x.values, fn);
    }
    assert22(isArray22(x), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert22(isFunction22(fn), "The second argument passed into the `some` function must be a function!");
    for (const v of x) {
      if (isArray22(v)) {
        if (some22(v, fn)) {
          return true;
        }
      } else {
        if (fn(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev22(x) {
    return std22(x);
  }
  function tan22(x) {
    try {
      if (!isNumber22(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.tan(x);
    } catch (e) {
      return NaN;
    }
  }
  var vtan22 = vectorize22(tan22);
  function timeSync22(fn, args) {
    assert22(isFunction22(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn(...args);
    } else {
      fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync22(fn, args) {
    assert22(isFunction22(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn(...args);
    } else {
      await fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union22() {
    return set22([...arguments].map((v) => {
      if (isArray22(v))
        return v;
      if (isDataFrame22(v))
        return v.values;
      if (isSeries22(v))
        return v.values;
      return [v];
    }));
  }
  function variance22(arr, shouldDropNaNs) {
    return stats22(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip22() {
    const out222 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame22(arr) || isSeries22(arr)) {
        arr = arr.values;
      }
      assert22(isArray22(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range22(0, max22(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined22(value) ? void 0 : value);
      });
      out222.push(row);
    });
    return out222;
  }
  var out22 = {
    abs: vabs22,
    add: vadd22,
    apply: vapply22,
    arccos: varccos22,
    arcsin: varcsin22,
    arctan: varctan22,
    argmax: argmax22,
    argmin: argmin22,
    assert: assert22,
    cast: cast22,
    ceil: vceil22,
    chop: vchop22,
    clamp: vclamp22,
    combinations: combinations22,
    combinationsIterator: combinationsIterator22,
    copy: copy22,
    correl: correl22,
    cos: vcos22,
    count: count22,
    covariance: covariance22,
    DataFrame: DataFrame22,
    dataTypes: dataTypes22,
    decycle: decycle22,
    diff: diff22,
    distance: distance22,
    divide: divide22,
    dot: dot22,
    dropMissing: dropMissing22,
    dropMissingPairwise: dropMissingPairwise22,
    dropNaN: dropNaN22,
    dropNaNPairwise: dropNaNPairwise22,
    dropUndefined: dropUndefined22,
    every: every22,
    exp: vexp22,
    factorial: vfactorial22,
    find: find22,
    findAll: findAll22,
    flatten: flatten22,
    float: vfloat22,
    floor: vfloor22,
    identity: identity22,
    IndexMatcher: IndexMatcher22,
    indexOf: indexOf22,
    inferType: inferType22,
    int: vint22,
    intersect: intersect22,
    inverse: inverse22,
    isArray: isArray22,
    isBoolean: isBoolean22,
    isBrowser: isBrowser222,
    isDataFrame: isDataFrame22,
    isDate: isDate22,
    isEqual: isEqual22,
    isFunction: isFunction22,
    isJagged: isJagged22,
    isNested: isNested22,
    isNumber: isNumber22,
    isObject: isObject22,
    isSeries: isSeries22,
    isString: isString22,
    isUndefined: isUndefined22,
    lerp: vlerp22,
    log: vlog22,
    MathError: MathError22,
    max: max22,
    mean: mean22,
    median: median22,
    min: min22,
    mod: vmod22,
    mode: mode22,
    multiply: vmultiply22,
    ndarray: ndarray22,
    normal: normal22,
    ones: ones22,
    permutations: permutations22,
    permutationsIterator: permutationsIterator22,
    pow: vpow22,
    print: print22,
    product: product22,
    random: random22,
    range: range22,
    remap: remap22,
    reshape: reshape22,
    reverse: reverse22,
    round: vround22,
    scale: scale22,
    seed: seed22,
    Series: Series22,
    set: set22,
    shape: shape22,
    shuffle: shuffle22,
    sign: vsign22,
    sin: vsin22,
    some: some22,
    sort: sort22,
    sqrt: vsqrt22,
    stats: stats22,
    std: std22,
    stdev: stdev22,
    subtract: subtract22,
    sum: sum22,
    tan: vtan22,
    timeAsync: timeAsync22,
    timeSync: timeSync22,
    time: timeSync22,
    transpose: transpose22,
    union: union22,
    variance: variance22,
    vectorize: vectorize22,
    zeros: zeros22,
    zip: zip22,
    dump() {
      const context22 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context22) {
        throw new out22.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out22).forEach((key) => {
        try {
          Object.defineProperty(context22, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out22[key]
          });
        } catch (e) {
          context22[key] = out22[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out22;
  }
  function isOfType(value, type, allowsSubclassInstances) {
    if (typeof allowsSubclassInstances === "undefined") {
      allowsSubclassInstances = true;
    }
    if (value === null || typeof value === "undefined") {
      return true;
    }
    if (type === "number" && typeof value === "number" && isNaN(value)) {
      return true;
    }
    if (type === Date && isDate22(value)) {
      return true;
    }
    try {
      return value instanceof type && (allowsSubclassInstances || value.constructor.name === type.name);
    } catch (e) {
      return typeof value === type;
    }
  }
  var canUseNewKeyword = {
    allowsSubclassInstances: {},
    doesNotAllowSubclassInstances: {}
  };
  var TypedArray = class _TypedArray extends Array {
    static allowsSubclassInstances = true;
    static registry = {
      allowsSubclassInstances: {},
      doesNotAllowSubclassInstances: {}
    };
    static type = null;
    static from(arr) {
      if (arguments.length > 1) {
        console.warn(
          "WARNING: The `TypedArray.from` static method's implementation differs from the standard `Array.from` static method's implementation. The `TypedArray.from` method only accepts one argument: an array of values. That array can be nested arbitrarily deeply."
        );
      }
      const key = this.allowsSubclassInstances ? "allowsSubclassInstances" : "doesNotAllowSubclassInstances";
      const out32 = createTypedArray(_TypedArray.registry[key][this.name]);
      if (arguments.length === 0) {
        return out32;
      }
      arr.forEach((value) => {
        if (this.isArray(value)) {
          const key2 = this.allowsSubclassInstances ? "allowsSubclassInstances" : "doesNotAllowSubclassInstances";
          canUseNewKeyword[key2][this.type] = true;
          const temp = new this();
          canUseNewKeyword[key2][this.type] = false;
          value.forEach((v) => temp.push(v));
          out32.push(this.proxify(temp));
        } else {
          out32.push(value);
        }
      });
      return out32;
    }
    static proxify(x) {
      return new Proxy(x, {
        get() {
          return Reflect.get(...arguments);
        },
        set(target, prop, value, receiver) {
          const intProp = parseInt(prop);
          if (!isNaN(intProp) && parseFloat(prop) === intProp && intProp >= 0) {
            receiver.challenge(value);
          }
          return Reflect.set(...arguments);
        }
      });
    }
    constructor(type, allowsSubclassInstances) {
      super();
      if (type === null || typeof type === "undefined") {
        throw new Error(
          `A type must be passed as the first argument to the \`TypedArray\` constructor!`
        );
      }
      if (type === Array) {
        throw new Error("It's not possible to create a TypedArray<Array>!");
      }
      Object.defineProperty(this, "type", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: type
      });
      if (typeof allowsSubclassInstances === "undefined" || allowsSubclassInstances === null) {
        allowsSubclassInstances = true;
      }
      Object.defineProperty(this, "allowsSubclassInstances", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: allowsSubclassInstances
      });
    }
    static get typeString() {
      if (typeof this.constructor.type === "function") {
        return this.constructor.type.name;
      } else {
        return this.constructor.type;
      }
    }
    get allowsSubclassInstances() {
      return this.constructor.allowsSubclassInstances;
    }
    get type() {
      return this.constructor.type;
    }
    canAccept(value) {
      return isOfType(
        value,
        this.constructor.type,
        this.constructor.allowsSubclassInstances
      ) || isArray22(value) && (value instanceof this.constructor || flatten22(value).every((v) => this.canAccept(v)));
    }
    challenge(value) {
      if (this.canAccept(value)) {
        return true;
      } else {
        throw new Error(
          `A ${this.constructor.name} cannot contain the value: ${typeof value === "string" || typeof value === "object" ? JSON.stringify(value) : value}`
        );
      }
    }
    concat() {
      const out32 = this.constructor.from(this);
      Array.from(arguments).forEach((arr) => {
        arr.forEach((value) => {
          this.challenge(value);
          out32.push(value);
        });
      });
      return out32;
    }
    fill(value, start, end) {
      this.challenge(value);
      return super.fill(value, start, end);
    }
    filter(fn, thisArg) {
      if (typeof thisArg !== "undefined") {
        fn = fn.bind(thisArg);
      } else {
        fn = fn.bind(this);
      }
      const out32 = Array.from(this).filter(fn);
      try {
        return this.constructor.from(out32);
      } catch (e) {
        return Array.from(out32);
      }
    }
    from() {
      return this.constructor.from(...arguments);
    }
    map(fn, thisArg) {
      if (typeof thisArg !== "undefined") {
        fn = fn.bind(thisArg);
      } else {
        fn = fn.bind(this);
      }
      const out32 = Array.from(this).map(fn);
      try {
        return this.constructor.from(out32);
      } catch (e) {
        return Array.from(out32);
      }
    }
    push() {
      Array.from(arguments).forEach((value) => {
        this.challenge(value);
      });
      return super.push(...arguments);
    }
    slice(start, end) {
      if (!start) {
        start = 0;
      }
      if (!end) {
        end = this.length;
      }
      const out32 = this.constructor.from([]);
      for (let i = start; i < end; i++) {
        out32.push(this[i]);
      }
      return out32;
    }
    splice() {
      const newValues = Array.from(arguments).slice(2).filter((v) => {
        this.challenge(v);
        return true;
      });
      const difference = newValues.length - arguments[1];
      const newLength = this.length + difference;
      for (let i = newLength - 1; i > arguments[0] + arguments[1]; i--) {
        this[i] = this[i - difference];
      }
      const removed = this.slice(arguments[0], arguments[0] + arguments[1]);
      newValues.forEach((v, i) => {
        this[arguments[0] + i] = v;
      });
      return removed;
    }
    toReversed() {
      const out32 = this.constructor.from([]);
      for (let i = this.length - 1; i >= 0; i--) {
        out32.push(this[i]);
      }
      return out32;
    }
    toSorted() {
      const temp = Array.from(this);
      temp.sort(...arguments);
      return this.constructor.from(temp);
    }
    toSpliced() {
      const temp = Array.from(this);
      temp.splice(...arguments);
      return this.constructor.from(temp);
    }
    unshift() {
      Array.from(arguments).forEach((value) => {
        this.challenge(value);
      });
      return super.unshift(...arguments);
    }
    with(index, value) {
      const out32 = this.slice();
      out32[index] = value;
      return out32;
    }
  };
  function createTypedArray(type, allowsSubclassInstances) {
    const key = allowsSubclassInstances ? "allowsSubclassInstances" : "doesNotAllowSubclassInstances";
    const typeString = typeof type === "function" ? type.name : type;
    const TempClass = (() => {
      if (TypedArray.registry[key][type]) {
        return TypedArray.registry[key][type];
      } else {
        class Temp extends TypedArray {
          constructor() {
            super(type, allowsSubclassInstances);
            if (!canUseNewKeyword[key][type]) {
              throw new Error(
                `New \`${this.constructor.name}\` instances cannot be created using the \`new\` keyword! They must be created using \`${this.constructor.name}.from([...])\`.`
              );
            }
          }
        }
        TypedArray.registry[key][type] = Temp;
        return Temp;
      }
    })();
    canUseNewKeyword[key][type] = true;
    const out32 = new TempClass(true);
    canUseNewKeyword[key][type] = false;
    Object.defineProperty(out32.constructor, "name", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: `${pascalify2(typeString)}Array`
    });
    Object.defineProperty(TempClass, "allowsSubclassInstances", {
      configurable: true,
      enumerable: true,
      writable: false,
      value: allowsSubclassInstances
    });
    Object.defineProperty(TempClass, "type", {
      configurable: true,
      enumerable: true,
      writable: false,
      value: type
    });
    TypedArray.registry[key][out32.constructor.name] = type;
    return TypedArray.proxify(out32);
  }
  function defineTypedProperty(obj, prop, type, options) {
    options = options || {
      configurable: true,
      enumerable: true
    };
    let _value;
    const allowsSubclassInstances = typeof options.allowsSubclassInstances === "undefined" ? true : !!options.allowsSubclassInstances;
    if (typeof type !== "function" && typeof type !== "string") {
      throw new Error(
        `A 'type' value (i.e., a class name or a string like "number" representing a primitive type) must be passed as the third argument to the \`defineTypedProperty\` function!`
      );
    }
    if (type === null || typeof type === "undefined") {
      throw new Error(
        `A 'type' value (i.e., a class name or a string like "number" representing a primitive type) must be passed as the third argument to the \`defineTypedProperty\` function!`
      );
    }
    if (type === Array) {
      throw new Error(
        "It's not possible to create a property of type Array (though you *can* create a TypedArray property)!"
      );
    }
    function getTypeString() {
      if (typeof type === "function") {
        return type.name;
      } else {
        return type;
      }
    }
    function canAccept(value) {
      return isOfType(value, type, allowsSubclassInstances);
    }
    function challenge(value) {
      if (canAccept(value)) {
        return true;
      } else {
        throw new Error(
          `The '${prop}' property can only have ${getTypeString()} values assigned to it!`
        );
      }
    }
    Object.defineProperty(obj, prop, {
      ...options,
      get() {
        return _value;
      },
      set(value) {
        challenge(value);
        _value = value;
      }
    });
  }
  if (typeof window !== "undefined") {
    window.JSTypeExperiments = {
      createType,
      createTypedArray,
      defineTypedProperty,
      isOfType
    };
  }

  // node_modules/@jrc03c/js-crypto-helpers/dist/js-crypto-helpers.import.mjs
  var Base64DecodingError = class extends Error {
  };
  var Base64EncodingError = class extends Error {
  };
  var DecryptionError = class extends Error {
  };
  var EncryptionError = class extends Error {
  };
  var HashingError = class extends Error {
  };
  var RandomStringGenerationError = class extends Error {
  };
  var __defProp5 = Object.defineProperty;
  var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField4 = (obj, key, value) => {
    __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber4(x) {
    return typeof x === "number" && !isNaN(x) || typeof x === "bigint";
  }
  var isBrowser5 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError4 = class extends Error {
    constructor(message) {
      if (isBrowser5()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert4(isTrue, message) {
    if (!isTrue)
      throw new MathError4(message);
  }
  var arrayTypes4 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined4(x) {
    return x === null || typeof x === "undefined";
  }
  var typeStrings4 = arrayTypes4.map((s222) => s222.name);
  function isArray4(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined4(obj.constructor)) {
        return arrayTypes4.indexOf(obj.constructor) > -1 || typeStrings4.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function isDataFrame4(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e) {
      return false;
    }
  }
  function isFunction4(fn) {
    return typeof fn === "function";
  }
  function isObject4(x) {
    return typeof x === "object" && !isUndefined4(x) && !isArray4(x);
  }
  function isSeries4(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e) {
      return false;
    }
  }
  function indexOf4(x, fn) {
    if (isDataFrame4(x)) {
      const index = indexOf4(x.values, fn);
      if (index.length > 0 && isNumber4(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      if (index.length > 1 && isNumber4(index[1]) && index[1] >= 0 && index[1] < x.columns.length) {
        index[1] = x.columns[index[1]];
      }
      return index;
    }
    if (isSeries4(x)) {
      const index = indexOf4(x.values, fn);
      if (index.length > 0 && isNumber4(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      return index;
    }
    assert4(isObject4(x) || isArray4(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction4(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject4(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return [key];
          }
          const results = helper522(value, fn2, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray4(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return [i];
          }
          const results = helper522(value, fn2, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn2(x2)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const paths = helper522(x, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy4(x) {
    function helper522(x2) {
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        if (isArray4(x2)) {
          if (!(x2 instanceof Array)) {
            return x2.slice();
          }
          return x2.map((v) => copy4(v));
        }
        if (isSeries4(x2)) {
          const out32 = x2.copy();
          out32.values = copy4(out32.values);
          return out32;
        }
        if (isDataFrame4(x2)) {
          const out32 = x2.copy();
          out32.values = copy4(x2.values);
          return out32;
        }
        if (x2 instanceof Date) {
          return new Date(x2.getTime());
        }
        x2 = decycle4(x2);
        const out222 = {};
        Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
          out222[key] = copy4(x2[key]);
        });
        return out222;
      } else {
        return x2;
      }
    }
    return helper522(decycle4(x));
  }
  function decycle4(x) {
    function helper522(x2, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x2) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x2;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x2 ? "/" : "/" + indexOf4(orig, x2).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x2 === "object") {
        if (x2 === null)
          return null;
        checked.push(x2);
        if (isArray4(x2)) {
          if (typeof x2.constructor !== "undefined" && x2.constructor.name !== "Array") {
            return x2.slice();
          }
          return x2.map((v, i) => helper522(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
            x2[key] = helper522(x2[key], checked, currentPath + "/" + key.toString());
          });
          return x2;
        }
      } else {
        return x2;
      }
    }
    const orig = x;
    let out222 = helper522(orig);
    if (isDataFrame4(x)) {
      const temp = x.copy();
      temp._values = out222.values;
      temp._columns = out222.columns;
      temp._index = out222.index;
      out222 = temp;
    }
    if (isSeries4(x)) {
      const temp = x.copy();
      temp.name = out222.name;
      temp._values = out222.values;
      temp._index = out222.index;
      out222 = temp;
    }
    return out222;
  }
  function isDate4(x) {
    return x instanceof Date && x.toString() !== "Invalid Date";
  }
  var numberTypes4 = ["number", "int", "float", "bigint"];
  function isEqual4(a, b) {
    function helper522(a2, b2) {
      const aType = typeof a2;
      const bType = typeof b2;
      if (aType !== bType && !numberTypes4.includes(aType) && !numberTypes4.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a2 === b2;
      if (aType === "symbol")
        return a2 === b2;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a2.toString();
          const bString = b2.toString();
          return aString === bString;
        } catch (e) {
          return false;
        }
      }
      if (aType === "string")
        return a2 === b2;
      if (aType === "function")
        return a2 === b2;
      if (aType === "object") {
        if (a2 === null || b2 === null) {
          return a2 === null && b2 === null;
        } else {
          if (isDate4(a2)) {
            if (isDate4(b2)) {
              return a2.getTime() === b2.getTime();
            } else {
              return false;
            }
          } else if (isDate4(b2)) {
            return false;
          }
          if (a2 instanceof RegExp && b2 instanceof RegExp) {
            return a2.toString() === b2.toString();
          }
          if (isArray4(a2) !== isArray4(b2)) {
            return false;
          }
          const aKeys = Object.keys(a2).concat(Object.getOwnPropertySymbols(a2));
          const bKeys = Object.keys(b2).concat(Object.getOwnPropertySymbols(b2));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper522(a2[key], b2[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper522(a, b);
    } catch (e) {
      return helper522(decycle4(a), decycle4(b));
    }
  }
  function makeKey6(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY5 = makeKey6(16);
  var UNDEFINED_KEY5 = makeKey6(16);
  var INFINITY_KEY5 = makeKey6(16);
  var MINUS_INFINITY_KEY5 = makeKey6(16);
  var SYMBOL_KEY5 = makeKey6(16);
  var Counter4 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x) {
      for (const v of x) {
        if (isArray4(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY5 : isUndefined4(value) ? UNDEFINED_KEY5 : isFunction4(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY5 : value === Infinity ? INFINITY_KEY5 : value === -Infinity ? MINUS_INFINITY_KEY5 : typeof value === "bigint" ? value.toString() : isDataFrame4(value) ? value.toJSONString() : isSeries4(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined4(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count222) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count222;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out222 = {};
      this.values.forEach((value) => {
        out222[value] = this.get(value);
      });
      return out222;
    }
  };
  function flatten4(arr) {
    if (isDataFrame4(arr) || isSeries4(arr)) {
      return flatten4(arr.values);
    }
    assert4(isArray4(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper522(arr2) {
      let out222 = [];
      arr2.forEach((child) => {
        if (isArray4(child)) {
          out222 = out222.concat(helper522(child));
        } else {
          out222.push(child);
        }
      });
      return out222;
    }
    return helper522(arr);
  }
  function stats4(x, options) {
    options = options || {};
    const counts = new Counter4();
    const out222 = {};
    const xflat = flatten4(x);
    const xnums = [];
    let max222 = -Infinity;
    let min222 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum222 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber4(v)) {
        try {
          if (v > max222) {
            max222 = v;
          }
          if (v < min222) {
            min222 = v;
          }
          sum222 += Number(v);
          xnums.push(v);
        } catch (e) {
          max222 = NaN;
          min222 = NaN;
          sum222 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean222 = sum222 / xnums.length;
    out222.counts = counts;
    out222.max = max222;
    out222.mean = mean222;
    out222.min = min222;
    out222.n = xflat.length;
    out222.sum = sum222;
    if (isNaN(out222.mean)) {
      out222.max = NaN;
      out222.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out222.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode222 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode222.push(pair[0]);
        } else {
          break;
        }
      }
      out222.mode = mode222.toSorted();
    }
    if (options.median) {
      if (isNaN(mean222)) {
        out222.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out222.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out222.median = BigInt(out222.median);
            } catch (e) {
            }
          }
        } else {
          out222.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance222 = 0;
      for (const v of xnums) {
        variance222 += Math.pow(Number(v) - mean222, 2);
      }
      variance222 /= xnums.length;
      const stdev222 = Math.sqrt(variance222);
      out222.stdev = stdev222;
      out222.variance = variance222;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out222.sum = BigInt(out222.sum);
      } catch (e) {
      }
      try {
        out222.mean = BigInt(out222.mean);
      } catch (e) {
      }
      if (options.mode) {
        out222.mode = out222.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e) {
            return v;
          }
        });
      }
    }
    return out222;
  }
  function count4(arr, matcher) {
    const { counts } = stats4(arr);
    if (!isUndefined4(matcher)) {
      if (isFunction4(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual4(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper7(x) {
    if (isDataFrame4(x) || isSeries4(x)) {
      return helper7(x.values);
    }
    if (isArray4(x)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x) {
        if (helper7(v)) {
          return true;
        }
        if (isArray4(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged4(x) {
    return helper7(decycle4(x));
  }
  function isNested4(x) {
    if (isDataFrame4(x) || isSeries4(x)) {
      return isNested4(x.values);
    }
    assert4(isArray4(x), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x.length; i++) {
      if (isArray4(x[i])) {
        return true;
      }
    }
    return false;
  }
  var error4 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray4(shape222) {
    assert4(!isUndefined4(shape222), error4);
    if (!isArray4(shape222))
      shape222 = [shape222];
    assert4(!isNested4(shape222), error4);
    assert4(shape222.length > 0, error4);
    let s222 = shape222[0];
    if (typeof s222 === "bigint")
      s222 = Number(s222);
    assert4(isNumber4(s222), error4);
    assert4(s222 >= 0, error4);
    assert4(Math.floor(s222) === s222, error4);
    assert4(s222 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape222.length === 1) {
      const out222 = [];
      for (let i = 0; i < s222; i++)
        out222.push(void 0);
      return out222;
    } else {
      const out222 = [];
      for (let i = 0; i < s222; i++) {
        out222.push(ndarray4(shape222.slice(1)));
      }
      return out222;
    }
  }
  function reverse4(arr) {
    if (isDataFrame4(arr) || isSeries4(arr)) {
      const out32 = arr.copy();
      out32.values = reverse4(out32.values);
      out32.index = reverse4(out32.index);
      return out32;
    }
    assert4(isArray4(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out222.push(arr[i]);
    return out222;
  }
  function range4(a, b, step = 1) {
    assert4(!isUndefined4(a) && !isUndefined4(b) && !isUndefined4(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert4(isNumber4(a) && isNumber4(b) && isNumber4(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert4(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out222 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out222.push(BigInt(i));
        } catch (e) {
          out222.push(i);
        }
      } else {
        out222.push(i);
      }
    }
    if (shouldReverse)
      out222 = reverse4(out222);
    return out222;
  }
  function makeKey24(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY24 = makeKey24(256);
  var UNDEFINED_KEY24 = makeKey24(256);
  var INFINITY_KEY24 = makeKey24(256);
  var MINUS_INFINITY_KEY24 = makeKey24(256);
  var SYMBOL_KEY24 = makeKey24(256);
  function set4(arr) {
    if (isDataFrame4(arr) || isSeries4(arr)) {
      return set4(arr.values);
    }
    assert4(isArray4(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = {};
    flatten4(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY24 : isUndefined4(item) ? UNDEFINED_KEY24 : isFunction4(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY24 : item === Infinity ? INFINITY_KEY24 : item === -Infinity ? MINUS_INFINITY_KEY24 : typeof item === "bigint" ? item.toString() : isDataFrame4(item) ? item.toJSONString() : isSeries4(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out222.push(item);
      temp[key] = true;
    });
    return out222;
  }
  function helper24(x) {
    if (isArray4(x)) {
      const childShapes = helper24(x[0]);
      return [x.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape4(x) {
    if (isDataFrame4(x) || isSeries4(x)) {
      return shape4(x.values);
    }
    assert4(isArray4(x), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper24(x);
  }
  function dfAppend4(df, x, axis) {
    if (isUndefined4(axis)) {
      axis = 0;
    }
    assert4(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray4(x)) {
      assert4(!isJagged4(x), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape4(x);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out222 = df.copy();
          out222._values.push(x);
          const maxRowLength = Math.max(df.shape[1], xShape[0]);
          out222._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out222 = df.copy();
          range4(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray4(df.shape[1]));
            }
            out222._values[i].push(x[i]);
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < out222._values[0].length) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x.map((row) => row.length).concat([df.shape[1]]));
          const out222 = df.copy();
          out222._values = out222._values.concat(x).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxRowLength = Math.max(...x.map((row) => row.length)) + df.shape[1];
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out222 = df.copy();
          range4(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray4(df.shape[1]));
            }
            out222._values[i] = out222._values[i].concat(x[i]);
            while (out222._values[i].length < maxRowLength) {
              out222._values[i].push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else {
        throw new MathError4("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries4(x)) {
      const out222 = dfAppend4(df, x.values, axis);
      if (axis === 0) {
        out222.index[out222.index.length - 1] = out222.index.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      } else {
        out222.columns[out222.columns.length - 1] = out222.columns.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      }
      return out222;
    } else if (isDataFrame4(x)) {
      if (axis === 0) {
        const out222 = df.copy();
        const maxRowLength = set4(out222._columns.concat(x._columns)).length;
        out222._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out222._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out222._values.push(temp.concat(rowCopy._values));
        }, 1);
        out222._columns = out222._columns.concat(x._columns.filter((c) => out222._columns.indexOf(c) < 0));
        while (out222._index.length < out222._values.length) {
          const newRowName = "row" + out222._index.length;
          out222._index.push(newRowName + (df._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out222;
      } else {
        const out222 = df.copy();
        out222._index.forEach((rowName, i) => {
          const xIndex = x._index.indexOf(rowName);
          if (xIndex > -1) {
            out222._values[i] = out222._values[i].concat(x._values[xIndex]);
          } else {
            out222._values[i] = out222._values[i].concat(ndarray4(x.shape[1]));
          }
        });
        x._index.forEach((rowName, i) => {
          const outIndex = out222._index.indexOf(rowName);
          if (outIndex < 0) {
            out222._index.push(rowName);
            out222._values.push(ndarray4(out222._columns.length).concat(x._values[i]));
          }
        });
        out222._columns = out222._columns.concat(x._columns.map((c) => c + (out222._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out222;
      }
    } else {
      throw new MathError4("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply4(DataFrame222, Series222, df, fn, axis) {
    axis = axis || 0;
    assert4(isFunction4(fn), "The first parameter to the `apply` method must be a function.");
    assert4(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df.columns.forEach((colName, i) => {
        const series = new Series222(df.values.map((row) => row[i]));
        series.name = colName;
        series.index = df.index;
        const value = fn(series, i, df);
        if (value instanceof Series222) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined4(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray4(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df.index;
        return out222;
      } else {
        const out222 = new Series222(df.columns.map((colName) => temp[colName]));
        out222.index = df.columns;
        return out222;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df.values.map((row, i) => {
        const series = new Series222(row);
        series.name = df.index[i];
        series.index = df.columns;
        const value = fn(series, i, df);
        if (isUndefined4(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray4(value);
        }
        if (value instanceof Series222) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df.index;
        out222.columns = df.columns;
        return out222;
      } else {
        const out222 = new Series222(temp);
        out222.index = df.index;
        return out222;
      }
    }
  }
  function isString4(s222) {
    return typeof s222 === "string";
  }
  function dfAssign4(DataFrame222, Series222, df, p1, p2) {
    const isDataFrame222 = (x) => x instanceof DataFrame222;
    const isSeries222 = (x) => x instanceof Series222;
    if (!isUndefined4(p2)) {
      assert4(isString4(p1), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert4(isArray4(p2) && !isJagged4(p2) && shape4(p2).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out222 = df.append(p2, 1);
      out222.columns[out222.columns.length - 1] = p1;
      return out222;
    } else {
      if (isDataFrame222(p1)) {
        return df.append(p1, 1);
      } else if (isSeries222(p1)) {
        return df.append(p1, 1);
      } else if (isObject4(p1)) {
        const maxColumnLength = Math.max(...Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).map((key) => p1[key].length));
        Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).forEach((key) => {
          while (p1[key].length < maxColumnLength) {
            p1[key].push(void 0);
          }
        });
        return df.append(new DataFrame222(p1), 1);
      } else {
        throw new MathError4("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy4(DataFrame222, df) {
    if (df.isEmpty)
      return new DataFrame222();
    const out222 = new DataFrame222(copy4(df.values));
    out222.columns = df.columns.slice();
    out222.index = df.index.slice();
    return out222;
  }
  function dfDrop4(DataFrame222, Series222, df, rows, cols) {
    if (isUndefined4(rows))
      rows = [];
    if (isUndefined4(cols))
      cols = [];
    if (isString4(rows) || isNumber4(rows))
      rows = [rows];
    if (isString4(cols) || isNumber4(cols))
      cols = [cols];
    assert4(isArray4(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert4(isArray4(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert4(shape4(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert4(shape4(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out222 = df.get(outIndex, outColumns);
    if (out222 instanceof Series222) {
      let temp = new DataFrame222();
      temp = temp.assign(out222);
      if (df.index.indexOf(out222.name) > -1)
        temp = temp.transpose();
      out222 = temp;
    }
    return out222;
  }
  function isInteger4(x) {
    return isNumber4(x) && (x >= 0 ? Math.floor(x) === x : Math.ceil(x) === x);
  }
  function isWholeNumber5(x) {
    return isInteger4(x) && x >= 0;
  }
  function dfDropMissing4(DataFrame222, Series222, df, axis, condition, threshold) {
    axis = axis || 0;
    assert4(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert4(isWholeNumber5(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert4(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper522(values) {
      if (threshold > 0) {
        let count222 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined4(value))
            count222++;
          if (count222 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined4(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined4(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out222 = df.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out222 = out222.assign(tempID, out222.index);
      const newValues = out222.values.map(helper522).filter((row) => row.length > 0);
      if (shape4(newValues).length < 2)
        return new DataFrame222();
      out222.values = newValues;
      let newIndex = out222.get(null, tempID);
      if (isUndefined4(newIndex))
        return new DataFrame222();
      if (isString4(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series222)
        newIndex = newIndex.values;
      out222.index = newIndex;
      out222 = out222.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out222.columns.forEach((colName, i) => {
        const values = out222.values.map((row) => row[i]);
        const newValues = helper522(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame222();
      }
      const newOut = new DataFrame222(temp);
      newOut.index = out222.index;
      return newOut;
    }
    return out222;
  }
  function dropNaN4(x) {
    if (isDataFrame4(x) || isSeries4(x)) {
      return x.dropNaN(...Object.values(arguments).slice(1));
    }
    assert4(isArray4(x), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x.forEach((v) => {
      try {
        return out222.push(dropNaN4(v));
      } catch (e) {
        if (isNumber4(v)) {
          return out222.push(v);
        }
      }
    });
    return out222;
  }
  function dfDropNaN4(DataFrame222, df, axis, condition, threshold) {
    axis = axis || 0;
    assert4(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert4(isWholeNumber5(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert4(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper522(values) {
      const numericalValues = dropNaN4(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out222 = df.copy();
    if (axis === 0) {
      const rowsToKeep = out222.index.filter((row) => {
        const values = out222.get(row, null).values;
        return helper522(values);
      });
      if (rowsToKeep.length > 0)
        return out222.get(rowsToKeep, null);
      else
        return new DataFrame222();
    } else if (axis === 1) {
      const colsToKeep = out222.columns.filter((col) => {
        const values = out222.get(null, col).values;
        return helper522(values);
      });
      if (colsToKeep.length > 0)
        return out222.get(null, colsToKeep);
      else
        return new DataFrame222();
    }
    return out222;
  }
  function arrayToObject4(x) {
    const out222 = {};
    flatten4(x).forEach((value, i) => {
      out222[value] = i;
    });
    return out222;
  }
  function undoArrayToObject4(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter4(DataFrame222, Series222, df, fn, axis) {
    assert4(isFunction4(fn), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined4(axis))
      axis = 0;
    assert4(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out222 = df.copy();
    if (out222.isEmpty)
      return out222;
    const index = arrayToObject4(out222.index);
    const columns = arrayToObject4(out222.columns);
    if (axis === 0) {
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df.index[i];
        series.index = df.columns;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count222++;
        } else {
          delete index[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject4(index)[0];
        temp.index = undoArrayToObject4(columns);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject4(index);
    } else if (axis === 1) {
      out222 = out222.transpose();
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df.columns[i];
        series.index = df.index;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count222++;
        } else {
          delete columns[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject4(columns)[0];
        temp.index = undoArrayToObject4(index);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject4(columns);
      out222 = out222.transpose();
    }
    return out222;
  }
  function dfGet4(df, rows, cols) {
    if (isString4(rows) || isNumber4(rows))
      rows = [rows];
    if (isString4(cols) || isNumber4(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set4((rows || []).concat(cols || []).map((v) => typeof v));
    assert4(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert4(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert4(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert4(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined4(rows)) {
      rows = rows.map((r) => {
        if (isString4(r)) {
          assert4(df.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber4(r)) {
          assert4(r >= 0, `Index ${r} is out of bounds!`);
          assert4(Math.floor(r) === r, `Row numbers must be integers!`);
          assert4(r < df.index.length, `Index ${r} is out of bounds!`);
          return df.index[r];
        }
      });
    }
    if (!isUndefined4(cols)) {
      cols = cols.map((c) => {
        if (isString4(c)) {
          assert4(df.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber4(c)) {
          assert4(c >= 0, `Column ${c} is out of bounds!`);
          assert4(Math.floor(c) === c, `Column numbers must be integers!`);
          assert4(c < df.columns.length, `Column ${c} is out of bounds!`);
          return df.columns[c];
        }
      });
    }
    return df.getSubsetByNames(rows, cols);
  }
  function alphaSort4(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort4(arr, fn) {
    if (isUndefined4(fn))
      fn = alphaSort4;
    if (isDataFrame4(arr) || isSeries4(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert4(isArray4(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert4(isFunction4(fn), "The second parameter of the `sort` function must be a comparison function!");
    const out222 = arr.slice();
    out222.sort(fn);
    return out222;
  }
  function camelify5(text) {
    const temp = text.toLowerCase();
    let out222 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out222 += char;
      } else {
        out222 += " ";
      }
    }
    const words = out222.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies4(DataFrame222, df, columns) {
    if (isUndefined4(columns)) {
      columns = df.columns;
    } else if (isString4(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert4(isString4(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df.columns.indexOf(col);
      assert4(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df.values.map((row) => row[colIndex]);
      const valuesSet = sort4(set4(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify5(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out222 = new DataFrame222(temp);
    out222.index = df.index;
    return out222;
  }
  function dfGetSubsetByIndices4(df, rowIndices, colIndices) {
    const dataShape = df.shape;
    if (isUndefined4(rowIndices))
      rowIndices = range4(0, dataShape[0]);
    if (isUndefined4(colIndices))
      colIndices = range4(0, dataShape[1]);
    if (isNumber4(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber4(colIndices))
      colIndices = [colIndices];
    assert4(isArray4(rowIndices) && isArray4(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert4(shape4(rowIndices).length === 1 && shape4(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert4(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert4(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert4(isWholeNumber5(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert4(rowIndex < df.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert4(isWholeNumber5(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert4(colIndex < df.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df.index[i]);
    const cols = colIndices.map((i) => df.columns[i]);
    return df.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames4(DataFrame222, Series222, df, rows, cols) {
    if (isUndefined4(rows))
      rows = df.index;
    if (isUndefined4(cols))
      cols = df.columns;
    if (isString4(rows))
      rows = [rows];
    if (isString4(cols))
      cols = [cols];
    assert4(isArray4(rows) && isArray4(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert4(shape4(rows).length === 1 && shape4(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert4(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert4(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert4(isString4(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert4(df.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert4(isString4(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert4(df.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df.values[df.index.indexOf(row)][df.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series222(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series222(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out222 = new DataFrame222(values);
    out222.columns = cols;
    out222.index = rows;
    return out222;
  }
  function dfPrint4(DataFrame222, Series222, df) {
    function truncate(s222, maxLength2) {
      if (isString4(s222)) {
        if (s222.length > maxLength2) {
          return s222.substring(0, maxLength2 - 3) + "...";
        } else {
          return s222;
        }
      } else {
        return s222;
      }
    }
    if (df.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df.index.length ? null : range4(0, halfMaxRows).concat(range4(df.index.length - halfMaxRows, df.index.length));
    const tempColumns = maxColumns > df.columns.length ? null : range4(0, halfMaxColumns).concat(range4(df.columns.length - halfMaxColumns, df.columns.length));
    let temp = df.get(tempRows, tempColumns);
    if (temp instanceof Series222) {
      if (df.shape[0] === 1) {
        temp = new DataFrame222([temp.values]);
        temp.index = df.index;
        temp.columns = new Series222(df.columns).get(tempColumns).values;
      } else if (df.shape[1] === 1) {
        temp = new DataFrame222([temp.values]).transpose();
        temp.index = new Series222(df.index).get(tempRows).values;
        temp.columns = df.columns;
      }
    }
    if (maxRows <= df.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range4(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series222) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df.shape, "\n");
    return df;
  }
  function leftPad4(x, maxLength) {
    assert4(isNumber4(x), "The `leftPad` function only works on numbers!");
    let out222 = x.toString();
    while (out222.length < maxLength)
      out222 = "0" + out222;
    return out222;
  }
  function dfResetIndex4(df, shouldSkipCopying) {
    const out222 = shouldSkipCopying ? df : df.copy();
    out222.index = range4(0, df.shape[0]).map((i) => {
      return "row" + leftPad4(i, (out222.index.length - 1).toString().length);
    });
    return out222;
  }
  function product4(arr, shouldDropNaNs) {
    if (isDataFrame4(arr) || isSeries4(arr)) {
      return product4(arr.values, shouldDropNaNs);
    }
    assert4(isArray4(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten4(arr);
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of temp) {
        if (!isNumber4(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  function isNaturalNumber4(x) {
    return isInteger4(x) && x > 0;
  }
  function reshape4(x, newShape) {
    if (isDataFrame4(x) || isSeries4(x)) {
      return reshape4(x.values, newShape);
    }
    assert4(isArray4(x), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber4(newShape))
      newShape = [newShape];
    assert4(isArray4(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert4(shape4(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert4(isNaturalNumber4(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten4(x);
    }
    const temp = flatten4(x);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert4(product4(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out222 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out222.push(reshape4(row, newShape.slice(1)));
    }
    return out222;
  }
  var MAX4 = Math.pow(2, 64);
  var s4 = [];
  seed4(Math.floor(Math.random() * MAX4));
  function splitmix644(state, n) {
    state = uint4(state);
    function helper522() {
      state += uint4("0x9e3779b97f4a7c15");
      let z = copy4(state);
      z = (z ^ z >> BigInt(30)) * uint4("0xbf58476d1ce4e5b9");
      z = (z ^ z >> BigInt(27)) * uint4("0x94d049bb133111eb");
      return z ^ z >> BigInt(31);
    }
    const out222 = [];
    for (let i = 0; i < n; i++)
      out222.push(helper522());
    return out222;
  }
  function uint4(x) {
    return BigInt.asUintN(64, BigInt(x));
  }
  function rotl4(x, k) {
    x = uint4(x);
    k = BigInt(k);
    return uint4(uint4(x << k) | uint4(x >> uint4(BigInt(64) - k)));
  }
  function seed4(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined4(val)) {
      assert4(isNumber4(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix644(Math.floor(val), 4);
      s4[0] = temp[0];
      s4[1] = temp[1];
      s4[2] = temp[2];
      s4[3] = temp[3];
    } else {
      return copy4(s4);
    }
  }
  function next4() {
    const result = uint4(rotl4(s4[0] + s4[3], 23) + s4[0]);
    const t = uint4(s4[1] << BigInt(17));
    s4[2] = uint4(s4[2] ^ s4[0]);
    s4[3] = uint4(s4[3] ^ s4[1]);
    s4[1] = uint4(s4[1] ^ s4[2]);
    s4[0] = uint4(s4[0] ^ s4[3]);
    s4[2] = uint4(s4[2] ^ t);
    s4[3] = rotl4(s4[3], 45);
    return Math.floor(Number(result)) / MAX4;
  }
  function random4(shape222) {
    if (isUndefined4(shape222))
      return next4();
    if (!isArray4(shape222))
      shape222 = [shape222];
    return reshape4(ndarray4(product4(shape222)).map(next4), shape222);
  }
  function shuffle4(arr) {
    if (isDataFrame4(arr) || isSeries4(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert4(isArray4(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random4() * temp.length);
      out222.push(temp.splice(index, 1)[0]);
    }
    return out222;
  }
  function dfShuffle4(df, axis) {
    if (isUndefined4(axis))
      axis = 0;
    assert4(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df.get(axis === 0 ? shuffle4(df.index) : null, axis === 1 ? shuffle4(df.columns) : null);
  }
  function isBoolean4(x) {
    return typeof x === "boolean";
  }
  function dfSort4(df, a, b) {
    if (isFunction4(a)) {
      return dfSortByFunction4(df, a, b);
    } else {
      return dfSortByColumns4(df, a, b);
    }
  }
  function dfSortByFunction4(df, fn, axis) {
    axis = isUndefined4(axis) ? 0 : axis;
    assert4(isFunction4(fn), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert4(isNumber4(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort4(df.index, (a, b) => {
        return fn(df.get(a, null), df.get(b, null));
      });
      return df.get(index, null);
    } else {
      const columns = sort4(df.columns, (a, b) => {
        return fn(df.get(null, a), df.get(null, b));
      });
      return df.get(null, columns);
    }
  }
  function dfSortByColumns4(df, cols, directions) {
    let out222 = df.copy();
    const indexID = random4().toString();
    out222 = out222.assign(indexID, out222.index);
    if (isUndefined4(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber4(cols) || isString4(cols)) {
      cols = [cols];
      if (isBoolean4(directions) || isString4(directions))
        directions = [directions];
    }
    assert4(isArray4(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert4(shape4(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined4(directions))
      directions = range4(0, cols.length).map(() => true);
    assert4(isArray4(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert4(shape4(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert4(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert4(isString4(col) || isNumber4(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString4(col)) {
        const index = out222.columns.indexOf(col);
        assert4(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber4(col)) {
        assert4(isWholeNumber5(col), "Column indices must be whole numbers!");
        assert4(col < out222.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert4(isString4(dir) || isBoolean4(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString4(dir)) {
        const value = dir.trim().toLowerCase();
        assert4(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean4(dir)) {
        return dir;
      }
    });
    out222.values = sort4(out222.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out222.columns.indexOf(indexID);
    out222.index = out222.values.map((row) => row[indexNumber]);
    out222 = out222.dropColumns(indexID);
    return out222;
  }
  function dfToDetailedObject4(df, axis) {
    if (isUndefined4(axis)) {
      axis = 0;
    } else {
      assert4(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out222 = {};
    if (axis === 0) {
      df.index.forEach((rowName, i) => {
        const temp = {};
        df.columns.forEach((colName, j) => {
          temp[colName] = df.values[i][j];
        });
        out222[rowName] = temp;
      });
    } else {
      df.columns.forEach((colName, j) => {
        const temp = {};
        df.index.forEach((rowName, i) => {
          temp[rowName] = df.values[i][j];
        });
        out222[colName] = temp;
      });
    }
    return out222;
  }
  function dfToJSONString4(df, axis) {
    return JSON.stringify(df.toObject(axis));
  }
  async function dfToJSON4(df, filename, axis) {
    const out222 = dfToJSONString4(df, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out222)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e) {
      browserError = e;
    }
    try {
      const fs = await import("node:fs");
      const path = await import("node:path");
      fs.writeFileSync(path.resolve(filename), out222, "utf8");
      wroteToDiskInNode = true;
    } catch (e) {
      nodeError = e;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError4(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError4(nodeError);
      } else {
        throw new MathError4("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df;
  }
  function dfToObject4(df) {
    const out222 = {};
    df.columns.forEach((col) => {
      out222[col] = df.get(col).values;
    });
    return out222;
  }
  function transpose4(arr) {
    if (isDataFrame4(arr) || isSeries4(arr)) {
      return arr.transpose();
    }
    assert4(isArray4(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape4(arr);
    assert4(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse4(arr);
    } else if (theShape.length === 2) {
      const out222 = ndarray4(reverse4(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out222[col][row] = arr[row][col];
        }
      }
      return out222;
    }
  }
  function seriesAppend4(Series222, series, x) {
    if (isSeries4(x)) {
      return new Series222(series.values.concat(x.values));
    }
    if (isArray4(x)) {
      const xShape = shape4(x);
      assert4(xShape.length === 1 && !isNested4(xShape), "Only vectors can be appended to Series!");
      const out222 = series.copy();
      x.forEach((v, i) => {
        out222._values.push(v);
        out222._index.push("item" + (series.values.length + i));
      });
      return out222;
    }
    return seriesAppend4(series, [x]);
  }
  function seriesApply4(series, fn) {
    assert4(isFunction4(fn), "The parameter to the `apply` method must be a function.");
    const out222 = series.copy();
    out222._values = out222._values.map((v, i) => fn(v, i));
    return out222;
  }
  function seriesDropMissing4(series) {
    const out222 = series.copy();
    const outIndex = [];
    out222._values = out222.values.filter((v, i) => {
      if (isUndefined4(v)) {
        return false;
      } else {
        outIndex.push(out222.index[i]);
        return true;
      }
    });
    out222._index = outIndex;
    return out222;
  }
  function seriesDropNaN4(Series222, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber4(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out222 = new Series222(values);
    out222.name = series.name;
    out222.index = index;
    return out222;
  }
  function seriesFilter4(Series222, series, fn) {
    let out222 = series.copy();
    const index = copy4(out222.index);
    const indicesToRemove = [];
    const newValues = out222.values.filter((value, i) => {
      const shouldKeep = fn(value, i, out222.values);
      if (!shouldKeep)
        indicesToRemove.push(out222.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out222 = new Series222();
      out222.name = series.name;
      return out222;
    }
    out222.values = newValues;
    out222.index = index;
    return out222;
  }
  function seriesGet4(series, indices) {
    if (isString4(indices) || isNumber4(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set4((indices || []).map((v) => typeof v));
    assert4(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert4(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert4(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert4(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined4(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert4(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert4(i >= 0, `Index ${i} is out of bounds!`);
          assert4(Math.floor(i) === i, `Indices must be integers!`);
          assert4(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices4(series, indices) {
    const dataShape = series.shape;
    if (isUndefined4(indices))
      indices = range4(0, dataShape[0]);
    assert4(isArray4(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert4(shape4(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert4(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert4(isWholeNumber5(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert4(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames4(Series222, series, indices) {
    if (isUndefined4(indices))
      indices = series.index;
    assert4(isArray4(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert4(shape4(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert4(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert4(isString4(name), "The `indices` array must contain only strings.");
      assert4(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out222 = new Series222(values);
    out222.index = indices;
    out222.name = series.name;
    return out222;
  }
  function seriesPrint4(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range4(0, maxRows / 2).concat(range4(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy4(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out222 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out222[temp.index[i]] = obj;
    });
    console.table(out222);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle4(series) {
    const out222 = series.copy();
    return out222.get(shuffle4(out222.index));
  }
  function seriesSort4(Series222, series, fn) {
    fn = fn || ((a, b) => a < b ? -1 : 1);
    assert4(isUndefined4(fn) || isFunction4(fn), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose4([series.values, series.index]);
    const temp = sort4(pairs, (aPair, bPair) => {
      return fn(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out222 = new Series222();
    out222._values = newValues;
    out222._index = newIndex;
    out222.name = series.name;
    return out222;
  }
  function seriesSortByIndex4(Series222, series) {
    let temp = transpose4([series.values, series.index]);
    temp = transpose4(sort4(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out222 = new Series222(temp[0]);
    out222.index = temp[1];
    out222.name = series.name;
    return out222;
  }
  function seriesToObject4(series) {
    const out222 = {};
    out222[series.name] = {};
    series.index.forEach((index, i) => {
      out222[series.name][index] = series.values[i];
    });
    return out222;
  }
  var SERIES_SYMBOL4 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass4(DataFrame222) {
    class Series222 {
      static [Symbol.hasInstance](x) {
        try {
          return !!x._symbol && x._symbol === SERIES_SYMBOL4;
        } catch (e) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL4
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x) {
            assert4(isArray4(x), "The new values must be a 1-dimensional array!");
            const dataShape = shape4(x);
            assert4(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range4(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad4(i, (x.length - 1).toString().length);
              }));
            }
            this._values = x;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x) {
            assert4(isArray4(x), "The new index must be a 1-dimensional array of strings!");
            assert4(x.length === this.shape[0], "The new index must be the same length as the old index!");
            assert4(shape4(x).length === 1, "The new index must be a 1-dimensional array of strings!");
            x.forEach((value) => {
              assert4(isString4(value), "All of the row names must be strings!");
            });
            this._index = x;
          }
        });
        if (data) {
          if (data instanceof Series222) {
            this.name = data.name;
            this.values = copy4(data.values);
            this.index = copy4(data.index);
          } else if (isArray4(data)) {
            const dataShape = shape4(data);
            assert4(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert4(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert4(shape4(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape4(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined4(v)).length === 0;
      }
      clear() {
        const out222 = this.copy();
        out222.values.forEach((v, i) => {
          out222.values[i] = void 0;
        });
        return out222;
      }
      get(indices) {
        return seriesGet4(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames4(Series222, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices4(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out222 = new Series222(reverse4(this.values));
        out222.index = reverse4(this.index);
        out222.name = this.name;
        return out222;
      }
      resetIndex() {
        const out222 = this.copy();
        out222.index = range4(0, this.shape[0]).map((i) => {
          return "item" + leftPad4(i, (out222.index.length - 1).toString().length);
        });
        return out222;
      }
      copy() {
        const out222 = new Series222();
        out222._values = copy4(this.values);
        out222._index = copy4(this.index);
        out222.name = this.name;
        return out222;
      }
      append(x) {
        return seriesAppend4(Series222, this, x);
      }
      apply(fn) {
        return seriesApply4(this, fn);
      }
      concat(x) {
        return this.append(x);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing4(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN4(Series222, this);
      }
      toObject() {
        return seriesToObject4(this);
      }
      print() {
        return seriesPrint4(this);
      }
      shuffle() {
        return seriesShuffle4(this);
      }
      sort(direction) {
        return seriesSort4(Series222, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex4(Series222, this);
      }
      filter(fn) {
        return seriesFilter4(Series222, this, fn);
      }
      toDataFrame() {
        const out222 = new DataFrame222(transpose4([this.values]));
        out222.columns = [this.name];
        out222.index = this.index;
        return out222;
      }
      transpose() {
        const out222 = this.copy();
        out222.values = reverse4(out222.values);
        out222.index = reverse4(out222.index);
        return out222;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series222;
  }
  var DATAFRAME_SYMBOL4 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey34(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out222 = "";
    for (let i = 0; i < n; i++)
      out222 += alpha[Math.floor(random4() * alpha.length)];
    return out222;
  }
  var DataFrame4 = class {
    static [Symbol.hasInstance](x) {
      try {
        return !!x._symbol && x._symbol === DATAFRAME_SYMBOL4;
      } catch (e) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL4
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined4(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x) {
          assert4(isArray4(x), "The new values must be a 2-dimensional array!");
          const dataShape = shape4(x);
          assert4(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range4(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad4(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range4(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad4(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x) {
          assert4(isArray4(x), "The new columns list must be a 1-dimensional array of strings!");
          assert4(this.isEmpty || x.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert4(shape4(x).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey34(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count4(x);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey34(8);
            }
            return v;
          });
          this._columns = x;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x) {
          assert4(isArray4(x), "The new index must be a 1-dimensional array of strings!");
          assert4(this.isEmpty || x.length === this.shape[0], "The new index must be the same length as the old index!");
          assert4(shape4(x).length === 1, "The new index must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey34(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count4(x);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey34(8);
            }
            return v;
          });
          this._index = x;
        }
      });
      assert4(isUndefined4(data) || isObject4(data) || isArray4(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame4) {
          this.values = copy4(data.values);
          this.columns = copy4(data.columns);
          this.index = copy4(data.index);
        } else if (isArray4(data)) {
          const dataShape = shape4(data);
          assert4(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert4(!isJagged4(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined4(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert4(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose4(temp);
          const dataShape = shape4(this.values);
          this._index = range4(0, dataShape[0]).map((i) => {
            return "row" + leftPad4(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape4(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out222 = new DataFrame4(ndarray4(this.shape));
      out222.columns = this.columns.slice();
      out222.index = this.index.slice();
      return out222;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e) {
          return this.get(rows, null);
        }
      }
      return dfGet4(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames4(DataFrame4, Series4, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices4(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies4(DataFrame4, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies4(DataFrame4, this, columns);
    }
    transpose() {
      const out222 = new DataFrame4(transpose4(this.values));
      out222.columns = this.index.slice();
      out222.index = this.columns.slice();
      return out222;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex4(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy4(DataFrame4, this);
    }
    assign(p1, p2) {
      return dfAssign4(DataFrame4, Series4, this, p1, p2);
    }
    apply(fn, axis) {
      return dfApply4(DataFrame4, Series4, this, fn, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing4(DataFrame4, Series4, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN4(DataFrame4, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop4(DataFrame4, Series4, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject4(this, axis);
    }
    toObject() {
      return dfToObject4(this);
    }
    toJSONString(axis) {
      return dfToJSONString4(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON4(this, filename, axis);
    }
    print() {
      return dfPrint4(DataFrame4, Series4, this);
    }
    sort(cols, directions) {
      return dfSort4(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn, axis) {
      return dfFilter4(DataFrame4, Series4, this, fn, axis);
    }
    shuffle(axis) {
      return dfShuffle4(this, axis);
    }
    append(x, axis) {
      return dfAppend4(this, x, axis);
    }
    concat(x, axis) {
      return this.append(x, axis);
    }
    join(x, axis) {
      return this.append(x, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series4 = createSeriesClass4(DataFrame4);
  function max4(arr, shouldDropNaNs) {
    return stats4(arr, { shouldDropNaNs }).max;
  }
  function vectorize4(fn) {
    assert4(isFunction4(fn), "You must pass a function into the `vectorize` function!");
    return function helper522() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray4(arg)) {
          return true;
        } else if (isSeries4(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame4(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s222, i) => {
        assert4(isEqual4(isArray4(s222) ? shape4(s222) : s222.shape, isArray4(childArrays[i + 1]) ? shape4(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max4(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out222 = range4(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray4(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries4(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame4(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper522(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual4(shape4(dataframes[0]), shape4(out222))) {
              const temp = new DataFrame4(out222);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame4(out222);
            }
          } catch (e) {
            return out222;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out222.length) {
              const temp = new Series4(out222);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series4(out222);
            }
          } catch (e) {
            return out222;
          }
        }
        return out222;
      } else {
        return fn(...arguments);
      }
    };
  }
  function abs4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        return x < 0 ? -x : x;
      } else {
        return Math.abs(x);
      }
    } catch (e) {
      return NaN;
    }
  }
  var vabs4 = vectorize4(abs4);
  function add4() {
    try {
      let out222 = 0;
      let resultShouldBeABigInt = false;
      const x = Object.values(arguments);
      for (let v of x) {
        if (!isNumber4(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  var vadd4 = vectorize4(add4);
  function apply4(x, fn) {
    try {
      return fn(x);
    } catch (e) {
      return NaN;
    }
  }
  var vapply4 = vectorize4(apply4);
  function arccos4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.acos(x);
    } catch (e) {
      return NaN;
    }
  }
  var varccos4 = vectorize4(arccos4);
  function arcsin4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.asin(x);
    } catch (e) {
      return NaN;
    }
  }
  var varcsin4 = vectorize4(arcsin4);
  function arctan4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.atan(x);
    } catch (e) {
      return NaN;
    }
  }
  var varctan4 = vectorize4(arctan4);
  function argmax4(x, shouldDropNaNs) {
    if (isDataFrame4(x)) {
      const index = argmax4(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries4(x)) {
      const index = argmax4(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert4(isArray4(x), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf4(x, max4(x, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function min4(arr, shouldDropNaNs) {
    return stats4(arr, { shouldDropNaNs }).min;
  }
  function argmin4(x, shouldDropNaNs) {
    if (isDataFrame4(x)) {
      const index = argmin4(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries4(x)) {
      const index = argmin4(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert4(isArray4(x), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf4(x, min4(x, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function cast4(value, type) {
    if (isDataFrame4(value) || isSeries4(value)) {
      return value.apply((item) => cast4(item, type));
    }
    if (isArray4(value)) {
      return value.map((v) => cast4(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined4(value)) {
        return NaN;
      }
      const booleanValue = cast4(value, "boolean");
      if (isBoolean4(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e) {
        const dateValue = cast4(value, "date");
        if (isDate4(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out222 = parseFloat(value);
      if (isNaN(out222))
        return NaN;
      return out222;
    }
    if (type === "int") {
      const out222 = cast4(value, "number");
      return out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
    }
    if (type === "float") {
      return cast4(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast4(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean4(value)) {
        return value;
      }
      if (isNumber4(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate4(value)) {
        return value;
      }
      if (isUndefined4(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out222 = new Date(value);
        if (!isDate4(out222))
          return null;
        return out222;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject4(value)) {
        return value;
      }
      const booleanValue = cast4(value, "boolean");
      if (isBoolean4(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast4(value, "number");
        if (isNumber4(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e) {
      }
      const dateValue = cast4(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out222 = JSON.parse(value);
        if (isArray4(out222)) {
          return out222.map((v) => cast4(v, type));
        } else {
          return out222;
        }
      } catch (e) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined4(value)) {
        if (isEqual4(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.ceil(x);
    } catch (e) {
      return NaN;
    }
  }
  var vceil4 = vectorize4(ceil4);
  function chop4(x, threshold) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      if (isUndefined4(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber4(threshold)) {
        return NaN;
      }
      return vabs4(x) < threshold ? 0 : x;
    } catch (e) {
      return NaN;
    }
  }
  var vchop4 = vectorize4(chop4);
  function int4(x) {
    if (isDataFrame4(x) || isSeries4(x)) {
      const out222 = x.copy();
      out222.values = int4(out222.values);
      return out222;
    }
    if (isArray4(x)) {
      return x.map((v) => int4(v));
    } else {
      try {
        const out222 = JSON.parse(x);
        if (isNumber4(out222)) {
          return typeof out222 === "bigint" ? Number(out222) : out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
        }
        return NaN;
      } catch (e) {
        return NaN;
      }
    }
  }
  var vint4 = vectorize4(int4);
  function clamp4(x, a, b) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (!isNumber4(a))
        return NaN;
      if (!isNumber4(b))
        return NaN;
      if (typeof x === "bigint") {
        return BigInt(clamp4(vint4(x), a, b));
      }
      if (x < a)
        return a;
      if (x > b)
        return b;
      return x;
    } catch (e) {
      return NaN;
    }
  }
  var vclamp4 = vectorize4(clamp4);
  function combinationsIterator4(x, r) {
    function* helper522(x2, r2) {
      if (r2 > x2.length) {
        yield x2;
      } else if (r2 <= 0) {
        yield [];
      } else if (x2.length < 2) {
        yield x2;
      } else {
        for (let i = 0; i < x2.length; i++) {
          const item = x2[i];
          const after = x2.slice(i + 1);
          if (after.length < r2 - 1) {
            continue;
          }
          if (r2 - 1 >= 0) {
            for (const child of combinationsIterator4(after, r2 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame4(x) || isSeries4(x)) {
      return combinationsIterator4(x.values, r);
    }
    assert4(isArray4(x), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert4(isNumber4(r) && vint4(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten4(x), r);
  }
  function combinations4(x, r) {
    const out222 = [];
    for (const combo of combinationsIterator4(x, r)) {
      out222.push(combo.slice());
    }
    return out222;
  }
  function intersect4() {
    const arrays = Object.values(arguments).map((x) => {
      if (isDataFrame4(x) || isSeries4(x)) {
        return set4(x.values);
      }
      assert4(isArray4(x), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set4(x);
    });
    const all = set4(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual4(other, v)) > -1);
    });
  }
  var _IndexMatcher4 = class {
    constructor(mode222) {
      assert4(isUndefined4(mode222) || mode222 === _IndexMatcher4.DROP_NAN_MODE || mode222 === _IndexMatcher4.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined4(mode222) ? mode222 : _IndexMatcher4.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x) => {
        if (isArray4(x)) {
          const xshape = shape4(x);
          if (xshape.length === 1) {
            x = new Series4(x);
          } else if (xshape.length === 2) {
            x = new DataFrame4(x);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert4(isDataFrame4(x) || isSeries4(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher4.DROP_MISSING_MODE) {
          indices.push(x.dropMissing().index);
        } else {
          indices.push(x.dropNaN().index);
        }
      });
      this.index = intersect4(...indices);
      return this;
    }
    transform() {
      assert4(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out222 = Object.values(arguments).map((x) => {
        if (isArray4(x)) {
          const xshape = shape4(x);
          if (xshape.length === 1) {
            return new Series4(x).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame4(x).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert4(isDataFrame4(x) || isSeries4(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x.get(this.index, null);
      });
      return out222.length === 1 ? out222[0] : out222;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher4 = _IndexMatcher4;
  __publicField4(IndexMatcher4, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField4(IndexMatcher4, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance4(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries4(x)) {
      return covariance4(x.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries4(y)) {
      return covariance4(x, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert4(isArray4(x) && isArray4(y) && shape4(x).length === 1 && shape4(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert4(x.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance4(...new IndexMatcher4().fitAndTransform(x, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats4(x, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats4(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx = Number(xstats.mean);
      const my = Number(ystats.mean);
      if (!isNumber4(mx) || !isNumber4(my)) {
        return NaN;
      }
      const n = Math.max(x.length, y.length);
      let out222 = 0;
      for (let i = 0; i < n; i++) {
        let vx = x[i];
        let vy = y[i];
        if (!isNumber4(vx))
          return NaN;
        if (!isNumber4(vy))
          return NaN;
        if (typeof vx === "bigint") {
          vx = Number(vx);
        }
        if (typeof vy === "bigint") {
          vy = Number(vy);
        }
        out222 += (vx - mx) * (vy - my);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out222 / x.length, xstats, ystats];
      } else {
        return out222 / x.length;
      }
    } catch (e) {
      return NaN;
    }
  }
  function correl4(x, y, shouldDropNaNs) {
    if (isSeries4(x)) {
      return correl4(x.values, y, shouldDropNaNs);
    }
    if (isSeries4(y)) {
      return correl4(x, y.values, shouldDropNaNs);
    }
    assert4(isArray4(x) && isArray4(y) && shape4(x).length === 1 && shape4(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert4(x.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance4(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e) {
      return NaN;
    }
  }
  function cos4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.cos(x);
    } catch (e) {
      return NaN;
    }
  }
  var vcos4 = vectorize4(cos4);
  var dataTypes4 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff4(a, b) {
    if (isDataFrame4(a) || isSeries4(a)) {
      return diff4(a.values, b);
    }
    if (isDataFrame4(b) || isSeries4(b)) {
      return diff4(a, b.values);
    }
    assert4(isArray4(a) && isArray4(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set4(a);
    const bTemp = set4(b);
    const out222 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual4(other, item)) < 0) {
        out222.push(item);
      }
    });
    return out222;
  }
  function pow4(x, p) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (!isNumber4(p))
        return NaN;
      if (typeof x === "bigint" || typeof p === "bigint") {
        const out222 = pow4(Number(x), Number(p));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.pow(x, p);
    } catch (e) {
      return NaN;
    }
  }
  var vpow4 = vectorize4(pow4);
  function sqrt4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        const out222 = sqrt4(Number(x));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.sqrt(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsqrt4 = vectorize4(sqrt4);
  function multiply4() {
    try {
      const x = Object.values(arguments);
      if (x.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of x) {
        if (!isNumber4(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  var vmultiply4 = vectorize4(multiply4);
  function scale4() {
    return vmultiply4(...arguments);
  }
  function subtract4(a, b) {
    return vadd4(a, scale4(b, -1));
  }
  function sum4(arr, shouldDropNaNs) {
    return stats4(arr, { shouldDropNaNs }).sum;
  }
  function distance4(a, b) {
    if (isNumber4(a) && isNumber4(b)) {
      return vabs4(a - b);
    }
    if (isDataFrame4(a) || isSeries4(a)) {
      return distance4(a.values, b);
    }
    if (isDataFrame4(b) || isSeries4(b)) {
      return distance4(a, b.values);
    }
    if (isArray4(a) && isArray4(b)) {
      assert4(isEqual4(shape4(a), shape4(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt4(sum4(vpow4(subtract4(a, b), 2)));
    } catch (e) {
      return NaN;
    }
  }
  function divide4(a, b) {
    return scale4(a, vpow4(b, -1));
  }
  function dot4(a, b) {
    if (isDataFrame4(a)) {
      const temp = dot4(a.values, b);
      if (shape4(temp).length === 1) {
        const out222 = new Series4(temp);
        out222.name = isSeries4(b) ? b.name : out222.name;
        out222.index = a.index.slice();
        return out222;
      } else {
        const out222 = new DataFrame4(temp);
        out222.index = a.index.slice();
        if (isDataFrame4(b)) {
          out222.columns = b.columns.slice();
        }
        return out222;
      }
    }
    if (isDataFrame4(b)) {
      const temp = dot4(a, b.values);
      if (shape4(temp).length === 1) {
        const out222 = new Series4(temp);
        out222.name = isSeries4(a) ? a.name : out222.name;
        out222.index = b.columns.slice();
        return out222;
      } else {
        const out222 = new DataFrame4(temp);
        out222.columns = b.columns.slice();
        return out222;
      }
    }
    if (isSeries4(a)) {
      return dot4(a.values, b);
    }
    if (isSeries4(b)) {
      return dot4(a, b.values);
    }
    assert4(isArray4(a) && isArray4(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape4(a);
    const bShape = shape4(b);
    assert4(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert4(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum4(scale4(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose4(b).map((col) => dot4(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot4(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose4(b);
      const out222 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot4(a[i], bTranspose[j]));
        }
        out222.push(row);
      }
      return out222;
    }
  }
  function dropMissing4(x) {
    if (isDataFrame4(x) || isSeries4(x)) {
      return x.dropMissing(...Object.values(arguments).slice(1));
    }
    assert4(isArray4(x), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x.forEach((v) => {
      try {
        return out222.push(dropMissing4(v));
      } catch (e) {
        if (!isUndefined4(v)) {
          out222.push(v);
        }
      }
    });
    return out222;
  }
  function dropMissingPairwise4(a, b) {
    if (isDataFrame4(a) || isSeries4(a)) {
      return dropMissingPairwise4(a.values, b);
    }
    if (isDataFrame4(b) || isSeries4(b)) {
      return dropMissingPairwise4(a, b.values);
    }
    assert4(isArray4(a) && isArray4(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert4(isEqual4(shape4(a), shape4(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise4(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (!isUndefined4(a[i]) && !isUndefined4(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise4(a, b) {
    if (isDataFrame4(a) || isSeries4(a)) {
      return dropNaNPairwise4(a.values, b);
    }
    if (isDataFrame4(b) || isSeries4(b)) {
      return dropNaNPairwise4(a, b.values);
    }
    assert4(isArray4(a) && isArray4(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert4(isEqual4(shape4(a), shape4(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise4(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (isNumber4(a[i]) && isNumber4(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined4(x) {
    return dropMissing4(x);
  }
  function every4(x, fn) {
    if (isDataFrame4(x) || isSeries4(x)) {
      return every4(x.values, fn);
    }
    assert4(isArray4(x), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert4(isFunction4(fn), "The second argument passed into the `every` function must be a function!");
    for (const v of x) {
      if (isArray4(v)) {
        if (!every4(v, fn)) {
          return false;
        }
      } else {
        if (!fn(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        if (x === 0n) {
          return 1n;
        } else {
          x = Number(x);
        }
      }
      return Math.exp(x);
    } catch (e) {
      return NaN;
    }
  }
  var vexp4 = vectorize4(exp4);
  function factorial4(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial4(vint4(n)));
      }
      if (n !== vint4(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial4(n - 1);
    } catch (e) {
      return NaN;
    }
  }
  var vfactorial4 = vectorize4(factorial4);
  function find4(x, fn) {
    if (isDataFrame4(x)) {
      return find4(x.values, fn);
    }
    if (isSeries4(x)) {
      return find4(x.values, fn);
    }
    assert4(isObject4(x) || isArray4(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction4(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject4(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return value;
          }
          const result = helper522(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray4(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return value;
          }
          const result = helper522(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn2(x2)) {
          return x2;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    return helper522(x, safeFn);
  }
  function findAll4(x, fn) {
    if (isDataFrame4(x)) {
      return findAll4(x.values, fn);
    }
    if (isSeries4(x)) {
      return findAll4(x.values, fn);
    }
    assert4(isObject4(x) || isArray4(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction4(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject4(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        const out222 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else if (isArray4(x2)) {
        checked.push(x2);
        const out222 = [];
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else {
        if (fn2(x2)) {
          return [x2];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const results = helper522(x, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float4(x) {
    try {
      if (x === "Infinity") {
        return Infinity;
      }
      if (x === "-Infinity") {
        return -Infinity;
      }
      const out222 = JSON.parse(x);
      if (isNumber4(out222))
        return out222;
      return NaN;
    } catch (e) {
      return NaN;
    }
  }
  var vfloat4 = vectorize4(float4);
  function floor4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        return x;
      }
      return Math.floor(x);
    } catch (e) {
      return NaN;
    }
  }
  var vfloor4 = vectorize4(floor4);
  function zeros4(shape222) {
    if (isNumber4(shape222))
      shape222 = [shape222];
    const out222 = [];
    const n = product4(shape222);
    for (let i = 0; i < n; i++)
      out222.push(0);
    return reshape4(out222, shape222);
  }
  function identity4(size) {
    if (typeof size === "bigint") {
      size = vint4(size);
    }
    assert4(!isUndefined4(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert4(isNumber4(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert4(vint4(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert4(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out222 = zeros4([size, size]);
    for (let i = 0; i < size; i++)
      out222[i][i] = 1;
    return out222;
  }
  var booleanValues4 = ["true", "false", "yes", "no"];
  var nullValues4 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger4(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint4(results.value) === results.value;
      } else {
        results.isInteger = every4(results.values, (v) => isNumber4(v) ? vint4(v) === v : true);
      }
    }
    return results;
  }
  function inferType4(arr) {
    if (isDataFrame4(arr)) {
      const out222 = arr.copy();
      const results = inferType4(arr.values);
      out222.values = results.values;
      return checkIfInteger4({ type: results.type, values: out222 });
    }
    if (isSeries4(arr)) {
      const out222 = arr.copy();
      const results = inferType4(arr.values);
      out222.values = results.values;
      return checkIfInteger4({ type: results.type, values: out222 });
    }
    if (!isArray4(arr)) {
      const out222 = inferType4([arr]);
      out222.value = out222.values[0];
      delete out222.values;
      return checkIfInteger4(out222);
    }
    assert4(isArray4(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten4(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate4(temp)) {
            return "date";
          }
        }
      } catch (e) {
      }
      if (!isString4(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues4.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues4.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber4(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray4(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e) {
        const vDate = new Date(v);
        if (isDate4(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count4(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger4({
      type: primaryType,
      values: vapply4(arr, (v) => cast4(v, primaryType))
    });
  }
  function inverse4(x) {
    if (isDataFrame4(x)) {
      const out222 = x.copy();
      out222.values = inverse4(out222.values);
      return out222;
    }
    assert4(isArray4(x), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape4(x);
    assert4(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert4(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert4(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x;
    } else if (xShape[0] === 1) {
      assert4(x[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x[0][0];
      let b = x[0][1];
      let c = x[1][0];
      let d = x[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det = a * d - b * c;
      assert4(det !== 0, "This matrix cannot be inverted!");
      const out222 = [
        [d, -b],
        [-c, a]
      ];
      return scale4(out222, 1 / det);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber4(a) || isNumber4(b) ? scale4(a, b) : dot4(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x.slice(0, divider).map((row) => row.slice(0, divider));
          const B = x.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C = x.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse4(A);
          const CompInv = inverse4(vadd4(D, times(-1, times(times(C, AInv), B))));
          const topLeft = vadd4(AInv, times(times(times(times(AInv, B), CompInv), C), AInv));
          const topRight = times(-1, times(times(AInv, B), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C), AInv));
          const bottomRight = CompInv;
          const out222 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out222;
        } catch (e) {
        }
      }
      assert4(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser24 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp4(a, b, f) {
    try {
      if (!isNumber4(a))
        return NaN;
      if (!isNumber4(b))
        return NaN;
      if (!isNumber4(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = lerp4(Number(a), Number(b), f);
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return f * (b - a) + a;
    } catch (e) {
      return NaN;
    }
  }
  var vlerp4 = vectorize4(lerp4);
  function log4(x, base) {
    try {
      base = isUndefined4(base) ? Math.E : base;
      if (!isNumber4(x))
        return NaN;
      if (!isNumber4(base))
        return NaN;
      if (typeof x === "bigint" || typeof base === "bigint") {
        const out222 = log4(Number(x), Number(base));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.log(x) / Math.log(base);
    } catch (e) {
      return NaN;
    }
  }
  var vlog4 = vectorize4(log4);
  function mean4(arr, shouldDropNaNs) {
    return stats4(arr, { shouldDropNaNs }).mean;
  }
  function median4(arr, shouldDropNaNs) {
    return stats4(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod4(a, b) {
    try {
      if (!isNumber4(a))
        return NaN;
      if (!isNumber4(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = mod4(Number(a), Number(b));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return a % b;
    } catch (e) {
      return NaN;
    }
  }
  var vmod4 = vectorize4(mod4);
  function mode4(arr, shouldDropNaNs) {
    return stats4(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper34() {
    const u1 = random4();
    const u2 = random4();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
  function normal4(shape222) {
    if (isUndefined4(shape222))
      return helper34();
    return vapply4(ndarray4(shape222), helper34);
  }
  function ones4(shape222) {
    return vapply4(ndarray4(shape222), () => 1);
  }
  function permutationsIterator4(x, r) {
    function* helper522(x2, r2) {
      r2 = r2 || x2.length;
      if (x2.length === 1) {
        yield [x2];
        return;
      }
      for (const c of combinations4(x2, r2)) {
        if (!c.slice)
          continue;
        const state = zeros4(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame4(x) || isSeries4(x)) {
      return permutationsIterator4(x.values, r);
    }
    assert4(isArray4(x), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined4(r)) {
      r = x.length;
    }
    assert4(isNumber4(r) && vint4(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten4(x), r);
  }
  function permutations4(x, r) {
    const out222 = [];
    for (const perm of permutationsIterator4(x, r)) {
      out222.push(perm.slice());
    }
    return out222;
  }
  function print4() {
    Object.keys(arguments).forEach((key) => {
      const x = arguments[key];
      if (isArray4(x)) {
        if (!isJagged4(x)) {
          const xShape = shape4(x);
          if (xShape.length === 1) {
            new Series4(x).print();
          } else if (xShape.length == 2) {
            new DataFrame4(x).print();
          } else {
            console.log(x);
          }
        } else {
          console.log(x);
        }
      } else if (isDataFrame4(x) || isSeries4(x)) {
        x.print();
      } else {
        console.log(x);
      }
    });
  }
  var helper44 = vectorize4((x, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x, a, b, c, d]) {
        if (!isNumber4(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x = Number(x);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out222 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  });
  function remap4(x, a, b, c, d) {
    if (isArray4(x) && isUndefined4(c) && isUndefined4(d)) {
      c = a;
      d = b;
      const results = stats4(x);
      a = results.min;
      b = results.max;
    }
    return helper44(x, a, b, c, d);
  }
  function round4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.round(x);
    } catch (e) {
      return NaN;
    }
  }
  var vround4 = vectorize4(round4);
  function sign4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint")
        return BigInt(sign4(Number(x)));
      if (x < 0)
        return -1;
      if (x > 0)
        return 1;
      return 0;
    } catch (e) {
      return NaN;
    }
  }
  var vsign4 = vectorize4(sign4);
  function sin4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.sin(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsin4 = vectorize4(sin4);
  function some4(x, fn) {
    if (isDataFrame4(x) || isSeries4(x)) {
      return some4(x.values, fn);
    }
    assert4(isArray4(x), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert4(isFunction4(fn), "The second argument passed into the `some` function must be a function!");
    for (const v of x) {
      if (isArray4(v)) {
        if (some4(v, fn)) {
          return true;
        }
      } else {
        if (fn(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std4(arr, shouldDropNaNs) {
    return stats4(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev4(x) {
    return std4(x);
  }
  function tan4(x) {
    try {
      if (!isNumber4(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.tan(x);
    } catch (e) {
      return NaN;
    }
  }
  var vtan4 = vectorize4(tan4);
  function timeSync4(fn, args) {
    assert4(isFunction4(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn(...args);
    } else {
      fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync4(fn, args) {
    assert4(isFunction4(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn(...args);
    } else {
      await fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union4() {
    return set4([...arguments].map((v) => {
      if (isArray4(v))
        return v;
      if (isDataFrame4(v))
        return v.values;
      if (isSeries4(v))
        return v.values;
      return [v];
    }));
  }
  function variance4(arr, shouldDropNaNs) {
    return stats4(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip4() {
    const out222 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame4(arr) || isSeries4(arr)) {
        arr = arr.values;
      }
      assert4(isArray4(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range4(0, max4(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined4(value) ? void 0 : value);
      });
      out222.push(row);
    });
    return out222;
  }
  var out4 = {
    abs: vabs4,
    add: vadd4,
    apply: vapply4,
    arccos: varccos4,
    arcsin: varcsin4,
    arctan: varctan4,
    argmax: argmax4,
    argmin: argmin4,
    assert: assert4,
    cast: cast4,
    ceil: vceil4,
    chop: vchop4,
    clamp: vclamp4,
    combinations: combinations4,
    combinationsIterator: combinationsIterator4,
    copy: copy4,
    correl: correl4,
    cos: vcos4,
    count: count4,
    covariance: covariance4,
    DataFrame: DataFrame4,
    dataTypes: dataTypes4,
    decycle: decycle4,
    diff: diff4,
    distance: distance4,
    divide: divide4,
    dot: dot4,
    dropMissing: dropMissing4,
    dropMissingPairwise: dropMissingPairwise4,
    dropNaN: dropNaN4,
    dropNaNPairwise: dropNaNPairwise4,
    dropUndefined: dropUndefined4,
    every: every4,
    exp: vexp4,
    factorial: vfactorial4,
    find: find4,
    findAll: findAll4,
    flatten: flatten4,
    float: vfloat4,
    floor: vfloor4,
    identity: identity4,
    IndexMatcher: IndexMatcher4,
    indexOf: indexOf4,
    inferType: inferType4,
    int: vint4,
    intersect: intersect4,
    inverse: inverse4,
    isArray: isArray4,
    isBoolean: isBoolean4,
    isBrowser: isBrowser24,
    isDataFrame: isDataFrame4,
    isDate: isDate4,
    isEqual: isEqual4,
    isFunction: isFunction4,
    isJagged: isJagged4,
    isNested: isNested4,
    isNumber: isNumber4,
    isObject: isObject4,
    isSeries: isSeries4,
    isString: isString4,
    isUndefined: isUndefined4,
    lerp: vlerp4,
    log: vlog4,
    MathError: MathError4,
    max: max4,
    mean: mean4,
    median: median4,
    min: min4,
    mod: vmod4,
    mode: mode4,
    multiply: vmultiply4,
    ndarray: ndarray4,
    normal: normal4,
    ones: ones4,
    permutations: permutations4,
    permutationsIterator: permutationsIterator4,
    pow: vpow4,
    print: print4,
    product: product4,
    random: random4,
    range: range4,
    remap: remap4,
    reshape: reshape4,
    reverse: reverse4,
    round: vround4,
    scale: scale4,
    seed: seed4,
    Series: Series4,
    set: set4,
    shape: shape4,
    shuffle: shuffle4,
    sign: vsign4,
    sin: vsin4,
    some: some4,
    sort: sort4,
    sqrt: vsqrt4,
    stats: stats4,
    std: std4,
    stdev: stdev4,
    subtract: subtract4,
    sum: sum4,
    tan: vtan4,
    timeAsync: timeAsync4,
    timeSync: timeSync4,
    time: timeSync4,
    transpose: transpose4,
    union: union4,
    variance: variance4,
    vectorize: vectorize4,
    zeros: zeros4,
    zip: zip4,
    dump() {
      const context22 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context22) {
        throw new out4.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out4).forEach((key) => {
        try {
          Object.defineProperty(context22, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out4[key]
          });
        } catch (e) {
          context22[key] = out4[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out4;
  }
  function camelify23(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    text = text.trim();
    let out222 = "";
    let shouldCapitalizeNextCharacter = false;
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      if (char.match(/[A-Za-z0-9]/g)) {
        if (out222.length === 0) {
          out222 += char.toLowerCase();
        } else if (shouldCapitalizeNextCharacter) {
          out222 += char.toUpperCase();
        } else {
          out222 += char;
        }
        shouldCapitalizeNextCharacter = false;
      } else if (!char.includes("'") && !char.includes("\u2019") && !char.includes("\u275C")) {
        shouldCapitalizeNextCharacter = true;
      }
    }
    return out222;
  }
  var __defProp23 = Object.defineProperty;
  var __defNormalProp23 = (obj, key, value) => key in obj ? __defProp23(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField23 = (obj, key, value) => {
    __defNormalProp23(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber23(x) {
    return typeof x === "number" && !isNaN(x) || typeof x === "bigint";
  }
  var isBrowser33 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError23 = class extends Error {
    constructor(message) {
      if (isBrowser33()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert23(isTrue, message) {
    if (!isTrue)
      throw new MathError23(message);
  }
  var arrayTypes23 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined23(x) {
    return x === null || typeof x === "undefined";
  }
  var typeStrings23 = arrayTypes23.map((s222) => s222.name);
  function isArray23(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined23(obj.constructor)) {
        return arrayTypes23.indexOf(obj.constructor) > -1 || typeStrings23.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function isDataFrame23(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e) {
      return false;
    }
  }
  function isFunction23(fn) {
    return typeof fn === "function";
  }
  function isObject23(x) {
    return typeof x === "object" && !isUndefined23(x) && !isArray23(x);
  }
  function isSeries23(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e) {
      return false;
    }
  }
  function indexOf23(x, fn) {
    if (isDataFrame23(x)) {
      const index = indexOf23(x.values, fn);
      if (index.length > 0 && isNumber23(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      if (index.length > 1 && isNumber23(index[1]) && index[1] >= 0 && index[1] < x.columns.length) {
        index[1] = x.columns[index[1]];
      }
      return index;
    }
    if (isSeries23(x)) {
      const index = indexOf23(x.values, fn);
      if (index.length > 0 && isNumber23(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      return index;
    }
    assert23(isObject23(x) || isArray23(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction23(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject23(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return [key];
          }
          const results = helper522(value, fn2, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray23(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return [i];
          }
          const results = helper522(value, fn2, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn2(x2)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const paths = helper522(x, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy23(x) {
    function helper522(x2) {
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        if (isArray23(x2)) {
          if (!(x2 instanceof Array)) {
            return x2.slice();
          }
          return x2.map((v) => copy23(v));
        }
        if (isSeries23(x2)) {
          const out32 = x2.copy();
          out32.values = copy23(out32.values);
          return out32;
        }
        if (isDataFrame23(x2)) {
          const out32 = x2.copy();
          out32.values = copy23(x2.values);
          return out32;
        }
        if (x2 instanceof Date) {
          return new Date(x2.getTime());
        }
        x2 = decycle23(x2);
        const out222 = {};
        Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
          out222[key] = copy23(x2[key]);
        });
        return out222;
      } else {
        return x2;
      }
    }
    return helper522(decycle23(x));
  }
  function decycle23(x) {
    function helper522(x2, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x2) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x2;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x2 ? "/" : "/" + indexOf23(orig, x2).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x2 === "object") {
        if (x2 === null)
          return null;
        checked.push(x2);
        if (isArray23(x2)) {
          if (typeof x2.constructor !== "undefined" && x2.constructor.name !== "Array") {
            return x2.slice();
          }
          return x2.map((v, i) => helper522(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
            x2[key] = helper522(x2[key], checked, currentPath + "/" + key.toString());
          });
          return x2;
        }
      } else {
        return x2;
      }
    }
    const orig = x;
    let out222 = helper522(orig);
    if (isDataFrame23(x)) {
      const temp = x.copy();
      temp._values = out222.values;
      temp._columns = out222.columns;
      temp._index = out222.index;
      out222 = temp;
    }
    if (isSeries23(x)) {
      const temp = x.copy();
      temp.name = out222.name;
      temp._values = out222.values;
      temp._index = out222.index;
      out222 = temp;
    }
    return out222;
  }
  function isDate23(x) {
    return x instanceof Date && x.toString() !== "Invalid Date";
  }
  var numberTypes23 = ["number", "int", "float", "bigint"];
  function isEqual23(a, b) {
    function helper522(a2, b2) {
      const aType = typeof a2;
      const bType = typeof b2;
      if (aType !== bType && !numberTypes23.includes(aType) && !numberTypes23.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a2 === b2;
      if (aType === "symbol")
        return a2 === b2;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a2.toString();
          const bString = b2.toString();
          return aString === bString;
        } catch (e) {
          return false;
        }
      }
      if (aType === "string")
        return a2 === b2;
      if (aType === "function")
        return a2 === b2;
      if (aType === "object") {
        if (a2 === null || b2 === null) {
          return a2 === null && b2 === null;
        } else {
          if (isDate23(a2)) {
            if (isDate23(b2)) {
              return a2.getTime() === b2.getTime();
            } else {
              return false;
            }
          } else if (isDate23(b2)) {
            return false;
          }
          if (a2 instanceof RegExp && b2 instanceof RegExp) {
            return a2.toString() === b2.toString();
          }
          if (isArray23(a2) !== isArray23(b2)) {
            return false;
          }
          const aKeys = Object.keys(a2).concat(Object.getOwnPropertySymbols(a2));
          const bKeys = Object.keys(b2).concat(Object.getOwnPropertySymbols(b2));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper522(a2[key], b2[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper522(a, b);
    } catch (e) {
      return helper522(decycle23(a), decycle23(b));
    }
  }
  function makeKey43(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY33 = makeKey43(16);
  var UNDEFINED_KEY33 = makeKey43(16);
  var INFINITY_KEY33 = makeKey43(16);
  var MINUS_INFINITY_KEY33 = makeKey43(16);
  var SYMBOL_KEY33 = makeKey43(16);
  var Counter23 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x) {
      for (const v of x) {
        if (isArray23(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY33 : isUndefined23(value) ? UNDEFINED_KEY33 : isFunction23(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY33 : value === Infinity ? INFINITY_KEY33 : value === -Infinity ? MINUS_INFINITY_KEY33 : typeof value === "bigint" ? value.toString() : isDataFrame23(value) ? value.toJSONString() : isSeries23(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined23(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count222) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count222;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out222 = {};
      this.values.forEach((value) => {
        out222[value] = this.get(value);
      });
      return out222;
    }
  };
  function flatten23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return flatten23(arr.values);
    }
    assert23(isArray23(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper522(arr2) {
      let out222 = [];
      arr2.forEach((child) => {
        if (isArray23(child)) {
          out222 = out222.concat(helper522(child));
        } else {
          out222.push(child);
        }
      });
      return out222;
    }
    return helper522(arr);
  }
  function stats23(x, options) {
    options = options || {};
    const counts = new Counter23();
    const out222 = {};
    const xflat = flatten23(x);
    const xnums = [];
    let max222 = -Infinity;
    let min222 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum222 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber23(v)) {
        try {
          if (v > max222) {
            max222 = v;
          }
          if (v < min222) {
            min222 = v;
          }
          sum222 += Number(v);
          xnums.push(v);
        } catch (e) {
          max222 = NaN;
          min222 = NaN;
          sum222 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean222 = sum222 / xnums.length;
    out222.counts = counts;
    out222.max = max222;
    out222.mean = mean222;
    out222.min = min222;
    out222.n = xflat.length;
    out222.sum = sum222;
    if (isNaN(out222.mean)) {
      out222.max = NaN;
      out222.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out222.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode222 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode222.push(pair[0]);
        } else {
          break;
        }
      }
      out222.mode = mode222.toSorted();
    }
    if (options.median) {
      if (isNaN(mean222)) {
        out222.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out222.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out222.median = BigInt(out222.median);
            } catch (e) {
            }
          }
        } else {
          out222.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance222 = 0;
      for (const v of xnums) {
        variance222 += Math.pow(Number(v) - mean222, 2);
      }
      variance222 /= xnums.length;
      const stdev222 = Math.sqrt(variance222);
      out222.stdev = stdev222;
      out222.variance = variance222;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out222.sum = BigInt(out222.sum);
      } catch (e) {
      }
      try {
        out222.mean = BigInt(out222.mean);
      } catch (e) {
      }
      if (options.mode) {
        out222.mode = out222.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e) {
            return v;
          }
        });
      }
    }
    return out222;
  }
  function count23(arr, matcher) {
    const { counts } = stats23(arr);
    if (!isUndefined23(matcher)) {
      if (isFunction23(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual23(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper53(x) {
    if (isDataFrame23(x) || isSeries23(x)) {
      return helper53(x.values);
    }
    if (isArray23(x)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x) {
        if (helper53(v)) {
          return true;
        }
        if (isArray23(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged23(x) {
    return helper53(decycle23(x));
  }
  function isNested23(x) {
    if (isDataFrame23(x) || isSeries23(x)) {
      return isNested23(x.values);
    }
    assert23(isArray23(x), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x.length; i++) {
      if (isArray23(x[i])) {
        return true;
      }
    }
    return false;
  }
  var error23 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray23(shape222) {
    assert23(!isUndefined23(shape222), error23);
    if (!isArray23(shape222))
      shape222 = [shape222];
    assert23(!isNested23(shape222), error23);
    assert23(shape222.length > 0, error23);
    let s222 = shape222[0];
    if (typeof s222 === "bigint")
      s222 = Number(s222);
    assert23(isNumber23(s222), error23);
    assert23(s222 >= 0, error23);
    assert23(Math.floor(s222) === s222, error23);
    assert23(s222 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape222.length === 1) {
      const out222 = [];
      for (let i = 0; i < s222; i++)
        out222.push(void 0);
      return out222;
    } else {
      const out222 = [];
      for (let i = 0; i < s222; i++) {
        out222.push(ndarray23(shape222.slice(1)));
      }
      return out222;
    }
  }
  function reverse23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      const out32 = arr.copy();
      out32.values = reverse23(out32.values);
      out32.index = reverse23(out32.index);
      return out32;
    }
    assert23(isArray23(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out222.push(arr[i]);
    return out222;
  }
  function range23(a, b, step = 1) {
    assert23(!isUndefined23(a) && !isUndefined23(b) && !isUndefined23(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert23(isNumber23(a) && isNumber23(b) && isNumber23(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert23(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out222 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out222.push(BigInt(i));
        } catch (e) {
          out222.push(i);
        }
      } else {
        out222.push(i);
      }
    }
    if (shouldReverse)
      out222 = reverse23(out222);
    return out222;
  }
  function makeKey223(n) {
    const alpha = "abcdefg1234567890";
    let out222 = "";
    while (out222.length < n)
      out222 += alpha[Math.floor(Math.random() * alpha.length)];
    return out222;
  }
  var NULL_KEY223 = makeKey223(256);
  var UNDEFINED_KEY223 = makeKey223(256);
  var INFINITY_KEY223 = makeKey223(256);
  var MINUS_INFINITY_KEY223 = makeKey223(256);
  var SYMBOL_KEY223 = makeKey223(256);
  function set23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return set23(arr.values);
    }
    assert23(isArray23(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = {};
    flatten23(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY223 : isUndefined23(item) ? UNDEFINED_KEY223 : isFunction23(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY223 : item === Infinity ? INFINITY_KEY223 : item === -Infinity ? MINUS_INFINITY_KEY223 : typeof item === "bigint" ? item.toString() : isDataFrame23(item) ? item.toJSONString() : isSeries23(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out222.push(item);
      temp[key] = true;
    });
    return out222;
  }
  function helper223(x) {
    if (isArray23(x)) {
      const childShapes = helper223(x[0]);
      return [x.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape23(x) {
    if (isDataFrame23(x) || isSeries23(x)) {
      return shape23(x.values);
    }
    assert23(isArray23(x), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper223(x);
  }
  function dfAppend23(df, x, axis) {
    if (isUndefined23(axis)) {
      axis = 0;
    }
    assert23(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray23(x)) {
      assert23(!isJagged23(x), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape23(x);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out222 = df.copy();
          out222._values.push(x);
          const maxRowLength = Math.max(df.shape[1], xShape[0]);
          out222._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out222 = df.copy();
          range23(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray23(df.shape[1]));
            }
            out222._values[i].push(x[i]);
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < out222._values[0].length) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x.map((row) => row.length).concat([df.shape[1]]));
          const out222 = df.copy();
          out222._values = out222._values.concat(x).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        } else {
          const maxRowLength = Math.max(...x.map((row) => row.length)) + df.shape[1];
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out222 = df.copy();
          range23(0, maxColLength).forEach((i) => {
            if (i >= out222._values.length) {
              out222._values.push(ndarray23(df.shape[1]));
            }
            out222._values[i] = out222._values[i].concat(x[i]);
            while (out222._values[i].length < maxRowLength) {
              out222._values[i].push(void 0);
            }
          });
          while (out222._index.length < out222._values.length) {
            out222._index.push("row" + out222._index.length);
          }
          while (out222._columns.length < maxRowLength) {
            out222._columns.push("col" + out222._columns.length);
          }
          return out222;
        }
      } else {
        throw new MathError23("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries23(x)) {
      const out222 = dfAppend23(df, x.values, axis);
      if (axis === 0) {
        out222.index[out222.index.length - 1] = out222.index.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      } else {
        out222.columns[out222.columns.length - 1] = out222.columns.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      }
      return out222;
    } else if (isDataFrame23(x)) {
      if (axis === 0) {
        const out222 = df.copy();
        const maxRowLength = set23(out222._columns.concat(x._columns)).length;
        out222._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out222._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out222._values.push(temp.concat(rowCopy._values));
        }, 1);
        out222._columns = out222._columns.concat(x._columns.filter((c) => out222._columns.indexOf(c) < 0));
        while (out222._index.length < out222._values.length) {
          const newRowName = "row" + out222._index.length;
          out222._index.push(newRowName + (df._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out222;
      } else {
        const out222 = df.copy();
        out222._index.forEach((rowName, i) => {
          const xIndex = x._index.indexOf(rowName);
          if (xIndex > -1) {
            out222._values[i] = out222._values[i].concat(x._values[xIndex]);
          } else {
            out222._values[i] = out222._values[i].concat(ndarray23(x.shape[1]));
          }
        });
        x._index.forEach((rowName, i) => {
          const outIndex = out222._index.indexOf(rowName);
          if (outIndex < 0) {
            out222._index.push(rowName);
            out222._values.push(ndarray23(out222._columns.length).concat(x._values[i]));
          }
        });
        out222._columns = out222._columns.concat(x._columns.map((c) => c + (out222._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out222;
      }
    } else {
      throw new MathError23("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply23(DataFrame222, Series222, df, fn, axis) {
    axis = axis || 0;
    assert23(isFunction23(fn), "The first parameter to the `apply` method must be a function.");
    assert23(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df.columns.forEach((colName, i) => {
        const series = new Series222(df.values.map((row) => row[i]));
        series.name = colName;
        series.index = df.index;
        const value = fn(series, i, df);
        if (value instanceof Series222) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined23(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray23(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df.index;
        return out222;
      } else {
        const out222 = new Series222(df.columns.map((colName) => temp[colName]));
        out222.index = df.columns;
        return out222;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df.values.map((row, i) => {
        const series = new Series222(row);
        series.name = df.index[i];
        series.index = df.columns;
        const value = fn(series, i, df);
        if (isUndefined23(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series222 || isArray23(value);
        }
        if (value instanceof Series222) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out222 = new DataFrame222(temp);
        out222.index = df.index;
        out222.columns = df.columns;
        return out222;
      } else {
        const out222 = new Series222(temp);
        out222.index = df.index;
        return out222;
      }
    }
  }
  function isString23(s222) {
    return typeof s222 === "string";
  }
  function dfAssign23(DataFrame222, Series222, df, p1, p2) {
    const isDataFrame222 = (x) => x instanceof DataFrame222;
    const isSeries222 = (x) => x instanceof Series222;
    if (!isUndefined23(p2)) {
      assert23(isString23(p1), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert23(isArray23(p2) && !isJagged23(p2) && shape23(p2).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out222 = df.append(p2, 1);
      out222.columns[out222.columns.length - 1] = p1;
      return out222;
    } else {
      if (isDataFrame222(p1)) {
        return df.append(p1, 1);
      } else if (isSeries222(p1)) {
        return df.append(p1, 1);
      } else if (isObject23(p1)) {
        const maxColumnLength = Math.max(...Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).map((key) => p1[key].length));
        Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).forEach((key) => {
          while (p1[key].length < maxColumnLength) {
            p1[key].push(void 0);
          }
        });
        return df.append(new DataFrame222(p1), 1);
      } else {
        throw new MathError23("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy23(DataFrame222, df) {
    if (df.isEmpty)
      return new DataFrame222();
    const out222 = new DataFrame222(copy23(df.values));
    out222.columns = df.columns.slice();
    out222.index = df.index.slice();
    return out222;
  }
  function dfDrop23(DataFrame222, Series222, df, rows, cols) {
    if (isUndefined23(rows))
      rows = [];
    if (isUndefined23(cols))
      cols = [];
    if (isString23(rows) || isNumber23(rows))
      rows = [rows];
    if (isString23(cols) || isNumber23(cols))
      cols = [cols];
    assert23(isArray23(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert23(isArray23(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert23(shape23(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert23(shape23(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out222 = df.get(outIndex, outColumns);
    if (out222 instanceof Series222) {
      let temp = new DataFrame222();
      temp = temp.assign(out222);
      if (df.index.indexOf(out222.name) > -1)
        temp = temp.transpose();
      out222 = temp;
    }
    return out222;
  }
  function isInteger23(x) {
    return isNumber23(x) && (x >= 0 ? Math.floor(x) === x : Math.ceil(x) === x);
  }
  function isWholeNumber23(x) {
    return isInteger23(x) && x >= 0;
  }
  function dfDropMissing23(DataFrame222, Series222, df, axis, condition, threshold) {
    axis = axis || 0;
    assert23(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert23(isWholeNumber23(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert23(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper522(values) {
      if (threshold > 0) {
        let count222 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined23(value))
            count222++;
          if (count222 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined23(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined23(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out222 = df.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out222 = out222.assign(tempID, out222.index);
      const newValues = out222.values.map(helper522).filter((row) => row.length > 0);
      if (shape23(newValues).length < 2)
        return new DataFrame222();
      out222.values = newValues;
      let newIndex = out222.get(null, tempID);
      if (isUndefined23(newIndex))
        return new DataFrame222();
      if (isString23(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series222)
        newIndex = newIndex.values;
      out222.index = newIndex;
      out222 = out222.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out222.columns.forEach((colName, i) => {
        const values = out222.values.map((row) => row[i]);
        const newValues = helper522(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame222();
      }
      const newOut = new DataFrame222(temp);
      newOut.index = out222.index;
      return newOut;
    }
    return out222;
  }
  function dropNaN23(x) {
    if (isDataFrame23(x) || isSeries23(x)) {
      return x.dropNaN(...Object.values(arguments).slice(1));
    }
    assert23(isArray23(x), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x.forEach((v) => {
      try {
        return out222.push(dropNaN23(v));
      } catch (e) {
        if (isNumber23(v)) {
          return out222.push(v);
        }
      }
    });
    return out222;
  }
  function dfDropNaN23(DataFrame222, df, axis, condition, threshold) {
    axis = axis || 0;
    assert23(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert23(isWholeNumber23(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert23(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper522(values) {
      const numericalValues = dropNaN23(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out222 = df.copy();
    if (axis === 0) {
      const rowsToKeep = out222.index.filter((row) => {
        const values = out222.get(row, null).values;
        return helper522(values);
      });
      if (rowsToKeep.length > 0)
        return out222.get(rowsToKeep, null);
      else
        return new DataFrame222();
    } else if (axis === 1) {
      const colsToKeep = out222.columns.filter((col) => {
        const values = out222.get(null, col).values;
        return helper522(values);
      });
      if (colsToKeep.length > 0)
        return out222.get(null, colsToKeep);
      else
        return new DataFrame222();
    }
    return out222;
  }
  function arrayToObject23(x) {
    const out222 = {};
    flatten23(x).forEach((value, i) => {
      out222[value] = i;
    });
    return out222;
  }
  function undoArrayToObject23(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter23(DataFrame222, Series222, df, fn, axis) {
    assert23(isFunction23(fn), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined23(axis))
      axis = 0;
    assert23(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out222 = df.copy();
    if (out222.isEmpty)
      return out222;
    const index = arrayToObject23(out222.index);
    const columns = arrayToObject23(out222.columns);
    if (axis === 0) {
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df.index[i];
        series.index = df.columns;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count222++;
        } else {
          delete index[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject23(index)[0];
        temp.index = undoArrayToObject23(columns);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject23(index);
    } else if (axis === 1) {
      out222 = out222.transpose();
      let count222 = 0;
      const newValues = out222.values.filter((row, i) => {
        const series = new Series222(row);
        series.name = df.columns[i];
        series.index = df.index;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count222++;
        } else {
          delete columns[out222.index[i]];
        }
        return shouldKeep;
      });
      if (count222 === 0) {
        return new DataFrame222();
      }
      if (count222 === 1) {
        const temp = new Series222(newValues[0]);
        temp.name = undoArrayToObject23(columns)[0];
        temp.index = undoArrayToObject23(index);
        return temp;
      }
      out222.values = newValues;
      out222.index = undoArrayToObject23(columns);
      out222 = out222.transpose();
    }
    return out222;
  }
  function dfGet23(df, rows, cols) {
    if (isString23(rows) || isNumber23(rows))
      rows = [rows];
    if (isString23(cols) || isNumber23(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set23((rows || []).concat(cols || []).map((v) => typeof v));
    assert23(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert23(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert23(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert23(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined23(rows)) {
      rows = rows.map((r) => {
        if (isString23(r)) {
          assert23(df.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber23(r)) {
          assert23(r >= 0, `Index ${r} is out of bounds!`);
          assert23(Math.floor(r) === r, `Row numbers must be integers!`);
          assert23(r < df.index.length, `Index ${r} is out of bounds!`);
          return df.index[r];
        }
      });
    }
    if (!isUndefined23(cols)) {
      cols = cols.map((c) => {
        if (isString23(c)) {
          assert23(df.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber23(c)) {
          assert23(c >= 0, `Column ${c} is out of bounds!`);
          assert23(Math.floor(c) === c, `Column numbers must be integers!`);
          assert23(c < df.columns.length, `Column ${c} is out of bounds!`);
          return df.columns[c];
        }
      });
    }
    return df.getSubsetByNames(rows, cols);
  }
  function alphaSort23(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort23(arr, fn) {
    if (isUndefined23(fn))
      fn = alphaSort23;
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert23(isArray23(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert23(isFunction23(fn), "The second parameter of the `sort` function must be a comparison function!");
    const out222 = arr.slice();
    out222.sort(fn);
    return out222;
  }
  function camelify222(text) {
    const temp = text.toLowerCase();
    let out222 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out222 += char;
      } else {
        out222 += " ";
      }
    }
    const words = out222.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies23(DataFrame222, df, columns) {
    if (isUndefined23(columns)) {
      columns = df.columns;
    } else if (isString23(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert23(isString23(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df.columns.indexOf(col);
      assert23(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df.values.map((row) => row[colIndex]);
      const valuesSet = sort23(set23(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify222(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out222 = new DataFrame222(temp);
    out222.index = df.index;
    return out222;
  }
  function dfGetSubsetByIndices23(df, rowIndices, colIndices) {
    const dataShape = df.shape;
    if (isUndefined23(rowIndices))
      rowIndices = range23(0, dataShape[0]);
    if (isUndefined23(colIndices))
      colIndices = range23(0, dataShape[1]);
    if (isNumber23(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber23(colIndices))
      colIndices = [colIndices];
    assert23(isArray23(rowIndices) && isArray23(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert23(shape23(rowIndices).length === 1 && shape23(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert23(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert23(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert23(isWholeNumber23(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert23(rowIndex < df.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert23(isWholeNumber23(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert23(colIndex < df.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df.index[i]);
    const cols = colIndices.map((i) => df.columns[i]);
    return df.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames23(DataFrame222, Series222, df, rows, cols) {
    if (isUndefined23(rows))
      rows = df.index;
    if (isUndefined23(cols))
      cols = df.columns;
    if (isString23(rows))
      rows = [rows];
    if (isString23(cols))
      cols = [cols];
    assert23(isArray23(rows) && isArray23(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert23(shape23(rows).length === 1 && shape23(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert23(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert23(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert23(isString23(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert23(df.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert23(isString23(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert23(df.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df.values[df.index.indexOf(row)][df.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series222(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series222(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out222 = new DataFrame222(values);
    out222.columns = cols;
    out222.index = rows;
    return out222;
  }
  function dfPrint23(DataFrame222, Series222, df) {
    function truncate(s222, maxLength2) {
      if (isString23(s222)) {
        if (s222.length > maxLength2) {
          return s222.substring(0, maxLength2 - 3) + "...";
        } else {
          return s222;
        }
      } else {
        return s222;
      }
    }
    if (df.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df.index.length ? null : range23(0, halfMaxRows).concat(range23(df.index.length - halfMaxRows, df.index.length));
    const tempColumns = maxColumns > df.columns.length ? null : range23(0, halfMaxColumns).concat(range23(df.columns.length - halfMaxColumns, df.columns.length));
    let temp = df.get(tempRows, tempColumns);
    if (temp instanceof Series222) {
      if (df.shape[0] === 1) {
        temp = new DataFrame222([temp.values]);
        temp.index = df.index;
        temp.columns = new Series222(df.columns).get(tempColumns).values;
      } else if (df.shape[1] === 1) {
        temp = new DataFrame222([temp.values]).transpose();
        temp.index = new Series222(df.index).get(tempRows).values;
        temp.columns = df.columns;
      }
    }
    if (maxRows <= df.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range23(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series222) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df.shape, "\n");
    return df;
  }
  function leftPad23(x, maxLength) {
    assert23(isNumber23(x), "The `leftPad` function only works on numbers!");
    let out222 = x.toString();
    while (out222.length < maxLength)
      out222 = "0" + out222;
    return out222;
  }
  function dfResetIndex23(df, shouldSkipCopying) {
    const out222 = shouldSkipCopying ? df : df.copy();
    out222.index = range23(0, df.shape[0]).map((i) => {
      return "row" + leftPad23(i, (out222.index.length - 1).toString().length);
    });
    return out222;
  }
  function product23(arr, shouldDropNaNs) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return product23(arr.values, shouldDropNaNs);
    }
    assert23(isArray23(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten23(arr);
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of temp) {
        if (!isNumber23(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  function isNaturalNumber23(x) {
    return isInteger23(x) && x > 0;
  }
  function reshape23(x, newShape) {
    if (isDataFrame23(x) || isSeries23(x)) {
      return reshape23(x.values, newShape);
    }
    assert23(isArray23(x), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber23(newShape))
      newShape = [newShape];
    assert23(isArray23(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert23(shape23(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert23(isNaturalNumber23(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten23(x);
    }
    const temp = flatten23(x);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert23(product23(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out222 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out222.push(reshape23(row, newShape.slice(1)));
    }
    return out222;
  }
  var MAX23 = Math.pow(2, 64);
  var s23 = [];
  seed23(Math.floor(Math.random() * MAX23));
  function splitmix6423(state, n) {
    state = uint23(state);
    function helper522() {
      state += uint23("0x9e3779b97f4a7c15");
      let z = copy23(state);
      z = (z ^ z >> BigInt(30)) * uint23("0xbf58476d1ce4e5b9");
      z = (z ^ z >> BigInt(27)) * uint23("0x94d049bb133111eb");
      return z ^ z >> BigInt(31);
    }
    const out222 = [];
    for (let i = 0; i < n; i++)
      out222.push(helper522());
    return out222;
  }
  function uint23(x) {
    return BigInt.asUintN(64, BigInt(x));
  }
  function rotl23(x, k) {
    x = uint23(x);
    k = BigInt(k);
    return uint23(uint23(x << k) | uint23(x >> uint23(BigInt(64) - k)));
  }
  function seed23(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined23(val)) {
      assert23(isNumber23(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix6423(Math.floor(val), 4);
      s23[0] = temp[0];
      s23[1] = temp[1];
      s23[2] = temp[2];
      s23[3] = temp[3];
    } else {
      return copy23(s23);
    }
  }
  function next23() {
    const result = uint23(rotl23(s23[0] + s23[3], 23) + s23[0]);
    const t = uint23(s23[1] << BigInt(17));
    s23[2] = uint23(s23[2] ^ s23[0]);
    s23[3] = uint23(s23[3] ^ s23[1]);
    s23[1] = uint23(s23[1] ^ s23[2]);
    s23[0] = uint23(s23[0] ^ s23[3]);
    s23[2] = uint23(s23[2] ^ t);
    s23[3] = rotl23(s23[3], 45);
    return Math.floor(Number(result)) / MAX23;
  }
  function random23(shape222) {
    if (isUndefined23(shape222))
      return next23();
    if (!isArray23(shape222))
      shape222 = [shape222];
    return reshape23(ndarray23(product23(shape222)).map(next23), shape222);
  }
  function shuffle23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert23(isArray23(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random23() * temp.length);
      out222.push(temp.splice(index, 1)[0]);
    }
    return out222;
  }
  function dfShuffle23(df, axis) {
    if (isUndefined23(axis))
      axis = 0;
    assert23(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df.get(axis === 0 ? shuffle23(df.index) : null, axis === 1 ? shuffle23(df.columns) : null);
  }
  function isBoolean23(x) {
    return typeof x === "boolean";
  }
  function dfSort23(df, a, b) {
    if (isFunction23(a)) {
      return dfSortByFunction23(df, a, b);
    } else {
      return dfSortByColumns23(df, a, b);
    }
  }
  function dfSortByFunction23(df, fn, axis) {
    axis = isUndefined23(axis) ? 0 : axis;
    assert23(isFunction23(fn), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert23(isNumber23(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort23(df.index, (a, b) => {
        return fn(df.get(a, null), df.get(b, null));
      });
      return df.get(index, null);
    } else {
      const columns = sort23(df.columns, (a, b) => {
        return fn(df.get(null, a), df.get(null, b));
      });
      return df.get(null, columns);
    }
  }
  function dfSortByColumns23(df, cols, directions) {
    let out222 = df.copy();
    const indexID = random23().toString();
    out222 = out222.assign(indexID, out222.index);
    if (isUndefined23(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber23(cols) || isString23(cols)) {
      cols = [cols];
      if (isBoolean23(directions) || isString23(directions))
        directions = [directions];
    }
    assert23(isArray23(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert23(shape23(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined23(directions))
      directions = range23(0, cols.length).map(() => true);
    assert23(isArray23(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert23(shape23(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert23(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert23(isString23(col) || isNumber23(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString23(col)) {
        const index = out222.columns.indexOf(col);
        assert23(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber23(col)) {
        assert23(isWholeNumber23(col), "Column indices must be whole numbers!");
        assert23(col < out222.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert23(isString23(dir) || isBoolean23(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString23(dir)) {
        const value = dir.trim().toLowerCase();
        assert23(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean23(dir)) {
        return dir;
      }
    });
    out222.values = sort23(out222.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out222.columns.indexOf(indexID);
    out222.index = out222.values.map((row) => row[indexNumber]);
    out222 = out222.dropColumns(indexID);
    return out222;
  }
  function dfToDetailedObject23(df, axis) {
    if (isUndefined23(axis)) {
      axis = 0;
    } else {
      assert23(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out222 = {};
    if (axis === 0) {
      df.index.forEach((rowName, i) => {
        const temp = {};
        df.columns.forEach((colName, j) => {
          temp[colName] = df.values[i][j];
        });
        out222[rowName] = temp;
      });
    } else {
      df.columns.forEach((colName, j) => {
        const temp = {};
        df.index.forEach((rowName, i) => {
          temp[rowName] = df.values[i][j];
        });
        out222[colName] = temp;
      });
    }
    return out222;
  }
  function dfToJSONString23(df, axis) {
    return JSON.stringify(df.toObject(axis));
  }
  async function dfToJSON23(df, filename, axis) {
    const out222 = dfToJSONString23(df, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out222)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e) {
      browserError = e;
    }
    try {
      const fs = await import("node:fs");
      const path = await import("node:path");
      fs.writeFileSync(path.resolve(filename), out222, "utf8");
      wroteToDiskInNode = true;
    } catch (e) {
      nodeError = e;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError23(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError23(nodeError);
      } else {
        throw new MathError23("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df;
  }
  function dfToObject23(df) {
    const out222 = {};
    df.columns.forEach((col) => {
      out222[col] = df.get(col).values;
    });
    return out222;
  }
  function transpose23(arr) {
    if (isDataFrame23(arr) || isSeries23(arr)) {
      return arr.transpose();
    }
    assert23(isArray23(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape23(arr);
    assert23(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse23(arr);
    } else if (theShape.length === 2) {
      const out222 = ndarray23(reverse23(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out222[col][row] = arr[row][col];
        }
      }
      return out222;
    }
  }
  function seriesAppend23(Series222, series, x) {
    if (isSeries23(x)) {
      return new Series222(series.values.concat(x.values));
    }
    if (isArray23(x)) {
      const xShape = shape23(x);
      assert23(xShape.length === 1 && !isNested23(xShape), "Only vectors can be appended to Series!");
      const out222 = series.copy();
      x.forEach((v, i) => {
        out222._values.push(v);
        out222._index.push("item" + (series.values.length + i));
      });
      return out222;
    }
    return seriesAppend23(series, [x]);
  }
  function seriesApply23(series, fn) {
    assert23(isFunction23(fn), "The parameter to the `apply` method must be a function.");
    const out222 = series.copy();
    out222._values = out222._values.map((v, i) => fn(v, i));
    return out222;
  }
  function seriesDropMissing23(series) {
    const out222 = series.copy();
    const outIndex = [];
    out222._values = out222.values.filter((v, i) => {
      if (isUndefined23(v)) {
        return false;
      } else {
        outIndex.push(out222.index[i]);
        return true;
      }
    });
    out222._index = outIndex;
    return out222;
  }
  function seriesDropNaN23(Series222, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber23(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out222 = new Series222(values);
    out222.name = series.name;
    out222.index = index;
    return out222;
  }
  function seriesFilter23(Series222, series, fn) {
    let out222 = series.copy();
    const index = copy23(out222.index);
    const indicesToRemove = [];
    const newValues = out222.values.filter((value, i) => {
      const shouldKeep = fn(value, i, out222.values);
      if (!shouldKeep)
        indicesToRemove.push(out222.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out222 = new Series222();
      out222.name = series.name;
      return out222;
    }
    out222.values = newValues;
    out222.index = index;
    return out222;
  }
  function seriesGet23(series, indices) {
    if (isString23(indices) || isNumber23(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set23((indices || []).map((v) => typeof v));
    assert23(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert23(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert23(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert23(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined23(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert23(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert23(i >= 0, `Index ${i} is out of bounds!`);
          assert23(Math.floor(i) === i, `Indices must be integers!`);
          assert23(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices23(series, indices) {
    const dataShape = series.shape;
    if (isUndefined23(indices))
      indices = range23(0, dataShape[0]);
    assert23(isArray23(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert23(shape23(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert23(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert23(isWholeNumber23(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert23(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames23(Series222, series, indices) {
    if (isUndefined23(indices))
      indices = series.index;
    assert23(isArray23(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert23(shape23(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert23(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert23(isString23(name), "The `indices` array must contain only strings.");
      assert23(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out222 = new Series222(values);
    out222.index = indices;
    out222.name = series.name;
    return out222;
  }
  function seriesPrint23(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range23(0, maxRows / 2).concat(range23(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy23(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out222 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out222[temp.index[i]] = obj;
    });
    console.table(out222);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle23(series) {
    const out222 = series.copy();
    return out222.get(shuffle23(out222.index));
  }
  function seriesSort23(Series222, series, fn) {
    fn = fn || ((a, b) => a < b ? -1 : 1);
    assert23(isUndefined23(fn) || isFunction23(fn), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose23([series.values, series.index]);
    const temp = sort23(pairs, (aPair, bPair) => {
      return fn(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out222 = new Series222();
    out222._values = newValues;
    out222._index = newIndex;
    out222.name = series.name;
    return out222;
  }
  function seriesSortByIndex23(Series222, series) {
    let temp = transpose23([series.values, series.index]);
    temp = transpose23(sort23(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out222 = new Series222(temp[0]);
    out222.index = temp[1];
    out222.name = series.name;
    return out222;
  }
  function seriesToObject23(series) {
    const out222 = {};
    out222[series.name] = {};
    series.index.forEach((index, i) => {
      out222[series.name][index] = series.values[i];
    });
    return out222;
  }
  var SERIES_SYMBOL23 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass23(DataFrame222) {
    class Series222 {
      static [Symbol.hasInstance](x) {
        try {
          return !!x._symbol && x._symbol === SERIES_SYMBOL23;
        } catch (e) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL23
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x) {
            assert23(isArray23(x), "The new values must be a 1-dimensional array!");
            const dataShape = shape23(x);
            assert23(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range23(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad23(i, (x.length - 1).toString().length);
              }));
            }
            this._values = x;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x) {
            assert23(isArray23(x), "The new index must be a 1-dimensional array of strings!");
            assert23(x.length === this.shape[0], "The new index must be the same length as the old index!");
            assert23(shape23(x).length === 1, "The new index must be a 1-dimensional array of strings!");
            x.forEach((value) => {
              assert23(isString23(value), "All of the row names must be strings!");
            });
            this._index = x;
          }
        });
        if (data) {
          if (data instanceof Series222) {
            this.name = data.name;
            this.values = copy23(data.values);
            this.index = copy23(data.index);
          } else if (isArray23(data)) {
            const dataShape = shape23(data);
            assert23(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert23(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert23(shape23(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape23(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined23(v)).length === 0;
      }
      clear() {
        const out222 = this.copy();
        out222.values.forEach((v, i) => {
          out222.values[i] = void 0;
        });
        return out222;
      }
      get(indices) {
        return seriesGet23(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames23(Series222, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices23(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out222 = new Series222(reverse23(this.values));
        out222.index = reverse23(this.index);
        out222.name = this.name;
        return out222;
      }
      resetIndex() {
        const out222 = this.copy();
        out222.index = range23(0, this.shape[0]).map((i) => {
          return "item" + leftPad23(i, (out222.index.length - 1).toString().length);
        });
        return out222;
      }
      copy() {
        const out222 = new Series222();
        out222._values = copy23(this.values);
        out222._index = copy23(this.index);
        out222.name = this.name;
        return out222;
      }
      append(x) {
        return seriesAppend23(Series222, this, x);
      }
      apply(fn) {
        return seriesApply23(this, fn);
      }
      concat(x) {
        return this.append(x);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing23(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN23(Series222, this);
      }
      toObject() {
        return seriesToObject23(this);
      }
      print() {
        return seriesPrint23(this);
      }
      shuffle() {
        return seriesShuffle23(this);
      }
      sort(direction) {
        return seriesSort23(Series222, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex23(Series222, this);
      }
      filter(fn) {
        return seriesFilter23(Series222, this, fn);
      }
      toDataFrame() {
        const out222 = new DataFrame222(transpose23([this.values]));
        out222.columns = [this.name];
        out222.index = this.index;
        return out222;
      }
      transpose() {
        const out222 = this.copy();
        out222.values = reverse23(out222.values);
        out222.index = reverse23(out222.index);
        return out222;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series222;
  }
  var DATAFRAME_SYMBOL23 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey323(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out222 = "";
    for (let i = 0; i < n; i++)
      out222 += alpha[Math.floor(random23() * alpha.length)];
    return out222;
  }
  var DataFrame23 = class {
    static [Symbol.hasInstance](x) {
      try {
        return !!x._symbol && x._symbol === DATAFRAME_SYMBOL23;
      } catch (e) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL23
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined23(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x) {
          assert23(isArray23(x), "The new values must be a 2-dimensional array!");
          const dataShape = shape23(x);
          assert23(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range23(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad23(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range23(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad23(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x) {
          assert23(isArray23(x), "The new columns list must be a 1-dimensional array of strings!");
          assert23(this.isEmpty || x.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert23(shape23(x).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey323(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count23(x);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey323(8);
            }
            return v;
          });
          this._columns = x;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x) {
          assert23(isArray23(x), "The new index must be a 1-dimensional array of strings!");
          assert23(this.isEmpty || x.length === this.shape[0], "The new index must be the same length as the old index!");
          assert23(shape23(x).length === 1, "The new index must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey323(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count23(x);
            const out222 = {};
            temp.values.forEach((v) => {
              out222[v] = temp.get(v);
            });
            return out222;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey323(8);
            }
            return v;
          });
          this._index = x;
        }
      });
      assert23(isUndefined23(data) || isObject23(data) || isArray23(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame23) {
          this.values = copy23(data.values);
          this.columns = copy23(data.columns);
          this.index = copy23(data.index);
        } else if (isArray23(data)) {
          const dataShape = shape23(data);
          assert23(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert23(!isJagged23(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined23(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert23(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose23(temp);
          const dataShape = shape23(this.values);
          this._index = range23(0, dataShape[0]).map((i) => {
            return "row" + leftPad23(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape23(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out222 = new DataFrame23(ndarray23(this.shape));
      out222.columns = this.columns.slice();
      out222.index = this.index.slice();
      return out222;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e) {
          return this.get(rows, null);
        }
      }
      return dfGet23(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames23(DataFrame23, Series23, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices23(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies23(DataFrame23, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies23(DataFrame23, this, columns);
    }
    transpose() {
      const out222 = new DataFrame23(transpose23(this.values));
      out222.columns = this.index.slice();
      out222.index = this.columns.slice();
      return out222;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex23(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy23(DataFrame23, this);
    }
    assign(p1, p2) {
      return dfAssign23(DataFrame23, Series23, this, p1, p2);
    }
    apply(fn, axis) {
      return dfApply23(DataFrame23, Series23, this, fn, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing23(DataFrame23, Series23, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN23(DataFrame23, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop23(DataFrame23, Series23, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject23(this, axis);
    }
    toObject() {
      return dfToObject23(this);
    }
    toJSONString(axis) {
      return dfToJSONString23(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON23(this, filename, axis);
    }
    print() {
      return dfPrint23(DataFrame23, Series23, this);
    }
    sort(cols, directions) {
      return dfSort23(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn, axis) {
      return dfFilter23(DataFrame23, Series23, this, fn, axis);
    }
    shuffle(axis) {
      return dfShuffle23(this, axis);
    }
    append(x, axis) {
      return dfAppend23(this, x, axis);
    }
    concat(x, axis) {
      return this.append(x, axis);
    }
    join(x, axis) {
      return this.append(x, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series23 = createSeriesClass23(DataFrame23);
  function max23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs }).max;
  }
  function vectorize23(fn) {
    assert23(isFunction23(fn), "You must pass a function into the `vectorize` function!");
    return function helper522() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray23(arg)) {
          return true;
        } else if (isSeries23(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame23(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s222, i) => {
        assert23(isEqual23(isArray23(s222) ? shape23(s222) : s222.shape, isArray23(childArrays[i + 1]) ? shape23(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max23(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out222 = range23(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray23(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries23(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame23(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper522(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual23(shape23(dataframes[0]), shape23(out222))) {
              const temp = new DataFrame23(out222);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame23(out222);
            }
          } catch (e) {
            return out222;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out222.length) {
              const temp = new Series23(out222);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series23(out222);
            }
          } catch (e) {
            return out222;
          }
        }
        return out222;
      } else {
        return fn(...arguments);
      }
    };
  }
  function abs23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        return x < 0 ? -x : x;
      } else {
        return Math.abs(x);
      }
    } catch (e) {
      return NaN;
    }
  }
  var vabs23 = vectorize23(abs23);
  function add23() {
    try {
      let out222 = 0;
      let resultShouldBeABigInt = false;
      const x = Object.values(arguments);
      for (let v of x) {
        if (!isNumber23(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  var vadd23 = vectorize23(add23);
  function apply23(x, fn) {
    try {
      return fn(x);
    } catch (e) {
      return NaN;
    }
  }
  var vapply23 = vectorize23(apply23);
  function arccos23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.acos(x);
    } catch (e) {
      return NaN;
    }
  }
  var varccos23 = vectorize23(arccos23);
  function arcsin23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.asin(x);
    } catch (e) {
      return NaN;
    }
  }
  var varcsin23 = vectorize23(arcsin23);
  function arctan23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.atan(x);
    } catch (e) {
      return NaN;
    }
  }
  var varctan23 = vectorize23(arctan23);
  function argmax23(x, shouldDropNaNs) {
    if (isDataFrame23(x)) {
      const index = argmax23(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries23(x)) {
      const index = argmax23(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert23(isArray23(x), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf23(x, max23(x, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function min23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs }).min;
  }
  function argmin23(x, shouldDropNaNs) {
    if (isDataFrame23(x)) {
      const index = argmin23(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries23(x)) {
      const index = argmin23(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert23(isArray23(x), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out222 = indexOf23(x, min23(x, shouldDropNaNs));
      if (out222) {
        if (out222.length === 0) {
          return void 0;
        } else if (out222.length === 1) {
          return out222[0];
        } else {
          return out222;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function cast23(value, type) {
    if (isDataFrame23(value) || isSeries23(value)) {
      return value.apply((item) => cast23(item, type));
    }
    if (isArray23(value)) {
      return value.map((v) => cast23(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined23(value)) {
        return NaN;
      }
      const booleanValue = cast23(value, "boolean");
      if (isBoolean23(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e) {
        const dateValue = cast23(value, "date");
        if (isDate23(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out222 = parseFloat(value);
      if (isNaN(out222))
        return NaN;
      return out222;
    }
    if (type === "int") {
      const out222 = cast23(value, "number");
      return out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
    }
    if (type === "float") {
      return cast23(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast23(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean23(value)) {
        return value;
      }
      if (isNumber23(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate23(value)) {
        return value;
      }
      if (isUndefined23(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out222 = new Date(value);
        if (!isDate23(out222))
          return null;
        return out222;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject23(value)) {
        return value;
      }
      const booleanValue = cast23(value, "boolean");
      if (isBoolean23(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast23(value, "number");
        if (isNumber23(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e) {
      }
      const dateValue = cast23(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out222 = JSON.parse(value);
        if (isArray23(out222)) {
          return out222.map((v) => cast23(v, type));
        } else {
          return out222;
        }
      } catch (e) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined23(value)) {
        if (isEqual23(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.ceil(x);
    } catch (e) {
      return NaN;
    }
  }
  var vceil23 = vectorize23(ceil23);
  function chop23(x, threshold) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      if (isUndefined23(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber23(threshold)) {
        return NaN;
      }
      return vabs23(x) < threshold ? 0 : x;
    } catch (e) {
      return NaN;
    }
  }
  var vchop23 = vectorize23(chop23);
  function int23(x) {
    if (isDataFrame23(x) || isSeries23(x)) {
      const out222 = x.copy();
      out222.values = int23(out222.values);
      return out222;
    }
    if (isArray23(x)) {
      return x.map((v) => int23(v));
    } else {
      try {
        const out222 = JSON.parse(x);
        if (isNumber23(out222)) {
          return typeof out222 === "bigint" ? Number(out222) : out222 >= 0 ? Math.floor(out222) : Math.ceil(out222);
        }
        return NaN;
      } catch (e) {
        return NaN;
      }
    }
  }
  var vint23 = vectorize23(int23);
  function clamp23(x, a, b) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (!isNumber23(a))
        return NaN;
      if (!isNumber23(b))
        return NaN;
      if (typeof x === "bigint") {
        return BigInt(clamp23(vint23(x), a, b));
      }
      if (x < a)
        return a;
      if (x > b)
        return b;
      return x;
    } catch (e) {
      return NaN;
    }
  }
  var vclamp23 = vectorize23(clamp23);
  function combinationsIterator23(x, r) {
    function* helper522(x2, r2) {
      if (r2 > x2.length) {
        yield x2;
      } else if (r2 <= 0) {
        yield [];
      } else if (x2.length < 2) {
        yield x2;
      } else {
        for (let i = 0; i < x2.length; i++) {
          const item = x2[i];
          const after = x2.slice(i + 1);
          if (after.length < r2 - 1) {
            continue;
          }
          if (r2 - 1 >= 0) {
            for (const child of combinationsIterator23(after, r2 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame23(x) || isSeries23(x)) {
      return combinationsIterator23(x.values, r);
    }
    assert23(isArray23(x), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert23(isNumber23(r) && vint23(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten23(x), r);
  }
  function combinations23(x, r) {
    const out222 = [];
    for (const combo of combinationsIterator23(x, r)) {
      out222.push(combo.slice());
    }
    return out222;
  }
  function intersect23() {
    const arrays = Object.values(arguments).map((x) => {
      if (isDataFrame23(x) || isSeries23(x)) {
        return set23(x.values);
      }
      assert23(isArray23(x), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set23(x);
    });
    const all = set23(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual23(other, v)) > -1);
    });
  }
  var _IndexMatcher23 = class {
    constructor(mode222) {
      assert23(isUndefined23(mode222) || mode222 === _IndexMatcher23.DROP_NAN_MODE || mode222 === _IndexMatcher23.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined23(mode222) ? mode222 : _IndexMatcher23.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x) => {
        if (isArray23(x)) {
          const xshape = shape23(x);
          if (xshape.length === 1) {
            x = new Series23(x);
          } else if (xshape.length === 2) {
            x = new DataFrame23(x);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert23(isDataFrame23(x) || isSeries23(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher23.DROP_MISSING_MODE) {
          indices.push(x.dropMissing().index);
        } else {
          indices.push(x.dropNaN().index);
        }
      });
      this.index = intersect23(...indices);
      return this;
    }
    transform() {
      assert23(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out222 = Object.values(arguments).map((x) => {
        if (isArray23(x)) {
          const xshape = shape23(x);
          if (xshape.length === 1) {
            return new Series23(x).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame23(x).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert23(isDataFrame23(x) || isSeries23(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x.get(this.index, null);
      });
      return out222.length === 1 ? out222[0] : out222;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher23 = _IndexMatcher23;
  __publicField23(IndexMatcher23, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField23(IndexMatcher23, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance23(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries23(x)) {
      return covariance23(x.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries23(y)) {
      return covariance23(x, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert23(isArray23(x) && isArray23(y) && shape23(x).length === 1 && shape23(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert23(x.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance23(...new IndexMatcher23().fitAndTransform(x, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats23(x, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats23(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx = Number(xstats.mean);
      const my = Number(ystats.mean);
      if (!isNumber23(mx) || !isNumber23(my)) {
        return NaN;
      }
      const n = Math.max(x.length, y.length);
      let out222 = 0;
      for (let i = 0; i < n; i++) {
        let vx = x[i];
        let vy = y[i];
        if (!isNumber23(vx))
          return NaN;
        if (!isNumber23(vy))
          return NaN;
        if (typeof vx === "bigint") {
          vx = Number(vx);
        }
        if (typeof vy === "bigint") {
          vy = Number(vy);
        }
        out222 += (vx - mx) * (vy - my);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out222 / x.length, xstats, ystats];
      } else {
        return out222 / x.length;
      }
    } catch (e) {
      return NaN;
    }
  }
  function correl23(x, y, shouldDropNaNs) {
    if (isSeries23(x)) {
      return correl23(x.values, y, shouldDropNaNs);
    }
    if (isSeries23(y)) {
      return correl23(x, y.values, shouldDropNaNs);
    }
    assert23(isArray23(x) && isArray23(y) && shape23(x).length === 1 && shape23(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert23(x.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance23(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e) {
      return NaN;
    }
  }
  function cos23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.cos(x);
    } catch (e) {
      return NaN;
    }
  }
  var vcos23 = vectorize23(cos23);
  var dataTypes23 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff23(a, b) {
    if (isDataFrame23(a) || isSeries23(a)) {
      return diff23(a.values, b);
    }
    if (isDataFrame23(b) || isSeries23(b)) {
      return diff23(a, b.values);
    }
    assert23(isArray23(a) && isArray23(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set23(a);
    const bTemp = set23(b);
    const out222 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual23(other, item)) < 0) {
        out222.push(item);
      }
    });
    return out222;
  }
  function pow23(x, p) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (!isNumber23(p))
        return NaN;
      if (typeof x === "bigint" || typeof p === "bigint") {
        const out222 = pow23(Number(x), Number(p));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.pow(x, p);
    } catch (e) {
      return NaN;
    }
  }
  var vpow23 = vectorize23(pow23);
  function sqrt23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        const out222 = sqrt23(Number(x));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.sqrt(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsqrt23 = vectorize23(sqrt23);
  function multiply23() {
    try {
      const x = Object.values(arguments);
      if (x.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out222 = 1;
      for (let v of x) {
        if (!isNumber23(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out222 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  }
  var vmultiply23 = vectorize23(multiply23);
  function scale23() {
    return vmultiply23(...arguments);
  }
  function subtract23(a, b) {
    return vadd23(a, scale23(b, -1));
  }
  function sum23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs }).sum;
  }
  function distance23(a, b) {
    if (isNumber23(a) && isNumber23(b)) {
      return vabs23(a - b);
    }
    if (isDataFrame23(a) || isSeries23(a)) {
      return distance23(a.values, b);
    }
    if (isDataFrame23(b) || isSeries23(b)) {
      return distance23(a, b.values);
    }
    if (isArray23(a) && isArray23(b)) {
      assert23(isEqual23(shape23(a), shape23(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt23(sum23(vpow23(subtract23(a, b), 2)));
    } catch (e) {
      return NaN;
    }
  }
  function divide23(a, b) {
    return scale23(a, vpow23(b, -1));
  }
  function dot23(a, b) {
    if (isDataFrame23(a)) {
      const temp = dot23(a.values, b);
      if (shape23(temp).length === 1) {
        const out222 = new Series23(temp);
        out222.name = isSeries23(b) ? b.name : out222.name;
        out222.index = a.index.slice();
        return out222;
      } else {
        const out222 = new DataFrame23(temp);
        out222.index = a.index.slice();
        if (isDataFrame23(b)) {
          out222.columns = b.columns.slice();
        }
        return out222;
      }
    }
    if (isDataFrame23(b)) {
      const temp = dot23(a, b.values);
      if (shape23(temp).length === 1) {
        const out222 = new Series23(temp);
        out222.name = isSeries23(a) ? a.name : out222.name;
        out222.index = b.columns.slice();
        return out222;
      } else {
        const out222 = new DataFrame23(temp);
        out222.columns = b.columns.slice();
        return out222;
      }
    }
    if (isSeries23(a)) {
      return dot23(a.values, b);
    }
    if (isSeries23(b)) {
      return dot23(a, b.values);
    }
    assert23(isArray23(a) && isArray23(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape23(a);
    const bShape = shape23(b);
    assert23(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert23(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum23(scale23(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose23(b).map((col) => dot23(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot23(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose23(b);
      const out222 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot23(a[i], bTranspose[j]));
        }
        out222.push(row);
      }
      return out222;
    }
  }
  function dropMissing23(x) {
    if (isDataFrame23(x) || isSeries23(x)) {
      return x.dropMissing(...Object.values(arguments).slice(1));
    }
    assert23(isArray23(x), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out222 = [];
    x.forEach((v) => {
      try {
        return out222.push(dropMissing23(v));
      } catch (e) {
        if (!isUndefined23(v)) {
          out222.push(v);
        }
      }
    });
    return out222;
  }
  function dropMissingPairwise23(a, b) {
    if (isDataFrame23(a) || isSeries23(a)) {
      return dropMissingPairwise23(a.values, b);
    }
    if (isDataFrame23(b) || isSeries23(b)) {
      return dropMissingPairwise23(a, b.values);
    }
    assert23(isArray23(a) && isArray23(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert23(isEqual23(shape23(a), shape23(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise23(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (!isUndefined23(a[i]) && !isUndefined23(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise23(a, b) {
    if (isDataFrame23(a) || isSeries23(a)) {
      return dropNaNPairwise23(a.values, b);
    }
    if (isDataFrame23(b) || isSeries23(b)) {
      return dropNaNPairwise23(a, b.values);
    }
    assert23(isArray23(a) && isArray23(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert23(isEqual23(shape23(a), shape23(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise23(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (isNumber23(a[i]) && isNumber23(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined23(x) {
    return dropMissing23(x);
  }
  function every23(x, fn) {
    if (isDataFrame23(x) || isSeries23(x)) {
      return every23(x.values, fn);
    }
    assert23(isArray23(x), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert23(isFunction23(fn), "The second argument passed into the `every` function must be a function!");
    for (const v of x) {
      if (isArray23(v)) {
        if (!every23(v, fn)) {
          return false;
        }
      } else {
        if (!fn(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        if (x === 0n) {
          return 1n;
        } else {
          x = Number(x);
        }
      }
      return Math.exp(x);
    } catch (e) {
      return NaN;
    }
  }
  var vexp23 = vectorize23(exp23);
  function factorial23(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial23(vint23(n)));
      }
      if (n !== vint23(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial23(n - 1);
    } catch (e) {
      return NaN;
    }
  }
  var vfactorial23 = vectorize23(factorial23);
  function find23(x, fn) {
    if (isDataFrame23(x)) {
      return find23(x.values, fn);
    }
    if (isSeries23(x)) {
      return find23(x.values, fn);
    }
    assert23(isObject23(x) || isArray23(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction23(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject23(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return value;
          }
          const result = helper522(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray23(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return value;
          }
          const result = helper522(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn2(x2)) {
          return x2;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    return helper522(x, safeFn);
  }
  function findAll23(x, fn) {
    if (isDataFrame23(x)) {
      return findAll23(x.values, fn);
    }
    if (isSeries23(x)) {
      return findAll23(x.values, fn);
    }
    assert23(isObject23(x) || isArray23(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction23(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper522(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject23(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        const out222 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else if (isArray23(x2)) {
        checked.push(x2);
        const out222 = [];
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out222.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper522(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out222.push(r));
          }
        }
        return out222;
      } else {
        if (fn2(x2)) {
          return [x2];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const results = helper522(x, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float23(x) {
    try {
      if (x === "Infinity") {
        return Infinity;
      }
      if (x === "-Infinity") {
        return -Infinity;
      }
      const out222 = JSON.parse(x);
      if (isNumber23(out222))
        return out222;
      return NaN;
    } catch (e) {
      return NaN;
    }
  }
  var vfloat23 = vectorize23(float23);
  function floor23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        return x;
      }
      return Math.floor(x);
    } catch (e) {
      return NaN;
    }
  }
  var vfloor23 = vectorize23(floor23);
  function zeros23(shape222) {
    if (isNumber23(shape222))
      shape222 = [shape222];
    const out222 = [];
    const n = product23(shape222);
    for (let i = 0; i < n; i++)
      out222.push(0);
    return reshape23(out222, shape222);
  }
  function identity23(size) {
    if (typeof size === "bigint") {
      size = vint23(size);
    }
    assert23(!isUndefined23(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert23(isNumber23(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert23(vint23(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert23(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out222 = zeros23([size, size]);
    for (let i = 0; i < size; i++)
      out222[i][i] = 1;
    return out222;
  }
  var booleanValues23 = ["true", "false", "yes", "no"];
  var nullValues23 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger23(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint23(results.value) === results.value;
      } else {
        results.isInteger = every23(results.values, (v) => isNumber23(v) ? vint23(v) === v : true);
      }
    }
    return results;
  }
  function inferType23(arr) {
    if (isDataFrame23(arr)) {
      const out222 = arr.copy();
      const results = inferType23(arr.values);
      out222.values = results.values;
      return checkIfInteger23({ type: results.type, values: out222 });
    }
    if (isSeries23(arr)) {
      const out222 = arr.copy();
      const results = inferType23(arr.values);
      out222.values = results.values;
      return checkIfInteger23({ type: results.type, values: out222 });
    }
    if (!isArray23(arr)) {
      const out222 = inferType23([arr]);
      out222.value = out222.values[0];
      delete out222.values;
      return checkIfInteger23(out222);
    }
    assert23(isArray23(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten23(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate23(temp)) {
            return "date";
          }
        }
      } catch (e) {
      }
      if (!isString23(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues23.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues23.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber23(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray23(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e) {
        const vDate = new Date(v);
        if (isDate23(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count23(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger23({
      type: primaryType,
      values: vapply23(arr, (v) => cast23(v, primaryType))
    });
  }
  function inverse23(x) {
    if (isDataFrame23(x)) {
      const out222 = x.copy();
      out222.values = inverse23(out222.values);
      return out222;
    }
    assert23(isArray23(x), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape23(x);
    assert23(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert23(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert23(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x;
    } else if (xShape[0] === 1) {
      assert23(x[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x[0][0];
      let b = x[0][1];
      let c = x[1][0];
      let d = x[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det = a * d - b * c;
      assert23(det !== 0, "This matrix cannot be inverted!");
      const out222 = [
        [d, -b],
        [-c, a]
      ];
      return scale23(out222, 1 / det);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber23(a) || isNumber23(b) ? scale23(a, b) : dot23(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x.slice(0, divider).map((row) => row.slice(0, divider));
          const B = x.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C = x.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse23(A);
          const CompInv = inverse23(vadd23(D, times(-1, times(times(C, AInv), B))));
          const topLeft = vadd23(AInv, times(times(times(times(AInv, B), CompInv), C), AInv));
          const topRight = times(-1, times(times(AInv, B), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C), AInv));
          const bottomRight = CompInv;
          const out222 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out222;
        } catch (e) {
        }
      }
      assert23(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser223 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp23(a, b, f) {
    try {
      if (!isNumber23(a))
        return NaN;
      if (!isNumber23(b))
        return NaN;
      if (!isNumber23(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = lerp23(Number(a), Number(b), f);
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return f * (b - a) + a;
    } catch (e) {
      return NaN;
    }
  }
  var vlerp23 = vectorize23(lerp23);
  function log23(x, base) {
    try {
      base = isUndefined23(base) ? Math.E : base;
      if (!isNumber23(x))
        return NaN;
      if (!isNumber23(base))
        return NaN;
      if (typeof x === "bigint" || typeof base === "bigint") {
        const out222 = log23(Number(x), Number(base));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return Math.log(x) / Math.log(base);
    } catch (e) {
      return NaN;
    }
  }
  var vlog23 = vectorize23(log23);
  function mean23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs }).mean;
  }
  function median23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod23(a, b) {
    try {
      if (!isNumber23(a))
        return NaN;
      if (!isNumber23(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out222 = mod23(Number(a), Number(b));
        try {
          return BigInt(out222);
        } catch (e) {
          return out222;
        }
      }
      return a % b;
    } catch (e) {
      return NaN;
    }
  }
  var vmod23 = vectorize23(mod23);
  function mode23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper323() {
    const u1 = random23();
    const u2 = random23();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
  function normal23(shape222) {
    if (isUndefined23(shape222))
      return helper323();
    return vapply23(ndarray23(shape222), helper323);
  }
  function ones23(shape222) {
    return vapply23(ndarray23(shape222), () => 1);
  }
  function permutationsIterator23(x, r) {
    function* helper522(x2, r2) {
      r2 = r2 || x2.length;
      if (x2.length === 1) {
        yield [x2];
        return;
      }
      for (const c of combinations23(x2, r2)) {
        if (!c.slice)
          continue;
        const state = zeros23(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame23(x) || isSeries23(x)) {
      return permutationsIterator23(x.values, r);
    }
    assert23(isArray23(x), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined23(r)) {
      r = x.length;
    }
    assert23(isNumber23(r) && vint23(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper522(flatten23(x), r);
  }
  function permutations23(x, r) {
    const out222 = [];
    for (const perm of permutationsIterator23(x, r)) {
      out222.push(perm.slice());
    }
    return out222;
  }
  function print23() {
    Object.keys(arguments).forEach((key) => {
      const x = arguments[key];
      if (isArray23(x)) {
        if (!isJagged23(x)) {
          const xShape = shape23(x);
          if (xShape.length === 1) {
            new Series23(x).print();
          } else if (xShape.length == 2) {
            new DataFrame23(x).print();
          } else {
            console.log(x);
          }
        } else {
          console.log(x);
        }
      } else if (isDataFrame23(x) || isSeries23(x)) {
        x.print();
      } else {
        console.log(x);
      }
    });
  }
  var helper423 = vectorize23((x, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x, a, b, c, d]) {
        if (!isNumber23(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x = Number(x);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out222 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out222);
        } catch (e) {
        }
      }
      return out222;
    } catch (e) {
      return NaN;
    }
  });
  function remap23(x, a, b, c, d) {
    if (isArray23(x) && isUndefined23(c) && isUndefined23(d)) {
      c = a;
      d = b;
      const results = stats23(x);
      a = results.min;
      b = results.max;
    }
    return helper423(x, a, b, c, d);
  }
  function round23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.round(x);
    } catch (e) {
      return NaN;
    }
  }
  var vround23 = vectorize23(round23);
  function sign23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint")
        return BigInt(sign23(Number(x)));
      if (x < 0)
        return -1;
      if (x > 0)
        return 1;
      return 0;
    } catch (e) {
      return NaN;
    }
  }
  var vsign23 = vectorize23(sign23);
  function sin23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.sin(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsin23 = vectorize23(sin23);
  function some23(x, fn) {
    if (isDataFrame23(x) || isSeries23(x)) {
      return some23(x.values, fn);
    }
    assert23(isArray23(x), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert23(isFunction23(fn), "The second argument passed into the `some` function must be a function!");
    for (const v of x) {
      if (isArray23(v)) {
        if (some23(v, fn)) {
          return true;
        }
      } else {
        if (fn(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev23(x) {
    return std23(x);
  }
  function tan23(x) {
    try {
      if (!isNumber23(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.tan(x);
    } catch (e) {
      return NaN;
    }
  }
  var vtan23 = vectorize23(tan23);
  function timeSync23(fn, args) {
    assert23(isFunction23(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn(...args);
    } else {
      fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync23(fn, args) {
    assert23(isFunction23(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn(...args);
    } else {
      await fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union23() {
    return set23([...arguments].map((v) => {
      if (isArray23(v))
        return v;
      if (isDataFrame23(v))
        return v.values;
      if (isSeries23(v))
        return v.values;
      return [v];
    }));
  }
  function variance23(arr, shouldDropNaNs) {
    return stats23(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip23() {
    const out222 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame23(arr) || isSeries23(arr)) {
        arr = arr.values;
      }
      assert23(isArray23(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range23(0, max23(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined23(value) ? void 0 : value);
      });
      out222.push(row);
    });
    return out222;
  }
  var out23 = {
    abs: vabs23,
    add: vadd23,
    apply: vapply23,
    arccos: varccos23,
    arcsin: varcsin23,
    arctan: varctan23,
    argmax: argmax23,
    argmin: argmin23,
    assert: assert23,
    cast: cast23,
    ceil: vceil23,
    chop: vchop23,
    clamp: vclamp23,
    combinations: combinations23,
    combinationsIterator: combinationsIterator23,
    copy: copy23,
    correl: correl23,
    cos: vcos23,
    count: count23,
    covariance: covariance23,
    DataFrame: DataFrame23,
    dataTypes: dataTypes23,
    decycle: decycle23,
    diff: diff23,
    distance: distance23,
    divide: divide23,
    dot: dot23,
    dropMissing: dropMissing23,
    dropMissingPairwise: dropMissingPairwise23,
    dropNaN: dropNaN23,
    dropNaNPairwise: dropNaNPairwise23,
    dropUndefined: dropUndefined23,
    every: every23,
    exp: vexp23,
    factorial: vfactorial23,
    find: find23,
    findAll: findAll23,
    flatten: flatten23,
    float: vfloat23,
    floor: vfloor23,
    identity: identity23,
    IndexMatcher: IndexMatcher23,
    indexOf: indexOf23,
    inferType: inferType23,
    int: vint23,
    intersect: intersect23,
    inverse: inverse23,
    isArray: isArray23,
    isBoolean: isBoolean23,
    isBrowser: isBrowser223,
    isDataFrame: isDataFrame23,
    isDate: isDate23,
    isEqual: isEqual23,
    isFunction: isFunction23,
    isJagged: isJagged23,
    isNested: isNested23,
    isNumber: isNumber23,
    isObject: isObject23,
    isSeries: isSeries23,
    isString: isString23,
    isUndefined: isUndefined23,
    lerp: vlerp23,
    log: vlog23,
    MathError: MathError23,
    max: max23,
    mean: mean23,
    median: median23,
    min: min23,
    mod: vmod23,
    mode: mode23,
    multiply: vmultiply23,
    ndarray: ndarray23,
    normal: normal23,
    ones: ones23,
    permutations: permutations23,
    permutationsIterator: permutationsIterator23,
    pow: vpow23,
    print: print23,
    product: product23,
    random: random23,
    range: range23,
    remap: remap23,
    reshape: reshape23,
    reverse: reverse23,
    round: vround23,
    scale: scale23,
    seed: seed23,
    Series: Series23,
    set: set23,
    shape: shape23,
    shuffle: shuffle23,
    sign: vsign23,
    sin: vsin23,
    some: some23,
    sort: sort23,
    sqrt: vsqrt23,
    stats: stats23,
    std: std23,
    stdev: stdev23,
    subtract: subtract23,
    sum: sum23,
    tan: vtan23,
    timeAsync: timeAsync23,
    timeSync: timeSync23,
    time: timeSync23,
    transpose: transpose23,
    union: union23,
    variance: variance23,
    vectorize: vectorize23,
    zeros: zeros23,
    zip: zip23,
    dump() {
      const context22 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context22) {
        throw new out23.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out23).forEach((key) => {
        try {
          Object.defineProperty(context22, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out23[key]
          });
        } catch (e) {
          context22[key] = out23[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out23;
  }
  var context3 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : void 0;
  function convertObjectToTypedArray3(x) {
    const typedArrayConstructorSymbol = Symbol.for("@TypedArrayConstructor");
    const typedArrayConstructorString = "Symbol(@TypedArrayConstructor)";
    const typedArrayConstructorKey = typedArrayConstructorSymbol in x ? typedArrayConstructorSymbol : typedArrayConstructorString in x ? typedArrayConstructorString : void 0;
    if (typedArrayConstructorKey) {
      if (!("values" in x)) {
        throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");
      }
      if (x[typedArrayConstructorKey] === "ArrayBuffer") {
        return new Uint8Array(x.values).buffer;
      }
      return new context3[x[typedArrayConstructorKey]](x.values);
    }
    if (isArray23(x) && x.constructor.name === "Array") {
      return x;
    }
    throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!");
  }
  function convertTypedArrayToObject3(x) {
    if (x instanceof ArrayBuffer || x instanceof BigInt64Array || x instanceof BigUint64Array || x instanceof Float32Array || x instanceof Float64Array || x instanceof Int16Array || x instanceof Int32Array || x instanceof Int8Array || x instanceof Uint16Array || x instanceof Uint32Array || x instanceof Uint8Array || x instanceof Uint8ClampedArray) {
      return {
        [Symbol.for("@TypedArrayConstructor")]: x.constructor.name,
        values: x instanceof ArrayBuffer ? Array.from(new Uint8Array(x)) : Array.from(x)
      };
    }
    if (isArray23(x)) {
      return x.map((v) => {
        try {
          return convertTypedArrayToObject3(v);
        } catch (e) {
          return v;
        }
      });
    }
    if (typeof x === "object" & x !== null) {
      if (isDate23(x)) {
        return new Date(x.getTime());
      }
      const out222 = {};
      Object.keys(x).forEach((key) => {
        try {
          out222[key] = convertTypedArrayToObject3(x[key]);
        } catch (e) {
          out222[key] = x[key];
        }
      });
      return out222;
    }
    throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.");
  }
  function isANumberString3(x) {
    x = x.trim();
    return !!(x.match(/^-?\d+(\.\d+)?$/g) || x.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g) || x.match(/^-?\.\d+$/g) || x === "NaN");
  }
  var punctuation3 = "!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";
  function replaceAll3(text, a, b) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    if (typeof a !== "string") {
      throw new Error("`a` must be a string!");
    }
    if (typeof b !== "string") {
      throw new Error("`b` must be a string!");
    }
    return text.split(a).join(b);
  }
  var doubleSpace3 = "  ";
  var singleSpace3 = " ";
  function strip3(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    let out222 = "";
    for (let i = 0; i < text.length; i++) {
      const char = text[i].toLowerCase();
      if (punctuation3.includes(char)) {
        out222 += singleSpace3;
      } else {
        out222 += char;
      }
    }
    while (out222.includes(doubleSpace3)) {
      out222 = replaceAll3(out222, doubleSpace3, singleSpace3);
    }
    return out222.trim();
  }
  function indent3(text, chars) {
    chars = chars || "";
    return text.split("\n").map((line) => {
      if (line.trim().length > 0) {
        return chars + line;
      } else {
        return line;
      }
    }).join("\n");
  }
  function kebabify3(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip3(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("-");
  }
  var specials3 = {
    "@Infinity": Infinity,
    "@NegativeInfinity": -Infinity,
    "@NaN": NaN,
    "@undefined": void 0
  };
  function fixUndefineds3(x) {
    if (typeof x === "object") {
      if (x === null) {
        return x;
      }
      if (isArray23(x)) {
        for (let i = 0; i < x.length; i++) {
          x[i] = fixUndefineds3(x[i]);
        }
      } else {
        Object.keys(x).concat(Object.getOwnPropertySymbols(x)).forEach((key) => {
          x[key] = fixUndefineds3(x[key]);
        });
      }
      return x;
    } else {
      if (typeof x === "undefined") {
        return void 0;
      }
      if (x === "Symbol(@undefined)") {
        return void 0;
      }
      return x;
    }
  }
  function parseAsBigInt3(x) {
    if (typeof x === "bigint") {
      return x;
    } else if (typeof x === "string") {
      if (x.match(/^\s*?-?\d+n\s*?$/g)) {
        try {
          return BigInt(x.split("n")[0]);
        } catch (e) {
          return NaN;
        }
      } else {
        return NaN;
      }
    } else {
      return NaN;
    }
  }
  function parseAsNumber3(x) {
    if (typeof x !== "string") {
      if (typeof x === "number") {
        return x;
      } else {
        return;
      }
    }
    if (isANumberString3(x)) {
      return parseFloat(x);
    }
  }
  function parseAsString3(x) {
    if (typeof x !== "string") {
      return;
    }
    const replacement = "@jrc03c/js-text-tools/newline-replacer";
    x = x.replaceAll("\n", replacement);
    if (x.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)) {
      let out222 = x.replace("Symbol(@String):", "");
      if (out222.match(/^".*?"$/g)) {
        try {
          return JSON.parse(out222);
        } catch (e) {
          out222 = out222.substring(1, out222.length - 1);
        }
      }
      out222 = out222.replaceAll(replacement, "\n");
      return out222;
    }
  }
  function parseAsSymbol3(x) {
    if (typeof x !== "string") {
      if (typeof x === "symbol") {
        return { out: x, isASymbol: true };
      } else {
        return;
      }
    }
    if (x.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)) {
      const xTemp = x.replace(/^.*?Symbol\(/g, "").replace(/\).*?$/g, "");
      if (xTemp in specials3) {
        return { out: specials3[xTemp], isASymbol: true };
      }
      return { out: Symbol.for(xTemp), isASymbol: true };
    }
  }
  function parseAsRegex3(x) {
    if (typeof x !== "string") {
      if (x instanceof RegExp) {
        return x;
      } else {
        return;
      }
    }
    const xTrimmed = x.trim();
    if (xTrimmed.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g)) {
      try {
        const pattern = xTrimmed.replace(/^\//g, "").replace(/\/(d|g|i|m|s|u|v|y)*?$/g, "");
        const flags = xTrimmed.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);
        return new RegExp(pattern, flags);
      } catch (e) {
      }
    }
  }
  function parseWithJSONParse3(x) {
    if (typeof x !== "string") {
      if (typeof x === "object") {
        return x;
      } else {
        return "Symbol(@undefined)";
      }
    }
    try {
      let out222 = JSON.parse(x, (key, value) => {
        try {
          const out32 = parse3(value);
          return typeof out32 === "undefined" ? "Symbol(@undefined)" : out32;
        } catch (e) {
          return typeof value === "undefined" ? "Symbol(@undefined)" : value;
        }
      });
      if (isArray23(out222)) {
        out222 = fixUndefineds3(out222);
      }
      return out222;
    } catch (e) {
      return x;
    }
  }
  function parseAsDate3(x) {
    if (typeof x !== "string") {
      if (x instanceof Date && x.toString() !== "Invalid Date") {
        return x;
      } else {
        return;
      }
    }
    try {
      const d = new Date(Date.parse(x));
      if (d.toString() !== "Invalid Date") {
        return d;
      }
    } catch (e) {
    }
  }
  function parseObjectKeysAndValues3(x) {
    if (typeof x === "object") {
      if (x !== null) {
        return fixUndefineds3(x);
      }
      return;
    }
    Object.keys(x).concat(Object.getOwnPropertySymbols(x)).forEach((key) => {
      try {
        let origKey = key;
        try {
          key = parse3(key);
        } catch (e) {
        }
        x[key] = parse3(x[origKey]);
        if (key !== origKey) {
          delete x[origKey];
        }
      } catch (e) {
      }
    });
    return fixUndefineds3(x);
  }
  function parse3(x) {
    function helper522(x2) {
      if (typeof x2 === "string") {
        let out222 = parseAsString3(x2);
        if (typeof out222 === "string") {
          return out222;
        }
        const results = parseAsSymbol3(x2);
        out222 = results ? results.out : void 0;
        if (results && results.isASymbol) {
          return out222;
        }
        out222 = parseAsRegex3(x2);
        if (out222 instanceof RegExp) {
          return out222;
        }
        out222 = parseAsBigInt3(x2);
        if (typeof out222 === "bigint") {
          return out222;
        }
        out222 = parseAsNumber3(x2);
        if (typeof out222 === "number") {
          return out222;
        }
        out222 = parseAsDate3(x2);
        if (out222 instanceof Date) {
          return out222;
        }
        out222 = parseWithJSONParse3(x2);
        if (typeof out222 !== "undefined") {
          if (out222 === "Symbol(@undefined)") {
            return void 0;
          } else {
            return out222;
          }
        }
        return x2;
      }
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        let out222;
        try {
          out222 = convertObjectToTypedArray3(x2);
          if (isArray23(out222))
            return out222;
        } catch (e) {
        }
        out222 = parseObjectKeysAndValues3(x2);
        if (out222) {
          try {
            return convertObjectToTypedArray3(out222);
          } catch (e) {
            return out222;
          }
        }
        return x2;
      }
      return x2;
    }
    return helper522(x);
  }
  function pascalify3(text) {
    const out222 = camelify23(text);
    return out222[0].toUpperCase() + out222.slice(1);
  }
  function snakeify3(text) {
    if (typeof text !== "string") {
      throw new Error("`text` must be a string!");
    }
    const words = strip3(text).split(" ");
    if (words.length === 0)
      return "";
    if (words.length === 1)
      return words[0];
    return words.join("_");
  }
  function prefix3(s222, n) {
    if (!s222 || n <= 0)
      return "";
    return range23(0, n).map(() => s222).join("");
  }
  function stringify3(x, indent22) {
    assert23(isString23(indent22) || isUndefined23(indent22), "The second parameter to the `stringify` function must be undefined or a string!");
    const newline = indent22 ? "\n" : "";
    function helper522(x2, indent32, depth) {
      depth = depth || 0;
      if (typeof x2 === "bigint") {
        return JSON.stringify(x2.toString() + "n");
      }
      if (typeof x2 === "number") {
        if (x2 === Infinity) {
          return '"Symbol(@Infinity)"';
        }
        if (x2 === -Infinity) {
          return '"Symbol(@NegativeInfinity)"';
        }
        if (isNaN(x2)) {
          return '"Symbol(@NaN)"';
        }
        return x2.toString();
      }
      if (typeof x2 === "string") {
        return JSON.stringify("Symbol(@String):" + x2);
      }
      if (typeof x2 === "boolean") {
        return x2.toString();
      }
      if (typeof x2 === "undefined") {
        return '"Symbol(@undefined)"';
      }
      if (typeof x2 === "symbol") {
        return JSON.stringify(x2.toString());
      }
      if (typeof x2 === "function") {
        return JSON.stringify(x2.toString());
      }
      if (x2 instanceof RegExp) {
        return x2.toString();
      }
      if (typeof x2 === "object") {
        if (x2 === null) {
          return "null";
        }
        if (isDate23(x2)) {
          return JSON.stringify(x2.toJSON());
        }
        if (isArray23(x2)) {
          if (x2.length === 0) {
            return prefix3(indent32, depth - 1) + "[]";
          }
          if (!(x2 instanceof Array)) {
            return helper522(convertTypedArrayToObject3(x2), null, indent32);
          }
          return prefix3(indent32, depth - 1) + "[" + newline + x2.map((v) => {
            let child = (() => {
              try {
                return helper522(convertTypedArrayToObject3(v), indent32, depth + 1);
              } catch (e) {
                return helper522(v, indent32, depth + 1);
              }
            })();
            if (isString23(child))
              child = child.trim();
            return prefix3(indent32, depth + 1) + child;
          }).join("," + newline) + newline + prefix3(indent32, depth) + "]";
        }
        if (Object.keys(x2).length + Object.getOwnPropertySymbols(x2).length === 0) {
          return prefix3(indent32, depth - 1) + "{}";
        }
        return prefix3(indent32, depth - 1) + "{" + newline + Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).map((key) => {
          let child = (() => {
            try {
              return helper522(convertTypedArrayToObject3(x2[key]), indent32, depth + 1);
            } catch (e) {
              return helper522(x2[key], indent32, depth + 1);
            }
          })();
          if (isString23(child))
            child = child.trim();
          const stringifiedKey = typeof key === "symbol" ? helper522(key) : JSON.stringify(key);
          return prefix3(indent32, depth + 1) + stringifiedKey + ":" + (indent32 ? " " : "") + child;
        }).join("," + newline) + newline + prefix3(indent32, depth) + "}";
      }
      return "undefined";
    }
    return helper522(decycle23(x), indent22);
  }
  function unindent3(text) {
    const lines = text.split("\n");
    const indentations = lines.filter((line) => line.trim().length > 0).map((line) => line.split("").findIndex((char) => !char.match(/\s/g)));
    const minIndentation = Math.min(...indentations);
    return lines.map((line) => line.substring(minIndentation)).join("\n");
  }
  function wrap3(raw, maxLineLength) {
    if (typeof raw !== "string") {
      throw new Error("The first argument to the `wrap` function must be a string!");
    }
    if (typeof maxLineLength === "undefined" || maxLineLength === null) {
      if (typeof process !== "undefined" && typeof process.stdout !== "undefined" && typeof process.stdout.columns === "number") {
        maxLineLength = process.stdout.columns > 80 ? 80 : process.stdout.columns;
      } else {
        maxLineLength = 80;
      }
    }
    if (isNaN(maxLineLength) || typeof maxLineLength !== "number") {
      throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");
    }
    const out222 = [];
    raw.split("\n").forEach((line) => {
      if (line.trim().length === 0) {
        return out222.push("");
      }
      const indentation = line.split(/[^\s]/g)[0];
      const words = line.replace(indentation, "").split(" ");
      let temp = indentation;
      words.forEach((word) => {
        const newLine = temp + (temp.trim().length > 0 ? " " : "") + word;
        if (newLine.length > maxLineLength) {
          out222.push(temp);
          temp = indentation + word;
        } else {
          temp = newLine;
        }
      });
      if (temp.length > 0) {
        out222.push(temp);
      }
    });
    return out222.join("\n");
  }
  if (typeof window !== "undefined") {
    window.JSTextTools = {
      camelify: camelify23,
      convertObjectToTypedArray: convertObjectToTypedArray3,
      convertTypedArrayToObject: convertTypedArrayToObject3,
      indent: indent3,
      isANumberString: isANumberString3,
      kebabify: kebabify3,
      parse: parse3,
      pascalify: pascalify3,
      punctuation: punctuation3,
      replaceAll: replaceAll3,
      snakeify: snakeify3,
      stringify: stringify3,
      strip: strip3,
      unindent: unindent3,
      wrap: wrap3
    };
  }
  function base64Decode(x) {
    if (!isString4(x)) {
      throw new Error(
        "The value passed into the `base64Decode` must be a string!"
      );
    }
    try {
      let out32 = decodeURIComponent(atob(x));
      let last = out32;
      let isStillParsing = true;
      while (isStillParsing) {
        try {
          out32 = parse3(out32);
          if (isEqual4(out32, last)) {
            isStillParsing = false;
          }
          last = out32;
        } catch (e) {
          isStillParsing = false;
        }
      }
      return out32;
    } catch (e) {
      throw new Base64DecodingError(e.toString());
    }
  }
  function base64Encode(x) {
    if (!isString4(x)) {
      x = stringify3(x);
    }
    return btoa(encodeURIComponent(x));
  }
  function isNaturalNumber32(x) {
    return isNumber4(x) && x > 0 && parseInt(x) === x;
  }
  async function decrypt(data, password, options) {
    options = options || {};
    const keyIterations = options.keyIterations || 21e4;
    if (!isString4(data)) {
      throw new Error(
        "The first argument passed into the `decrypt` function must be a string (i.e., the same string returned from the `encrypt` function)!"
      );
    }
    if (!isString4(password) || password.length === 0) {
      throw new Error(
        "The second argument passed into the `decrypt` function must be a string representing the password with which to decrypt the encrypted data."
      );
    }
    if (!isNaturalNumber32(keyIterations)) {
      throw new Error(
        "The 'keyIterations' option passed into the `decrypt` function must be undefined or a natural number (i.e., a positive integer) representing the number of iterations used during the key derivation. NOTE: For decryption to be successful, this number must match the number of iterations that was used during the encryption of the data."
      );
    }
    data = parse3(base64Decode(data));
    let { iv, salt, value } = data;
    if (!iv || !salt || !value) {
      throw new Error(
        "The first argument passed into the `decrypt` function must be an object with properties 'iv', 'salt', and 'value' (i.e., the same object returned from the `encrypt` function)!"
      );
    }
    let out32, key;
    try {
      const keyMaterial = await crypto.subtle.importKey(
        "raw",
        new TextEncoder().encode(password),
        "PBKDF2",
        false,
        ["deriveBits", "deriveKey"]
      );
      key = await crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt,
          iterations: keyIterations,
          hash: "SHA-512"
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
    } catch (e) {
      throw new DecryptionError(e.toString());
    }
    try {
      out32 = new TextDecoder().decode(
        await crypto.subtle.decrypt({ name: "AES-GCM", iv }, key, value)
      );
    } catch (e) {
      throw new DecryptionError("Invalid password!");
    }
    try {
      return parse3(out32);
    } catch (e) {
      return out32;
    }
  }
  async function encrypt(data, password, options) {
    options = options || {};
    const saltLength = options.saltLength || 32;
    const ivLength = options.ivLength || 32;
    const keyIterations = options.keyIterations || 21e4;
    if (!isString4(password) && password.length > 0) {
      throw new Error(
        "The second argument passed into the `encrypt` function must be a string representing the password with which the data will be encrypted!"
      );
    }
    if (!isNaturalNumber32(saltLength)) {
      throw new Error(
        "The 'saltLength' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the length of the new salt to be generated."
      );
    }
    if (!isNaturalNumber32(ivLength)) {
      throw new Error(
        "The 'ivLength' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the length of the initialization vector to be generated."
      );
    }
    if (!isNaturalNumber32(keyIterations)) {
      throw new Error(
        "The 'keyIterations' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the number of iterations used during the key derivation."
      );
    }
    let out32, salt, iv;
    try {
      salt = crypto.getRandomValues(new Uint8Array(saltLength));
      const keyMaterial = await crypto.subtle.importKey(
        "raw",
        new TextEncoder().encode(password),
        "PBKDF2",
        false,
        ["deriveBits", "deriveKey"]
      );
      const key = await crypto.subtle.deriveKey(
        {
          name: "PBKDF2",
          salt,
          iterations: keyIterations,
          hash: "SHA-512"
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        true,
        ["encrypt", "decrypt"]
      );
      iv = crypto.getRandomValues(new Uint8Array(ivLength));
      out32 = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        key,
        new TextEncoder().encode(stringify3(data))
      );
    } catch (e) {
      throw new EncryptionError(e.toString());
    }
    return base64Encode(
      stringify3({
        salt,
        iv,
        value: out32
      })
    );
  }
  async function hash(x, salt) {
    if (isUndefined4(salt)) {
      salt = "";
    } else {
      if (!isString4(salt)) {
        throw new Error(
          "The second value passed into the `hash` function must be undefined or a string representing a salt to be added to the first value before hashing!"
        );
      }
    }
    if (!isString4(x)) {
      x = stringify3(x);
    }
    try {
      return Array.from(
        new Uint8Array(
          await crypto.subtle.digest(
            "SHA-512",
            new TextEncoder().encode(x + salt)
          )
        )
      ).map((b) => b.toString(16).padStart(2, "0")).join("");
    } catch (e) {
      throw new HashingError(e.toString());
    }
  }
  function randomString(n, charset) {
    if (isUndefined4(n)) {
      n = 256;
    } else {
      if (!isNaturalNumber32(n)) {
        throw new Error(
          "The first value passed into the `randomString` function must be undefined or a positive integer representing the length of the returned string! If no length is passed, then the default length will be 256."
        );
      }
    }
    if (isUndefined4(charset)) {
      charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
    } else {
      if (!isString4(charset) || charset.length <= 1) {
        throw new Error(
          "The second value passed into the `randomString` function must be undefined or a string representing the set of characters of which the returned string will be comprised! Note that a given character set must contain at least 2 characters in order to be secure. If the character set is undefined, then the default value is the lower- and upper-case Latin alphabet and the digits 0-9."
        );
      }
    }
    try {
      let out32 = "";
      for (let i = 0; i < n; i++) {
        const index = crypto.getRandomValues(new Uint32Array(1))[0] % charset.length;
        out32 += charset[index];
      }
      return out32;
    } catch (e) {
      throw new RandomStringGenerationError(e.toString());
    }
  }
  if (typeof window !== "undefined") {
    window.JSCryptoHelpers = {
      base64Decode,
      Base64DecodingError,
      base64Encode,
      Base64EncodingError,
      decrypt,
      DecryptionError,
      encrypt,
      EncryptionError,
      hash,
      HashingError,
      parse: parse3,
      randomString,
      RandomStringGenerationError,
      stringify: stringify3
    };
  }

  // node_modules/@jrc03c/make-key/dist/make-key.import.mjs
  var __defProp6 = Object.defineProperty;
  var __defNormalProp5 = (obj, key, value) => key in obj ? __defProp6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField5 = (obj, key, value) => {
    __defNormalProp5(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  function isNumber5(x) {
    return typeof x === "number" && !isNaN(x) || typeof x === "bigint";
  }
  var isBrowser6 = new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`);
  var MathError5 = class extends Error {
    constructor(message) {
      if (isBrowser6()) {
        super(message);
      } else {
        super("\n\n\x1B[31m" + message + "\n\x1B[0m");
      }
    }
  };
  function assert5(isTrue, message) {
    if (!isTrue)
      throw new MathError5(message);
  }
  var arrayTypes5 = [
    Array,
    ArrayBuffer,
    BigInt64Array,
    BigUint64Array,
    Float32Array,
    Float64Array,
    Int16Array,
    Int32Array,
    Int8Array,
    Uint16Array,
    Uint32Array,
    Uint8Array,
    Uint8ClampedArray
  ];
  function isUndefined5(x) {
    return x === null || typeof x === "undefined";
  }
  var typeStrings5 = arrayTypes5.map((s24) => s24.name);
  function isArray5(obj) {
    try {
      if (obj instanceof Array) {
        return true;
      }
      if (!isUndefined5(obj.constructor)) {
        return arrayTypes5.indexOf(obj.constructor) > -1 || typeStrings5.indexOf(obj.constructor.name) > -1;
      }
      return false;
    } catch (e) {
      return false;
    }
  }
  function isDataFrame5(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/dataframe");
    } catch (e) {
      return false;
    }
  }
  function isFunction5(fn) {
    return typeof fn === "function";
  }
  function isObject5(x) {
    return typeof x === "object" && !isUndefined5(x) && !isArray5(x);
  }
  function isSeries5(x) {
    try {
      return !!x._symbol && x._symbol === Symbol.for("@jrc03c/js-math-tools/series");
    } catch (e) {
      return false;
    }
  }
  function indexOf5(x, fn) {
    if (isDataFrame5(x)) {
      const index = indexOf5(x.values, fn);
      if (index.length > 0 && isNumber5(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      if (index.length > 1 && isNumber5(index[1]) && index[1] >= 0 && index[1] < x.columns.length) {
        index[1] = x.columns[index[1]];
      }
      return index;
    }
    if (isSeries5(x)) {
      const index = indexOf5(x.values, fn);
      if (index.length > 0 && isNumber5(index[0]) && index[0] >= 0 && index[0] < x.index.length) {
        index[0] = x.index[index[0]];
      }
      return index;
    }
    assert5(isObject5(x) || isArray5(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!");
    if (!isFunction5(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper54(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject5(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return [key];
          }
          const results = helper54(value, fn2, checked);
          if (results && results.length > 0) {
            return [key].concat(results);
          }
        }
      } else if (isArray5(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return [i];
          }
          const results = helper54(value, fn2, checked);
          if (results && results.length > 0) {
            return [i].concat(results);
          }
        }
      } else {
        if (fn2(x2)) {
          return [];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const paths = helper54(x, safeFn);
    if (paths && paths.length > 0) {
      return paths;
    } else {
      return null;
    }
  }
  function copy5(x) {
    function helper54(x2) {
      if (typeof x2 === "object") {
        if (x2 === null) {
          return null;
        }
        if (isArray5(x2)) {
          if (!(x2 instanceof Array)) {
            return x2.slice();
          }
          return x2.map((v) => copy5(v));
        }
        if (isSeries5(x2)) {
          const out32 = x2.copy();
          out32.values = copy5(out32.values);
          return out32;
        }
        if (isDataFrame5(x2)) {
          const out32 = x2.copy();
          out32.values = copy5(x2.values);
          return out32;
        }
        if (x2 instanceof Date) {
          return new Date(x2.getTime());
        }
        x2 = decycle5(x2);
        const out24 = {};
        Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
          out24[key] = copy5(x2[key]);
        });
        return out24;
      } else {
        return x2;
      }
    }
    return helper54(decycle5(x));
  }
  function decycle5(x) {
    function helper54(x2, checked, currentPath) {
      checked = checked || [];
      currentPath = currentPath || "";
      if (checked.indexOf(x2) > -1) {
        const parts = currentPath.split("/").slice(currentPath.startsWith("/") ? 1 : 0);
        const isANestedCopy = parts.some((v, i) => {
          const subParts = parts.slice(0, parts.length - i - 1);
          let temp = orig;
          subParts.forEach((part) => {
            temp = temp[part];
          });
          return temp === x2;
        });
        if (isANestedCopy) {
          const pathToCopy = orig === x2 ? "/" : "/" + indexOf5(orig, x2).join("/");
          return `<reference to "${pathToCopy}">`;
        }
      }
      if (typeof x2 === "object") {
        if (x2 === null)
          return null;
        checked.push(x2);
        if (isArray5(x2)) {
          if (typeof x2.constructor !== "undefined" && x2.constructor.name !== "Array") {
            return x2.slice();
          }
          return x2.map((v, i) => helper54(v, checked, currentPath + "/" + i));
        } else {
          Object.keys(x2).concat(Object.getOwnPropertySymbols(x2)).forEach((key) => {
            x2[key] = helper54(x2[key], checked, currentPath + "/" + key.toString());
          });
          return x2;
        }
      } else {
        return x2;
      }
    }
    const orig = x;
    let out24 = helper54(orig);
    if (isDataFrame5(x)) {
      const temp = x.copy();
      temp._values = out24.values;
      temp._columns = out24.columns;
      temp._index = out24.index;
      out24 = temp;
    }
    if (isSeries5(x)) {
      const temp = x.copy();
      temp.name = out24.name;
      temp._values = out24.values;
      temp._index = out24.index;
      out24 = temp;
    }
    return out24;
  }
  function isDate5(x) {
    return x instanceof Date && x.toString() !== "Invalid Date";
  }
  var numberTypes5 = ["number", "int", "float", "bigint"];
  function isEqual5(a, b) {
    function helper54(a2, b2) {
      const aType = typeof a2;
      const bType = typeof b2;
      if (aType !== bType && !numberTypes5.includes(aType) && !numberTypes5.includes(bType))
        return false;
      if (aType === "undefined" && bType === "undefined")
        return true;
      if (aType === "boolean")
        return a2 === b2;
      if (aType === "symbol")
        return a2 === b2;
      if (aType === "number" || aType === "bigint") {
        try {
          const aString = a2.toString();
          const bString = b2.toString();
          return aString === bString;
        } catch (e) {
          return false;
        }
      }
      if (aType === "string")
        return a2 === b2;
      if (aType === "function")
        return a2 === b2;
      if (aType === "object") {
        if (a2 === null || b2 === null) {
          return a2 === null && b2 === null;
        } else {
          if (isDate5(a2)) {
            if (isDate5(b2)) {
              return a2.getTime() === b2.getTime();
            } else {
              return false;
            }
          } else if (isDate5(b2)) {
            return false;
          }
          if (a2 instanceof RegExp && b2 instanceof RegExp) {
            return a2.toString() === b2.toString();
          }
          if (isArray5(a2) !== isArray5(b2)) {
            return false;
          }
          const aKeys = Object.keys(a2).concat(Object.getOwnPropertySymbols(a2));
          const bKeys = Object.keys(b2).concat(Object.getOwnPropertySymbols(b2));
          if (aKeys.length !== bKeys.length)
            return false;
          for (let i = 0; i < aKeys.length; i++) {
            const key = aKeys[i];
            if (!helper54(a2[key], b2[key]))
              return false;
          }
          return true;
        }
      }
    }
    try {
      return helper54(a, b);
    } catch (e) {
      return helper54(decycle5(a), decycle5(b));
    }
  }
  function makeKey7(n) {
    const alpha = "abcdefg1234567890";
    let out24 = "";
    while (out24.length < n)
      out24 += alpha[Math.floor(Math.random() * alpha.length)];
    return out24;
  }
  var NULL_KEY6 = makeKey7(16);
  var UNDEFINED_KEY6 = makeKey7(16);
  var INFINITY_KEY6 = makeKey7(16);
  var MINUS_INFINITY_KEY6 = makeKey7(16);
  var SYMBOL_KEY6 = makeKey7(16);
  var Counter5 = class {
    constructor() {
      this.clear();
    }
    get counts() {
      return this.values.map((v) => this.get(v));
    }
    get values() {
      return Object.values(this.valuesDict);
    }
    clear() {
      this.countsDict = {};
      this.valuesDict = {};
      return this;
    }
    count(x) {
      for (const v of x) {
        if (isArray5(v)) {
          this.count(v);
        } else {
          this.increment(v);
        }
      }
      return this;
    }
    delete(value) {
      const key = this.getStandardizedKey(value);
      delete this.countsDict[key];
      delete this.valuesDict[key];
      return this;
    }
    get(value) {
      return this.countsDict[this.getStandardizedKey(value)] || 0;
    }
    getStandardizedKey(value) {
      return typeof value === "object" && value === null ? NULL_KEY6 : isUndefined5(value) ? UNDEFINED_KEY6 : isFunction5(value) ? value.toString() : typeof value === "symbol" ? value.toString() + " - " + SYMBOL_KEY6 : value === Infinity ? INFINITY_KEY6 : value === -Infinity ? MINUS_INFINITY_KEY6 : typeof value === "bigint" ? value.toString() : isDataFrame5(value) ? value.toJSONString() : isSeries5(value) ? JSON.stringify(value.toObject()) : JSON.stringify(value);
    }
    has(value) {
      return !isUndefined5(this.countsDict[this.getStandardizedKey(value)]);
    }
    increment(value) {
      return this.set(value, this.get(value) + 1);
    }
    set(value, count24) {
      const key = this.getStandardizedKey(value);
      this.countsDict[key] = count24;
      this.valuesDict[key] = value;
      return this;
    }
    toArray() {
      return this.values.map((v) => ({ value: v, count: this.get(v) }));
    }
    toObject() {
      const out24 = {};
      this.values.forEach((value) => {
        out24[value] = this.get(value);
      });
      return out24;
    }
  };
  function flatten5(arr) {
    if (isDataFrame5(arr) || isSeries5(arr)) {
      return flatten5(arr.values);
    }
    assert5(isArray5(arr), "The `flatten` function only works on arrays, Series, and DataFrames!");
    function helper54(arr2) {
      let out24 = [];
      arr2.forEach((child) => {
        if (isArray5(child)) {
          out24 = out24.concat(helper54(child));
        } else {
          out24.push(child);
        }
      });
      return out24;
    }
    return helper54(arr);
  }
  function stats5(x, options) {
    options = options || {};
    const counts = new Counter5();
    const out24 = {};
    const xflat = flatten5(x);
    const xnums = [];
    let max24 = -Infinity;
    let min24 = Infinity;
    let resultsShouldIncludeBigInts = false;
    let sum24 = 0;
    for (const v of xflat) {
      if (typeof v === "bigint") {
        resultsShouldIncludeBigInts = true;
      }
      if (!options.shouldDropNaNs || isNumber5(v)) {
        try {
          if (v > max24) {
            max24 = v;
          }
          if (v < min24) {
            min24 = v;
          }
          sum24 += Number(v);
          xnums.push(v);
        } catch (e) {
          max24 = NaN;
          min24 = NaN;
          sum24 = NaN;
        }
      }
      counts.increment(v);
    }
    const mean24 = sum24 / xnums.length;
    out24.counts = counts;
    out24.max = max24;
    out24.mean = mean24;
    out24.min = min24;
    out24.n = xflat.length;
    out24.sum = sum24;
    if (isNaN(out24.mean)) {
      out24.max = NaN;
      out24.min = NaN;
    }
    if (options.shouldDropNaNs) {
      out24.nWithoutNaNs = xnums.length;
    }
    if (options.mode) {
      const sortedCountPairs = Array.from(counts.values.map((v) => [v, counts.get(v)])).toSorted((a, b) => b[1] - a[1]);
      const highestCount = sortedCountPairs[0][1];
      const mode24 = [];
      for (const pair of sortedCountPairs) {
        if (pair[1] == highestCount) {
          mode24.push(pair[0]);
        } else {
          break;
        }
      }
      out24.mode = mode24.toSorted();
    }
    if (options.median) {
      if (isNaN(mean24)) {
        out24.median = NaN;
      } else {
        const xnumsSorted = xnums.toSorted((a, b) => Number(a) - Number(b));
        const middle = Math.floor(xnumsSorted.length / 2);
        if (xnumsSorted.length % 2 === 0) {
          const left = xnumsSorted[middle - 1];
          const right = xnumsSorted[middle];
          out24.median = (Number(left) + Number(right)) / 2;
          if (resultsShouldIncludeBigInts && typeof left === "bigint" && typeof right === "bigint") {
            try {
              out24.median = BigInt(out24.median);
            } catch (e) {
            }
          }
        } else {
          out24.median = xnumsSorted[middle];
        }
      }
    }
    if (options.stdev || options.variance) {
      let variance24 = 0;
      for (const v of xnums) {
        variance24 += Math.pow(Number(v) - mean24, 2);
      }
      variance24 /= xnums.length;
      const stdev24 = Math.sqrt(variance24);
      out24.stdev = stdev24;
      out24.variance = variance24;
    }
    if (resultsShouldIncludeBigInts) {
      try {
        out24.sum = BigInt(out24.sum);
      } catch (e) {
      }
      try {
        out24.mean = BigInt(out24.mean);
      } catch (e) {
      }
      if (options.mode) {
        out24.mode = out24.mode.map((v) => {
          try {
            return BigInt(v);
          } catch (e) {
            return v;
          }
        });
      }
    }
    return out24;
  }
  function count5(arr, matcher) {
    const { counts } = stats5(arr);
    if (!isUndefined5(matcher)) {
      if (isFunction5(matcher)) {
        counts.values.forEach((v) => {
          if (!matcher(v)) {
            counts.delete(v);
          }
        });
      } else {
        counts.values.forEach((v) => {
          if (!isEqual5(v, matcher)) {
            counts.delete(v);
          }
        });
      }
    }
    return counts;
  }
  function helper8(x) {
    if (isDataFrame5(x) || isSeries5(x)) {
      return helper8(x.values);
    }
    if (isArray5(x)) {
      let hasArrayValues = false;
      let hasNonArrayValues = false;
      let arrayLength = null;
      for (const v of x) {
        if (helper8(v)) {
          return true;
        }
        if (isArray5(v)) {
          if (arrayLength === null) {
            arrayLength = v.length;
          } else if (v.length !== arrayLength) {
            return true;
          }
          hasArrayValues = true;
        } else {
          hasNonArrayValues = true;
        }
        if (hasArrayValues && hasNonArrayValues) {
          return true;
        }
      }
    }
    return false;
  }
  function isJagged5(x) {
    return helper8(decycle5(x));
  }
  function isNested5(x) {
    if (isDataFrame5(x) || isSeries5(x)) {
      return isNested5(x.values);
    }
    assert5(isArray5(x), "The `isNested` function only works on arrays, Series, and DataFrames!");
    for (let i = 0; i < x.length; i++) {
      if (isArray5(x[i])) {
        return true;
      }
    }
    return false;
  }
  var error5 = "You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";
  function ndarray5(shape24) {
    assert5(!isUndefined5(shape24), error5);
    if (!isArray5(shape24))
      shape24 = [shape24];
    assert5(!isNested5(shape24), error5);
    assert5(shape24.length > 0, error5);
    let s24 = shape24[0];
    if (typeof s24 === "bigint")
      s24 = Number(s24);
    assert5(isNumber5(s24), error5);
    assert5(s24 >= 0, error5);
    assert5(Math.floor(s24) === s24, error5);
    assert5(s24 !== Infinity, "We can't create an array containing an infinite number of values!");
    if (shape24.length === 1) {
      const out24 = [];
      for (let i = 0; i < s24; i++)
        out24.push(void 0);
      return out24;
    } else {
      const out24 = [];
      for (let i = 0; i < s24; i++) {
        out24.push(ndarray5(shape24.slice(1)));
      }
      return out24;
    }
  }
  function reverse5(arr) {
    if (isDataFrame5(arr) || isSeries5(arr)) {
      const out32 = arr.copy();
      out32.values = reverse5(out32.values);
      out32.index = reverse5(out32.index);
      return out32;
    }
    assert5(isArray5(arr), "The `reverse` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    for (let i = arr.length - 1; i >= 0; i--)
      out24.push(arr[i]);
    return out24;
  }
  function range5(a, b, step = 1) {
    assert5(!isUndefined5(a) && !isUndefined5(b) && !isUndefined5(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert5(isNumber5(a) && isNumber5(b) && isNumber5(step), "You must pass two numbers and optionally a step value to the `range` function!");
    assert5(step > 0, "The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");
    let shouldReverse = false;
    const shouldIncludeBigInts = typeof a === "bigint" || typeof b === "bigint" || typeof step === "bigint";
    a = Number(a);
    b = Number(b);
    step = Number(step);
    if (a > b) {
      shouldReverse = true;
      const buffer = a;
      a = b + step;
      b = buffer + step;
    }
    let out24 = [];
    for (let i = a; i < b; i += step) {
      if (shouldIncludeBigInts) {
        try {
          out24.push(BigInt(i));
        } catch (e) {
          out24.push(i);
        }
      } else {
        out24.push(i);
      }
    }
    if (shouldReverse)
      out24 = reverse5(out24);
    return out24;
  }
  function makeKey25(n) {
    const alpha = "abcdefg1234567890";
    let out24 = "";
    while (out24.length < n)
      out24 += alpha[Math.floor(Math.random() * alpha.length)];
    return out24;
  }
  var NULL_KEY25 = makeKey25(256);
  var UNDEFINED_KEY25 = makeKey25(256);
  var INFINITY_KEY25 = makeKey25(256);
  var MINUS_INFINITY_KEY25 = makeKey25(256);
  var SYMBOL_KEY25 = makeKey25(256);
  function set5(arr) {
    if (isDataFrame5(arr) || isSeries5(arr)) {
      return set5(arr.values);
    }
    assert5(isArray5(arr), "The `set` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    const temp = {};
    flatten5(arr).forEach((item) => {
      const key = typeof item === "object" && item === null ? NULL_KEY25 : isUndefined5(item) ? UNDEFINED_KEY25 : isFunction5(item) ? item.toString() : typeof item === "symbol" ? item.toString() + " - " + SYMBOL_KEY25 : item === Infinity ? INFINITY_KEY25 : item === -Infinity ? MINUS_INFINITY_KEY25 : typeof item === "bigint" ? item.toString() : isDataFrame5(item) ? item.toJSONString() : isSeries5(item) ? JSON.stringify(item.toObject()) : JSON.stringify(item);
      if (!temp[key])
        out24.push(item);
      temp[key] = true;
    });
    return out24;
  }
  function helper25(x) {
    if (isArray5(x)) {
      const childShapes = helper25(x[0]);
      return [x.length].concat(childShapes || []);
    } else {
      return void 0;
    }
  }
  function shape5(x) {
    if (isDataFrame5(x) || isSeries5(x)) {
      return shape5(x.values);
    }
    assert5(isArray5(x), "The `shape` function only works on arrays, Series, and DataFrames!");
    return helper25(x);
  }
  function dfAppend5(df, x, axis) {
    if (isUndefined5(axis)) {
      axis = 0;
    }
    assert5(axis === 0 || axis === 1 || axis === "vertical" || axis === "horizontal", 'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".');
    if (isArray5(x)) {
      assert5(!isJagged5(x), "The array of data you're trying to append to this DataFrame is jagged!");
      const xShape = shape5(x);
      if (xShape.length === 1) {
        if (axis === 0) {
          const out24 = df.copy();
          out24._values.push(x);
          const maxRowLength = Math.max(df.shape[1], xShape[0]);
          out24._values.forEach((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        } else {
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out24 = df.copy();
          range5(0, maxColLength).forEach((i) => {
            if (i >= out24._values.length) {
              out24._values.push(ndarray5(df.shape[1]));
            }
            out24._values[i].push(x[i]);
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < out24._values[0].length) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        }
      } else if (xShape.length === 2) {
        if (axis === 0) {
          const maxRowLength = Math.max(...x.map((row) => row.length).concat([df.shape[1]]));
          const out24 = df.copy();
          out24._values = out24._values.concat(x).map((row) => {
            while (row.length < maxRowLength) {
              row.push(void 0);
            }
            return row;
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        } else {
          const maxRowLength = Math.max(...x.map((row) => row.length)) + df.shape[1];
          const maxColLength = Math.max(df.shape[0], xShape[0]);
          const out24 = df.copy();
          range5(0, maxColLength).forEach((i) => {
            if (i >= out24._values.length) {
              out24._values.push(ndarray5(df.shape[1]));
            }
            out24._values[i] = out24._values[i].concat(x[i]);
            while (out24._values[i].length < maxRowLength) {
              out24._values[i].push(void 0);
            }
          });
          while (out24._index.length < out24._values.length) {
            out24._index.push("row" + out24._index.length);
          }
          while (out24._columns.length < maxRowLength) {
            out24._columns.push("col" + out24._columns.length);
          }
          return out24;
        }
      } else {
        throw new MathError5("Only 1- and 2-dimensional arrays can be appended to a DataFrame!");
      }
    } else if (isSeries5(x)) {
      const out24 = dfAppend5(df, x.values, axis);
      if (axis === 0) {
        out24.index[out24.index.length - 1] = out24.index.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      } else {
        out24.columns[out24.columns.length - 1] = out24.columns.indexOf(x.name) > -1 ? x.name + " (2)" : x.name;
      }
      return out24;
    } else if (isDataFrame5(x)) {
      if (axis === 0) {
        const out24 = df.copy();
        const maxRowLength = set5(out24._columns.concat(x._columns)).length;
        out24._values.forEach((row) => {
          while (row.length < maxRowLength) {
            row.push(void 0);
          }
        });
        x.apply((row) => {
          const rowCopy = row.copy();
          const temp = [];
          out24._columns.forEach((col) => {
            const index = rowCopy._index.indexOf(col);
            if (index > -1) {
              temp.push(rowCopy._values[index]);
              rowCopy._values.splice(index, 1);
              rowCopy._index.splice(index, 1);
            } else {
              temp.push(void 0);
            }
          });
          out24._values.push(temp.concat(rowCopy._values));
        }, 1);
        out24._columns = out24._columns.concat(x._columns.filter((c) => out24._columns.indexOf(c) < 0));
        while (out24._index.length < out24._values.length) {
          const newRowName = "row" + out24._index.length;
          out24._index.push(newRowName + (df._index.indexOf(newRowName) > -1 ? " (2)" : ""));
        }
        return out24;
      } else {
        const out24 = df.copy();
        out24._index.forEach((rowName, i) => {
          const xIndex = x._index.indexOf(rowName);
          if (xIndex > -1) {
            out24._values[i] = out24._values[i].concat(x._values[xIndex]);
          } else {
            out24._values[i] = out24._values[i].concat(ndarray5(x.shape[1]));
          }
        });
        x._index.forEach((rowName, i) => {
          const outIndex = out24._index.indexOf(rowName);
          if (outIndex < 0) {
            out24._index.push(rowName);
            out24._values.push(ndarray5(out24._columns.length).concat(x._values[i]));
          }
        });
        out24._columns = out24._columns.concat(x._columns.map((c) => c + (out24._columns.indexOf(c) > -1 ? " (2)" : "")));
        return out24;
      }
    } else {
      throw new MathError5("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!");
    }
  }
  function dfApply5(DataFrame24, Series24, df, fn, axis) {
    axis = axis || 0;
    assert5(isFunction5(fn), "The first parameter to the `apply` method must be a function.");
    assert5(axis === 0 || axis === 1, "The second parameter to the `apply` method (the `axis`) must be 0 or 1.");
    if (axis === 0) {
      const temp = {};
      let shouldReturnADataFrame;
      df.columns.forEach((colName, i) => {
        const series = new Series24(df.values.map((row) => row[i]));
        series.name = colName;
        series.index = df.index;
        const value = fn(series, i, df);
        if (value instanceof Series24) {
          temp[colName] = value.values;
        } else {
          temp[colName] = value;
        }
        if (isUndefined5(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series24 || isArray5(value);
        }
      });
      if (shouldReturnADataFrame) {
        const out24 = new DataFrame24(temp);
        out24.index = df.index;
        return out24;
      } else {
        const out24 = new Series24(df.columns.map((colName) => temp[colName]));
        out24.index = df.columns;
        return out24;
      }
    } else if (axis === 1) {
      let shouldReturnADataFrame;
      const temp = df.values.map((row, i) => {
        const series = new Series24(row);
        series.name = df.index[i];
        series.index = df.columns;
        const value = fn(series, i, df);
        if (isUndefined5(shouldReturnADataFrame)) {
          shouldReturnADataFrame = value instanceof Series24 || isArray5(value);
        }
        if (value instanceof Series24) {
          return value.values;
        } else {
          return value;
        }
      });
      if (shouldReturnADataFrame) {
        const out24 = new DataFrame24(temp);
        out24.index = df.index;
        out24.columns = df.columns;
        return out24;
      } else {
        const out24 = new Series24(temp);
        out24.index = df.index;
        return out24;
      }
    }
  }
  function isString5(s24) {
    return typeof s24 === "string";
  }
  function dfAssign5(DataFrame24, Series24, df, p1, p2) {
    const isDataFrame24 = (x) => x instanceof DataFrame24;
    const isSeries24 = (x) => x instanceof Series24;
    if (!isUndefined5(p2)) {
      assert5(isString5(p1), "If passing two arguments into the `assign` method, then the first argument must be a string name!");
      assert5(isArray5(p2) && !isJagged5(p2) && shape5(p2).length === 1, "If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");
      const out24 = df.append(p2, 1);
      out24.columns[out24.columns.length - 1] = p1;
      return out24;
    } else {
      if (isDataFrame24(p1)) {
        return df.append(p1, 1);
      } else if (isSeries24(p1)) {
        return df.append(p1, 1);
      } else if (isObject5(p1)) {
        const maxColumnLength = Math.max(...Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).map((key) => p1[key].length));
        Object.keys(p1).concat(Object.getOwnPropertySymbols(p1)).forEach((key) => {
          while (p1[key].length < maxColumnLength) {
            p1[key].push(void 0);
          }
        });
        return df.append(new DataFrame24(p1), 1);
      } else {
        throw new MathError5("You must pass a DataFrame, Series, or object into the `assign` method!");
      }
    }
  }
  function dfCopy5(DataFrame24, df) {
    if (df.isEmpty)
      return new DataFrame24();
    const out24 = new DataFrame24(copy5(df.values));
    out24.columns = df.columns.slice();
    out24.index = df.index.slice();
    return out24;
  }
  function dfDrop5(DataFrame24, Series24, df, rows, cols) {
    if (isUndefined5(rows))
      rows = [];
    if (isUndefined5(cols))
      cols = [];
    if (isString5(rows) || isNumber5(rows))
      rows = [rows];
    if (isString5(cols) || isNumber5(cols))
      cols = [cols];
    assert5(isArray5(rows), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert5(isArray5(cols), "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert5(shape5(rows).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    assert5(shape5(cols).length === 1, "The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");
    let outIndex, outColumns;
    df.index.forEach((row, i) => {
      if (rows.indexOf(row) < 0 && rows.indexOf(i) < 0) {
        if (!outIndex)
          outIndex = [];
        outIndex.push(row);
      }
    });
    df.columns.forEach((col, i) => {
      if (cols.indexOf(col) < 0 && cols.indexOf(i) < 0) {
        if (!outColumns)
          outColumns = [];
        outColumns.push(col);
      }
    });
    let out24 = df.get(outIndex, outColumns);
    if (out24 instanceof Series24) {
      let temp = new DataFrame24();
      temp = temp.assign(out24);
      if (df.index.indexOf(out24.name) > -1)
        temp = temp.transpose();
      out24 = temp;
    }
    return out24;
  }
  function isInteger5(x) {
    return isNumber5(x) && (x >= 0 ? Math.floor(x) === x : Math.ceil(x) === x);
  }
  function isWholeNumber6(x) {
    return isInteger5(x) && x >= 0;
  }
  function dfDropMissing5(DataFrame24, Series24, df, axis, condition, threshold) {
    axis = axis || 0;
    assert5(axis === 0 || axis === 1, "The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert5(isWholeNumber6(threshold), "The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert5(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");
    function helper54(values) {
      if (threshold > 0) {
        let count24 = 0;
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined5(value))
            count24++;
          if (count24 >= threshold)
            return [];
        }
      } else if (condition === "any") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (isUndefined5(value))
            return [];
        }
      } else if (condition === "all") {
        for (let i = 0; i < values.length; i++) {
          const value = values[i];
          if (!isUndefined5(value))
            return values;
        }
        return [];
      }
      return values;
    }
    let out24 = df.copy();
    const tempID = Math.random().toString();
    if (axis === 0) {
      out24 = out24.assign(tempID, out24.index);
      const newValues = out24.values.map(helper54).filter((row) => row.length > 0);
      if (shape5(newValues).length < 2)
        return new DataFrame24();
      out24.values = newValues;
      let newIndex = out24.get(null, tempID);
      if (isUndefined5(newIndex))
        return new DataFrame24();
      if (isString5(newIndex))
        newIndex = [newIndex];
      if (newIndex instanceof Series24)
        newIndex = newIndex.values;
      out24.index = newIndex;
      out24 = out24.drop(null, tempID);
    } else if (axis === 1) {
      const temp = {};
      out24.columns.forEach((colName, i) => {
        const values = out24.values.map((row) => row[i]);
        const newValues = helper54(values);
        if (newValues.length > 0) {
          temp[colName] = newValues;
        }
      });
      if (Object.keys(temp).length + Object.getOwnPropertySymbols(temp).length === 0) {
        return new DataFrame24();
      }
      const newOut = new DataFrame24(temp);
      newOut.index = out24.index;
      return newOut;
    }
    return out24;
  }
  function dropNaN5(x) {
    if (isDataFrame5(x) || isSeries5(x)) {
      return x.dropNaN(...Object.values(arguments).slice(1));
    }
    assert5(isArray5(x), "The `dropNaN` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    x.forEach((v) => {
      try {
        return out24.push(dropNaN5(v));
      } catch (e) {
        if (isNumber5(v)) {
          return out24.push(v);
        }
      }
    });
    return out24;
  }
  function dfDropNaN5(DataFrame24, df, axis, condition, threshold) {
    axis = axis || 0;
    assert5(axis === 0 || axis === 1, "The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1.");
    threshold = threshold || 0;
    assert5(isWholeNumber6(threshold), "The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values).");
    condition = threshold > 0 ? "none" : condition || "any";
    assert5(condition === "any" || condition === "all" || condition === "none", "The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");
    function helper54(values) {
      const numericalValues = dropNaN5(values);
      if (threshold > 0)
        return values.length - numericalValues.length < threshold;
      if (condition === "any")
        return numericalValues.length === values.length;
      if (condition === "all")
        return numericalValues.length > 0;
      return true;
    }
    const out24 = df.copy();
    if (axis === 0) {
      const rowsToKeep = out24.index.filter((row) => {
        const values = out24.get(row, null).values;
        return helper54(values);
      });
      if (rowsToKeep.length > 0)
        return out24.get(rowsToKeep, null);
      else
        return new DataFrame24();
    } else if (axis === 1) {
      const colsToKeep = out24.columns.filter((col) => {
        const values = out24.get(null, col).values;
        return helper54(values);
      });
      if (colsToKeep.length > 0)
        return out24.get(null, colsToKeep);
      else
        return new DataFrame24();
    }
    return out24;
  }
  function arrayToObject5(x) {
    const out24 = {};
    flatten5(x).forEach((value, i) => {
      out24[value] = i;
    });
    return out24;
  }
  function undoArrayToObject5(obj) {
    return Object.keys(obj).concat(Object.getOwnPropertySymbols(obj)).sort((a, b) => obj[a] - obj[b]);
  }
  function dfFilter5(DataFrame24, Series24, df, fn, axis) {
    assert5(isFunction5(fn), "The `filter` method takes a single parameter: a function that is used to filter the values.");
    if (isUndefined5(axis))
      axis = 0;
    assert5(axis === 0 || axis === 1, "The `axis` parameter to the `filter` method must be 0 or 1.");
    let out24 = df.copy();
    if (out24.isEmpty)
      return out24;
    const index = arrayToObject5(out24.index);
    const columns = arrayToObject5(out24.columns);
    if (axis === 0) {
      let count24 = 0;
      const newValues = out24.values.filter((row, i) => {
        const series = new Series24(row);
        series.name = df.index[i];
        series.index = df.columns;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count24++;
        } else {
          delete index[out24.index[i]];
        }
        return shouldKeep;
      });
      if (count24 === 0) {
        return new DataFrame24();
      }
      if (count24 === 1) {
        const temp = new Series24(newValues[0]);
        temp.name = undoArrayToObject5(index)[0];
        temp.index = undoArrayToObject5(columns);
        return temp;
      }
      out24.values = newValues;
      out24.index = undoArrayToObject5(index);
    } else if (axis === 1) {
      out24 = out24.transpose();
      let count24 = 0;
      const newValues = out24.values.filter((row, i) => {
        const series = new Series24(row);
        series.name = df.columns[i];
        series.index = df.index;
        const shouldKeep = fn(series, i, df);
        if (shouldKeep) {
          count24++;
        } else {
          delete columns[out24.index[i]];
        }
        return shouldKeep;
      });
      if (count24 === 0) {
        return new DataFrame24();
      }
      if (count24 === 1) {
        const temp = new Series24(newValues[0]);
        temp.name = undoArrayToObject5(columns)[0];
        temp.index = undoArrayToObject5(index);
        return temp;
      }
      out24.values = newValues;
      out24.index = undoArrayToObject5(columns);
      out24 = out24.transpose();
    }
    return out24;
  }
  function dfGet5(df, rows, cols) {
    if (isString5(rows) || isNumber5(rows))
      rows = [rows];
    if (isString5(cols) || isNumber5(cols))
      cols = [cols];
    for (const i in rows) {
      if (typeof rows[i] === "bigint") {
        rows[i] = Number(rows[i]);
      }
    }
    for (const i in cols) {
      if (typeof cols[i] === "bigint") {
        cols[i] = Number(cols[i]);
      }
    }
    const types = set5((rows || []).concat(cols || []).map((v) => typeof v));
    assert5(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert5(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert5(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert5(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined5(rows)) {
      rows = rows.map((r) => {
        if (isString5(r)) {
          assert5(df.index.indexOf(r) > -1, `Row "${r}" does not exist!`);
          return r;
        }
        if (isNumber5(r)) {
          assert5(r >= 0, `Index ${r} is out of bounds!`);
          assert5(Math.floor(r) === r, `Row numbers must be integers!`);
          assert5(r < df.index.length, `Index ${r} is out of bounds!`);
          return df.index[r];
        }
      });
    }
    if (!isUndefined5(cols)) {
      cols = cols.map((c) => {
        if (isString5(c)) {
          assert5(df.columns.indexOf(c) > -1, `Column "${c}" does not exist!`);
          return c;
        }
        if (isNumber5(c)) {
          assert5(c >= 0, `Column ${c} is out of bounds!`);
          assert5(Math.floor(c) === c, `Column numbers must be integers!`);
          assert5(c < df.columns.length, `Column ${c} is out of bounds!`);
          return df.columns[c];
        }
      });
    }
    return df.getSubsetByNames(rows, cols);
  }
  function alphaSort5(a, b) {
    try {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    } catch (e) {
      a = typeof a === "object" && a !== null ? JSON.stringify(a) : a.toString();
      b = typeof b === "object" && b !== null ? JSON.stringify(b) : b.toString();
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
  }
  function sort5(arr, fn) {
    if (isUndefined5(fn))
      fn = alphaSort5;
    if (isDataFrame5(arr) || isSeries5(arr)) {
      return arr.sort(...Object.values(arguments).slice(1));
    }
    assert5(isArray5(arr), "The `sort` function only works on arrays, Series, and DataFrames!");
    assert5(isFunction5(fn), "The second parameter of the `sort` function must be a comparison function!");
    const out24 = arr.slice();
    out24.sort(fn);
    return out24;
  }
  function camelify6(text) {
    const temp = text.toLowerCase();
    let out24 = "";
    for (let i = 0; i < temp.length; i++) {
      const char = temp[i];
      if (char.match(/[a-z0-9]/g)) {
        out24 += char;
      } else {
        out24 += " ";
      }
    }
    const words = out24.split(" ").filter((word) => word.length > 0);
    return words[0] + words.slice(1).map((word) => word[0].toUpperCase() + word.substring(1)).join("");
  }
  function dfGetDummies5(DataFrame24, df, columns) {
    if (isUndefined5(columns)) {
      columns = df.columns;
    } else if (isString5(columns)) {
      columns = [columns];
    }
    const temp = {};
    columns.forEach((col) => {
      assert5(isString5(col), "You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");
      const colIndex = df.columns.indexOf(col);
      assert5(colIndex > -1, `The given DataFrame does not have a column called "${col}"!`);
      const values = df.values.map((row) => row[colIndex]);
      const valuesSet = sort5(set5(values));
      values.forEach((value) => {
        valuesSet.forEach((orig) => {
          const colName = col + "_" + camelify6(orig.toString());
          if (!temp[colName]) {
            temp[colName] = [];
          }
          if (value === orig) {
            temp[colName].push(1);
          } else {
            temp[colName].push(0);
          }
        });
      });
    });
    const out24 = new DataFrame24(temp);
    out24.index = df.index;
    return out24;
  }
  function dfGetSubsetByIndices5(df, rowIndices, colIndices) {
    const dataShape = df.shape;
    if (isUndefined5(rowIndices))
      rowIndices = range5(0, dataShape[0]);
    if (isUndefined5(colIndices))
      colIndices = range5(0, dataShape[1]);
    if (isNumber5(rowIndices))
      rowIndices = [rowIndices];
    if (isNumber5(colIndices))
      colIndices = [colIndices];
    assert5(isArray5(rowIndices) && isArray5(colIndices), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert5(shape5(rowIndices).length === 1 && shape5(colIndices).length === 1, "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
    assert5(rowIndices.length > 0, "The `rowIndices` array must contain at least one index.");
    assert5(colIndices.length > 0, "The `colIndices` array must contain at least one index.");
    rowIndices.forEach((rowIndex) => {
      assert5(isWholeNumber6(rowIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert5(rowIndex < df.index.length, `The row index ${rowIndex} is out of bounds.`);
    });
    colIndices.forEach((colIndex) => {
      assert5(isWholeNumber6(colIndex), "The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers.");
      assert5(colIndex < df.columns.length, `The column index ${colIndex} is out of bounds.`);
    });
    const rows = rowIndices.map((i) => df.index[i]);
    const cols = colIndices.map((i) => df.columns[i]);
    return df.getSubsetByNames(rows, cols);
  }
  function dfGetSubsetByNames5(DataFrame24, Series24, df, rows, cols) {
    if (isUndefined5(rows))
      rows = df.index;
    if (isUndefined5(cols))
      cols = df.columns;
    if (isString5(rows))
      rows = [rows];
    if (isString5(cols))
      cols = [cols];
    assert5(isArray5(rows) && isArray5(cols), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert5(shape5(rows).length === 1 && shape5(cols).length === 1, "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
    assert5(rows.length > 0, "The `rows` array must contain at least one row name.");
    assert5(cols.length > 0, "The `cols` array must contain at least one column name.");
    rows.forEach((row) => {
      assert5(isString5(row), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert5(df.index.indexOf(row) > -1, `The row name "${row}" does not exist in the list of rows.`);
    });
    cols.forEach((col) => {
      assert5(isString5(col), "The `rows` and `cols` parameters must be 1-dimensional arrays of strings.");
      assert5(df.columns.indexOf(col) > -1, `The column name "${col}" does not exist in the list of columns.`);
    });
    const values = rows.map((row) => {
      return cols.map((col) => {
        return df.values[df.index.indexOf(row)][df.columns.indexOf(col)];
      });
    });
    if (rows.length === 1 && cols.length === 1) {
      return values[0][0];
    }
    if (rows.length === 1) {
      const out32 = new Series24(values[0]);
      out32.name = rows[0];
      out32.index = cols;
      return out32;
    }
    if (cols.length === 1) {
      const out32 = new Series24(values.map((v) => v[0]));
      out32.name = cols[0];
      out32.index = rows;
      return out32;
    }
    const out24 = new DataFrame24(values);
    out24.columns = cols;
    out24.index = rows;
    return out24;
  }
  function dfPrint5(DataFrame24, Series24, df) {
    function truncate(s24, maxLength2) {
      if (isString5(s24)) {
        if (s24.length > maxLength2) {
          return s24.substring(0, maxLength2 - 3) + "...";
        } else {
          return s24;
        }
      } else {
        return s24;
      }
    }
    if (df.isEmpty) {
      console.table({});
      console.log("Shape:", [0, 0], "\n");
      return df;
    }
    const maxRows = typeof window === "undefined" ? 20 : 10;
    const halfMaxRows = Math.floor(maxRows / 2);
    const maxColumns = typeof process === "undefined" ? 10 : Math.floor(process.stdout.columns / 24) - 1;
    const halfMaxColumns = Math.floor(maxColumns / 2);
    const tempRows = maxRows > df.index.length ? null : range5(0, halfMaxRows).concat(range5(df.index.length - halfMaxRows, df.index.length));
    const tempColumns = maxColumns > df.columns.length ? null : range5(0, halfMaxColumns).concat(range5(df.columns.length - halfMaxColumns, df.columns.length));
    let temp = df.get(tempRows, tempColumns);
    if (temp instanceof Series24) {
      if (df.shape[0] === 1) {
        temp = new DataFrame24([temp.values]);
        temp.index = df.index;
        temp.columns = new Series24(df.columns).get(tempColumns).values;
      } else if (df.shape[1] === 1) {
        temp = new DataFrame24([temp.values]).transpose();
        temp.index = new Series24(df.index).get(tempRows).values;
        temp.columns = df.columns;
      }
    }
    if (maxRows <= df.index.length) {
      temp._index.splice(halfMaxRows, 0, "...");
      temp._values.splice(halfMaxRows, 0, range5(0, temp.columns.length).map(() => "..."));
    }
    if (maxColumns <= df.columns.length) {
      temp._columns.splice(halfMaxColumns, 0, "...");
      temp._values = temp._values.map((row) => {
        row.splice(halfMaxColumns, 0, "...");
        return row;
      });
    }
    const maxLength = 28;
    if (temp instanceof Series24) {
      temp.values = temp.values.map((value) => truncate(value, maxLength));
      temp.name = truncate(temp.name, maxLength);
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    } else {
      temp.values = temp.values.map((row) => {
        return row.map((value) => truncate(value, maxLength));
      });
      temp.columns = temp.columns.map((col) => truncate(col, maxLength));
      temp.index = temp.index.map((row) => truncate(row, maxLength));
    }
    console.table(temp.toDetailedObject());
    console.log("Shape:", df.shape, "\n");
    return df;
  }
  function leftPad5(x, maxLength) {
    assert5(isNumber5(x), "The `leftPad` function only works on numbers!");
    let out24 = x.toString();
    while (out24.length < maxLength)
      out24 = "0" + out24;
    return out24;
  }
  function dfResetIndex5(df, shouldSkipCopying) {
    const out24 = shouldSkipCopying ? df : df.copy();
    out24.index = range5(0, df.shape[0]).map((i) => {
      return "row" + leftPad5(i, (out24.index.length - 1).toString().length);
    });
    return out24;
  }
  function product5(arr, shouldDropNaNs) {
    if (isDataFrame5(arr) || isSeries5(arr)) {
      return product5(arr.values, shouldDropNaNs);
    }
    assert5(isArray5(arr), "The `product` function only works on arrays, Series, and DataFrames!");
    try {
      if (arr.length === 0)
        return NaN;
      const temp = flatten5(arr);
      let resultShouldBeABigInt = false;
      let out24 = 1;
      for (let v of temp) {
        if (!isNumber5(v)) {
          if (shouldDropNaNs) {
            v = 1;
          } else {
            return NaN;
          }
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  }
  function isNaturalNumber5(x) {
    return isInteger5(x) && x > 0;
  }
  function reshape5(x, newShape) {
    if (isDataFrame5(x) || isSeries5(x)) {
      return reshape5(x.values, newShape);
    }
    assert5(isArray5(x), "The first argument passed into the `reshape` function must be an array!");
    if (isNumber5(newShape))
      newShape = [newShape];
    assert5(isArray5(newShape), "The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    assert5(shape5(newShape).length === 1, "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
    newShape = newShape.map((v) => {
      if (typeof v === "bigint") {
        v = Number(v);
      }
      assert5(isNaturalNumber5(v), "The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!");
      return Number(v);
    });
    if (newShape.length === 0) {
      return flatten5(x);
    }
    const temp = flatten5(x);
    if (newShape.length === 1 && newShape[0] === temp.length) {
      return temp;
    }
    assert5(product5(newShape) === temp.length, "The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");
    const out24 = [];
    const step = Math.floor(temp.length / newShape[0]);
    for (let i = 0; i < newShape[0]; i++) {
      const row = temp.slice(i * step, (i + 1) * step);
      out24.push(reshape5(row, newShape.slice(1)));
    }
    return out24;
  }
  var MAX5 = Math.pow(2, 64);
  var s5 = [];
  seed5(Math.floor(Math.random() * MAX5));
  function splitmix645(state, n) {
    state = uint5(state);
    function helper54() {
      state += uint5("0x9e3779b97f4a7c15");
      let z = copy5(state);
      z = (z ^ z >> BigInt(30)) * uint5("0xbf58476d1ce4e5b9");
      z = (z ^ z >> BigInt(27)) * uint5("0x94d049bb133111eb");
      return z ^ z >> BigInt(31);
    }
    const out24 = [];
    for (let i = 0; i < n; i++)
      out24.push(helper54());
    return out24;
  }
  function uint5(x) {
    return BigInt.asUintN(64, BigInt(x));
  }
  function rotl5(x, k) {
    x = uint5(x);
    k = BigInt(k);
    return uint5(uint5(x << k) | uint5(x >> uint5(BigInt(64) - k)));
  }
  function seed5(val) {
    if (typeof val === "bigint") {
      val = Number(val);
    }
    if (!isUndefined5(val)) {
      assert5(isNumber5(val), "If passing a value into the `seed` function, then that value must be an integer!");
      const temp = splitmix645(Math.floor(val), 4);
      s5[0] = temp[0];
      s5[1] = temp[1];
      s5[2] = temp[2];
      s5[3] = temp[3];
    } else {
      return copy5(s5);
    }
  }
  function next5() {
    const result = uint5(rotl5(s5[0] + s5[3], 23) + s5[0]);
    const t = uint5(s5[1] << BigInt(17));
    s5[2] = uint5(s5[2] ^ s5[0]);
    s5[3] = uint5(s5[3] ^ s5[1]);
    s5[1] = uint5(s5[1] ^ s5[2]);
    s5[0] = uint5(s5[0] ^ s5[3]);
    s5[2] = uint5(s5[2] ^ t);
    s5[3] = rotl5(s5[3], 45);
    return Math.floor(Number(result)) / MAX5;
  }
  function random5(shape24) {
    if (isUndefined5(shape24))
      return next5();
    if (!isArray5(shape24))
      shape24 = [shape24];
    return reshape5(ndarray5(product5(shape24)).map(next5), shape24);
  }
  function shuffle5(arr) {
    if (isDataFrame5(arr) || isSeries5(arr)) {
      return arr.shuffle(...Object.values(arguments).slice(1));
    }
    assert5(isArray5(arr), "The `shuffle` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    const temp = arr.slice();
    for (let i = 0; i < arr.length; i++) {
      const index = Math.floor(random5() * temp.length);
      out24.push(temp.splice(index, 1)[0]);
    }
    return out24;
  }
  function dfShuffle5(df, axis) {
    if (isUndefined5(axis))
      axis = 0;
    assert5(axis === 0 || axis === 1, "The `axis` parameter to the `shuffle` must be 0, 1, or undefined.");
    return df.get(axis === 0 ? shuffle5(df.index) : null, axis === 1 ? shuffle5(df.columns) : null);
  }
  function isBoolean5(x) {
    return typeof x === "boolean";
  }
  function dfSort5(df, a, b) {
    if (isFunction5(a)) {
      return dfSortByFunction5(df, a, b);
    } else {
      return dfSortByColumns5(df, a, b);
    }
  }
  function dfSortByFunction5(df, fn, axis) {
    axis = isUndefined5(axis) ? 0 : axis;
    assert5(isFunction5(fn), "When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!");
    assert5(isNumber5(axis), "When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other.");
    if (axis === 0) {
      const index = sort5(df.index, (a, b) => {
        return fn(df.get(a, null), df.get(b, null));
      });
      return df.get(index, null);
    } else {
      const columns = sort5(df.columns, (a, b) => {
        return fn(df.get(null, a), df.get(null, b));
      });
      return df.get(null, columns);
    }
  }
  function dfSortByColumns5(df, cols, directions) {
    let out24 = df.copy();
    const indexID = random5().toString();
    out24 = out24.assign(indexID, out24.index);
    if (isUndefined5(cols)) {
      cols = [indexID];
      directions = [true];
    }
    if (isNumber5(cols) || isString5(cols)) {
      cols = [cols];
      if (isBoolean5(directions) || isString5(directions))
        directions = [directions];
    }
    assert5(isArray5(cols), "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    assert5(shape5(cols).length === 1, "The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null.");
    if (isUndefined5(directions))
      directions = range5(0, cols.length).map(() => true);
    assert5(isArray5(directions), "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert5(shape5(directions).length === 1, "The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null.");
    assert5(cols.length === directions.length, "The arrays passed into the `sort` method must be equal in length.");
    cols = cols.map((col) => {
      assert5(isString5(col) || isNumber5(col), "Column references can either be column names (as strings) or column indices (as whole numbers).");
      if (isString5(col)) {
        const index = out24.columns.indexOf(col);
        assert5(index > -1, `The column "${col}" does not exist!`);
        return index;
      }
      if (isNumber5(col)) {
        assert5(isWholeNumber6(col), "Column indices must be whole numbers!");
        assert5(col < out24.columns.length, `The index ${col} is out of bounds!`);
        return col;
      }
    });
    directions = directions.map((dir) => {
      assert5(isString5(dir) || isBoolean5(dir), "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
      if (isString5(dir)) {
        const value = dir.trim().toLowerCase();
        assert5(value === "ascending" || value === "descending", "Direction references can either be strings ('ascending' or 'descending') or booleans (true or false).");
        return value === "ascending";
      }
      if (isBoolean5(dir)) {
        return dir;
      }
    });
    out24.values = sort5(out24.values, (a, b) => {
      let counter = 0;
      while (a[cols[counter]] === b[cols[counter]] && counter < cols.length) {
        counter++;
      }
      const isAscending = directions[counter];
      if (a[cols[counter]] === b[cols[counter]])
        return 0;
      if (a[cols[counter]] < b[cols[counter]])
        return isAscending ? -1 : 1;
      if (a[cols[counter]] > b[cols[counter]])
        return isAscending ? 1 : -1;
    });
    const indexNumber = out24.columns.indexOf(indexID);
    out24.index = out24.values.map((row) => row[indexNumber]);
    out24 = out24.dropColumns(indexID);
    return out24;
  }
  function dfToDetailedObject5(df, axis) {
    if (isUndefined5(axis)) {
      axis = 0;
    } else {
      assert5(axis === 0 || axis === 1, "The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");
    }
    const out24 = {};
    if (axis === 0) {
      df.index.forEach((rowName, i) => {
        const temp = {};
        df.columns.forEach((colName, j) => {
          temp[colName] = df.values[i][j];
        });
        out24[rowName] = temp;
      });
    } else {
      df.columns.forEach((colName, j) => {
        const temp = {};
        df.index.forEach((rowName, i) => {
          temp[rowName] = df.values[i][j];
        });
        out24[colName] = temp;
      });
    }
    return out24;
  }
  function dfToJSONString5(df, axis) {
    return JSON.stringify(df.toObject(axis));
  }
  async function dfToJSON5(df, filename, axis) {
    const out24 = dfToJSONString5(df, axis);
    let downloadedInBrowser = false;
    let wroteToDiskInNode = false;
    let browserError, nodeError;
    try {
      let newFilename = filename;
      if (filename.includes("/")) {
        const parts = filename.split("/");
        newFilename = parts[parts.length - 1];
      }
      const a = document.createElement("a");
      a.href = `data:application/json;charset=utf-8,${encodeURIComponent(out24)}`;
      a.download = newFilename;
      a.dispatchEvent(new MouseEvent("click"));
      downloadedInBrowser = true;
    } catch (e) {
      browserError = e;
    }
    try {
      const fs = await import("node:fs");
      const path = await import("node:path");
      fs.writeFileSync(path.resolve(filename), out24, "utf8");
      wroteToDiskInNode = true;
    } catch (e) {
      nodeError = e;
    }
    if (!downloadedInBrowser && !wroteToDiskInNode) {
      if (typeof window !== "undefined") {
        throw new MathError5(browserError);
      } else if (typeof module !== "undefined") {
        throw new MathError5(nodeError);
      } else {
        throw new MathError5("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");
      }
    }
    return df;
  }
  function dfToObject5(df) {
    const out24 = {};
    df.columns.forEach((col) => {
      out24[col] = df.get(col).values;
    });
    return out24;
  }
  function transpose5(arr) {
    if (isDataFrame5(arr) || isSeries5(arr)) {
      return arr.transpose();
    }
    assert5(isArray5(arr), "The `transpose` function only works on arrays, Series, and DataFrames!");
    const theShape = shape5(arr);
    assert5(theShape.length <= 2, "I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!");
    if (theShape.length === 1) {
      return reverse5(arr);
    } else if (theShape.length === 2) {
      const out24 = ndarray5(reverse5(theShape));
      for (let row = 0; row < theShape[0]; row++) {
        for (let col = 0; col < theShape[1]; col++) {
          out24[col][row] = arr[row][col];
        }
      }
      return out24;
    }
  }
  function seriesAppend5(Series24, series, x) {
    if (isSeries5(x)) {
      return new Series24(series.values.concat(x.values));
    }
    if (isArray5(x)) {
      const xShape = shape5(x);
      assert5(xShape.length === 1 && !isNested5(xShape), "Only vectors can be appended to Series!");
      const out24 = series.copy();
      x.forEach((v, i) => {
        out24._values.push(v);
        out24._index.push("item" + (series.values.length + i));
      });
      return out24;
    }
    return seriesAppend5(series, [x]);
  }
  function seriesApply5(series, fn) {
    assert5(isFunction5(fn), "The parameter to the `apply` method must be a function.");
    const out24 = series.copy();
    out24._values = out24._values.map((v, i) => fn(v, i));
    return out24;
  }
  function seriesDropMissing5(series) {
    const out24 = series.copy();
    const outIndex = [];
    out24._values = out24.values.filter((v, i) => {
      if (isUndefined5(v)) {
        return false;
      } else {
        outIndex.push(out24.index[i]);
        return true;
      }
    });
    out24._index = outIndex;
    return out24;
  }
  function seriesDropNaN5(Series24, series) {
    const index = [];
    const values = [];
    series.values.forEach((value, i) => {
      if (isNumber5(value)) {
        values.push(value);
        index.push(series.index[i]);
      }
    });
    const out24 = new Series24(values);
    out24.name = series.name;
    out24.index = index;
    return out24;
  }
  function seriesFilter5(Series24, series, fn) {
    let out24 = series.copy();
    const index = copy5(out24.index);
    const indicesToRemove = [];
    const newValues = out24.values.filter((value, i) => {
      const shouldKeep = fn(value, i, out24.values);
      if (!shouldKeep)
        indicesToRemove.push(out24.index[i]);
      return shouldKeep;
    });
    indicesToRemove.forEach((i) => {
      index.splice(index.indexOf(i), 1);
    });
    if (newValues.length === 0) {
      out24 = new Series24();
      out24.name = series.name;
      return out24;
    }
    out24.values = newValues;
    out24.index = index;
    return out24;
  }
  function seriesGet5(series, indices) {
    if (isString5(indices) || isNumber5(indices))
      indices = [indices];
    for (const i in indices) {
      if (typeof indices[i] === "bigint") {
        indices[i] = Number(indices[i]);
      }
    }
    const types = set5((indices || []).map((v) => typeof v));
    assert5(types.length <= 2, "Only whole numbers and/or strings are allowed in `get` arrays!");
    if (types.length === 1) {
      assert5(types[0] === "string" || types[0] === "number", "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (types.length === 2) {
      assert5(types.indexOf("string") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
      assert5(types.indexOf("number") > -1, "Only whole numbers and/or strings are allowed in `get` arrays!");
    }
    if (!isUndefined5(indices)) {
      indices = indices.map((i) => {
        if (typeof i === "string") {
          assert5(series.index.indexOf(i) > -1, `Index "${i}" does not exist!`);
          return i;
        }
        if (typeof i === "number") {
          assert5(i >= 0, `Index ${i} is out of bounds!`);
          assert5(Math.floor(i) === i, `Indices must be integers!`);
          assert5(i < series.index.length, `Index ${i} is out of bounds!`);
          return series.index[i];
        }
      });
    }
    return series.getSubsetByNames(indices);
  }
  function seriesGetSubsetByIndices5(series, indices) {
    const dataShape = series.shape;
    if (isUndefined5(indices))
      indices = range5(0, dataShape[0]);
    assert5(isArray5(indices), "The `indices` array must be 1-dimensional array of whole numbers.");
    assert5(shape5(indices).length === 1, "The `indices` array must be a 1-dimensional array of whole numbers.");
    assert5(indices.length > 0, "The `indices` array must contain at least one index.");
    indices.forEach((index) => {
      assert5(isWholeNumber6(index), "The `indices` array must be a 1-dimensional array of whole numbers.");
      assert5(index < series.index.length, `The row index ${index} is out of bounds.`);
    });
    const rows = indices.map((i) => series.index[i]);
    return series.getSubsetByNames(rows);
  }
  function seriesGetSubsetByNames5(Series24, series, indices) {
    if (isUndefined5(indices))
      indices = series.index;
    assert5(isArray5(indices), "The `indices` array must be a 1-dimensional array of strings.");
    assert5(shape5(indices).length === 1, "The `indices` array must be a 1-dimensional array of strings.");
    assert5(indices.length > 0, "The `indices` array must contain at least one index name.");
    indices.forEach((name) => {
      assert5(isString5(name), "The `indices` array must contain only strings.");
      assert5(series.index.indexOf(name) > -1, `The name "${name}" does not exist in the index.`);
    });
    const values = indices.map((name) => {
      return series.values[series.index.indexOf(name)];
    });
    if (values.length === 1)
      return values[0];
    const out24 = new Series24(values);
    out24.index = indices;
    out24.name = series.name;
    return out24;
  }
  function seriesPrint5(series) {
    let temp = series.copy();
    const maxRows = typeof window === "undefined" ? 20 : 10;
    if (temp.index.length > maxRows) {
      temp = temp.get(range5(0, maxRows / 2).concat(range5(temp.index.length - maxRows / 2, temp.index.length)));
      const tempIndex = copy5(temp.index);
      tempIndex.splice(Math.floor(tempIndex.length / 2), 0, "...");
      temp.values.push("...");
      temp.index.push("...");
      temp = temp.get(tempIndex);
    }
    const out24 = {};
    temp.values.forEach((value, i) => {
      const obj = {};
      obj[temp.name] = value;
      out24[temp.index[i]] = obj;
    });
    console.table(out24);
    console.log("Shape:", series.shape, "\n");
    return series;
  }
  function seriesShuffle5(series) {
    const out24 = series.copy();
    return out24.get(shuffle5(out24.index));
  }
  function seriesSort5(Series24, series, fn) {
    fn = fn || ((a, b) => a < b ? -1 : 1);
    assert5(isUndefined5(fn) || isFunction5(fn), "You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");
    const pairs = transpose5([series.values, series.index]);
    const temp = sort5(pairs, (aPair, bPair) => {
      return fn(aPair[0], bPair[0]);
    });
    const newValues = [];
    const newIndex = [];
    temp.forEach((pair) => {
      newValues.push(pair[0]);
      newIndex.push(pair[1]);
    });
    const out24 = new Series24();
    out24._values = newValues;
    out24._index = newIndex;
    out24.name = series.name;
    return out24;
  }
  function seriesSortByIndex5(Series24, series) {
    let temp = transpose5([series.values, series.index]);
    temp = transpose5(sort5(temp, (a, b) => {
      if (a[1] === b[1])
        return 0;
      if (a[1] < b[1])
        return -1;
      if (a[1] > b[1])
        return 1;
    }));
    const out24 = new Series24(temp[0]);
    out24.index = temp[1];
    out24.name = series.name;
    return out24;
  }
  function seriesToObject5(series) {
    const out24 = {};
    out24[series.name] = {};
    series.index.forEach((index, i) => {
      out24[series.name][index] = series.values[i];
    });
    return out24;
  }
  var SERIES_SYMBOL5 = Symbol.for("@jrc03c/js-math-tools/series");
  function createSeriesClass5(DataFrame24) {
    class Series24 {
      static [Symbol.hasInstance](x) {
        try {
          return !!x._symbol && x._symbol === SERIES_SYMBOL5;
        } catch (e) {
          return false;
        }
      }
      constructor(data) {
        this.name = "data";
        Object.defineProperty(this, "_symbol", {
          configurable: false,
          enumerable: false,
          writable: false,
          value: SERIES_SYMBOL5
        });
        Object.defineProperty(this, "_values", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "values", {
          configurable: true,
          enumerable: true,
          get() {
            return this._values;
          },
          set(x) {
            assert5(isArray5(x), "The new values must be a 1-dimensional array!");
            const dataShape = shape5(x);
            assert5(dataShape.length === 1, "The new array of values must be 1-dimensional!");
            if (dataShape[0] < this._index.length) {
              this._index = this._index.slice(0, dataShape[0]);
            } else if (dataShape[0] > this._index.length) {
              this._index = this._index.concat(range5(this._index.length, dataShape[0]).map((i) => {
                return "item" + leftPad5(i, (x.length - 1).toString().length);
              }));
            }
            this._values = x;
          }
        });
        Object.defineProperty(this, "_index", {
          value: [],
          configurable: true,
          enumerable: false,
          writable: true
        });
        Object.defineProperty(this, "index", {
          configurable: true,
          enumerable: true,
          get() {
            return this._index;
          },
          set(x) {
            assert5(isArray5(x), "The new index must be a 1-dimensional array of strings!");
            assert5(x.length === this.shape[0], "The new index must be the same length as the old index!");
            assert5(shape5(x).length === 1, "The new index must be a 1-dimensional array of strings!");
            x.forEach((value) => {
              assert5(isString5(value), "All of the row names must be strings!");
            });
            this._index = x;
          }
        });
        if (data) {
          if (data instanceof Series24) {
            this.name = data.name;
            this.values = copy5(data.values);
            this.index = copy5(data.index);
          } else if (isArray5(data)) {
            const dataShape = shape5(data);
            assert5(dataShape.length === 1, "When passing an array into the constructor of a Series, the array must be 1-dimensional!");
            this.values = data;
          } else if (data instanceof Object) {
            const keys = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
            assert5(keys.length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            const name = keys[0];
            const values = data[name];
            assert5(shape5(values).length === 1, "When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");
            this.name = name;
            this.values = values.slice();
          }
        }
      }
      get shape() {
        return shape5(this.values);
      }
      get length() {
        return this.shape[0];
      }
      get isEmpty() {
        return this.values.filter((v) => !isUndefined5(v)).length === 0;
      }
      clear() {
        const out24 = this.copy();
        out24.values.forEach((v, i) => {
          out24.values[i] = void 0;
        });
        return out24;
      }
      get(indices) {
        return seriesGet5(this, indices);
      }
      getSubsetByNames(indices) {
        return seriesGetSubsetByNames5(Series24, this, indices);
      }
      getSubsetByIndices(indices) {
        return seriesGetSubsetByIndices5(this, indices);
      }
      loc(indices) {
        return this.getSubsetByNames(indices);
      }
      iloc(indices) {
        return this.getSubsetByIndices(indices);
      }
      reverse() {
        const out24 = new Series24(reverse5(this.values));
        out24.index = reverse5(this.index);
        out24.name = this.name;
        return out24;
      }
      resetIndex() {
        const out24 = this.copy();
        out24.index = range5(0, this.shape[0]).map((i) => {
          return "item" + leftPad5(i, (out24.index.length - 1).toString().length);
        });
        return out24;
      }
      copy() {
        const out24 = new Series24();
        out24._values = copy5(this.values);
        out24._index = copy5(this.index);
        out24.name = this.name;
        return out24;
      }
      append(x) {
        return seriesAppend5(Series24, this, x);
      }
      apply(fn) {
        return seriesApply5(this, fn);
      }
      concat(x) {
        return this.append(x);
      }
      dropMissing(condition, threshold) {
        return seriesDropMissing5(this, condition, threshold);
      }
      dropNaN() {
        return seriesDropNaN5(Series24, this);
      }
      toObject() {
        return seriesToObject5(this);
      }
      print() {
        return seriesPrint5(this);
      }
      shuffle() {
        return seriesShuffle5(this);
      }
      sort(direction) {
        return seriesSort5(Series24, this, direction);
      }
      sortByIndex() {
        return seriesSortByIndex5(Series24, this);
      }
      filter(fn) {
        return seriesFilter5(Series24, this, fn);
      }
      toDataFrame() {
        const out24 = new DataFrame24(transpose5([this.values]));
        out24.columns = [this.name];
        out24.index = this.index;
        return out24;
      }
      transpose() {
        const out24 = this.copy();
        out24.values = reverse5(out24.values);
        out24.index = reverse5(out24.index);
        return out24;
      }
      getDummies() {
        return this.toDataFrame().getDummies();
      }
      oneHotEncode() {
        return this.getDummies();
      }
    }
    return Series24;
  }
  var DATAFRAME_SYMBOL5 = Symbol.for("@jrc03c/js-math-tools/dataframe");
  function makeKey35(n) {
    const alpha = "abcdefghijklmnopqrstuvwxyz1234567890";
    let out24 = "";
    for (let i = 0; i < n; i++)
      out24 += alpha[Math.floor(random5() * alpha.length)];
    return out24;
  }
  var DataFrame5 = class {
    static [Symbol.hasInstance](x) {
      try {
        return !!x._symbol && x._symbol === DATAFRAME_SYMBOL5;
      } catch (e) {
        return false;
      }
    }
    constructor(data) {
      Object.defineProperty(this, "_symbol", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: DATAFRAME_SYMBOL5
      });
      Object.defineProperty(this, "_values", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "values", {
        configurable: true,
        enumerable: true,
        get() {
          if (this._values.length === 0 || !isUndefined5(this._values[0]) && this._values[0].length === 0) {
            return [[]];
          }
          return this._values;
        },
        set(x) {
          assert5(isArray5(x), "The new values must be a 2-dimensional array!");
          const dataShape = shape5(x);
          assert5(dataShape.length === 2, "The new array of values must be 2-dimensional!");
          if (dataShape[0] < this._index.length) {
            this._index = this._index.slice(0, dataShape[0]);
          } else if (dataShape[0] > this._index.length) {
            this._index = this._index.concat(range5(this._index.length, dataShape[0]).map((i) => {
              return "row" + leftPad5(i, (dataShape[0] - 1).toString().length);
            }));
          }
          if (dataShape[1] < this._columns.length) {
            this._columns = this._columns.slice(0, dataShape[1]);
          } else if (dataShape[1] > this._columns.length) {
            this._columns = this._columns.concat(range5(this._columns.length, dataShape[1]).map((i) => {
              return "col" + leftPad5(i, (dataShape[1] - 1).toString().length);
            }));
          }
          this._values = x;
        }
      });
      Object.defineProperty(this, "_columns", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "columns", {
        configurable: true,
        enumerable: true,
        get() {
          return this._columns;
        },
        set(x) {
          assert5(isArray5(x), "The new columns list must be a 1-dimensional array of strings!");
          assert5(this.isEmpty || x.length === this.shape[1], "The new columns list must be the same length as the old columns list!");
          assert5(shape5(x).length === 1, "The new columns list must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey35(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count5(x);
            const out24 = {};
            temp.values.forEach((v) => {
              out24[v] = temp.get(v);
            });
            return out24;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey35(8);
            }
            return v;
          });
          this._columns = x;
        }
      });
      Object.defineProperty(this, "_index", {
        value: [],
        configurable: true,
        enumerable: false,
        writable: true
      });
      Object.defineProperty(this, "index", {
        configurable: true,
        enumerable: true,
        get() {
          return this._index;
        },
        set(x) {
          assert5(isArray5(x), "The new index must be a 1-dimensional array of strings!");
          assert5(this.isEmpty || x.length === this.shape[0], "The new index must be the same length as the old index!");
          assert5(shape5(x).length === 1, "The new index must be a 1-dimensional array of strings!");
          x = x.map((v) => {
            if (typeof v !== "string") {
              v = JSON.stringify(v) || v.toString();
            }
            if (v.trim().length === 0) {
              return "untitled_" + makeKey35(8);
            }
            return v.trim();
          });
          const counts = (() => {
            const temp = count5(x);
            const out24 = {};
            temp.values.forEach((v) => {
              out24[v] = temp.get(v);
            });
            return out24;
          })();
          x = x.map((v) => {
            if (counts[v] > 1) {
              return v + "_" + makeKey35(8);
            }
            return v;
          });
          this._index = x;
        }
      });
      assert5(isUndefined5(data) || isObject5(data) || isArray5(data), "The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values.");
      if (data) {
        if (data instanceof DataFrame5) {
          this.values = copy5(data.values);
          this.columns = copy5(data.columns);
          this.index = copy5(data.index);
        } else if (isArray5(data)) {
          const dataShape = shape5(data);
          assert5(dataShape.length === 2, "The `data` array passed into the constructor of a DataFrame must be 2-dimensional!");
          assert5(!isJagged5(data), "The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!");
          this.values = data;
        } else {
          this._columns = Object.keys(data).concat(Object.getOwnPropertySymbols(data)).map((v) => v.toString());
          const temp = [];
          let lastColName = null;
          let lastColLength = null;
          this._columns.forEach((col) => {
            if (isUndefined5(lastColLength)) {
              lastColName = col;
              lastColLength = data[col].length;
            }
            assert5(data[col].length === lastColLength, `The object passed into the DataFrame constructor contains arrays of different lengths! The key "${lastColName}" points to an array containing ${lastColLength} items, and the key "${col}" points to an array containing ${data[col].length} items.`);
            lastColLength = data[col].length;
            const values = data[col];
            temp.push(values);
          });
          this._values = transpose5(temp);
          const dataShape = shape5(this.values);
          this._index = range5(0, dataShape[0]).map((i) => {
            return "row" + leftPad5(i, (dataShape[0] - 1).toString().length);
          });
        }
      }
    }
    get shape() {
      return shape5(this.values);
    }
    get length() {
      return this.shape[0];
    }
    get width() {
      return this.shape[1];
    }
    get rows() {
      return this.index;
    }
    set rows(rows) {
      this.index = rows;
    }
    get isEmpty() {
      return this.values.length === 0 || this.values.every((row) => row.length === 0);
    }
    clear() {
      const out24 = new DataFrame5(ndarray5(this.shape));
      out24.columns = this.columns.slice();
      out24.index = this.index.slice();
      return out24;
    }
    get(rows, cols) {
      if (arguments.length === 0) {
        return this;
      }
      if (arguments.length === 1) {
        try {
          return this.get(null, rows);
        } catch (e) {
          return this.get(rows, null);
        }
      }
      return dfGet5(this, rows, cols);
    }
    getSubsetByNames(rows, cols) {
      return dfGetSubsetByNames5(DataFrame5, Series5, this, rows, cols);
    }
    getSubsetByIndices(rowIndices, colIndices) {
      return dfGetSubsetByIndices5(this, rowIndices, colIndices);
    }
    getDummies(columns) {
      return dfGetDummies5(DataFrame5, this, columns);
    }
    oneHotEncode(columns) {
      return dfGetDummies5(DataFrame5, this, columns);
    }
    transpose() {
      const out24 = new DataFrame5(transpose5(this.values));
      out24.columns = this.index.slice();
      out24.index = this.columns.slice();
      return out24;
    }
    get T() {
      return this.transpose();
    }
    resetIndex(shouldSkipCopying) {
      return dfResetIndex5(this, shouldSkipCopying);
    }
    copy() {
      return dfCopy5(DataFrame5, this);
    }
    assign(p1, p2) {
      return dfAssign5(DataFrame5, Series5, this, p1, p2);
    }
    apply(fn, axis) {
      return dfApply5(DataFrame5, Series5, this, fn, axis);
    }
    dropMissing(axis, condition, threshold) {
      return dfDropMissing5(DataFrame5, Series5, this, axis, condition, threshold);
    }
    dropNaN(axis, condition, threshold) {
      return dfDropNaN5(DataFrame5, this, axis, condition, threshold);
    }
    drop(rows, cols) {
      return dfDrop5(DataFrame5, Series5, this, rows, cols);
    }
    dropColumns(columns) {
      return this.drop(null, columns);
    }
    dropRows(rows) {
      return this.drop(rows, null);
    }
    toDetailedObject(axis) {
      return dfToDetailedObject5(this, axis);
    }
    toObject() {
      return dfToObject5(this);
    }
    toJSONString(axis) {
      return dfToJSONString5(this, axis);
    }
    saveAsJSON(filename, axis) {
      return dfToJSON5(this, filename, axis);
    }
    print() {
      return dfPrint5(DataFrame5, Series5, this);
    }
    sort(cols, directions) {
      return dfSort5(this, cols, directions);
    }
    sortByIndex() {
      return this.sort();
    }
    filter(fn, axis) {
      return dfFilter5(DataFrame5, Series5, this, fn, axis);
    }
    shuffle(axis) {
      return dfShuffle5(this, axis);
    }
    append(x, axis) {
      return dfAppend5(this, x, axis);
    }
    concat(x, axis) {
      return this.append(x, axis);
    }
    join(x, axis) {
      return this.append(x, axis);
    }
    toString() {
      return JSON.stringify(this);
    }
  };
  var Series5 = createSeriesClass5(DataFrame5);
  function max5(arr, shouldDropNaNs) {
    return stats5(arr, { shouldDropNaNs }).max;
  }
  function vectorize5(fn) {
    assert5(isFunction5(fn), "You must pass a function into the `vectorize` function!");
    return function helper54() {
      let hasSeries, hasDataFrames;
      const series = [];
      const dataframes = [];
      const childArrays = Object.keys(arguments).filter((key) => {
        const arg = arguments[key];
        if (isArray5(arg)) {
          return true;
        } else if (isSeries5(arg)) {
          hasSeries = true;
          series.push(arg);
          return true;
        } else if (isDataFrame5(arg)) {
          hasDataFrames = true;
          dataframes.push(arg);
          return true;
        } else {
          return false;
        }
      }).map((key) => arguments[key]);
      childArrays.slice(0, -1).forEach((s24, i) => {
        assert5(isEqual5(isArray5(s24) ? shape5(s24) : s24.shape, isArray5(childArrays[i + 1]) ? shape5(childArrays[i + 1]) : childArrays[i + 1].shape), `When passing multiple arrays into the \`${fn.name}\` function, all of the arrays must have the same shape!`);
      });
      if (childArrays.length > 0) {
        const maxLength = max5(childArrays.map((a) => a.length ? a.length : a.values.length));
        const out24 = range5(0, maxLength).map((i) => {
          const args = Object.keys(arguments).map((key) => {
            if (isArray5(arguments[key])) {
              return arguments[key][i];
            } else if (isSeries5(arguments[key])) {
              return arguments[key].values[i];
            } else if (isDataFrame5(arguments[key])) {
              return arguments[key].values[i];
            } else {
              return arguments[key];
            }
          });
          return helper54(...args);
        });
        if (hasDataFrames) {
          try {
            if (dataframes.length === 1 && isEqual5(shape5(dataframes[0]), shape5(out24))) {
              const temp = new DataFrame5(out24);
              temp.index = dataframes[0].index.slice();
              temp.columns = dataframes[0].columns.slice();
              return temp;
            } else {
              return new DataFrame5(out24);
            }
          } catch (e) {
            return out24;
          }
        }
        if (hasSeries) {
          try {
            if (series.length === 1 && series[0].length === out24.length) {
              const temp = new Series5(out24);
              temp.name = series[0].name;
              temp.index = series[0].index.slice();
              return temp;
            } else {
              return new Series5(out24);
            }
          } catch (e) {
            return out24;
          }
        }
        return out24;
      } else {
        return fn(...arguments);
      }
    };
  }
  function abs5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        return x < 0 ? -x : x;
      } else {
        return Math.abs(x);
      }
    } catch (e) {
      return NaN;
    }
  }
  var vabs5 = vectorize5(abs5);
  function add5() {
    try {
      let out24 = 0;
      let resultShouldBeABigInt = false;
      const x = Object.values(arguments);
      for (let v of x) {
        if (!isNumber5(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 += v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  }
  var vadd5 = vectorize5(add5);
  function apply5(x, fn) {
    try {
      return fn(x);
    } catch (e) {
      return NaN;
    }
  }
  var vapply5 = vectorize5(apply5);
  function arccos5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.acos(x);
    } catch (e) {
      return NaN;
    }
  }
  var varccos5 = vectorize5(arccos5);
  function arcsin5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.asin(x);
    } catch (e) {
      return NaN;
    }
  }
  var varcsin5 = vectorize5(arcsin5);
  function arctan5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.atan(x);
    } catch (e) {
      return NaN;
    }
  }
  var varctan5 = vectorize5(arctan5);
  function argmax5(x, shouldDropNaNs) {
    if (isDataFrame5(x)) {
      const index = argmax5(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries5(x)) {
      const index = argmax5(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert5(isArray5(x), "The `argmax` function only works on arrays, Series, and DataFrames!");
    try {
      const out24 = indexOf5(x, max5(x, shouldDropNaNs));
      if (out24) {
        if (out24.length === 0) {
          return void 0;
        } else if (out24.length === 1) {
          return out24[0];
        } else {
          return out24;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function min5(arr, shouldDropNaNs) {
    return stats5(arr, { shouldDropNaNs }).min;
  }
  function argmin5(x, shouldDropNaNs) {
    if (isDataFrame5(x)) {
      const index = argmin5(x.values, shouldDropNaNs);
      return [x.index[index[0]], x.columns[index[1]]];
    }
    if (isSeries5(x)) {
      const index = argmin5(x.values, shouldDropNaNs);
      return x.index[index];
    }
    assert5(isArray5(x), "The `argmin` function only works on arrays, Series, and DataFrames!");
    try {
      const out24 = indexOf5(x, min5(x, shouldDropNaNs));
      if (out24) {
        if (out24.length === 0) {
          return void 0;
        } else if (out24.length === 1) {
          return out24[0];
        } else {
          return out24;
        }
      } else {
        return void 0;
      }
    } catch (e) {
      return void 0;
    }
  }
  function cast5(value, type) {
    if (isDataFrame5(value) || isSeries5(value)) {
      return value.apply((item) => cast5(item, type));
    }
    if (isArray5(value)) {
      return value.map((v) => cast5(v, type));
    }
    if (type === "null") {
      return null;
    }
    if (type === "number") {
      if (isUndefined5(value)) {
        return NaN;
      }
      const booleanValue = cast5(value, "boolean");
      if (isBoolean5(booleanValue)) {
        return booleanValue ? 1 : 0;
      }
      try {
        JSON.parse(value);
      } catch (e) {
        const dateValue = cast5(value, "date");
        if (isDate5(dateValue)) {
          return dateValue.getTime();
        }
      }
      const out24 = parseFloat(value);
      if (isNaN(out24))
        return NaN;
      return out24;
    }
    if (type === "int") {
      const out24 = cast5(value, "number");
      return out24 >= 0 ? Math.floor(out24) : Math.ceil(out24);
    }
    if (type === "float") {
      return cast5(value, "number");
    }
    if (type === "bigint") {
      if (typeof value === "bigint") {
        return value;
      }
      return BigInt(cast5(value, "int"));
    }
    if (type === "boolean") {
      if (isBoolean5(value)) {
        return value;
      }
      if (isNumber5(value)) {
        if (value === 0) {
          return false;
        }
        if (value === 1) {
          return true;
        }
        return null;
      }
      try {
        const vBool = (typeof value === "object" ? value.toString() === "null" ? "false" : JSON.stringify(value) : value.toString()).trim().toLowerCase();
        if (vBool === "true" || vBool === "yes" || vBool === "y") {
          return true;
        }
        if (vBool === "false" || vBool === "no" || vBool === "n") {
          return false;
        }
        return null;
      } catch (e) {
        return null;
      }
    }
    if (type === "date") {
      if (isDate5(value)) {
        return value;
      }
      if (isUndefined5(value)) {
        return null;
      }
      const valueFloat = parseFloat(value);
      if (!isNaN(valueFloat)) {
        const out24 = new Date(value);
        if (!isDate5(out24))
          return null;
        return out24;
      }
      const valueDate = Date.parse(value);
      if (!isNaN(valueDate)) {
        return new Date(valueDate);
      }
      return null;
    }
    if (type === "object") {
      if (isObject5(value)) {
        return value;
      }
      const booleanValue = cast5(value, "boolean");
      if (isBoolean5(booleanValue)) {
        return null;
      }
      try {
        const numberValue = cast5(value, "number");
        if (isNumber5(numberValue)) {
          JSON.parse(value);
          return null;
        }
      } catch (e) {
      }
      const dateValue = cast5(value, "date");
      if (dateValue) {
        return dateValue;
      }
      try {
        const out24 = JSON.parse(value);
        if (isArray5(out24)) {
          return out24.map((v) => cast5(v, type));
        } else {
          return out24;
        }
      } catch (e) {
        return null;
      }
    }
    if (type === "string") {
      if (isUndefined5(value)) {
        if (isEqual5(value, void 0)) {
          return "undefined";
        }
        return "null";
      }
      if (value instanceof Date) {
        return value.toJSON();
      }
      const valueString = (() => {
        if (typeof value === "object") {
          if (value === null) {
            return "null";
          } else {
            return JSON.stringify(value);
          }
        } else {
          return value.toString();
        }
      })();
      return valueString;
    }
  }
  function ceil5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.ceil(x);
    } catch (e) {
      return NaN;
    }
  }
  var vceil5 = vectorize5(ceil5);
  function chop5(x, threshold) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      if (isUndefined5(threshold)) {
        threshold = 1e-10;
      } else if (!isNumber5(threshold)) {
        return NaN;
      }
      return vabs5(x) < threshold ? 0 : x;
    } catch (e) {
      return NaN;
    }
  }
  var vchop5 = vectorize5(chop5);
  function int5(x) {
    if (isDataFrame5(x) || isSeries5(x)) {
      const out24 = x.copy();
      out24.values = int5(out24.values);
      return out24;
    }
    if (isArray5(x)) {
      return x.map((v) => int5(v));
    } else {
      try {
        const out24 = JSON.parse(x);
        if (isNumber5(out24)) {
          return typeof out24 === "bigint" ? Number(out24) : out24 >= 0 ? Math.floor(out24) : Math.ceil(out24);
        }
        return NaN;
      } catch (e) {
        return NaN;
      }
    }
  }
  var vint5 = vectorize5(int5);
  function clamp5(x, a, b) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (!isNumber5(a))
        return NaN;
      if (!isNumber5(b))
        return NaN;
      if (typeof x === "bigint") {
        return BigInt(clamp5(vint5(x), a, b));
      }
      if (x < a)
        return a;
      if (x > b)
        return b;
      return x;
    } catch (e) {
      return NaN;
    }
  }
  var vclamp5 = vectorize5(clamp5);
  function combinationsIterator5(x, r) {
    function* helper54(x2, r2) {
      if (r2 > x2.length) {
        yield x2;
      } else if (r2 <= 0) {
        yield [];
      } else if (x2.length < 2) {
        yield x2;
      } else {
        for (let i = 0; i < x2.length; i++) {
          const item = x2[i];
          const after = x2.slice(i + 1);
          if (after.length < r2 - 1) {
            continue;
          }
          if (r2 - 1 >= 0) {
            for (const child of combinationsIterator5(after, r2 - 1)) {
              yield [item].concat(child);
            }
          }
        }
      }
    }
    if (isDataFrame5(x) || isSeries5(x)) {
      return combinationsIterator5(x.values, r);
    }
    assert5(isArray5(x), "The `combinations` function only works on arrays, Series, and DataFrames!");
    assert5(isNumber5(r) && vint5(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper54(flatten5(x), r);
  }
  function combinations5(x, r) {
    const out24 = [];
    for (const combo of combinationsIterator5(x, r)) {
      out24.push(combo.slice());
    }
    return out24;
  }
  function intersect5() {
    const arrays = Object.values(arguments).map((x) => {
      if (isDataFrame5(x) || isSeries5(x)) {
        return set5(x.values);
      }
      assert5(isArray5(x), "The `intersect` function only works on arrays, Series, and DataFrames!");
      return set5(x);
    });
    const all = set5(arrays);
    return all.filter((v) => {
      return arrays.every((arr) => arr.findIndex((other) => isEqual5(other, v)) > -1);
    });
  }
  var _IndexMatcher5 = class {
    constructor(mode24) {
      assert5(isUndefined5(mode24) || mode24 === _IndexMatcher5.DROP_NAN_MODE || mode24 === _IndexMatcher5.DROP_MISSING_MODE, "The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)");
      this.mode = !isUndefined5(mode24) ? mode24 : _IndexMatcher5.DROP_NAN_MODE;
      this.index = null;
    }
    fit() {
      const indices = [];
      Object.values(arguments).forEach((x) => {
        if (isArray5(x)) {
          const xshape = shape5(x);
          if (xshape.length === 1) {
            x = new Series5(x);
          } else if (xshape.length === 2) {
            x = new DataFrame5(x);
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert5(isDataFrame5(x) || isSeries5(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        if (this.mode === _IndexMatcher5.DROP_MISSING_MODE) {
          indices.push(x.dropMissing().index);
        } else {
          indices.push(x.dropNaN().index);
        }
      });
      this.index = intersect5(...indices);
      return this;
    }
    transform() {
      assert5(!!this.index, "The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");
      const out24 = Object.values(arguments).map((x) => {
        if (isArray5(x)) {
          const xshape = shape5(x);
          if (xshape.length === 1) {
            return new Series5(x).get(this.index).values;
          } else if (xshape.length === 2) {
            return new DataFrame5(x).get(this.index, null).values;
          } else {
            throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
          }
        }
        assert5(isDataFrame5(x) || isSeries5(x), "The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!");
        return x.get(this.index, null);
      });
      return out24.length === 1 ? out24[0] : out24;
    }
    fitAndTransform() {
      return this.fit(...arguments).transform(...arguments);
    }
  };
  var IndexMatcher5 = _IndexMatcher5;
  __publicField5(IndexMatcher5, "DROP_NAN_MODE", "DROP_NAN_MODE");
  __publicField5(IndexMatcher5, "DROP_MISSING_MODE", "DROP_MISSING_MODE");
  function covariance5(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects) {
    if (isSeries5(x)) {
      return covariance5(x.values, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    if (isSeries5(y)) {
      return covariance5(x, y.values, shouldDropNaNs, shouldAlsoReturnStatsObjects);
    }
    assert5(isArray5(x) && isArray5(y) && shape5(x).length === 1 && shape5(y).length === 1, "The `covariance` function only works on 1-dimensional arrays and Series!");
    assert5(x.length === y.length, "The two arrays or Series passed into the `covariance` function must have the same length!");
    if (shouldDropNaNs) {
      return covariance5(...new IndexMatcher5().fitAndTransform(x, y), false, shouldAlsoReturnStatsObjects);
    }
    try {
      const xstats = stats5(x, { stdev: shouldAlsoReturnStatsObjects });
      const ystats = stats5(y, { stdev: shouldAlsoReturnStatsObjects });
      const mx = Number(xstats.mean);
      const my = Number(ystats.mean);
      if (!isNumber5(mx) || !isNumber5(my)) {
        return NaN;
      }
      const n = Math.max(x.length, y.length);
      let out24 = 0;
      for (let i = 0; i < n; i++) {
        let vx = x[i];
        let vy = y[i];
        if (!isNumber5(vx))
          return NaN;
        if (!isNumber5(vy))
          return NaN;
        if (typeof vx === "bigint") {
          vx = Number(vx);
        }
        if (typeof vy === "bigint") {
          vy = Number(vy);
        }
        out24 += (vx - mx) * (vy - my);
      }
      if (shouldAlsoReturnStatsObjects) {
        return [out24 / x.length, xstats, ystats];
      } else {
        return out24 / x.length;
      }
    } catch (e) {
      return NaN;
    }
  }
  function correl5(x, y, shouldDropNaNs) {
    if (isSeries5(x)) {
      return correl5(x.values, y, shouldDropNaNs);
    }
    if (isSeries5(y)) {
      return correl5(x, y.values, shouldDropNaNs);
    }
    assert5(isArray5(x) && isArray5(y) && shape5(x).length === 1 && shape5(y).length === 1, "The `correl` function only works on 1-dimensional arrays and Series!");
    assert5(x.length === y.length, "The two arrays or Series passed into the `correl` function must have the same length!");
    try {
      const shouldAlsoReturnStatsObjects = true;
      const [num, xstats, ystats] = covariance5(x, y, shouldDropNaNs, shouldAlsoReturnStatsObjects);
      const den = xstats.stdev * ystats.stdev;
      return num / den;
    } catch (e) {
      return NaN;
    }
  }
  function cos5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.cos(x);
    } catch (e) {
      return NaN;
    }
  }
  var vcos5 = vectorize5(cos5);
  var dataTypes5 = Object.freeze({
    boolean: "boolean",
    date: "date",
    null: "null",
    number: "number",
    object: "object",
    string: "string"
  });
  function diff5(a, b) {
    if (isDataFrame5(a) || isSeries5(a)) {
      return diff5(a.values, b);
    }
    if (isDataFrame5(b) || isSeries5(b)) {
      return diff5(a, b.values);
    }
    assert5(isArray5(a) && isArray5(b), "The `diff` function only works on arrays, Series, and DataFrames!");
    const aTemp = set5(a);
    const bTemp = set5(b);
    const out24 = [];
    aTemp.forEach((item) => {
      if (bTemp.findIndex((other) => isEqual5(other, item)) < 0) {
        out24.push(item);
      }
    });
    return out24;
  }
  function pow5(x, p) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (!isNumber5(p))
        return NaN;
      if (typeof x === "bigint" || typeof p === "bigint") {
        const out24 = pow5(Number(x), Number(p));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return Math.pow(x, p);
    } catch (e) {
      return NaN;
    }
  }
  var vpow5 = vectorize5(pow5);
  function sqrt5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        const out24 = sqrt5(Number(x));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return Math.sqrt(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsqrt5 = vectorize5(sqrt5);
  function multiply5() {
    try {
      const x = Object.values(arguments);
      if (x.length === 0)
        return NaN;
      let resultShouldBeABigInt = false;
      let out24 = 1;
      for (let v of x) {
        if (!isNumber5(v))
          return NaN;
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
          v = Number(v);
        }
        out24 *= v;
      }
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  }
  var vmultiply5 = vectorize5(multiply5);
  function scale5() {
    return vmultiply5(...arguments);
  }
  function subtract5(a, b) {
    return vadd5(a, scale5(b, -1));
  }
  function sum5(arr, shouldDropNaNs) {
    return stats5(arr, { shouldDropNaNs }).sum;
  }
  function distance5(a, b) {
    if (isNumber5(a) && isNumber5(b)) {
      return vabs5(a - b);
    }
    if (isDataFrame5(a) || isSeries5(a)) {
      return distance5(a.values, b);
    }
    if (isDataFrame5(b) || isSeries5(b)) {
      return distance5(a, b.values);
    }
    if (isArray5(a) && isArray5(b)) {
      assert5(isEqual5(shape5(a), shape5(b)), "If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");
    }
    try {
      return vsqrt5(sum5(vpow5(subtract5(a, b), 2)));
    } catch (e) {
      return NaN;
    }
  }
  function divide5(a, b) {
    return scale5(a, vpow5(b, -1));
  }
  function dot5(a, b) {
    if (isDataFrame5(a)) {
      const temp = dot5(a.values, b);
      if (shape5(temp).length === 1) {
        const out24 = new Series5(temp);
        out24.name = isSeries5(b) ? b.name : out24.name;
        out24.index = a.index.slice();
        return out24;
      } else {
        const out24 = new DataFrame5(temp);
        out24.index = a.index.slice();
        if (isDataFrame5(b)) {
          out24.columns = b.columns.slice();
        }
        return out24;
      }
    }
    if (isDataFrame5(b)) {
      const temp = dot5(a, b.values);
      if (shape5(temp).length === 1) {
        const out24 = new Series5(temp);
        out24.name = isSeries5(a) ? a.name : out24.name;
        out24.index = b.columns.slice();
        return out24;
      } else {
        const out24 = new DataFrame5(temp);
        out24.columns = b.columns.slice();
        return out24;
      }
    }
    if (isSeries5(a)) {
      return dot5(a.values, b);
    }
    if (isSeries5(b)) {
      return dot5(a, b.values);
    }
    assert5(isArray5(a) && isArray5(b), "The `dot` function only works on arrays, Series, and DataFrames!");
    const aShape = shape5(a);
    const bShape = shape5(b);
    assert5(aShape.length <= 2 && bShape.length <= 2, "I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!");
    assert5(aShape[aShape.length - 1] === bShape[0], `There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${aShape[aShape.length - 1]} !== ${bShape[0]})`);
    if (aShape.length === 1 && bShape.length === 1) {
      return sum5(scale5(a, b));
    } else if (aShape.length === 1 && bShape.length === 2) {
      return transpose5(b).map((col) => dot5(a, col));
    } else if (aShape.length === 2 && bShape.length === 1) {
      return a.map((row) => dot5(row, b));
    } else if (aShape.length === 2 && bShape.length === 2) {
      const bTranspose = transpose5(b);
      const out24 = [];
      for (let i = 0; i < a.length; i++) {
        const row = [];
        for (let j = 0; j < bTranspose.length; j++) {
          row.push(dot5(a[i], bTranspose[j]));
        }
        out24.push(row);
      }
      return out24;
    }
  }
  function dropMissing5(x) {
    if (isDataFrame5(x) || isSeries5(x)) {
      return x.dropMissing(...Object.values(arguments).slice(1));
    }
    assert5(isArray5(x), "The `dropMissing` function only works on arrays, Series, and DataFrames!");
    const out24 = [];
    x.forEach((v) => {
      try {
        return out24.push(dropMissing5(v));
      } catch (e) {
        if (!isUndefined5(v)) {
          out24.push(v);
        }
      }
    });
    return out24;
  }
  function dropMissingPairwise5(a, b) {
    if (isDataFrame5(a) || isSeries5(a)) {
      return dropMissingPairwise5(a.values, b);
    }
    if (isDataFrame5(b) || isSeries5(b)) {
      return dropMissingPairwise5(a, b.values);
    }
    assert5(isArray5(a) && isArray5(b), "The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!");
    assert5(isEqual5(shape5(a), shape5(b)), "The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropMissingPairwise5(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (!isUndefined5(a[i]) && !isUndefined5(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropNaNPairwise5(a, b) {
    if (isDataFrame5(a) || isSeries5(a)) {
      return dropNaNPairwise5(a.values, b);
    }
    if (isDataFrame5(b) || isSeries5(b)) {
      return dropNaNPairwise5(a, b.values);
    }
    assert5(isArray5(a) && isArray5(b), "The `dropNaNPairwise` only works on arrays, Series, and DataFrames!");
    assert5(isEqual5(shape5(a), shape5(b)), "The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");
    const aOut = [];
    const bOut = [];
    for (let i = 0; i < a.length; i++) {
      try {
        const [aChildren, bChildren] = dropNaNPairwise5(a[i], b[i]);
        aOut.push(aChildren);
        bOut.push(bChildren);
      } catch (e) {
        if (isNumber5(a[i]) && isNumber5(b[i])) {
          aOut.push(a[i]);
          bOut.push(b[i]);
        }
      }
    }
    return [aOut, bOut];
  }
  function dropUndefined5(x) {
    return dropMissing5(x);
  }
  function every5(x, fn) {
    if (isDataFrame5(x) || isSeries5(x)) {
      return every5(x.values, fn);
    }
    assert5(isArray5(x), "The first argument passed into the `every` function must be an array, Series, or DataFrame!");
    assert5(isFunction5(fn), "The second argument passed into the `every` function must be a function!");
    for (const v of x) {
      if (isArray5(v)) {
        if (!every5(v, fn)) {
          return false;
        }
      } else {
        if (!fn(v)) {
          return false;
        }
      }
    }
    return true;
  }
  function exp5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        if (x === 0n) {
          return 1n;
        } else {
          x = Number(x);
        }
      }
      return Math.exp(x);
    } catch (e) {
      return NaN;
    }
  }
  var vexp5 = vectorize5(exp5);
  function factorial5(n) {
    try {
      if (typeof n === "bigint") {
        return BigInt(factorial5(vint5(n)));
      }
      if (n !== vint5(n))
        return NaN;
      if (n <= 1)
        return 1;
      return n * factorial5(n - 1);
    } catch (e) {
      return NaN;
    }
  }
  var vfactorial5 = vectorize5(factorial5);
  function find5(x, fn) {
    if (isDataFrame5(x)) {
      return find5(x.values, fn);
    }
    if (isSeries5(x)) {
      return find5(x.values, fn);
    }
    assert5(isObject5(x) || isArray5(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!");
    if (!isFunction5(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper54(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject5(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          if (fn2(value)) {
            return value;
          }
          const result = helper54(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else if (isArray5(x2)) {
        checked.push(x2);
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          if (fn2(value)) {
            return value;
          }
          const result = helper54(value, fn2, checked);
          if (result) {
            return result;
          }
        }
      } else {
        if (fn2(x2)) {
          return x2;
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    return helper54(x, safeFn);
  }
  function findAll5(x, fn) {
    if (isDataFrame5(x)) {
      return findAll5(x.values, fn);
    }
    if (isSeries5(x)) {
      return findAll5(x.values, fn);
    }
    assert5(isObject5(x) || isArray5(x), "You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!");
    if (!isFunction5(fn)) {
      const value = fn;
      fn = (v) => v === value;
    }
    function helper54(x2, fn2, checked) {
      checked = checked || [];
      if (checked.indexOf(x2) > -1) {
        return null;
      }
      if (isObject5(x2)) {
        checked.push(x2);
        const keys = Object.keys(x2).concat(Object.getOwnPropertySymbols(x2));
        const out24 = [];
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          const value = x2[key];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out24.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper54(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out24.push(r));
          }
        }
        return out24;
      } else if (isArray5(x2)) {
        checked.push(x2);
        const out24 = [];
        for (let i = 0; i < x2.length; i++) {
          const value = x2[i];
          let alreadyStoredThisValue = false;
          if (fn2(value)) {
            out24.push(value);
            alreadyStoredThisValue = true;
          }
          const results2 = helper54(value, fn2, checked);
          if (results2 && results2.length > 0) {
            results2.slice(alreadyStoredThisValue ? 1 : 0).forEach((r) => out24.push(r));
          }
        }
        return out24;
      } else {
        if (fn2(x2)) {
          return [x2];
        }
      }
      return null;
    }
    function safeFn(v) {
      try {
        return fn(v);
      } catch (e) {
        return false;
      }
    }
    const results = helper54(x, safeFn);
    if (results && results.length > 0) {
      return results;
    } else {
      return null;
    }
  }
  function float5(x) {
    try {
      if (x === "Infinity") {
        return Infinity;
      }
      if (x === "-Infinity") {
        return -Infinity;
      }
      const out24 = JSON.parse(x);
      if (isNumber5(out24))
        return out24;
      return NaN;
    } catch (e) {
      return NaN;
    }
  }
  var vfloat5 = vectorize5(float5);
  function floor5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        return x;
      }
      return Math.floor(x);
    } catch (e) {
      return NaN;
    }
  }
  var vfloor5 = vectorize5(floor5);
  function zeros5(shape24) {
    if (isNumber5(shape24))
      shape24 = [shape24];
    const out24 = [];
    const n = product5(shape24);
    for (let i = 0; i < n; i++)
      out24.push(0);
    return reshape5(out24, shape24);
  }
  function identity5(size) {
    if (typeof size === "bigint") {
      size = vint5(size);
    }
    assert5(!isUndefined5(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert5(isNumber5(size), "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert5(vint5(size) === size, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    assert5(size > 0, "You must pass an integer greater than 0 (representing the size) into the `identity` function!");
    const out24 = zeros5([size, size]);
    for (let i = 0; i < size; i++)
      out24[i][i] = 1;
    return out24;
  }
  var booleanValues5 = ["true", "false", "yes", "no"];
  var nullValues5 = ["null", "none", "nan", "na", "n/a", "", "undefined"];
  function checkIfInteger5(results) {
    if (results.type === "number") {
      if (typeof results.value !== "undefined") {
        results.isInteger = vint5(results.value) === results.value;
      } else {
        results.isInteger = every5(results.values, (v) => isNumber5(v) ? vint5(v) === v : true);
      }
    }
    return results;
  }
  function inferType5(arr) {
    if (isDataFrame5(arr)) {
      const out24 = arr.copy();
      const results = inferType5(arr.values);
      out24.values = results.values;
      return checkIfInteger5({ type: results.type, values: out24 });
    }
    if (isSeries5(arr)) {
      const out24 = arr.copy();
      const results = inferType5(arr.values);
      out24.values = results.values;
      return checkIfInteger5({ type: results.type, values: out24 });
    }
    if (!isArray5(arr)) {
      const out24 = inferType5([arr]);
      out24.value = out24.values[0];
      delete out24.values;
      return checkIfInteger5(out24);
    }
    assert5(isArray5(arr), "The `inferType` function only works on arrays, Series, and DataFrames!");
    const types = flatten5(arr).map((v) => {
      if (v === void 0)
        return "null";
      try {
        if (typeof v === "object") {
          const temp = new Date(v.getTime());
          if (isDate5(temp)) {
            return "date";
          }
        }
      } catch (e) {
      }
      if (!isString5(v)) {
        if (typeof v === "bigint") {
          v = v.toString() + "n";
        } else {
          v = JSON.stringify(v);
        }
      }
      const vLower = v.toLowerCase();
      const vLowerTrimmed = vLower.trim();
      if (nullValues5.indexOf(vLowerTrimmed) > -1) {
        return "null";
      }
      if (booleanValues5.indexOf(vLowerTrimmed) > -1) {
        return "boolean";
      }
      try {
        if (v.match(/^-?\d+n$/g)) {
          return "bigint";
        }
        const vParsed = JSON.parse(v);
        if (isNumber5(vParsed)) {
          return "number";
        }
        if (typeof vParsed === "object") {
          if (isArray5(vParsed))
            return "string";
          return "object";
        }
        return "string";
      } catch (e) {
        const vDate = new Date(v);
        if (isDate5(vDate)) {
          return "date";
        }
        return "string";
      }
    });
    const counts = count5(types);
    const sortedValues = counts.values.toSorted((a, b) => counts.get(b) - counts.get(a));
    const primaryType = sortedValues[0];
    return checkIfInteger5({
      type: primaryType,
      values: vapply5(arr, (v) => cast5(v, primaryType))
    });
  }
  function inverse5(x) {
    if (isDataFrame5(x)) {
      const out24 = x.copy();
      out24.values = inverse5(out24.values);
      return out24;
    }
    assert5(isArray5(x), "The `inverse` function only works on square 2-dimensional arrays or DataFrames!");
    const xShape = shape5(x);
    assert5(xShape.length === 2, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert5(xShape[0] === xShape[1], "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    assert5(xShape[0] >= 0, "The array passed into the `inverse` function must be exactly two-dimensional and square!");
    if (xShape[0] === 0) {
      return x;
    } else if (xShape[0] === 1) {
      assert5(x[0][0] !== 0, "This matrix cannot be inverted!");
      let v = x[0][0];
      if (typeof v === "bigint")
        v = Number(v);
      return 1 / v;
    } else if (xShape[0] === 2) {
      let a = x[0][0];
      let b = x[0][1];
      let c = x[1][0];
      let d = x[1][1];
      if (typeof a === "bigint")
        a = Number(a);
      if (typeof b === "bigint")
        b = Number(b);
      if (typeof c === "bigint")
        c = Number(c);
      if (typeof d === "bigint")
        d = Number(d);
      const det = a * d - b * c;
      assert5(det !== 0, "This matrix cannot be inverted!");
      const out24 = [
        [d, -b],
        [-c, a]
      ];
      return scale5(out24, 1 / det);
    } else if (xShape[0] > 1) {
      const times = (a, b) => isNumber5(a) || isNumber5(b) ? scale5(a, b) : dot5(a, b);
      for (let divider = 1; divider < xShape[0] - 1; divider++) {
        try {
          const A = x.slice(0, divider).map((row) => row.slice(0, divider));
          const B = x.slice(0, divider).map((row) => row.slice(divider, xShape[0]));
          const C = x.slice(divider, xShape[0]).map((row) => row.slice(0, divider));
          const D = x.slice(divider, xShape[0]).map((row) => row.slice(divider, xShape[0]));
          const AInv = inverse5(A);
          const CompInv = inverse5(vadd5(D, times(-1, times(times(C, AInv), B))));
          const topLeft = vadd5(AInv, times(times(times(times(AInv, B), CompInv), C), AInv));
          const topRight = times(-1, times(times(AInv, B), CompInv));
          const bottomLeft = times(-1, times(times(CompInv, C), AInv));
          const bottomRight = CompInv;
          const out24 = topLeft.map((row, i) => row.concat(topRight[i])).concat(bottomLeft.map((row, i) => row.concat(bottomRight[i])));
          return out24;
        } catch (e) {
        }
      }
      assert5(false, "This matrix cannot be inverted!");
    }
  }
  var isBrowser25 = new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);
  function lerp5(a, b, f) {
    try {
      if (!isNumber5(a))
        return NaN;
      if (!isNumber5(b))
        return NaN;
      if (!isNumber5(f))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out24 = lerp5(Number(a), Number(b), f);
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return f * (b - a) + a;
    } catch (e) {
      return NaN;
    }
  }
  var vlerp5 = vectorize5(lerp5);
  function log5(x, base) {
    try {
      base = isUndefined5(base) ? Math.E : base;
      if (!isNumber5(x))
        return NaN;
      if (!isNumber5(base))
        return NaN;
      if (typeof x === "bigint" || typeof base === "bigint") {
        const out24 = log5(Number(x), Number(base));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return Math.log(x) / Math.log(base);
    } catch (e) {
      return NaN;
    }
  }
  var vlog5 = vectorize5(log5);
  function mean5(arr, shouldDropNaNs) {
    return stats5(arr, { shouldDropNaNs }).mean;
  }
  function median5(arr, shouldDropNaNs) {
    return stats5(arr, { shouldDropNaNs, median: true }).median;
  }
  function mod5(a, b) {
    try {
      if (!isNumber5(a))
        return NaN;
      if (!isNumber5(b))
        return NaN;
      if (typeof a === "bigint" || typeof b === "bigint") {
        const out24 = mod5(Number(a), Number(b));
        try {
          return BigInt(out24);
        } catch (e) {
          return out24;
        }
      }
      return a % b;
    } catch (e) {
      return NaN;
    }
  }
  var vmod5 = vectorize5(mod5);
  function mode5(arr, shouldDropNaNs) {
    return stats5(arr, { shouldDropNaNs, mode: true }).mode;
  }
  function helper35() {
    const u1 = random5();
    const u2 = random5();
    return Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
  }
  function normal5(shape24) {
    if (isUndefined5(shape24))
      return helper35();
    return vapply5(ndarray5(shape24), helper35);
  }
  function ones5(shape24) {
    return vapply5(ndarray5(shape24), () => 1);
  }
  function permutationsIterator5(x, r) {
    function* helper54(x2, r2) {
      r2 = r2 || x2.length;
      if (x2.length === 1) {
        yield [x2];
        return;
      }
      for (const c of combinations5(x2, r2)) {
        if (!c.slice)
          continue;
        const state = zeros5(c.length);
        yield c;
        let i = 1;
        while (i < c.length) {
          if (state[i] < i) {
            if (i % 2 === 0) {
              const buf = c[0];
              c[0] = c[i];
              c[i] = buf;
            } else {
              const buf = c[state[i]];
              c[state[i]] = c[i];
              c[i] = buf;
            }
            yield c;
            state[i] += 1;
            i = 1;
          } else {
            state[i] = 0;
            i += 1;
          }
        }
      }
    }
    if (isDataFrame5(x) || isSeries5(x)) {
      return permutationsIterator5(x.values, r);
    }
    assert5(isArray5(x), "The `permutations` function only works on arrays, Series, and DataFrames!");
    if (isUndefined5(r)) {
      r = x.length;
    }
    assert5(isNumber5(r) && vint5(r) === r && r >= 0, "`r` must be a non-negative integer!");
    return helper54(flatten5(x), r);
  }
  function permutations5(x, r) {
    const out24 = [];
    for (const perm of permutationsIterator5(x, r)) {
      out24.push(perm.slice());
    }
    return out24;
  }
  function print5() {
    Object.keys(arguments).forEach((key) => {
      const x = arguments[key];
      if (isArray5(x)) {
        if (!isJagged5(x)) {
          const xShape = shape5(x);
          if (xShape.length === 1) {
            new Series5(x).print();
          } else if (xShape.length == 2) {
            new DataFrame5(x).print();
          } else {
            console.log(x);
          }
        } else {
          console.log(x);
        }
      } else if (isDataFrame5(x) || isSeries5(x)) {
        x.print();
      } else {
        console.log(x);
      }
    });
  }
  var helper45 = vectorize5((x, a, b, c, d) => {
    try {
      let resultShouldBeABigInt = false;
      for (const v of [x, a, b, c, d]) {
        if (!isNumber5(v)) {
          return NaN;
        }
        if (typeof v === "bigint") {
          resultShouldBeABigInt = true;
        }
      }
      if (resultShouldBeABigInt) {
        x = Number(x);
        a = Number(a);
        b = Number(b);
        c = Number(c);
        d = Number(d);
      }
      const num = (d - c) * (x - a);
      const den = b - a;
      if (den === 0)
        return NaN;
      const out24 = num / den + c;
      if (resultShouldBeABigInt) {
        try {
          return BigInt(out24);
        } catch (e) {
        }
      }
      return out24;
    } catch (e) {
      return NaN;
    }
  });
  function remap5(x, a, b, c, d) {
    if (isArray5(x) && isUndefined5(c) && isUndefined5(d)) {
      c = a;
      d = b;
      const results = stats5(x);
      a = results.min;
      b = results.max;
    }
    return helper45(x, a, b, c, d);
  }
  function round5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint")
        return x;
      return Math.round(x);
    } catch (e) {
      return NaN;
    }
  }
  var vround5 = vectorize5(round5);
  function sign5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint")
        return BigInt(sign5(Number(x)));
      if (x < 0)
        return -1;
      if (x > 0)
        return 1;
      return 0;
    } catch (e) {
      return NaN;
    }
  }
  var vsign5 = vectorize5(sign5);
  function sin5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.sin(x);
    } catch (e) {
      return NaN;
    }
  }
  var vsin5 = vectorize5(sin5);
  function some5(x, fn) {
    if (isDataFrame5(x) || isSeries5(x)) {
      return some5(x.values, fn);
    }
    assert5(isArray5(x), "The first argument passed into the `some` function must be an array, Series, or DataFrame!");
    assert5(isFunction5(fn), "The second argument passed into the `some` function must be a function!");
    for (const v of x) {
      if (isArray5(v)) {
        if (some5(v, fn)) {
          return true;
        }
      } else {
        if (fn(v)) {
          return true;
        }
      }
    }
    return false;
  }
  function std5(arr, shouldDropNaNs) {
    return stats5(arr, { shouldDropNaNs, stdev: true }).stdev;
  }
  function stdev5(x) {
    return std5(x);
  }
  function tan5(x) {
    try {
      if (!isNumber5(x))
        return NaN;
      if (typeof x === "bigint") {
        x = Number(x);
      }
      return Math.tan(x);
    } catch (e) {
      return NaN;
    }
  }
  var vtan5 = vectorize5(tan5);
  function timeSync5(fn, args) {
    assert5(isFunction5(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      fn(...args);
    } else {
      fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  async function timeAsync5(fn, args) {
    assert5(isFunction5(fn), "`fn` must be a function!");
    const start = /* @__PURE__ */ new Date();
    if (args) {
      await fn(...args);
    } else {
      await fn();
    }
    return /* @__PURE__ */ new Date() - start;
  }
  function union5() {
    return set5([...arguments].map((v) => {
      if (isArray5(v))
        return v;
      if (isDataFrame5(v))
        return v.values;
      if (isSeries5(v))
        return v.values;
      return [v];
    }));
  }
  function variance5(arr, shouldDropNaNs) {
    return stats5(arr, { shouldDropNaNs, variance: true }).variance;
  }
  function zip5() {
    const out24 = [];
    const arrays = Object.values(arguments).map((arr) => {
      if (isDataFrame5(arr) || isSeries5(arr)) {
        arr = arr.values;
      }
      assert5(isArray5(arr), "The `zip` function only works on arrays, Series, and DataFrames!");
      return arr;
    });
    range5(0, max5(arrays.map((arr) => arr.length))).forEach((i) => {
      const row = [];
      arrays.forEach((arr) => {
        const value = arr[i];
        row.push(isUndefined5(value) ? void 0 : value);
      });
      out24.push(row);
    });
    return out24;
  }
  var out5 = {
    abs: vabs5,
    add: vadd5,
    apply: vapply5,
    arccos: varccos5,
    arcsin: varcsin5,
    arctan: varctan5,
    argmax: argmax5,
    argmin: argmin5,
    assert: assert5,
    cast: cast5,
    ceil: vceil5,
    chop: vchop5,
    clamp: vclamp5,
    combinations: combinations5,
    combinationsIterator: combinationsIterator5,
    copy: copy5,
    correl: correl5,
    cos: vcos5,
    count: count5,
    covariance: covariance5,
    DataFrame: DataFrame5,
    dataTypes: dataTypes5,
    decycle: decycle5,
    diff: diff5,
    distance: distance5,
    divide: divide5,
    dot: dot5,
    dropMissing: dropMissing5,
    dropMissingPairwise: dropMissingPairwise5,
    dropNaN: dropNaN5,
    dropNaNPairwise: dropNaNPairwise5,
    dropUndefined: dropUndefined5,
    every: every5,
    exp: vexp5,
    factorial: vfactorial5,
    find: find5,
    findAll: findAll5,
    flatten: flatten5,
    float: vfloat5,
    floor: vfloor5,
    identity: identity5,
    IndexMatcher: IndexMatcher5,
    indexOf: indexOf5,
    inferType: inferType5,
    int: vint5,
    intersect: intersect5,
    inverse: inverse5,
    isArray: isArray5,
    isBoolean: isBoolean5,
    isBrowser: isBrowser25,
    isDataFrame: isDataFrame5,
    isDate: isDate5,
    isEqual: isEqual5,
    isFunction: isFunction5,
    isJagged: isJagged5,
    isNested: isNested5,
    isNumber: isNumber5,
    isObject: isObject5,
    isSeries: isSeries5,
    isString: isString5,
    isUndefined: isUndefined5,
    lerp: vlerp5,
    log: vlog5,
    MathError: MathError5,
    max: max5,
    mean: mean5,
    median: median5,
    min: min5,
    mod: vmod5,
    mode: mode5,
    multiply: vmultiply5,
    ndarray: ndarray5,
    normal: normal5,
    ones: ones5,
    permutations: permutations5,
    permutationsIterator: permutationsIterator5,
    pow: vpow5,
    print: print5,
    product: product5,
    random: random5,
    range: range5,
    remap: remap5,
    reshape: reshape5,
    reverse: reverse5,
    round: vround5,
    scale: scale5,
    seed: seed5,
    Series: Series5,
    set: set5,
    shape: shape5,
    shuffle: shuffle5,
    sign: vsign5,
    sin: vsin5,
    some: some5,
    sort: sort5,
    sqrt: vsqrt5,
    stats: stats5,
    std: std5,
    stdev: stdev5,
    subtract: subtract5,
    sum: sum5,
    tan: vtan5,
    timeAsync: timeAsync5,
    timeSync: timeSync5,
    time: timeSync5,
    transpose: transpose5,
    union: union5,
    variance: variance5,
    vectorize: vectorize5,
    zeros: zeros5,
    zip: zip5,
    dump() {
      const context4 = typeof globalThis !== "undefined" ? globalThis : typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : void 0;
      if (!context4) {
        throw new out5.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");
      }
      Object.keys(out5).forEach((key) => {
        try {
          Object.defineProperty(context4, key, {
            configurable: false,
            enumerable: true,
            writable: false,
            value: out5[key]
          });
        } catch (e) {
          context4[key] = out5[key];
        }
      });
    }
  };
  if (typeof window !== "undefined") {
    window.JSMathTools = out5;
  }
  function makeKey44(keyLength, keySeed, charset) {
    if (arguments.length === 2) {
      if (isNumber5(arguments[1])) {
        charset = null;
      } else {
        charset = keySeed;
        keySeed = null;
      }
    }
    assert5(
      isNumber5(keyLength) && vint5(keyLength) === keyLength,
      "`keyLength` must be an integer!"
    );
    if (keySeed) {
      assert5(
        isNumber5(keySeed) && vint5(keySeed) === keySeed,
        "`keySeed` must be an integer!"
      );
      seed5(keySeed);
    }
    if (charset) {
      assert5(isString5(charset), "`charset` must be a string!");
    }
    let out24 = "";
    charset = charset || "abcdefg1234567890";
    for (let i = 0; i < keyLength; i++) {
      out24 += charset[vint5(random5() * charset.length)];
    }
    return out24;
  }
  if (typeof window !== "undefined") {
    window.makeKey = makeKey44;
  }

  // src/document/word-count-map.mjs
  var WordCountMap = class extends Map {
    constructor(data) {
      super();
      data = data || {};
      Object.keys(data).forEach((key) => {
        this.set(key, data[key]);
      });
    }
    delete(key) {
      if (typeof key !== "string") {
        throw new Error(
          `The \`delete\` method of a \`WordCountMap\` instance can only accept keys that are strings!`
        );
      }
      return super.delete(key);
    }
    get(key) {
      if (typeof key !== "string") {
        throw new Error(
          `The \`get\` method of a \`WordCountMap\` instance can only accept keys that are strings!`
        );
      }
      return super.get(key);
    }
    has(key) {
      if (typeof key !== "string") {
        throw new Error(
          `The \`has\` method of a \`WordCountMap\` instance can only accept keys that are strings!`
        );
      }
      return super.has(key);
    }
    set(key, value) {
      if (typeof key !== "string") {
        throw new Error(
          `The \`set\` method of a \`WordCountMap\` instance can only accept keys that are strings!`
        );
      }
      if (!isWholeNumber3(value)) {
        throw new Error(
          `The \`set\` method of a \`WordCountMap\` instance can only accept values that are whole numbers (i.e., non-negative integers)!`
        );
      }
      return super.set(key, value);
    }
    stringify() {
      return JSON.stringify(this.toObject(), ...arguments);
    }
    toObject() {
      const out6 = {};
      Array.from(this.keys()).forEach((key) => {
        out6[key] = this.get(key);
      });
      return out6;
    }
  };

  // src/document/index.mjs
  var WholeNumberType = createType("WholeNumber", isWholeNumber3);
  var Document = class {
    constructor(data) {
      data = data || {};
      defineTypedProperty(this, "cleaned", "string");
      this.cleaned = data.cleaned || "";
      defineTypedProperty(this, "hasBeenIndexed", "boolean");
      this.hasBeenIndexed = data.hasBeenIndexed || false;
      defineTypedProperty(this, "id", "string");
      this.id = data.id || "";
      defineTypedProperty(this, "maxNgramLength", WholeNumberType);
      this.maxNgramLength = typeof data.maxNgramLength === "undefined" ? Infinity : data.maxNgramLength;
      defineTypedProperty(this, "name", "string");
      this.name = data.name || makeKey44(32);
      defineTypedProperty(this, "ngrams", StringSet);
      this.ngrams = new StringSet(data.ngrams || []);
      defineTypedProperty(this, "raw", "string");
      this.raw = data.raw || "";
      defineTypedProperty(this, "totalWordCount", WholeNumberType);
      this.totalWordCount = data.totalWordCount || 0;
      defineTypedProperty(this, "wordCounts", WordCountMap);
      this.wordCounts = new WordCountMap(data.wordCounts || {});
      defineTypedProperty(this, "words", StringSet);
      this.words = new StringSet(data.words || []);
    }
    getWordCount(word) {
      if (!this.hasBeenIndexed) {
        throw new Error(
          `The document "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`
        );
      }
      return this.wordCounts.get(word) || 0;
    }
    async index(progress) {
      this.id = await hash(this.raw);
      this.cleaned = clean(this.raw);
      const allWords = this.cleaned.split(" ");
      this.totalWordCount = allWords.length;
      const unsortedWordSet = set2(allWords);
      this.words = new StringSet(unsortedWordSet);
      allWords.forEach((word, i) => {
        const count6 = this.wordCounts.get(word);
        if (typeof count6 === "undefined") {
          this.wordCounts.set(word, 1);
        } else {
          this.wordCounts.set(word, count6 + 1);
        }
        if (progress) progress(0.5 * i / allWords.length);
      });
      const nMax = Math.min(unsortedWordSet.length, this.maxNgramLength);
      for (let n = 2; n <= nMax; n++) {
        for (let i = 0; i < unsortedWordSet.length - n; i++) {
          const phrase = unsortedWordSet.slice(i, i + n).join(" ");
          this.ngrams.add(phrase);
          if (progress) {
            progress(0.5 + 0.5 * ((n + i / (unsortedWordSet.length - n)) / nMax));
          }
        }
      }
      if (progress) progress(1);
      this.hasBeenIndexed = true;
      return this;
    }
    stringify() {
      return JSON.stringify(this.toObject(), ...arguments);
    }
    toObject() {
      return {
        cleaned: this.cleaned,
        hasBeenIndexed: this.hasBeenIndexed,
        id: this.id,
        maxNgramLength: this.maxNgramLength,
        name: this.name,
        ngrams: this.ngrams.toSortedArray(),
        raw: this.raw,
        totalWordCount: this.totalWordCount,
        wordCounts: this.wordCounts.toObject(),
        words: this.words.toSortedArray()
      };
    }
  };

  // src/corpus/index.mjs
  var WholeNumberType2 = createType("WholeNumber", isWholeNumber3);
  var Scoring = {
    TF_BINARY: "TF_BINARY",
    TF_RAW_COUNT: "TF_RAW_COUNT",
    TF_TERM_FREQUENCY: "TF_TERM_FREQUENCY",
    TF_LOG_NORMALIZATION: "TF_LOG_NORMALIZATION",
    TF_DOUBLE_NORMALIZATION_K: "TF_DOUBLE_NORMALIZATION_K",
    IDF_UNARY: "IDF_UNARY",
    IDF_INVERSE_DOCUMENT_FREQUENCY: "IDF_INVERSE_DOCUMENT_FREQUENCY",
    IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH: "IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH",
    IDF_INVERSE_DOCUMENT_FREQUENCY_MAX: "IDF_INVERSE_DOCUMENT_FREQUENCY_MAX",
    IDF_PROBABILISTIC_INVERSE_DOCUMENT_FREQUENCY: "IDF_PROBABILISTIC_INVERSE_DOCUMENT_FREQUENCY"
  };
  var ScoringType = createType("Scoring", (v) => !!Scoring[v]);
  var ZeroToOneNumberType = createType(
    "ZeroToOneNumber",
    (v) => typeof v === "number" && !isNaN(v) && v >= 0 && v <= 1
  );
  var Corpus = class {
    static Scoring = Scoring;
    constructor(data) {
      data = data || {};
      const docs = createTypedArray(Document).from(
        data.docs ? data.docs.map((doc) => new Document(doc)) : []
      );
      defineTypedProperty(this, "docs", docs.constructor);
      this.docs = docs;
      defineTypedProperty(this, "hasBeenIndexed", "boolean");
      this.hasBeenIndexed = data.hasBeenIndexed || false;
      defineTypedProperty(this, "maxNgramLength", WholeNumberType2);
      this.maxNgramLength = typeof data.maxNgramLength === "undefined" ? 0 : data.maxNgramLength;
      defineTypedProperty(this, "name", "string");
      this.name = data.name || "Untitled corpus";
      defineTypedProperty(this, "ngrams", StringSet);
      this.ngrams = new StringSet(data.ngrams || []);
      defineTypedProperty(this, "words", StringSet);
      this.words = new StringSet(data.words || []);
      defineTypedProperty(this, "tfScoringMethod", ScoringType);
      this.tfScoringMethod = data.tfScoringMethod || Scoring.TF_LOG_NORMALIZATION;
      defineTypedProperty(
        this,
        "tfScoringDoubleNormalizationK",
        ZeroToOneNumberType
      );
      this.tfScoringDoubleNormalizationK = typeof data.tfScoringDoubleNormalizationK === "undefined" ? 0.5 : data.tfScoringDoubleNormalizationK;
      defineTypedProperty(this, "idfScoringMethod", ScoringType);
      this.idfScoringMethod = data.idfScoringMethod || Scoring.IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH;
    }
    computeDocumentSimilarity(doc1, doc2) {
      if (!this.hasBeenIndexed) {
        throw new Error(
          `The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`
        );
      }
      const vec1 = [];
      const vec2 = [];
      this.words.forEach((word) => {
        vec1.push(this.computeTFIDFScore(word, doc1));
        vec2.push(this.computeTFIDFScore(word, doc2));
      });
      return cosineSimilarity(vec1, vec2);
    }
    computeIDFScore(word) {
      if (!this.hasBeenIndexed) {
        throw new Error(
          `The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`
        );
      }
      if (this.idfScoringMethod === Scoring.IDF_UNARY) {
        return 1;
      }
      const df = this.docs.filter((doc) => doc.getWordCount(word) > 0).length;
      if (this.idfScoringMethod === Scoring.IDF_INVERSE_DOCUMENT_FREQUENCY) {
        return Math.log(this.docs.length / (df + 1));
      }
      if (this.idfScoringMethod === Scoring.IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH) {
        return Math.log(this.docs.length / (df + 1)) + 1;
      }
      if (this.idfScoringMethod === Scoring.IDF_INVERSE_DOCUMENT_FREQUENCY_MAX) {
        let maxDf = 0;
        this.words.toArray().forEach((word2) => {
          const tempDf = this.docs.filter(
            (doc) => doc.getWordCount(word2) > 0
          ).length;
          if (tempDf > maxDf) {
            maxDf = tempDf;
          }
        });
        return Math.log(maxDf / (df + 1));
      }
      if (this.idfScoringMethod === Scoring.IDF_PROBABILISTIC_INVERSE_DOCUMENT_FREQUENCY) {
        return Math.log((this.docs.length - df + 1) / (df + 1));
      }
    }
    computeTFIDFScore(word, doc) {
      if (!this.hasBeenIndexed) {
        throw new Error(
          `The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`
        );
      }
      return this.computeTFScore(word, doc) * this.computeIDFScore(word);
    }
    computeTFScore(word, doc) {
      if (!this.hasBeenIndexed) {
        throw new Error(
          `The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`
        );
      }
      if (this.tfScoringMethod === Scoring.TF_BINARY) {
        return doc.getWordCount(word) > 0 ? 1 : 0;
      }
      if (this.tfScoringMethod === Scoring.TF_RAW_COUNT) {
        return doc.getWordCount(word);
      }
      if (this.tfScoringMethod === Scoring.TF_TERM_FREQUENCY) {
        return doc.getWordCount(word) / doc.totalWordCount;
      }
      if (this.tfScoringMethod === Scoring.TF_LOG_NORMALIZATION) {
        return Math.log(1 + doc.getWordCount(word));
      }
      if (this.tfScoringMethod === Scoring.TF_DOUBLE_NORMALIZATION_K) {
        let mostFrequentWordCount = 0;
        doc.words.forEach((otherWord) => {
          const count6 = doc.getWordCount(otherWord);
          if (count6 > mostFrequentWordCount) {
            mostFrequentWordCount = count6;
          }
        });
        return this.tfScoringDoubleNormalizationK + (1 - this.tfScoringDoubleNormalizationK) * doc.getWordCount(word) / mostFrequentWordCount;
      }
    }
    getWordCounts(word) {
      if (!this.hasBeenIndexed) {
        throw new Error(
          `The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`
        );
      }
      return this.docs.map((doc) => {
        return {
          doc: { name: doc.name, id: doc.id },
          count: doc.getWordCount(word)
        };
      });
    }
    async index(progress) {
      for (let i = 0; i < this.docs.length; i++) {
        const doc = this.docs[i];
        await doc.index(
          progress ? (p) => progress((i + p) / this.docs.length) : null
        );
      }
      this.hasBeenIndexed = true;
      return this;
    }
    stringify() {
      return JSON.stringify(this.toObject(), ...arguments);
    }
    toObject() {
      return {
        docs: this.docs.map((doc) => doc.toObject(...arguments)),
        hasBeenIndexed: this.hasBeenIndexed,
        idfScoringMethod: this.idfScoringMethod,
        maxNgramLength: this.maxNgramLength,
        name: this.name,
        ngrams: this.ngrams.toSortedArray(),
        tfScoringDoubleNormalizationK: this.tfScoringDoubleNormalizationK,
        tfScoringMethod: this.tfScoringMethod,
        words: this.words.toSortedArray()
      };
    }
  };

  // src/index.mjs
  if (typeof window !== "undefined") {
    window.JSNLPTools = { Corpus, Document };
  }
})();
