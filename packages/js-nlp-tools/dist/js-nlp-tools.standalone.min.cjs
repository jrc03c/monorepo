(()=>{var gg=Object.create;var Ac=Object.defineProperty;var pg=Object.getOwnPropertyDescriptor;var yg=Object.getOwnPropertyNames;var bg=Object.getPrototypeOf,vg=Object.prototype.hasOwnProperty;var Et=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var Ng=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let o of yg(t))!vg.call(e,o)&&o!==n&&Ac(e,o,{get:()=>t[o],enumerable:!(r=pg(t,o))||r.enumerable});return e};var Dt=(e,t,n)=>(n=e!=null?gg(bg(e)):{},Ng(t||!e||!e.__esModule?Ac(n,"default",{value:e,enumerable:!0}):n,e));function Uc(e){if(typeof e!="string")throw new Error("`text` must be a string!");e=e.trim();let t="",n=!1;for(let r=0;r<e.length;r++){let o=e[r];o.match(/[A-Za-z0-9]/g)?(t.length===0?t+=o.toLowerCase():n?t+=o.toUpperCase():t+=o,n=!1):!o.includes("'")&&!o.includes("\u2019")&&!o.includes("\u275C")&&(n=!0)}return t}var wg=Object.defineProperty,Eg=(e,t,n)=>t in e?wg(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Lc=(e,t,n)=>(Eg(e,typeof t!="symbol"?t+"":t,n),n);function C(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Dg=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),ur=class extends Error{constructor(e){Dg()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function g(e,t){if(!e)throw new ur(t)}var Vc=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function Y(e){return e===null||typeof e>"u"}var Sg=Vc.map(e=>e.name);function D(e){try{return e instanceof Array?!0:Y(e.constructor)?!1:Vc.indexOf(e.constructor)>-1||Sg.indexOf(e.constructor.name)>-1}catch{return!1}}function X(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function qe(e){return typeof e=="function"}function gn(e){return typeof e=="object"&&!Y(e)&&!D(e)}function V(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function Jr(e,t){if(X(e)){let u=Jr(e.values,t);return u.length>0&&C(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&C(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(V(e)){let u=Jr(e.values,t);return u.length>0&&C(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(g(gn(e)||D(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!qe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(gn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(D(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function tt(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(D(n))return n instanceof Array?n.map(o=>tt(o)):n.slice();if(V(n)){let o=n.copy();return o.values=tt(o.values),o}if(X(n)){let o=n.copy();return o.values=tt(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=pr(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=tt(n[o])}),r}else return n}return t(pr(e))}function pr(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+Jr(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),D(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(X(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(V(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function Zt(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var Ic=["number","int","float","bigint"];function pn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!Ic.includes(u)&&!Ic.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(Zt(r))return Zt(o)?r.getTime()===o.getTime():!1;if(Zt(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(D(r)!==D(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(pr(e),pr(t))}}function Vo(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Og=Vo(16),Fg=Vo(16),_g=Vo(16),Tg=Vo(16),Ag=Vo(16),Ig=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)D(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Og:Y(e)?Fg:qe(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Ag:e===1/0?_g:e===-1/0?Tg:typeof e=="bigint"?e.toString():X(e)?e.toJSONString():V(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!Y(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function Xt(e){if(X(e)||V(e))return Xt(e.values);g(D(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{D(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Tt(e,t){t=t||{};let n=new Ig,r={},o=Xt(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||C(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function es(e,t){let{counts:n}=Tt(e);return Y(t)||(qe(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{pn(r,t)||n.delete(r)})),n}function Zi(e){if(X(e)||V(e))return Zi(e.values);if(D(e)){let t=!1,n=!1,r=null;for(let o of e){if(Zi(o))return!0;if(D(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function zo(e){return Zi(pr(e))}function ss(e){if(X(e)||V(e))return ss(e.values);g(D(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(D(e[t]))return!0;return!1}var Pr="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Qt(e){g(!Y(e),Pr),D(e)||(e=[e]),g(!ss(e),Pr),g(e.length>0,Pr);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),g(C(t),Pr),g(t>=0,Pr),g(Math.floor(t)===t,Pr),g(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(Qt(e.slice(1)));return n}}function dn(e){if(X(e)||V(e)){let n=e.copy();return n.values=dn(n.values),n.index=dn(n.index),n}g(D(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Be(e,t,n=1){g(!Y(e)&&!Y(t)&&!Y(n),"You must pass two numbers and optionally a step value to the `range` function!"),g(C(e)&&C(t)&&C(n),"You must pass two numbers and optionally a step value to the `range` function!"),g(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=dn(u)),u}function Wo(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var jg=Wo(256),Cg=Wo(256),Mg=Wo(256),Bg=Wo(256),Pg=Wo(256);function Lt(e){if(X(e)||V(e))return Lt(e.values);g(D(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return Xt(e).forEach(r=>{let o=typeof r=="object"&&r===null?jg:Y(r)?Cg:qe(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Pg:r===1/0?Mg:r===-1/0?Bg:typeof r=="bigint"?r.toString():X(r)?r.toJSONString():V(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function zc(e){if(D(e)){let t=zc(e[0]);return[e.length].concat(t||[])}else return}function Z(e){return X(e)||V(e)?Z(e.values):(g(D(e),"The `shape` function only works on arrays, Series, and DataFrames!"),zc(e))}function Wc(e,t,n){if(Y(n)&&(n=0),g(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),D(t)){g(!zo(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=Z(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Be(0,o).forEach(s=>{s>=u._values.length&&u._values.push(Qt(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Be(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(Qt(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new ur("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(V(t)){let r=Wc(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(X(t))if(n===0){let r=e.copy(),o=Lt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(Qt(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(Qt(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new ur("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function Rg(e,t,n,r,o){if(o=o||0,g(qe(r),"The first parameter to the `apply` method must be a function."),g(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,Y(s)&&(s=c instanceof t||D(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return Y(u)&&(u=c instanceof t||D(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function he(e){return typeof e=="string"}function kg(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(Y(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(gn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new ur("You must pass a DataFrame, Series, or object into the `assign` method!")}else{g(he(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),g(D(o)&&!zo(o)&&Z(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function Yg(e,t){if(t.isEmpty)return new e;let n=new e(tt(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function Jg(e,t,n,r,o){Y(r)&&(r=[]),Y(o)&&(o=[]),(he(r)||C(r))&&(r=[r]),(he(o)||C(o))&&(o=[o]),g(D(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),g(D(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),g(Z(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),g(Z(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function Gc(e){return C(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function $r(e){return Gc(e)&&e>=0}function $g(e,t,n,r,o,u){r=r||0,g(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,g($r(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",g(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(Y(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(Y(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!Y(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(Z(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(Y(c))return new e;he(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function la(e){if(X(e)||V(e))return e.dropNaN(...Object.values(arguments).slice(1));g(D(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(la(n))}catch{if(C(n))return t.push(n)}}),t}function Kg(e,t,n,r,o){n=n||0,g(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,g($r(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",g(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=la(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function jc(e){let t={};return Xt(e).forEach((n,r)=>{t[n]=r}),t}function Rr(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function Ug(e,t,n,r,o){g(qe(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),Y(o)&&(o=0),g(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=jc(u.index),i=jc(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Rr(s)[0],c.index=Rr(i),c}u.values=l,u.index=Rr(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Rr(i)[0],c.index=Rr(s),c}u.values=l,u.index=Rr(i),u=u.transpose()}return u}function Lg(e,t,n){(he(t)||C(t))&&(t=[t]),(he(n)||C(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Lt((t||[]).concat(n||[]).map(o=>typeof o));return g(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&g(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(g(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),g(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Y(t)||(t=t.map(o=>{if(he(o))return g(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(C(o))return g(o>=0,`Index ${o} is out of bounds!`),g(Math.floor(o)===o,"Row numbers must be integers!"),g(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),Y(n)||(n=n.map(o=>{if(he(o))return g(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(C(o))return g(o>=0,`Column ${o} is out of bounds!`),g(Math.floor(o)===o,"Column numbers must be integers!"),g(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function Vg(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function yr(e,t){if(Y(t)&&(t=Vg),X(e)||V(e))return e.sort(...Object.values(arguments).slice(1));g(D(e),"The `sort` function only works on arrays, Series, and DataFrames!"),g(qe(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function zg(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function Cc(e,t,n){Y(n)?n=t.columns:he(n)&&(n=[n]);let r={};n.forEach(u=>{g(he(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);g(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=yr(Lt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+zg(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function Wg(e,t,n){let r=e.shape;Y(t)&&(t=Be(0,r[0])),Y(n)&&(n=Be(0,r[1])),C(t)&&(t=[t]),C(n)&&(n=[n]),g(D(t)&&D(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),g(Z(t).length===1&&Z(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),g(t.length>0,"The `rowIndices` array must contain at least one index."),g(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{g($r(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),g(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{g($r(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),g(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function Gg(e,t,n,r,o){Y(r)&&(r=n.index),Y(o)&&(o=n.columns),he(r)&&(r=[r]),he(o)&&(o=[o]),g(D(r)&&D(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),g(Z(r).length===1&&Z(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),g(r.length>0,"The `rows` array must contain at least one row name."),g(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{g(he(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),g(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{g(he(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),g(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function qg(e,t,n){function r(h,m){return he(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Be(0,u).concat(Be(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Be(0,i).concat(Be(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Be(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function kr(e,t){g(C(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function Hg(e,t){let n=t?e:e.copy();return n.index=Be(0,e.shape[0]).map(r=>"row"+kr(r,(n.index.length-1).toString().length)),n}function Go(e,t){if(X(e)||V(e))return Go(e.values,t);g(D(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=Xt(e),r=!1,o=1;for(let u of n){if(!C(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function Qg(e){return Gc(e)&&e>0}function Uo(e,t){if(X(e)||V(e))return Uo(e.values,t);if(g(D(e),"The first argument passed into the `reshape` function must be an array!"),C(t)&&(t=[t]),g(D(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),g(Z(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),g(Qg(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return Xt(e);let n=Xt(e);if(t.length===1&&t[0]===n.length)return n;g(Go(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(Uo(s,t.slice(1)))}return r}var qc=Math.pow(2,64),Fe=[];Hc(Math.floor(Math.random()*qc));function Zg(e,t){e=at(e);function n(){e+=at("0x9e3779b97f4a7c15");let o=tt(e);return o=(o^o>>BigInt(30))*at("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*at("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function at(e){return BigInt.asUintN(64,BigInt(e))}function Mc(e,t){return e=at(e),t=BigInt(t),at(at(e<<t)|at(e>>at(BigInt(64)-t)))}function Hc(e){if(typeof e=="bigint"&&(e=Number(e)),Y(e))return tt(Fe);{g(C(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=Zg(Math.floor(e),4);Fe[0]=t[0],Fe[1]=t[1],Fe[2]=t[2],Fe[3]=t[3]}}function Bc(){let e=at(Mc(Fe[0]+Fe[3],23)+Fe[0]),t=at(Fe[1]<<BigInt(17));return Fe[2]=at(Fe[2]^Fe[0]),Fe[3]=at(Fe[3]^Fe[1]),Fe[1]=at(Fe[1]^Fe[2]),Fe[0]=at(Fe[0]^Fe[3]),Fe[2]=at(Fe[2]^t),Fe[3]=Mc(Fe[3],45),Math.floor(Number(e))/qc}function Kr(e){return Y(e)?Bc():(D(e)||(e=[e]),Uo(Qt(Go(e)).map(Bc),e))}function ts(e){if(X(e)||V(e))return e.shuffle(...Object.values(arguments).slice(1));g(D(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(Kr()*n.length);t.push(n.splice(o,1)[0])}return t}function Xg(e,t){return Y(t)&&(t=0),g(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?ts(e.index):null,t===1?ts(e.columns):null)}function gr(e){return typeof e=="boolean"}function xg(e,t,n){return qe(t)?ep(e,t,n):tp(e,t,n)}function ep(e,t,n){if(n=Y(n)?0:n,g(qe(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),g(C(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=yr(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=yr(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function tp(e,t,n){let r=e.copy(),o=Kr().toString();r=r.assign(o,r.index),Y(t)&&(t=[o],n=[!0]),(C(t)||he(t))&&(t=[t],(gr(n)||he(n))&&(n=[n])),g(D(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),g(Z(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),Y(n)&&(n=Be(0,t.length).map(()=>!0)),g(D(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),g(Z(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),g(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(g(he(s)||C(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),he(s)){let i=r.columns.indexOf(s);return g(i>-1,`The column "${s}" does not exist!`),i}if(C(s))return g($r(s),"Column indices must be whole numbers!"),g(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(g(he(s)||gr(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),he(s)){let i=s.trim().toLowerCase();return g(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(gr(s))return s}),r.values=yr(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function np(e,t){Y(t)?t=0:g(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function Qc(e,t){return JSON.stringify(e.toObject(t))}async function rp(e,t,n){let r=Qc(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new ur(s):typeof module<"u"?new ur(i):new ur("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function op(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function Un(e){if(X(e)||V(e))return e.transpose();g(D(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=Z(e);if(g(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return dn(e);if(t.length===2){let n=Qt(dn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function Zc(e,t,n){if(V(n))return new e(t.values.concat(n.values));if(D(n)){let r=Z(n);g(r.length===1&&!ss(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return Zc(t,[n])}function up(e,t){g(qe(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function sp(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>Y(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function ip(e,t){let n=[],r=[];t.values.forEach((u,s)=>{C(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function ap(e,t,n){let r=t.copy(),o=tt(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function lp(e,t){(he(t)||C(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Lt((t||[]).map(r=>typeof r));return g(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&g(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(g(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),g(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),Y(t)||(t=t.map(r=>{if(typeof r=="string")return g(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return g(r>=0,`Index ${r} is out of bounds!`),g(Math.floor(r)===r,"Indices must be integers!"),g(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function cp(e,t){let n=e.shape;Y(t)&&(t=Be(0,n[0])),g(D(t),"The `indices` array must be 1-dimensional array of whole numbers."),g(Z(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),g(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{g($r(o),"The `indices` array must be a 1-dimensional array of whole numbers."),g(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function fp(e,t,n){Y(n)&&(n=t.index),g(D(n),"The `indices` array must be a 1-dimensional array of strings."),g(Z(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),g(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{g(he(u),"The `indices` array must contain only strings."),g(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function hp(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Be(0,n/2).concat(Be(t.index.length-n/2,t.index.length)));let o=tt(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function mp(e){let t=e.copy();return t.get(ts(t.index))}function dp(e,t,n){n=n||((a,l)=>a<l?-1:1),g(Y(n)||qe(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Un([t.values,t.index]),o=yr(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function gp(e,t){let n=Un([t.values,t.index]);n=Un(yr(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function pp(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Pc=Symbol.for("@jrc03c/js-math-tools/series");function yp(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Pc}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Pc}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){g(D(o),"The new values must be a 1-dimensional array!");let u=Z(o);g(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Be(this._index.length,u[0]).map(s=>"item"+kr(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){g(D(o),"The new index must be a 1-dimensional array of strings!"),g(o.length===this.shape[0],"The new index must be the same length as the old index!"),g(Z(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{g(he(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=tt(r.values),this.index=tt(r.index);else if(D(r)){let o=Z(r);g(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());g(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];g(Z(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return Z(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!Y(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return lp(this,r)}getSubsetByNames(r){return fp(t,this,r)}getSubsetByIndices(r){return cp(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(dn(this.values));return r.index=dn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Be(0,this.shape[0]).map(o=>"item"+kr(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=tt(this.values),r._index=tt(this.index),r.name=this.name,r}append(r){return Zc(t,this,r)}apply(r){return up(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return sp(this,r,o)}dropNaN(){return ip(t,this)}toObject(){return pp(this)}print(){return hp(this)}shuffle(){return mp(this)}sort(r){return dp(t,this,r)}sortByIndex(){return gp(t,this)}filter(r){return ap(t,this,r)}toDataFrame(){let r=new e(Un([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=dn(r.values),r.index=dn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Rc=Symbol.for("@jrc03c/js-math-tools/dataframe");function qu(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(Kr()*t.length)];return n}var Me=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Rc}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Rc}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!Y(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){g(D(t),"The new values must be a 2-dimensional array!");let n=Z(t);g(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Be(this._index.length,n[0]).map(r=>"row"+kr(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Be(this._columns.length,n[1]).map(r=>"col"+kr(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){g(D(t),"The new columns list must be a 1-dimensional array of strings!"),g(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),g(Z(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+qu(8):r.trim()));let n=(()=>{let r=es(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+qu(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){g(D(t),"The new index must be a 1-dimensional array of strings!"),g(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),g(Z(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+qu(8):r.trim()));let n=(()=>{let r=es(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+qu(8):r),this._index=t}}),g(Y(e)||gn(e)||D(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Me)this.values=tt(e.values),this.columns=tt(e.columns),this.index=tt(e.index);else if(D(e)){let t=Z(e);g(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),g(!zo(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{Y(r)&&(n=u,r=e[u].length),g(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=Un(t);let o=Z(this.values);this._index=Be(0,o[0]).map(u=>"row"+kr(u,(o[0]-1).toString().length))}}get shape(){return Z(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Me(Qt(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return Lg(this,e,t)}getSubsetByNames(e,t){return Gg(Me,gt,this,e,t)}getSubsetByIndices(e,t){return Wg(this,e,t)}getDummies(e){return Cc(Me,this,e)}oneHotEncode(e){return Cc(Me,this,e)}transpose(){let e=new Me(Un(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return Hg(this,e)}copy(){return Yg(Me,this)}assign(e,t){return kg(Me,gt,this,e,t)}apply(e,t){return Rg(Me,gt,this,e,t)}dropMissing(e,t,n){return $g(Me,gt,this,e,t,n)}dropNaN(e,t,n){return Kg(Me,this,e,t,n)}drop(e,t){return Jg(Me,gt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return np(this,e)}toObject(){return op(this)}toJSONString(e){return Qc(this,e)}saveAsJSON(e,t){return rp(this,e,t)}print(){return qg(Me,gt,this)}sort(e,t){return xg(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return Ug(Me,gt,this,e,t)}shuffle(e){return Xg(this,e)}append(e,t){return Wc(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},gt=yp(Me);function is(e,t){return Tt(e,{shouldDropNaNs:t}).max}function pe(e){return g(qe(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return D(a)?!0:V(a)?(n=!0,o.push(a),!0):X(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{g(pn(D(i)?Z(i):i.shape,D(s[a+1])?Z(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=is(s.map(l=>l.length?l.length:l.values.length)),a=Be(0,i).map(l=>{let c=Object.keys(arguments).map(f=>D(arguments[f])?arguments[f][l]:V(arguments[f])||X(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&pn(Z(u[0]),Z(a))){let l=new Me(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Me(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new gt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new gt(a)}catch{return a}return a}else return e(...arguments)}}function bp(e){try{return C(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var ca=pe(bp);function vp(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!C(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var ns=pe(vp);function Np(e,t){try{return t(e)}catch{return NaN}}var as=pe(Np);function wp(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var Ep=pe(wp);function Dp(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var Sp=pe(Dp);function Op(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var Fp=pe(Op);function Xi(e,t){if(X(e)){let n=Xi(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(V(e)){let n=Xi(e.values,t);return e.index[n]}g(D(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=Jr(e,is(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Xc(e,t){return Tt(e,{shouldDropNaNs:t}).min}function xi(e,t){if(X(e)){let n=xi(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(V(e)){let n=xi(e.values,t);return e.index[n]}g(D(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=Jr(e,Xc(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function _t(e,t){if(X(e)||V(e))return e.apply(n=>_t(n,t));if(D(e))return e.map(n=>_t(n,t));if(t==="null")return null;if(t==="number"){if(Y(e))return NaN;let n=_t(e,"boolean");if(gr(n))return n?1:0;try{JSON.parse(e)}catch{let u=_t(e,"date");if(Zt(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=_t(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return _t(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(_t(e,"int"));if(t==="boolean"){if(gr(e))return e;if(C(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Zt(e))return e;if(Y(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return Zt(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(gn(e))return e;let n=_t(e,"boolean");if(gr(n))return null;try{let o=_t(e,"number");if(C(o))return JSON.parse(e),null}catch{}let r=_t(e,"date");if(r)return r;try{let o=JSON.parse(e);return D(o)?o.map(u=>_t(u,t)):o}catch{return null}}if(t==="string")return Y(e)?pn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function _p(e){try{return C(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var Tp=pe(_p);function Ap(e,t){try{if(!C(e))return NaN;if(typeof e=="bigint")return e;if(Y(t))t=1e-10;else if(!C(t))return NaN;return ca(e)<t?0:e}catch{return NaN}}var Ip=pe(Ap);function ea(e){if(X(e)||V(e)){let t=e.copy();return t.values=ea(t.values),t}if(D(e))return e.map(t=>ea(t));try{let t=JSON.parse(e);return C(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var yn=pe(ea);function xc(e,t,n){try{return C(e)?C(t)?C(n)?typeof e=="bigint"?BigInt(xc(yn(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var jp=pe(xc);function rs(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of rs(i,o-1))yield[s].concat(a)}}return X(e)||V(e)?rs(e.values,t):(g(D(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),g(C(t)&&yn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Xt(e),t))}function ef(e,t){let n=[];for(let r of rs(e,t))n.push(r.slice());return n}function tf(){let e=Object.values(arguments).map(n=>X(n)||V(n)?Lt(n.values):(g(D(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Lt(n)));return Lt(e).filter(n=>e.every(r=>r.findIndex(o=>pn(o,n))>-1))}var Jo=class{constructor(e){g(Y(e)||e===Jo.DROP_NAN_MODE||e===Jo.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=Y(e)?Jo.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(D(t)){let n=Z(t);if(n.length===1)t=new gt(t);else if(n.length===2)t=new Me(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}g(X(t)||V(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===Jo.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=tf(...e),this}transform(){g(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(D(t)){let n=Z(t);if(n.length===1)return new gt(t).get(this.index).values;if(n.length===2)return new Me(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return g(X(t)||V(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},ls=Jo;Lc(ls,"DROP_NAN_MODE","DROP_NAN_MODE");Lc(ls,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Ko(e,t,n,r){if(V(e))return Ko(e.values,t,n,r);if(V(t))return Ko(e,t.values,n,r);if(g(D(e)&&D(t)&&Z(e).length===1&&Z(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),g(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Ko(...new ls().fitAndTransform(e,t),!1,r);try{let o=Tt(e,{stdev:r}),u=Tt(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!C(s)||!C(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!C(f))return NaN;if(!C(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function ta(e,t,n){if(V(e))return ta(e.values,t,n);if(V(t))return ta(e,t.values,n);g(D(e)&&D(t)&&Z(e).length===1&&Z(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),g(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Ko(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function Cp(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var Mp=pe(Cp),Bp=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function na(e,t){if(X(e)||V(e))return na(e.values,t);if(X(t)||V(t))return na(e,t.values);g(D(e)&&D(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Lt(e),r=Lt(t),o=[];return n.forEach(u=>{r.findIndex(s=>pn(s,u))<0&&o.push(u)}),o}function nf(e,t){try{if(!C(e))return NaN;if(!C(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=nf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var fa=pe(nf);function rf(e){try{if(!C(e))return NaN;if(typeof e=="bigint"){let t=rf(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var of=pe(rf);function Pp(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!C(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var uf=pe(Pp);function Ur(){return uf(...arguments)}function sf(e,t){return ns(e,Ur(t,-1))}function ha(e,t){return Tt(e,{shouldDropNaNs:t}).sum}function ra(e,t){if(C(e)&&C(t))return ca(e-t);if(X(e)||V(e))return ra(e.values,t);if(X(t)||V(t))return ra(e,t.values);D(e)&&D(t)&&g(pn(Z(e),Z(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return of(ha(fa(sf(e,t),2)))}catch{return NaN}}function Rp(e,t){return Ur(e,fa(t,-1))}function Kn(e,t){if(X(e)){let o=Kn(e.values,t);if(Z(o).length===1){let u=new gt(o);return u.name=V(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Me(o);return u.index=e.index.slice(),X(t)&&(u.columns=t.columns.slice()),u}}if(X(t)){let o=Kn(e,t.values);if(Z(o).length===1){let u=new gt(o);return u.name=V(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Me(o);return u.columns=t.columns.slice(),u}}if(V(e))return Kn(e.values,t);if(V(t))return Kn(e,t.values);g(D(e)&&D(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=Z(e),r=Z(t);if(g(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),g(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return ha(Ur(e,t));if(n.length===1&&r.length===2)return Un(t).map(o=>Kn(e,o));if(n.length===2&&r.length===1)return e.map(o=>Kn(o,t));if(n.length===2&&r.length===2){let o=Un(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(Kn(e[s],o[a]));u.push(i)}return u}}function ma(e){if(X(e)||V(e))return e.dropMissing(...Object.values(arguments).slice(1));g(D(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(ma(n))}catch{Y(n)||t.push(n)}}),t}function Qu(e,t){if(X(e)||V(e))return Qu(e.values,t);if(X(t)||V(t))return Qu(e,t.values);g(D(e)&&D(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),g(pn(Z(e),Z(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Qu(e[o],t[o]);n.push(u),r.push(s)}catch{!Y(e[o])&&!Y(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function Zu(e,t){if(X(e)||V(e))return Zu(e.values,t);if(X(t)||V(t))return Zu(e,t.values);g(D(e)&&D(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),g(pn(Z(e),Z(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Zu(e[o],t[o]);n.push(u),r.push(s)}catch{C(e[o])&&C(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function kp(e){return ma(e)}function os(e,t){if(X(e)||V(e))return os(e.values,t);g(D(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),g(qe(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(D(n)){if(!os(n,t))return!1}else if(!t(n))return!1;return!0}function Yp(e){try{if(!C(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var Jp=pe(Yp);function oa(e){try{return typeof e=="bigint"?BigInt(oa(yn(e))):e!==yn(e)?NaN:e<=1?1:e*oa(e-1)}catch{return NaN}}var $p=pe(oa);function ua(e,t){if(X(e)||V(e))return ua(e.values,t);if(g(gn(e)||D(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!qe(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(gn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(D(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function sa(e,t){if(X(e)||V(e))return sa(e.values,t);if(g(gn(e)||D(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!qe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(gn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(D(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function Kp(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return C(t)?t:NaN}catch{return NaN}}var Up=pe(Kp);function Lp(e){try{return C(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var Vp=pe(Lp);function da(e){C(e)&&(e=[e]);let t=[],n=Go(e);for(let r=0;r<n;r++)t.push(0);return Uo(t,e)}function zp(e){typeof e=="bigint"&&(e=yn(e)),g(!Y(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),g(C(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),g(yn(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),g(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=da([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var Wp=["true","false","yes","no"],Gp=["null","none","nan","na","n/a","","undefined"];function Hu(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=yn(e.value)===e.value:e.isInteger=os(e.values,t=>C(t)?yn(t)===t:!0)),e}function Xu(e){if(X(e)){let u=e.copy(),s=Xu(e.values);return u.values=s.values,Hu({type:s.type,values:u})}if(V(e)){let u=e.copy(),s=Xu(e.values);return u.values=s.values,Hu({type:s.type,values:u})}if(!D(e)){let u=Xu([e]);return u.value=u.values[0],delete u.values,Hu(u)}g(D(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=Xt(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(Zt(a))return"date"}}catch{}he(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(Gp.indexOf(i)>-1)return"null";if(Wp.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return C(a)?"number":typeof a=="object"?D(a)?"string":"object":"string"}catch{let l=new Date(u);return Zt(l)?"date":"string"}}),n=es(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return Hu({type:o,values:as(e,u=>_t(u,o))})}function xu(e){if(X(e)){let n=e.copy();return n.values=xu(n.values),n}g(D(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=Z(e);if(g(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),g(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),g(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){g(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;g(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return Ur(i,1/s)}else if(t[0]>1){let n=(r,o)=>C(r)||C(o)?Ur(r,o):Kn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=xu(o),l=xu(ns(i,n(-1,n(n(s,a),u)))),c=ns(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}g(!1,"This matrix cannot be inverted!")}}var qp=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function af(e,t,n){try{if(!C(e))return NaN;if(!C(t))return NaN;if(!C(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=af(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var Hp=pe(af);function lf(e,t){try{if(t=Y(t)?Math.E:t,!C(e))return NaN;if(!C(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=lf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var Qp=pe(lf);function Zp(e,t){return Tt(e,{shouldDropNaNs:t}).mean}function Xp(e,t){return Tt(e,{shouldDropNaNs:t,median:!0}).median}function cf(e,t){try{if(!C(e))return NaN;if(!C(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=cf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var xp=pe(cf);function ey(e,t){return Tt(e,{shouldDropNaNs:t,mode:!0}).mode}function kc(){let e=Kr(),t=Kr();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function ty(e){return Y(e)?kc():as(Qt(e),kc)}function ny(e){return as(Qt(e),()=>1)}function ga(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of ef(r,o)){if(!u.slice)continue;let s=da(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return X(e)||V(e)?ga(e.values,t):(g(D(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),Y(t)&&(t=e.length),g(C(t)&&yn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Xt(e),t))}function ry(e,t){let n=[];for(let r of ga(e,t))n.push(r.slice());return n}function oy(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(D(t))if(zo(t))console.log(t);else{let n=Z(t);n.length===1?new gt(t).print():n.length==2?new Me(t).print():console.log(t)}else X(t)||V(t)?t.print():console.log(t)})}var uy=pe((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!C(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function sy(e,t,n,r,o){if(D(e)&&Y(r)&&Y(o)){r=t,o=n;let u=Tt(e);t=u.min,n=u.max}return uy(e,t,n,r,o)}function iy(e){try{return C(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var ay=pe(iy);function ff(e){try{return C(e)?typeof e=="bigint"?BigInt(ff(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var ly=pe(ff);function cy(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var fy=pe(cy);function ia(e,t){if(X(e)||V(e))return ia(e.values,t);g(D(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),g(qe(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(D(n)){if(ia(n,t))return!0}else if(t(n))return!0;return!1}function hf(e,t){return Tt(e,{shouldDropNaNs:t,stdev:!0}).stdev}function hy(e){return hf(e)}function my(e){try{return C(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var dy=pe(my);function Yc(e,t){g(qe(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function gy(e,t){g(qe(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function py(){return Lt([...arguments].map(e=>D(e)?e:X(e)||V(e)?e.values:[e]))}function yy(e,t){return Tt(e,{shouldDropNaNs:t,variance:!0}).variance}function by(){let e=[],t=Object.values(arguments).map(n=>((X(n)||V(n))&&(n=n.values),g(D(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Be(0,is(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(Y(u)?void 0:u)}),e.push(r)}),e}var $o={abs:ca,add:ns,apply:as,arccos:Ep,arcsin:Sp,arctan:Fp,argmax:Xi,argmin:xi,assert:g,cast:_t,ceil:Tp,chop:Ip,clamp:jp,combinations:ef,combinationsIterator:rs,copy:tt,correl:ta,cos:Mp,count:es,covariance:Ko,DataFrame:Me,dataTypes:Bp,decycle:pr,diff:na,distance:ra,divide:Rp,dot:Kn,dropMissing:ma,dropMissingPairwise:Qu,dropNaN:la,dropNaNPairwise:Zu,dropUndefined:kp,every:os,exp:Jp,factorial:$p,find:ua,findAll:sa,flatten:Xt,float:Up,floor:Vp,identity:zp,IndexMatcher:ls,indexOf:Jr,inferType:Xu,int:yn,intersect:tf,inverse:xu,isArray:D,isBoolean:gr,isBrowser:qp,isDataFrame:X,isDate:Zt,isEqual:pn,isFunction:qe,isJagged:zo,isNested:ss,isNumber:C,isObject:gn,isSeries:V,isString:he,isUndefined:Y,lerp:Hp,log:Qp,MathError:ur,max:is,mean:Zp,median:Xp,min:Xc,mod:xp,mode:ey,multiply:uf,ndarray:Qt,normal:ty,ones:ny,permutations:ry,permutationsIterator:ga,pow:fa,print:oy,product:Go,random:Kr,range:Be,remap:sy,reshape:Uo,reverse:dn,round:ay,scale:Ur,seed:Hc,Series:gt,set:Lt,shape:Z,shuffle:ts,sign:ly,sin:fy,some:ia,sort:yr,sqrt:of,stats:Tt,std:hf,stdev:hy,subtract:sf,sum:ha,tan:dy,timeAsync:gy,timeSync:Yc,time:Yc,transpose:Un,union:py,variance:yy,vectorize:pe,zeros:da,zip:by,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new $o.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys($o).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:$o[t]})}catch{e[t]=$o[t]}})}};typeof window<"u"&&(window.JSMathTools=$o);var vy=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:void 0;function aa(e){let t=Symbol.for("@TypedArrayConstructor"),n="Symbol(@TypedArrayConstructor)",r=t in e?t:n in e?n:void 0;if(r){if(!("values"in e))throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");return e[r]==="ArrayBuffer"?new Uint8Array(e.values).buffer:new vy[e[r]](e.values)}if(D(e)&&e.constructor.name==="Array")return e;throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!")}function Yr(e){if(e instanceof ArrayBuffer||e instanceof BigInt64Array||e instanceof BigUint64Array||e instanceof Float32Array||e instanceof Float64Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Int8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:e.constructor.name,values:e instanceof ArrayBuffer?Array.from(new Uint8Array(e)):Array.from(e)};if(D(e))return e.map(t=>{try{return Yr(t)}catch{return t}});if(typeof e=="object"&e!==null){if(Zt(e))return new Date(e.getTime());let t={};return Object.keys(e).forEach(n=>{try{t[n]=Yr(e[n])}catch{t[n]=e[n]}}),t}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function mf(e){return e=e.trim(),!!(e.match(/^-?\d+(\.\d+)?$/g)||e.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g)||e.match(/^-?\.\d+$/g)||e==="NaN")}var df="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";function gf(e,t,n){if(typeof e!="string")throw new Error("`text` must be a string!");if(typeof t!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return e.split(t).join(n)}var Jc="  ",$c=" ";function qo(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t="";for(let n=0;n<e.length;n++){let r=e[n].toLowerCase();df.includes(r)?t+=$c:t+=r}for(;t.includes(Jc);)t=gf(t,Jc,$c);return t.trim()}function Ny(e,t){return t=t||"",e.split(`
`).map(n=>n.trim().length>0?t+n:n).join(`
`)}function wy(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=qo(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("-")}var Kc={"@Infinity":1/0,"@NegativeInfinity":-1/0,"@NaN":NaN,"@undefined":void 0};function Lo(e){if(typeof e=="object"){if(e===null)return e;if(D(e))for(let t=0;t<e.length;t++)e[t]=Lo(e[t]);else Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{e[t]=Lo(e[t])});return e}else return typeof e>"u"||e==="Symbol(@undefined)"?void 0:e}function Ey(e){if(typeof e=="bigint")return e;if(typeof e=="string")if(e.match(/^\s*?-?\d+n\s*?$/g))try{return BigInt(e.split("n")[0])}catch{return NaN}else return NaN;else return NaN}function Dy(e){if(typeof e!="string")return typeof e=="number"?e:void 0;if(mf(e))return parseFloat(e)}function Sy(e){if(typeof e!="string")return;let t="@jrc03c/js-text-tools/newline-replacer";if(e=e.replaceAll(`
`,t),e.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)){let n=e.replace("Symbol(@String):","");if(n.match(/^".*?"$/g))try{return JSON.parse(n)}catch{n=n.substring(1,n.length-1)}return n=n.replaceAll(t,`
`),n}}function Oy(e){if(typeof e!="string")return typeof e=="symbol"?{out:e,isASymbol:!0}:void 0;if(e.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)){let t=e.replace(/^.*?Symbol\(/g,"").replace(/\).*?$/g,"");return t in Kc?{out:Kc[t],isASymbol:!0}:{out:Symbol.for(t),isASymbol:!0}}}function Fy(e){if(typeof e!="string")return e instanceof RegExp?e:void 0;let t=e.trim();if(t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g))try{let n=t.replace(/^\//g,"").replace(/\/(d|g|i|m|s|u|v|y)*?$/g,""),r=t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);return new RegExp(n,r)}catch{}}function _y(e){if(typeof e!="string")return typeof e=="object"?e:"Symbol(@undefined)";try{let t=JSON.parse(e,(n,r)=>{try{let o=us(r);return typeof o>"u"?"Symbol(@undefined)":o}catch{return typeof r>"u"?"Symbol(@undefined)":r}});return D(t)&&(t=Lo(t)),t}catch{return e}}function Ty(e){if(typeof e!="string")return e instanceof Date&&e.toString()!=="Invalid Date"?e:void 0;try{let t=new Date(Date.parse(e));if(t.toString()!=="Invalid Date")return t}catch{}}function Ay(e){return typeof e=="object"?e!==null?Lo(e):void 0:(Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{try{let n=t;try{t=us(t)}catch{}e[t]=us(e[n]),t!==n&&delete e[n]}catch{}}),Lo(e))}function us(e){function t(n){if(typeof n=="string"){let r=Sy(n);if(typeof r=="string")return r;let o=Oy(n);return r=o?o.out:void 0,o&&o.isASymbol||(r=Fy(n),r instanceof RegExp)||(r=Ey(n),typeof r=="bigint")||(r=Dy(n),typeof r=="number")||(r=Ty(n),r instanceof Date)?r:(r=_y(n),typeof r<"u"?r==="Symbol(@undefined)"?void 0:r:n)}if(typeof n=="object"){if(n===null)return null;let r;try{if(r=aa(n),D(r))return r}catch{}if(r=Ay(n),r)try{return aa(r)}catch{return r}return n}return n}return t(e)}function Iy(e){let t=Uc(e);return t[0].toUpperCase()+t.slice(1)}function jy(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=qo(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("_")}function or(e,t){return!e||t<=0?"":Be(0,t).map(()=>e).join("")}function pf(e,t){g(he(t)||Y(t),"The second parameter to the `stringify` function must be undefined or a string!");let n=t?`
`:"";function r(o,u,s){return s=s||0,typeof o=="bigint"?JSON.stringify(o.toString()+"n"):typeof o=="number"?o===1/0?'"Symbol(@Infinity)"':o===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(o)?'"Symbol(@NaN)"':o.toString():typeof o=="string"?JSON.stringify("Symbol(@String):"+o):typeof o=="boolean"?o.toString():typeof o>"u"?'"Symbol(@undefined)"':typeof o=="symbol"||typeof o=="function"?JSON.stringify(o.toString()):o instanceof RegExp?o.toString():typeof o=="object"?o===null?"null":Zt(o)?JSON.stringify(o.toJSON()):D(o)?o.length===0?or(u,s-1)+"[]":o instanceof Array?or(u,s-1)+"["+n+o.map(i=>{let a=(()=>{try{return r(Yr(i),u,s+1)}catch{return r(i,u,s+1)}})();return he(a)&&(a=a.trim()),or(u,s+1)+a}).join(","+n)+n+or(u,s)+"]":r(Yr(o),null,u):Object.keys(o).length+Object.getOwnPropertySymbols(o).length===0?or(u,s-1)+"{}":or(u,s-1)+"{"+n+Object.keys(o).concat(Object.getOwnPropertySymbols(o)).map(i=>{let a=(()=>{try{return r(Yr(o[i]),u,s+1)}catch{return r(o[i],u,s+1)}})();he(a)&&(a=a.trim());let l=typeof i=="symbol"?r(i):JSON.stringify(i);return or(u,s+1)+l+":"+(u?" ":"")+a}).join(","+n)+n+or(u,s)+"}":"undefined"}return r(pr(e),t)}function Cy(e){let t=e.split(`
`),n=t.filter(o=>o.trim().length>0).map(o=>o.split("").findIndex(u=>!u.match(/\s/g))),r=Math.min(...n);return t.map(o=>o.substring(r)).join(`
`)}function My(e,t){if(typeof e!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof t>"u"||t===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?t=process.stdout.columns>80?80:process.stdout.columns:t=80),isNaN(t)||typeof t!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return e.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let o=r.split(/[^\s]/g)[0],u=r.replace(o,"").split(" "),s=o;u.forEach(i=>{let a=s+(s.trim().length>0?" ":"")+i;a.length>t?(n.push(s),s=o+i):s=a}),s.length>0&&n.push(s)}),n.join(`
`)}typeof window<"u"&&(window.JSTextTools={camelify:Uc,convertObjectToTypedArray:aa,convertTypedArrayToObject:Yr,indent:Ny,isANumberString:mf,kebabify:wy,parse:us,pascalify:Iy,punctuation:df,replaceAll:gf,snakeify:jy,stringify:pf,strip:qo,unindent:Cy,wrap:My});function pa(e){let t=e.match(/[A-Za-z]'([A-Za-z]|\s)/g);for(;t;)t.forEach(r=>{e=e.replaceAll(r,r.replaceAll("'",""))}),t=e.match(/[A-Za-z]'([A-Za-z]|\s)/g);let n=qo(e.toLowerCase()).replaceAll(/\s/g," ");for(;n.includes("  ");)n=n.replaceAll("  "," ");return n.trim()}var By=Object.defineProperty,Py=(e,t,n)=>t in e?By(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Ff=(e,t,n)=>(Py(e,typeof t!="symbol"?t+"":t,n),n);function M(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Ry=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),sr=class extends Error{constructor(e){Ry()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function b(e,t){if(!e)throw new sr(t)}var _f=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function K(e){return e===null||typeof e>"u"}var ky=_f.map(e=>e.name);function _(e){try{return e instanceof Array?!0:K(e.constructor)?!1:_f.indexOf(e.constructor)>-1||ky.indexOf(e.constructor.name)>-1}catch{return!1}}function ee(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function He(e){return typeof e=="function"}function vn(e){return typeof e=="object"&&!K(e)&&!_(e)}function z(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function Wr(e,t){if(ee(e)){let u=Wr(e.values,t);return u.length>0&&M(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&M(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(z(e)){let u=Wr(e.values,t);return u.length>0&&M(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(b(vn(e)||_(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!He(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(vn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(_(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function nt(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(_(n))return n instanceof Array?n.map(o=>nt(o)):n.slice();if(z(n)){let o=n.copy();return o.values=nt(o.values),o}if(ee(n)){let o=n.copy();return o.values=nt(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=Gr(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=nt(n[o])}),r}else return n}return t(Gr(e))}function Gr(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+Wr(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),_(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(ee(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(z(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function Ln(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var yf=["number","int","float","bigint"];function Nn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!yf.includes(u)&&!yf.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(Ln(r))return Ln(o)?r.getTime()===o.getTime():!1;if(Ln(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(_(r)!==_(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Gr(e),Gr(t))}}function xo(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Yy=xo(16),Jy=xo(16),$y=xo(16),Ky=xo(16),Uy=xo(16),Ly=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)_(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Yy:K(e)?Jy:He(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Uy:e===1/0?$y:e===-1/0?Ky:typeof e=="bigint"?e.toString():ee(e)?e.toJSONString():z(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!K(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function en(e){if(ee(e)||z(e))return en(e.values);b(_(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{_(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function jt(e,t){t=t||{};let n=new Ly,r={},o=en(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||M(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function ps(e,t){let{counts:n}=jt(e);return K(t)||(He(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{Nn(r,t)||n.delete(r)})),n}function ya(e){if(ee(e)||z(e))return ya(e.values);if(_(e)){let t=!1,n=!1,r=null;for(let o of e){if(ya(o))return!0;if(_(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function eu(e){return ya(Gr(e))}function ws(e){if(ee(e)||z(e))return ws(e.values);b(_(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(_(e[t]))return!0;return!1}var Lr="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function xt(e){b(!K(e),Lr),_(e)||(e=[e]),b(!ws(e),Lr),b(e.length>0,Lr);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),b(M(t),Lr),b(t>=0,Lr),b(Math.floor(t)===t,Lr),b(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(xt(e.slice(1)));return n}}function bn(e){if(ee(e)||z(e)){let n=e.copy();return n.values=bn(n.values),n.index=bn(n.index),n}b(_(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Le(e,t,n=1){b(!K(e)&&!K(t)&&!K(n),"You must pass two numbers and optionally a step value to the `range` function!"),b(M(e)&&M(t)&&M(n),"You must pass two numbers and optionally a step value to the `range` function!"),b(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=bn(u)),u}function tu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Vy=tu(256),zy=tu(256),Wy=tu(256),Gy=tu(256),qy=tu(256);function St(e){if(ee(e)||z(e))return St(e.values);b(_(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return en(e).forEach(r=>{let o=typeof r=="object"&&r===null?Vy:K(r)?zy:He(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+qy:r===1/0?Wy:r===-1/0?Gy:typeof r=="bigint"?r.toString():ee(r)?r.toJSONString():z(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function Tf(e){if(_(e)){let t=Tf(e[0]);return[e.length].concat(t||[])}else return}function x(e){return ee(e)||z(e)?x(e.values):(b(_(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Tf(e))}function Af(e,t,n){if(K(n)&&(n=0),b(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),_(t)){b(!eu(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=x(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Le(0,o).forEach(s=>{s>=u._values.length&&u._values.push(xt(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Le(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(xt(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new sr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(z(t)){let r=Af(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(ee(t))if(n===0){let r=e.copy(),o=St(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(xt(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(xt(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new sr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function Hy(e,t,n,r,o){if(o=o||0,b(He(r),"The first parameter to the `apply` method must be a function."),b(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,K(s)&&(s=c instanceof t||_(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return K(u)&&(u=c instanceof t||_(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function Se(e){return typeof e=="string"}function Qy(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(K(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(vn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new sr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{b(Se(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),b(_(o)&&!eu(o)&&x(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function Zy(e,t){if(t.isEmpty)return new e;let n=new e(nt(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function Xy(e,t,n,r,o){K(r)&&(r=[]),K(o)&&(o=[]),(Se(r)||M(r))&&(r=[r]),(Se(o)||M(o))&&(o=[o]),b(_(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),b(_(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),b(x(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),b(x(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function If(e){return M(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function qr(e){return If(e)&&e>=0}function xy(e,t,n,r,o,u){r=r||0,b(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,b(qr(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",b(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(K(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(K(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!K(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(x(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(K(c))return new e;Se(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function Ta(e){if(ee(e)||z(e))return e.dropNaN(...Object.values(arguments).slice(1));b(_(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Ta(n))}catch{if(M(n))return t.push(n)}}),t}function e0(e,t,n,r,o){n=n||0,b(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,b(qr(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",b(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=Ta(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function bf(e){let t={};return en(e).forEach((n,r)=>{t[n]=r}),t}function Vr(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function t0(e,t,n,r,o){b(He(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),K(o)&&(o=0),b(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=bf(u.index),i=bf(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Vr(s)[0],c.index=Vr(i),c}u.values=l,u.index=Vr(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Vr(i)[0],c.index=Vr(s),c}u.values=l,u.index=Vr(i),u=u.transpose()}return u}function n0(e,t,n){(Se(t)||M(t))&&(t=[t]),(Se(n)||M(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=St((t||[]).concat(n||[]).map(o=>typeof o));return b(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&b(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(b(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),b(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),K(t)||(t=t.map(o=>{if(Se(o))return b(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(M(o))return b(o>=0,`Index ${o} is out of bounds!`),b(Math.floor(o)===o,"Row numbers must be integers!"),b(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),K(n)||(n=n.map(o=>{if(Se(o))return b(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(M(o))return b(o>=0,`Column ${o} is out of bounds!`),b(Math.floor(o)===o,"Column numbers must be integers!"),b(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function r0(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Vn(e,t){if(K(t)&&(t=r0),ee(e)||z(e))return e.sort(...Object.values(arguments).slice(1));b(_(e),"The `sort` function only works on arrays, Series, and DataFrames!"),b(He(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function o0(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function vf(e,t,n){K(n)?n=t.columns:Se(n)&&(n=[n]);let r={};n.forEach(u=>{b(Se(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);b(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Vn(St(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+o0(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function u0(e,t,n){let r=e.shape;K(t)&&(t=Le(0,r[0])),K(n)&&(n=Le(0,r[1])),M(t)&&(t=[t]),M(n)&&(n=[n]),b(_(t)&&_(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),b(x(t).length===1&&x(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),b(t.length>0,"The `rowIndices` array must contain at least one index."),b(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{b(qr(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),b(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{b(qr(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),b(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function s0(e,t,n,r,o){K(r)&&(r=n.index),K(o)&&(o=n.columns),Se(r)&&(r=[r]),Se(o)&&(o=[o]),b(_(r)&&_(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),b(x(r).length===1&&x(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),b(r.length>0,"The `rows` array must contain at least one row name."),b(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{b(Se(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),b(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{b(Se(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),b(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function i0(e,t,n){function r(h,m){return Se(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Le(0,u).concat(Le(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Le(0,i).concat(Le(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Le(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function zr(e,t){b(M(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function a0(e,t){let n=t?e:e.copy();return n.index=Le(0,e.shape[0]).map(r=>"row"+zr(r,(n.index.length-1).toString().length)),n}function nu(e,t){if(ee(e)||z(e))return nu(e.values,t);b(_(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=en(e),r=!1,o=1;for(let u of n){if(!M(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function l0(e){return If(e)&&e>0}function Xo(e,t){if(ee(e)||z(e))return Xo(e.values,t);if(b(_(e),"The first argument passed into the `reshape` function must be an array!"),M(t)&&(t=[t]),b(_(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),b(x(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),b(l0(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return en(e);let n=en(e);if(t.length===1&&t[0]===n.length)return n;b(nu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(Xo(s,t.slice(1)))}return r}var jf=Math.pow(2,64),_e=[];Cf(Math.floor(Math.random()*jf));function c0(e,t){e=lt(e);function n(){e+=lt("0x9e3779b97f4a7c15");let o=nt(e);return o=(o^o>>BigInt(30))*lt("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*lt("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function lt(e){return BigInt.asUintN(64,BigInt(e))}function Nf(e,t){return e=lt(e),t=BigInt(t),lt(lt(e<<t)|lt(e>>lt(BigInt(64)-t)))}function Cf(e){if(typeof e=="bigint"&&(e=Number(e)),K(e))return nt(_e);{b(M(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=c0(Math.floor(e),4);_e[0]=t[0],_e[1]=t[1],_e[2]=t[2],_e[3]=t[3]}}function wf(){let e=lt(Nf(_e[0]+_e[3],23)+_e[0]),t=lt(_e[1]<<BigInt(17));return _e[2]=lt(_e[2]^_e[0]),_e[3]=lt(_e[3]^_e[1]),_e[1]=lt(_e[1]^_e[2]),_e[0]=lt(_e[0]^_e[3]),_e[2]=lt(_e[2]^t),_e[3]=Nf(_e[3],45),Math.floor(Number(e))/jf}function Hr(e){return K(e)?wf():(_(e)||(e=[e]),Xo(xt(nu(e)).map(wf),e))}function ys(e){if(ee(e)||z(e))return e.shuffle(...Object.values(arguments).slice(1));b(_(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(Hr()*n.length);t.push(n.splice(o,1)[0])}return t}function f0(e,t){return K(t)&&(t=0),b(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?ys(e.index):null,t===1?ys(e.columns):null)}function br(e){return typeof e=="boolean"}function h0(e,t,n){return He(t)?m0(e,t,n):d0(e,t,n)}function m0(e,t,n){if(n=K(n)?0:n,b(He(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),b(M(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Vn(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Vn(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function d0(e,t,n){let r=e.copy(),o=Hr().toString();r=r.assign(o,r.index),K(t)&&(t=[o],n=[!0]),(M(t)||Se(t))&&(t=[t],(br(n)||Se(n))&&(n=[n])),b(_(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),b(x(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),K(n)&&(n=Le(0,t.length).map(()=>!0)),b(_(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),b(x(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),b(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(b(Se(s)||M(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),Se(s)){let i=r.columns.indexOf(s);return b(i>-1,`The column "${s}" does not exist!`),i}if(M(s))return b(qr(s),"Column indices must be whole numbers!"),b(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(b(Se(s)||br(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),Se(s)){let i=s.trim().toLowerCase();return b(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(br(s))return s}),r.values=Vn(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function g0(e,t){K(t)?t=0:b(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function Mf(e,t){return JSON.stringify(e.toObject(t))}async function p0(e,t,n){let r=Mf(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new sr(s):typeof module<"u"?new sr(i):new sr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function y0(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function zn(e){if(ee(e)||z(e))return e.transpose();b(_(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=x(e);if(b(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return bn(e);if(t.length===2){let n=xt(bn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function Bf(e,t,n){if(z(n))return new e(t.values.concat(n.values));if(_(n)){let r=x(n);b(r.length===1&&!ws(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return Bf(t,[n])}function b0(e,t){b(He(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function v0(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>K(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function N0(e,t){let n=[],r=[];t.values.forEach((u,s)=>{M(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function w0(e,t,n){let r=t.copy(),o=nt(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function E0(e,t){(Se(t)||M(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=St((t||[]).map(r=>typeof r));return b(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&b(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(b(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),b(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),K(t)||(t=t.map(r=>{if(typeof r=="string")return b(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return b(r>=0,`Index ${r} is out of bounds!`),b(Math.floor(r)===r,"Indices must be integers!"),b(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function D0(e,t){let n=e.shape;K(t)&&(t=Le(0,n[0])),b(_(t),"The `indices` array must be 1-dimensional array of whole numbers."),b(x(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),b(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{b(qr(o),"The `indices` array must be a 1-dimensional array of whole numbers."),b(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function S0(e,t,n){K(n)&&(n=t.index),b(_(n),"The `indices` array must be a 1-dimensional array of strings."),b(x(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),b(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{b(Se(u),"The `indices` array must contain only strings."),b(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function O0(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Le(0,n/2).concat(Le(t.index.length-n/2,t.index.length)));let o=nt(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function F0(e){let t=e.copy();return t.get(ys(t.index))}function _0(e,t,n){n=n||((a,l)=>a<l?-1:1),b(K(n)||He(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=zn([t.values,t.index]),o=Vn(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function T0(e,t){let n=zn([t.values,t.index]);n=zn(Vn(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function A0(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Ef=Symbol.for("@jrc03c/js-math-tools/series");function I0(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Ef}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Ef}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){b(_(o),"The new values must be a 1-dimensional array!");let u=x(o);b(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Le(this._index.length,u[0]).map(s=>"item"+zr(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){b(_(o),"The new index must be a 1-dimensional array of strings!"),b(o.length===this.shape[0],"The new index must be the same length as the old index!"),b(x(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{b(Se(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=nt(r.values),this.index=nt(r.index);else if(_(r)){let o=x(r);b(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());b(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];b(x(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return x(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!K(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return E0(this,r)}getSubsetByNames(r){return S0(t,this,r)}getSubsetByIndices(r){return D0(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(bn(this.values));return r.index=bn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Le(0,this.shape[0]).map(o=>"item"+zr(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=nt(this.values),r._index=nt(this.index),r.name=this.name,r}append(r){return Bf(t,this,r)}apply(r){return b0(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return v0(this,r,o)}dropNaN(){return N0(t,this)}toObject(){return A0(this)}print(){return O0(this)}shuffle(){return F0(this)}sort(r){return _0(t,this,r)}sortByIndex(){return T0(t,this)}filter(r){return w0(t,this,r)}toDataFrame(){let r=new e(zn([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=bn(r.values),r.index=bn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Df=Symbol.for("@jrc03c/js-math-tools/dataframe");function cs(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(Hr()*t.length)];return n}var Pe=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Df}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Df}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!K(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){b(_(t),"The new values must be a 2-dimensional array!");let n=x(t);b(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Le(this._index.length,n[0]).map(r=>"row"+zr(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Le(this._columns.length,n[1]).map(r=>"col"+zr(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){b(_(t),"The new columns list must be a 1-dimensional array of strings!"),b(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),b(x(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+cs(8):r.trim()));let n=(()=>{let r=ps(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+cs(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){b(_(t),"The new index must be a 1-dimensional array of strings!"),b(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),b(x(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+cs(8):r.trim()));let n=(()=>{let r=ps(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+cs(8):r),this._index=t}}),b(K(e)||vn(e)||_(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Pe)this.values=nt(e.values),this.columns=nt(e.columns),this.index=nt(e.index);else if(_(e)){let t=x(e);b(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),b(!eu(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{K(r)&&(n=u,r=e[u].length),b(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=zn(t);let o=x(this.values);this._index=Le(0,o[0]).map(u=>"row"+zr(u,(o[0]-1).toString().length))}}get shape(){return x(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Pe(xt(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return n0(this,e,t)}getSubsetByNames(e,t){return s0(Pe,pt,this,e,t)}getSubsetByIndices(e,t){return u0(this,e,t)}getDummies(e){return vf(Pe,this,e)}oneHotEncode(e){return vf(Pe,this,e)}transpose(){let e=new Pe(zn(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return a0(this,e)}copy(){return Zy(Pe,this)}assign(e,t){return Qy(Pe,pt,this,e,t)}apply(e,t){return Hy(Pe,pt,this,e,t)}dropMissing(e,t,n){return xy(Pe,pt,this,e,t,n)}dropNaN(e,t,n){return e0(Pe,this,e,t,n)}drop(e,t){return Xy(Pe,pt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return g0(this,e)}toObject(){return y0(this)}toJSONString(e){return Mf(this,e)}saveAsJSON(e,t){return p0(this,e,t)}print(){return i0(Pe,pt,this)}sort(e,t){return h0(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return t0(Pe,pt,this,e,t)}shuffle(e){return f0(this,e)}append(e,t){return Af(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},pt=I0(Pe);function Es(e,t){return jt(e,{shouldDropNaNs:t}).max}function ye(e){return b(He(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return _(a)?!0:z(a)?(n=!0,o.push(a),!0):ee(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{b(Nn(_(i)?x(i):i.shape,_(s[a+1])?x(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=Es(s.map(l=>l.length?l.length:l.values.length)),a=Le(0,i).map(l=>{let c=Object.keys(arguments).map(f=>_(arguments[f])?arguments[f][l]:z(arguments[f])||ee(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&Nn(x(u[0]),x(a))){let l=new Pe(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Pe(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new pt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new pt(a)}catch{return a}return a}else return e(...arguments)}}function j0(e){try{return M(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var Aa=ye(j0);function C0(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!M(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var bs=ye(C0);function M0(e,t){try{return t(e)}catch{return NaN}}var Ds=ye(M0);function B0(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var P0=ye(B0);function R0(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var k0=ye(R0);function Y0(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var J0=ye(Y0);function ba(e,t){if(ee(e)){let n=ba(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(z(e)){let n=ba(e.values,t);return e.index[n]}b(_(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=Wr(e,Es(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Pf(e,t){return jt(e,{shouldDropNaNs:t}).min}function va(e,t){if(ee(e)){let n=va(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(z(e)){let n=va(e.values,t);return e.index[n]}b(_(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=Wr(e,Pf(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function At(e,t){if(ee(e)||z(e))return e.apply(n=>At(n,t));if(_(e))return e.map(n=>At(n,t));if(t==="null")return null;if(t==="number"){if(K(e))return NaN;let n=At(e,"boolean");if(br(n))return n?1:0;try{JSON.parse(e)}catch{let u=At(e,"date");if(Ln(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=At(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return At(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(At(e,"int"));if(t==="boolean"){if(br(e))return e;if(M(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Ln(e))return e;if(K(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return Ln(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(vn(e))return e;let n=At(e,"boolean");if(br(n))return null;try{let o=At(e,"number");if(M(o))return JSON.parse(e),null}catch{}let r=At(e,"date");if(r)return r;try{let o=JSON.parse(e);return _(o)?o.map(u=>At(u,t)):o}catch{return null}}if(t==="string")return K(e)?Nn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function $0(e){try{return M(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var K0=ye($0);function U0(e,t){try{if(!M(e))return NaN;if(typeof e=="bigint")return e;if(K(t))t=1e-10;else if(!M(t))return NaN;return Aa(e)<t?0:e}catch{return NaN}}var L0=ye(U0);function Na(e){if(ee(e)||z(e)){let t=e.copy();return t.values=Na(t.values),t}if(_(e))return e.map(t=>Na(t));try{let t=JSON.parse(e);return M(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var wn=ye(Na);function Rf(e,t,n){try{return M(e)?M(t)?M(n)?typeof e=="bigint"?BigInt(Rf(wn(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var Ia=ye(Rf);function vs(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of vs(i,o-1))yield[s].concat(a)}}return ee(e)||z(e)?vs(e.values,t):(b(_(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),b(M(t)&&wn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(en(e),t))}function kf(e,t){let n=[];for(let r of vs(e,t))n.push(r.slice());return n}function Yf(){let e=Object.values(arguments).map(n=>ee(n)||z(n)?St(n.values):(b(_(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),St(n)));return St(e).filter(n=>e.every(r=>r.findIndex(o=>Nn(o,n))>-1))}var Ho=class{constructor(e){b(K(e)||e===Ho.DROP_NAN_MODE||e===Ho.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=K(e)?Ho.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(_(t)){let n=x(t);if(n.length===1)t=new pt(t);else if(n.length===2)t=new Pe(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}b(ee(t)||z(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===Ho.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Yf(...e),this}transform(){b(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(_(t)){let n=x(t);if(n.length===1)return new pt(t).get(this.index).values;if(n.length===2)return new Pe(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return b(ee(t)||z(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ss=Ho;Ff(Ss,"DROP_NAN_MODE","DROP_NAN_MODE");Ff(Ss,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Zo(e,t,n,r){if(z(e))return Zo(e.values,t,n,r);if(z(t))return Zo(e,t.values,n,r);if(b(_(e)&&_(t)&&x(e).length===1&&x(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),b(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Zo(...new Ss().fitAndTransform(e,t),!1,r);try{let o=jt(e,{stdev:r}),u=jt(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!M(s)||!M(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!M(f))return NaN;if(!M(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function wa(e,t,n){if(z(e))return wa(e.values,t,n);if(z(t))return wa(e,t.values,n);b(_(e)&&_(t)&&x(e).length===1&&x(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),b(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Zo(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function V0(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var z0=ye(V0),W0=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Ea(e,t){if(ee(e)||z(e))return Ea(e.values,t);if(ee(t)||z(t))return Ea(e,t.values);b(_(e)&&_(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=St(e),r=St(t),o=[];return n.forEach(u=>{r.findIndex(s=>Nn(s,u))<0&&o.push(u)}),o}function Jf(e,t){try{if(!M(e))return NaN;if(!M(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Jf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var ja=ye(Jf);function $f(e){try{if(!M(e))return NaN;if(typeof e=="bigint"){let t=$f(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Kf=ye($f);function G0(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!M(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var Uf=ye(G0);function Qr(){return Uf(...arguments)}function Lf(e,t){return bs(e,Qr(t,-1))}function Ca(e,t){return jt(e,{shouldDropNaNs:t}).sum}function Da(e,t){if(M(e)&&M(t))return Aa(e-t);if(ee(e)||z(e))return Da(e.values,t);if(ee(t)||z(t))return Da(e,t.values);_(e)&&_(t)&&b(Nn(x(e),x(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Kf(Ca(ja(Lf(e,t),2)))}catch{return NaN}}function q0(e,t){return Qr(e,ja(t,-1))}function It(e,t){if(ee(e)){let o=It(e.values,t);if(x(o).length===1){let u=new pt(o);return u.name=z(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Pe(o);return u.index=e.index.slice(),ee(t)&&(u.columns=t.columns.slice()),u}}if(ee(t)){let o=It(e,t.values);if(x(o).length===1){let u=new pt(o);return u.name=z(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Pe(o);return u.columns=t.columns.slice(),u}}if(z(e))return It(e.values,t);if(z(t))return It(e,t.values);b(_(e)&&_(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=x(e),r=x(t);if(b(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),b(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Ca(Qr(e,t));if(n.length===1&&r.length===2)return zn(t).map(o=>It(e,o));if(n.length===2&&r.length===1)return e.map(o=>It(o,t));if(n.length===2&&r.length===2){let o=zn(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(It(e[s],o[a]));u.push(i)}return u}}function Ma(e){if(ee(e)||z(e))return e.dropMissing(...Object.values(arguments).slice(1));b(_(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Ma(n))}catch{K(n)||t.push(n)}}),t}function hs(e,t){if(ee(e)||z(e))return hs(e.values,t);if(ee(t)||z(t))return hs(e,t.values);b(_(e)&&_(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),b(Nn(x(e),x(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=hs(e[o],t[o]);n.push(u),r.push(s)}catch{!K(e[o])&&!K(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function ms(e,t){if(ee(e)||z(e))return ms(e.values,t);if(ee(t)||z(t))return ms(e,t.values);b(_(e)&&_(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),b(Nn(x(e),x(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=ms(e[o],t[o]);n.push(u),r.push(s)}catch{M(e[o])&&M(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function H0(e){return Ma(e)}function Ns(e,t){if(ee(e)||z(e))return Ns(e.values,t);b(_(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),b(He(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(_(n)){if(!Ns(n,t))return!1}else if(!t(n))return!1;return!0}function Q0(e){try{if(!M(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var Z0=ye(Q0);function Sa(e){try{return typeof e=="bigint"?BigInt(Sa(wn(e))):e!==wn(e)?NaN:e<=1?1:e*Sa(e-1)}catch{return NaN}}var X0=ye(Sa);function Oa(e,t){if(ee(e)||z(e))return Oa(e.values,t);if(b(vn(e)||_(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!He(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(vn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(_(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function Fa(e,t){if(ee(e)||z(e))return Fa(e.values,t);if(b(vn(e)||_(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!He(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(vn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(_(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function x0(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return M(t)?t:NaN}catch{return NaN}}var eb=ye(x0);function tb(e){try{return M(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var nb=ye(tb);function Ba(e){M(e)&&(e=[e]);let t=[],n=nu(e);for(let r=0;r<n;r++)t.push(0);return Xo(t,e)}function rb(e){typeof e=="bigint"&&(e=wn(e)),b(!K(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),b(M(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),b(wn(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),b(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Ba([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var ob=["true","false","yes","no"],ub=["null","none","nan","na","n/a","","undefined"];function fs(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=wn(e.value)===e.value:e.isInteger=Ns(e.values,t=>M(t)?wn(t)===t:!0)),e}function ds(e){if(ee(e)){let u=e.copy(),s=ds(e.values);return u.values=s.values,fs({type:s.type,values:u})}if(z(e)){let u=e.copy(),s=ds(e.values);return u.values=s.values,fs({type:s.type,values:u})}if(!_(e)){let u=ds([e]);return u.value=u.values[0],delete u.values,fs(u)}b(_(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=en(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(Ln(a))return"date"}}catch{}Se(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(ub.indexOf(i)>-1)return"null";if(ob.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return M(a)?"number":typeof a=="object"?_(a)?"string":"object":"string"}catch{let l=new Date(u);return Ln(l)?"date":"string"}}),n=ps(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return fs({type:o,values:Ds(e,u=>At(u,o))})}function gs(e){if(ee(e)){let n=e.copy();return n.values=gs(n.values),n}b(_(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=x(e);if(b(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),b(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),b(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){b(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;b(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return Qr(i,1/s)}else if(t[0]>1){let n=(r,o)=>M(r)||M(o)?Qr(r,o):It(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=gs(o),l=gs(bs(i,n(-1,n(n(s,a),u)))),c=bs(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}b(!1,"This matrix cannot be inverted!")}}var Os=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Vf(e,t,n){try{if(!M(e))return NaN;if(!M(t))return NaN;if(!M(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Vf(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var sb=ye(Vf);function zf(e,t){try{if(t=K(t)?Math.E:t,!M(e))return NaN;if(!M(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=zf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var ib=ye(zf);function ab(e,t){return jt(e,{shouldDropNaNs:t}).mean}function lb(e,t){return jt(e,{shouldDropNaNs:t,median:!0}).median}function Wf(e,t){try{if(!M(e))return NaN;if(!M(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Wf(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var cb=ye(Wf);function fb(e,t){return jt(e,{shouldDropNaNs:t,mode:!0}).mode}function Sf(){let e=Hr(),t=Hr();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function hb(e){return K(e)?Sf():Ds(xt(e),Sf)}function mb(e){return Ds(xt(e),()=>1)}function Pa(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of kf(r,o)){if(!u.slice)continue;let s=Ba(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return ee(e)||z(e)?Pa(e.values,t):(b(_(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),K(t)&&(t=e.length),b(M(t)&&wn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(en(e),t))}function db(e,t){let n=[];for(let r of Pa(e,t))n.push(r.slice());return n}function gb(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(_(t))if(eu(t))console.log(t);else{let n=x(t);n.length===1?new pt(t).print():n.length==2?new Pe(t).print():console.log(t)}else ee(t)||z(t)?t.print():console.log(t)})}var pb=ye((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!M(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function yb(e,t,n,r,o){if(_(e)&&K(r)&&K(o)){r=t,o=n;let u=jt(e);t=u.min,n=u.max}return pb(e,t,n,r,o)}function bb(e){try{return M(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var vb=ye(bb);function Gf(e){try{return M(e)?typeof e=="bigint"?BigInt(Gf(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var Nb=ye(Gf);function wb(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Eb=ye(wb);function _a(e,t){if(ee(e)||z(e))return _a(e.values,t);b(_(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),b(He(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(_(n)){if(_a(n,t))return!0}else if(t(n))return!0;return!1}function qf(e,t){return jt(e,{shouldDropNaNs:t,stdev:!0}).stdev}function Db(e){return qf(e)}function Sb(e){try{return M(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var Ob=ye(Sb);function Of(e,t){b(He(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function Fb(e,t){b(He(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function _b(){return St([...arguments].map(e=>_(e)?e:ee(e)||z(e)?e.values:[e]))}function Tb(e,t){return jt(e,{shouldDropNaNs:t,variance:!0}).variance}function Ab(){let e=[],t=Object.values(arguments).map(n=>((ee(n)||z(n))&&(n=n.values),b(_(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Le(0,Es(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(K(u)?void 0:u)}),e.push(r)}),e}var Qo={abs:Aa,add:bs,apply:Ds,arccos:P0,arcsin:k0,arctan:J0,argmax:ba,argmin:va,assert:b,cast:At,ceil:K0,chop:L0,clamp:Ia,combinations:kf,combinationsIterator:vs,copy:nt,correl:wa,cos:z0,count:ps,covariance:Zo,DataFrame:Pe,dataTypes:W0,decycle:Gr,diff:Ea,distance:Da,divide:q0,dot:It,dropMissing:Ma,dropMissingPairwise:hs,dropNaN:Ta,dropNaNPairwise:ms,dropUndefined:H0,every:Ns,exp:Z0,factorial:X0,find:Oa,findAll:Fa,flatten:en,float:eb,floor:nb,identity:rb,IndexMatcher:Ss,indexOf:Wr,inferType:ds,int:wn,intersect:Yf,inverse:gs,isArray:_,isBoolean:br,isBrowser:Os,isDataFrame:ee,isDate:Ln,isEqual:Nn,isFunction:He,isJagged:eu,isNested:ws,isNumber:M,isObject:vn,isSeries:z,isString:Se,isUndefined:K,lerp:sb,log:ib,MathError:sr,max:Es,mean:ab,median:lb,min:Pf,mod:cb,mode:fb,multiply:Uf,ndarray:xt,normal:hb,ones:mb,permutations:db,permutationsIterator:Pa,pow:ja,print:gb,product:nu,random:Hr,range:Le,remap:yb,reshape:Xo,reverse:bn,round:vb,scale:Qr,seed:Cf,Series:pt,set:St,shape:x,shuffle:ys,sign:Nb,sin:Eb,some:_a,sort:Vn,sqrt:Kf,stats:jt,std:qf,stdev:Db,subtract:Lf,sum:Ca,tan:Ob,timeAsync:Fb,timeSync:Of,time:Of,transpose:zn,union:_b,variance:Tb,vectorize:ye,zeros:Ba,zip:Ab,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Qo.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Qo).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Qo[t]})}catch{e[t]=Qo[t]}})}};typeof window<"u"&&(window.JSMathTools=Qo);function Fs(e){return Math.sqrt(It(e,e))}function Ra(e,t){return Ia(It(e,t)/(Fs(e)*Fs(t)),0,1)}function vr(e){return typeof e=="number"&&!isNaN(e)&&e>=0&&Math.floor(e)===e&&e<1/0}var Ot=class extends Set{add(t){if(typeof t!="string")throw new Error("`StringSet` instances can only contain strings!");return super.add(t)}addAll(t){return t.forEach(n=>this.add(n)),this}delete(t){if(typeof t!="string")throw new Error("`StringSet` instances can only contain strings!");return super.delete(t)}deleteAll(t){return t.forEach(n=>this.delete(n)),this}has(t){if(typeof t!="string")throw new Error("`StringSet` instances can only contain strings!");return super.has(t)}hasAll(t){return t.every(n=>this.has(n))}toArray(){return Array.from(this)}toSortedArray(){return Vn(this.toArray())}};function ph(e){if(typeof e!="string")throw new Error("`text` must be a string!");e=e.trim();let t="",n=!1;for(let r=0;r<e.length;r++){let o=e[r];o.match(/[A-Za-z0-9]/g)?(t.length===0?t+=o.toLowerCase():n?t+=o.toUpperCase():t+=o,n=!1):!o.includes("'")&&!o.includes("\u2019")&&!o.includes("\u275C")&&(n=!0)}return t}var Ib=Object.defineProperty,jb=(e,t,n)=>t in e?Ib(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,yh=(e,t,n)=>(jb(e,typeof t!="symbol"?t+"":t,n),n);function B(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Cb=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),ar=class extends Error{constructor(e){Cb()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function p(e,t){if(!e)throw new ar(t)}var bh=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function J(e){return e===null||typeof e>"u"}var Mb=bh.map(e=>e.name);function S(e){try{return e instanceof Array?!0:J(e.constructor)?!1:bh.indexOf(e.constructor)>-1||Mb.indexOf(e.constructor.name)>-1}catch{return!1}}function re(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function Qe(e){return typeof e=="function"}function On(e){return typeof e=="object"&&!J(e)&&!S(e)}function W(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function uo(e,t){if(re(e)){let u=uo(e.values,t);return u.length>0&&B(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&B(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(W(e)){let u=uo(e.values,t);return u.length>0&&B(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(p(On(e)||S(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Qe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(On(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(S(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function rt(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(S(n))return n instanceof Array?n.map(o=>rt(o)):n.slice();if(W(n)){let o=n.copy();return o.values=rt(o.values),o}if(re(n)){let o=n.copy();return o.values=rt(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=Er(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=rt(n[o])}),r}else return n}return t(Er(e))}function Er(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+uo(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),S(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(re(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(W(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function rn(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var Hf=["number","int","float","bigint"];function Fn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!Hf.includes(u)&&!Hf.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(rn(r))return rn(o)?r.getTime()===o.getTime():!1;if(rn(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(S(r)!==S(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Er(e),Er(t))}}function mu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Bb=mu(16),Pb=mu(16),Rb=mu(16),kb=mu(16),Yb=mu(16),Jb=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)S(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Bb:J(e)?Pb:Qe(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Yb:e===1/0?Rb:e===-1/0?kb:typeof e=="bigint"?e.toString():re(e)?e.toJSONString():W(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!J(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function on(e){if(re(e)||W(e))return on(e.values);p(S(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{S(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Bt(e,t){t=t||{};let n=new Jb,r={},o=on(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||B(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function Js(e,t){let{counts:n}=Bt(e);return J(t)||(Qe(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{Fn(r,t)||n.delete(r)})),n}function ka(e){if(re(e)||W(e))return ka(e.values);if(S(e)){let t=!1,n=!1,r=null;for(let o of e){if(ka(o))return!0;if(S(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function du(e){return ka(Er(e))}function Qs(e){if(re(e)||W(e))return Qs(e.values);p(S(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(S(e[t]))return!0;return!1}var Zr="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function tn(e){p(!J(e),Zr),S(e)||(e=[e]),p(!Qs(e),Zr),p(e.length>0,Zr);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),p(B(t),Zr),p(t>=0,Zr),p(Math.floor(t)===t,Zr),p(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(tn(e.slice(1)));return n}}function En(e){if(re(e)||W(e)){let n=e.copy();return n.values=En(n.values),n.index=En(n.index),n}p(S(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Ye(e,t,n=1){p(!J(e)&&!J(t)&&!J(n),"You must pass two numbers and optionally a step value to the `range` function!"),p(B(e)&&B(t)&&B(n),"You must pass two numbers and optionally a step value to the `range` function!"),p(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=En(u)),u}function gu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var $b=gu(256),Kb=gu(256),Ub=gu(256),Lb=gu(256),Vb=gu(256);function Vt(e){if(re(e)||W(e))return Vt(e.values);p(S(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return on(e).forEach(r=>{let o=typeof r=="object"&&r===null?$b:J(r)?Kb:Qe(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Vb:r===1/0?Ub:r===-1/0?Lb:typeof r=="bigint"?r.toString():re(r)?r.toJSONString():W(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function vh(e){if(S(e)){let t=vh(e[0]);return[e.length].concat(t||[])}else return}function te(e){return re(e)||W(e)?te(e.values):(p(S(e),"The `shape` function only works on arrays, Series, and DataFrames!"),vh(e))}function Nh(e,t,n){if(J(n)&&(n=0),p(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),S(t)){p(!du(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=te(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Ye(0,o).forEach(s=>{s>=u._values.length&&u._values.push(tn(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Ye(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(tn(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new ar("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(W(t)){let r=Nh(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(re(t))if(n===0){let r=e.copy(),o=Vt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(tn(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(tn(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new ar("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function zb(e,t,n,r,o){if(o=o||0,p(Qe(r),"The first parameter to the `apply` method must be a function."),p(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,J(s)&&(s=c instanceof t||S(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return J(u)&&(u=c instanceof t||S(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function me(e){return typeof e=="string"}function Wb(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(J(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(On(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new ar("You must pass a DataFrame, Series, or object into the `assign` method!")}else{p(me(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),p(S(o)&&!du(o)&&te(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function Gb(e,t){if(t.isEmpty)return new e;let n=new e(rt(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function qb(e,t,n,r,o){J(r)&&(r=[]),J(o)&&(o=[]),(me(r)||B(r))&&(r=[r]),(me(o)||B(o))&&(o=[o]),p(S(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),p(S(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),p(te(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),p(te(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function wh(e){return B(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function so(e){return wh(e)&&e>=0}function Hb(e,t,n,r,o,u){r=r||0,p(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,p(so(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",p(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(J(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(J(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!J(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(te(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(J(c))return new e;me(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function sl(e){if(re(e)||W(e))return e.dropNaN(...Object.values(arguments).slice(1));p(S(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(sl(n))}catch{if(B(n))return t.push(n)}}),t}function Qb(e,t,n,r,o){n=n||0,p(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,p(so(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",p(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=sl(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function Qf(e){let t={};return on(e).forEach((n,r)=>{t[n]=r}),t}function Xr(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function Zb(e,t,n,r,o){p(Qe(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),J(o)&&(o=0),p(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=Qf(u.index),i=Qf(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Xr(s)[0],c.index=Xr(i),c}u.values=l,u.index=Xr(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Xr(i)[0],c.index=Xr(s),c}u.values=l,u.index=Xr(i),u=u.transpose()}return u}function Xb(e,t,n){(me(t)||B(t))&&(t=[t]),(me(n)||B(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Vt((t||[]).concat(n||[]).map(o=>typeof o));return p(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&p(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(p(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),p(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),J(t)||(t=t.map(o=>{if(me(o))return p(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(B(o))return p(o>=0,`Index ${o} is out of bounds!`),p(Math.floor(o)===o,"Row numbers must be integers!"),p(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),J(n)||(n=n.map(o=>{if(me(o))return p(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(B(o))return p(o>=0,`Column ${o} is out of bounds!`),p(Math.floor(o)===o,"Column numbers must be integers!"),p(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function xb(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Dr(e,t){if(J(t)&&(t=xb),re(e)||W(e))return e.sort(...Object.values(arguments).slice(1));p(S(e),"The `sort` function only works on arrays, Series, and DataFrames!"),p(Qe(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function e1(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function Zf(e,t,n){J(n)?n=t.columns:me(n)&&(n=[n]);let r={};n.forEach(u=>{p(me(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);p(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Dr(Vt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+e1(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function t1(e,t,n){let r=e.shape;J(t)&&(t=Ye(0,r[0])),J(n)&&(n=Ye(0,r[1])),B(t)&&(t=[t]),B(n)&&(n=[n]),p(S(t)&&S(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),p(te(t).length===1&&te(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),p(t.length>0,"The `rowIndices` array must contain at least one index."),p(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{p(so(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),p(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{p(so(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),p(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function n1(e,t,n,r,o){J(r)&&(r=n.index),J(o)&&(o=n.columns),me(r)&&(r=[r]),me(o)&&(o=[o]),p(S(r)&&S(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),p(te(r).length===1&&te(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),p(r.length>0,"The `rows` array must contain at least one row name."),p(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{p(me(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),p(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{p(me(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),p(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function r1(e,t,n){function r(h,m){return me(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Ye(0,u).concat(Ye(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Ye(0,i).concat(Ye(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Ye(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function no(e,t){p(B(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function o1(e,t){let n=t?e:e.copy();return n.index=Ye(0,e.shape[0]).map(r=>"row"+no(r,(n.index.length-1).toString().length)),n}function pu(e,t){if(re(e)||W(e))return pu(e.values,t);p(S(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=on(e),r=!1,o=1;for(let u of n){if(!B(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function u1(e){return wh(e)&&e>0}function cu(e,t){if(re(e)||W(e))return cu(e.values,t);if(p(S(e),"The first argument passed into the `reshape` function must be an array!"),B(t)&&(t=[t]),p(S(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),p(te(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),p(u1(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return on(e);let n=on(e);if(t.length===1&&t[0]===n.length)return n;p(pu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(cu(s,t.slice(1)))}return r}var Eh=Math.pow(2,64),Te=[];Dh(Math.floor(Math.random()*Eh));function s1(e,t){e=ct(e);function n(){e+=ct("0x9e3779b97f4a7c15");let o=rt(e);return o=(o^o>>BigInt(30))*ct("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*ct("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function ct(e){return BigInt.asUintN(64,BigInt(e))}function Xf(e,t){return e=ct(e),t=BigInt(t),ct(ct(e<<t)|ct(e>>ct(BigInt(64)-t)))}function Dh(e){if(typeof e=="bigint"&&(e=Number(e)),J(e))return rt(Te);{p(B(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=s1(Math.floor(e),4);Te[0]=t[0],Te[1]=t[1],Te[2]=t[2],Te[3]=t[3]}}function xf(){let e=ct(Xf(Te[0]+Te[3],23)+Te[0]),t=ct(Te[1]<<BigInt(17));return Te[2]=ct(Te[2]^Te[0]),Te[3]=ct(Te[3]^Te[1]),Te[1]=ct(Te[1]^Te[2]),Te[0]=ct(Te[0]^Te[3]),Te[2]=ct(Te[2]^t),Te[3]=Xf(Te[3],45),Math.floor(Number(e))/Eh}function io(e){return J(e)?xf():(S(e)||(e=[e]),cu(tn(pu(e)).map(xf),e))}function $s(e){if(re(e)||W(e))return e.shuffle(...Object.values(arguments).slice(1));p(S(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(io()*n.length);t.push(n.splice(o,1)[0])}return t}function i1(e,t){return J(t)&&(t=0),p(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?$s(e.index):null,t===1?$s(e.columns):null)}function Nr(e){return typeof e=="boolean"}function a1(e,t,n){return Qe(t)?l1(e,t,n):c1(e,t,n)}function l1(e,t,n){if(n=J(n)?0:n,p(Qe(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),p(B(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Dr(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Dr(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function c1(e,t,n){let r=e.copy(),o=io().toString();r=r.assign(o,r.index),J(t)&&(t=[o],n=[!0]),(B(t)||me(t))&&(t=[t],(Nr(n)||me(n))&&(n=[n])),p(S(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),p(te(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),J(n)&&(n=Ye(0,t.length).map(()=>!0)),p(S(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),p(te(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),p(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(p(me(s)||B(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),me(s)){let i=r.columns.indexOf(s);return p(i>-1,`The column "${s}" does not exist!`),i}if(B(s))return p(so(s),"Column indices must be whole numbers!"),p(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(p(me(s)||Nr(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),me(s)){let i=s.trim().toLowerCase();return p(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Nr(s))return s}),r.values=Dr(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function f1(e,t){J(t)?t=0:p(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function Sh(e,t){return JSON.stringify(e.toObject(t))}async function h1(e,t,n){let r=Sh(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new ar(s):typeof module<"u"?new ar(i):new ar("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function m1(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function qn(e){if(re(e)||W(e))return e.transpose();p(S(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=te(e);if(p(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return En(e);if(t.length===2){let n=tn(En(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function Oh(e,t,n){if(W(n))return new e(t.values.concat(n.values));if(S(n)){let r=te(n);p(r.length===1&&!Qs(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return Oh(t,[n])}function d1(e,t){p(Qe(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function g1(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>J(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function p1(e,t){let n=[],r=[];t.values.forEach((u,s)=>{B(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function y1(e,t,n){let r=t.copy(),o=rt(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function b1(e,t){(me(t)||B(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Vt((t||[]).map(r=>typeof r));return p(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&p(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(p(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),p(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),J(t)||(t=t.map(r=>{if(typeof r=="string")return p(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return p(r>=0,`Index ${r} is out of bounds!`),p(Math.floor(r)===r,"Indices must be integers!"),p(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function v1(e,t){let n=e.shape;J(t)&&(t=Ye(0,n[0])),p(S(t),"The `indices` array must be 1-dimensional array of whole numbers."),p(te(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),p(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{p(so(o),"The `indices` array must be a 1-dimensional array of whole numbers."),p(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function N1(e,t,n){J(n)&&(n=t.index),p(S(n),"The `indices` array must be a 1-dimensional array of strings."),p(te(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),p(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{p(me(u),"The `indices` array must contain only strings."),p(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function w1(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Ye(0,n/2).concat(Ye(t.index.length-n/2,t.index.length)));let o=rt(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function E1(e){let t=e.copy();return t.get($s(t.index))}function D1(e,t,n){n=n||((a,l)=>a<l?-1:1),p(J(n)||Qe(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=qn([t.values,t.index]),o=Dr(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function S1(e,t){let n=qn([t.values,t.index]);n=qn(Dr(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function O1(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var eh=Symbol.for("@jrc03c/js-math-tools/series");function F1(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===eh}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:eh}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){p(S(o),"The new values must be a 1-dimensional array!");let u=te(o);p(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Ye(this._index.length,u[0]).map(s=>"item"+no(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){p(S(o),"The new index must be a 1-dimensional array of strings!"),p(o.length===this.shape[0],"The new index must be the same length as the old index!"),p(te(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{p(me(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=rt(r.values),this.index=rt(r.index);else if(S(r)){let o=te(r);p(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());p(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];p(te(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return te(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!J(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return b1(this,r)}getSubsetByNames(r){return N1(t,this,r)}getSubsetByIndices(r){return v1(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(En(this.values));return r.index=En(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Ye(0,this.shape[0]).map(o=>"item"+no(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=rt(this.values),r._index=rt(this.index),r.name=this.name,r}append(r){return Oh(t,this,r)}apply(r){return d1(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return g1(this,r,o)}dropNaN(){return p1(t,this)}toObject(){return O1(this)}print(){return w1(this)}shuffle(){return E1(this)}sort(r){return D1(t,this,r)}sortByIndex(){return S1(t,this)}filter(r){return y1(t,this,r)}toDataFrame(){let r=new e(qn([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=En(r.values),r.index=En(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var th=Symbol.for("@jrc03c/js-math-tools/dataframe");function _s(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(io()*t.length)];return n}var Re=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===th}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:th}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!J(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){p(S(t),"The new values must be a 2-dimensional array!");let n=te(t);p(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Ye(this._index.length,n[0]).map(r=>"row"+no(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Ye(this._columns.length,n[1]).map(r=>"col"+no(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){p(S(t),"The new columns list must be a 1-dimensional array of strings!"),p(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),p(te(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+_s(8):r.trim()));let n=(()=>{let r=Js(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+_s(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){p(S(t),"The new index must be a 1-dimensional array of strings!"),p(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),p(te(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+_s(8):r.trim()));let n=(()=>{let r=Js(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+_s(8):r),this._index=t}}),p(J(e)||On(e)||S(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Re)this.values=rt(e.values),this.columns=rt(e.columns),this.index=rt(e.index);else if(S(e)){let t=te(e);p(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),p(!du(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{J(r)&&(n=u,r=e[u].length),p(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=qn(t);let o=te(this.values);this._index=Ye(0,o[0]).map(u=>"row"+no(u,(o[0]-1).toString().length))}}get shape(){return te(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Re(tn(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return Xb(this,e,t)}getSubsetByNames(e,t){return n1(Re,yt,this,e,t)}getSubsetByIndices(e,t){return t1(this,e,t)}getDummies(e){return Zf(Re,this,e)}oneHotEncode(e){return Zf(Re,this,e)}transpose(){let e=new Re(qn(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return o1(this,e)}copy(){return Gb(Re,this)}assign(e,t){return Wb(Re,yt,this,e,t)}apply(e,t){return zb(Re,yt,this,e,t)}dropMissing(e,t,n){return Hb(Re,yt,this,e,t,n)}dropNaN(e,t,n){return Qb(Re,this,e,t,n)}drop(e,t){return qb(Re,yt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return f1(this,e)}toObject(){return m1(this)}toJSONString(e){return Sh(this,e)}saveAsJSON(e,t){return h1(this,e,t)}print(){return r1(Re,yt,this)}sort(e,t){return a1(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return Zb(Re,yt,this,e,t)}shuffle(e){return i1(this,e)}append(e,t){return Nh(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},yt=F1(Re);function Zs(e,t){return Bt(e,{shouldDropNaNs:t}).max}function be(e){return p(Qe(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return S(a)?!0:W(a)?(n=!0,o.push(a),!0):re(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{p(Fn(S(i)?te(i):i.shape,S(s[a+1])?te(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=Zs(s.map(l=>l.length?l.length:l.values.length)),a=Ye(0,i).map(l=>{let c=Object.keys(arguments).map(f=>S(arguments[f])?arguments[f][l]:W(arguments[f])||re(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&Fn(te(u[0]),te(a))){let l=new Re(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Re(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new yt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new yt(a)}catch{return a}return a}else return e(...arguments)}}function _1(e){try{return B(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var il=be(_1);function T1(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!B(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Ks=be(T1);function A1(e,t){try{return t(e)}catch{return NaN}}var Xs=be(A1);function I1(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var j1=be(I1);function C1(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var M1=be(C1);function B1(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var P1=be(B1);function Ya(e,t){if(re(e)){let n=Ya(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(W(e)){let n=Ya(e.values,t);return e.index[n]}p(S(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=uo(e,Zs(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Fh(e,t){return Bt(e,{shouldDropNaNs:t}).min}function Ja(e,t){if(re(e)){let n=Ja(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(W(e)){let n=Ja(e.values,t);return e.index[n]}p(S(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=uo(e,Fh(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Ct(e,t){if(re(e)||W(e))return e.apply(n=>Ct(n,t));if(S(e))return e.map(n=>Ct(n,t));if(t==="null")return null;if(t==="number"){if(J(e))return NaN;let n=Ct(e,"boolean");if(Nr(n))return n?1:0;try{JSON.parse(e)}catch{let u=Ct(e,"date");if(rn(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=Ct(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return Ct(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(Ct(e,"int"));if(t==="boolean"){if(Nr(e))return e;if(B(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(rn(e))return e;if(J(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return rn(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(On(e))return e;let n=Ct(e,"boolean");if(Nr(n))return null;try{let o=Ct(e,"number");if(B(o))return JSON.parse(e),null}catch{}let r=Ct(e,"date");if(r)return r;try{let o=JSON.parse(e);return S(o)?o.map(u=>Ct(u,t)):o}catch{return null}}if(t==="string")return J(e)?Fn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function R1(e){try{return B(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var k1=be(R1);function Y1(e,t){try{if(!B(e))return NaN;if(typeof e=="bigint")return e;if(J(t))t=1e-10;else if(!B(t))return NaN;return il(e)<t?0:e}catch{return NaN}}var J1=be(Y1);function $a(e){if(re(e)||W(e)){let t=e.copy();return t.values=$a(t.values),t}if(S(e))return e.map(t=>$a(t));try{let t=JSON.parse(e);return B(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var _n=be($a);function _h(e,t,n){try{return B(e)?B(t)?B(n)?typeof e=="bigint"?BigInt(_h(_n(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var $1=be(_h);function Us(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of Us(i,o-1))yield[s].concat(a)}}return re(e)||W(e)?Us(e.values,t):(p(S(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),p(B(t)&&_n(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(on(e),t))}function Th(e,t){let n=[];for(let r of Us(e,t))n.push(r.slice());return n}function Ah(){let e=Object.values(arguments).map(n=>re(n)||W(n)?Vt(n.values):(p(S(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Vt(n)));return Vt(e).filter(n=>e.every(r=>r.findIndex(o=>Fn(o,n))>-1))}var ru=class{constructor(e){p(J(e)||e===ru.DROP_NAN_MODE||e===ru.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=J(e)?ru.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(S(t)){let n=te(t);if(n.length===1)t=new yt(t);else if(n.length===2)t=new Re(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}p(re(t)||W(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===ru.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Ah(...e),this}transform(){p(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(S(t)){let n=te(t);if(n.length===1)return new yt(t).get(this.index).values;if(n.length===2)return new Re(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return p(re(t)||W(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},xs=ru;yh(xs,"DROP_NAN_MODE","DROP_NAN_MODE");yh(xs,"DROP_MISSING_MODE","DROP_MISSING_MODE");function iu(e,t,n,r){if(W(e))return iu(e.values,t,n,r);if(W(t))return iu(e,t.values,n,r);if(p(S(e)&&S(t)&&te(e).length===1&&te(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),p(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return iu(...new xs().fitAndTransform(e,t),!1,r);try{let o=Bt(e,{stdev:r}),u=Bt(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!B(s)||!B(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!B(f))return NaN;if(!B(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function Ka(e,t,n){if(W(e))return Ka(e.values,t,n);if(W(t))return Ka(e,t.values,n);p(S(e)&&S(t)&&te(e).length===1&&te(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),p(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=iu(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function K1(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var U1=be(K1),L1=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Ua(e,t){if(re(e)||W(e))return Ua(e.values,t);if(re(t)||W(t))return Ua(e,t.values);p(S(e)&&S(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Vt(e),r=Vt(t),o=[];return n.forEach(u=>{r.findIndex(s=>Fn(s,u))<0&&o.push(u)}),o}function Ih(e,t){try{if(!B(e))return NaN;if(!B(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Ih(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var al=be(Ih);function jh(e){try{if(!B(e))return NaN;if(typeof e=="bigint"){let t=jh(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Ch=be(jh);function V1(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!B(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var Mh=be(V1);function ao(){return Mh(...arguments)}function Bh(e,t){return Ks(e,ao(t,-1))}function ll(e,t){return Bt(e,{shouldDropNaNs:t}).sum}function La(e,t){if(B(e)&&B(t))return il(e-t);if(re(e)||W(e))return La(e.values,t);if(re(t)||W(t))return La(e,t.values);S(e)&&S(t)&&p(Fn(te(e),te(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Ch(ll(al(Bh(e,t),2)))}catch{return NaN}}function z1(e,t){return ao(e,al(t,-1))}function Wn(e,t){if(re(e)){let o=Wn(e.values,t);if(te(o).length===1){let u=new yt(o);return u.name=W(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Re(o);return u.index=e.index.slice(),re(t)&&(u.columns=t.columns.slice()),u}}if(re(t)){let o=Wn(e,t.values);if(te(o).length===1){let u=new yt(o);return u.name=W(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Re(o);return u.columns=t.columns.slice(),u}}if(W(e))return Wn(e.values,t);if(W(t))return Wn(e,t.values);p(S(e)&&S(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=te(e),r=te(t);if(p(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),p(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return ll(ao(e,t));if(n.length===1&&r.length===2)return qn(t).map(o=>Wn(e,o));if(n.length===2&&r.length===1)return e.map(o=>Wn(o,t));if(n.length===2&&r.length===2){let o=qn(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(Wn(e[s],o[a]));u.push(i)}return u}}function cl(e){if(re(e)||W(e))return e.dropMissing(...Object.values(arguments).slice(1));p(S(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(cl(n))}catch{J(n)||t.push(n)}}),t}function js(e,t){if(re(e)||W(e))return js(e.values,t);if(re(t)||W(t))return js(e,t.values);p(S(e)&&S(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),p(Fn(te(e),te(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=js(e[o],t[o]);n.push(u),r.push(s)}catch{!J(e[o])&&!J(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function Cs(e,t){if(re(e)||W(e))return Cs(e.values,t);if(re(t)||W(t))return Cs(e,t.values);p(S(e)&&S(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),p(Fn(te(e),te(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Cs(e[o],t[o]);n.push(u),r.push(s)}catch{B(e[o])&&B(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function W1(e){return cl(e)}function Ls(e,t){if(re(e)||W(e))return Ls(e.values,t);p(S(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),p(Qe(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(S(n)){if(!Ls(n,t))return!1}else if(!t(n))return!1;return!0}function G1(e){try{if(!B(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var q1=be(G1);function Va(e){try{return typeof e=="bigint"?BigInt(Va(_n(e))):e!==_n(e)?NaN:e<=1?1:e*Va(e-1)}catch{return NaN}}var H1=be(Va);function za(e,t){if(re(e)||W(e))return za(e.values,t);if(p(On(e)||S(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Qe(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(On(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(S(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function Wa(e,t){if(re(e)||W(e))return Wa(e.values,t);if(p(On(e)||S(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Qe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(On(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(S(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function Q1(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return B(t)?t:NaN}catch{return NaN}}var Z1=be(Q1);function X1(e){try{return B(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var x1=be(X1);function fl(e){B(e)&&(e=[e]);let t=[],n=pu(e);for(let r=0;r<n;r++)t.push(0);return cu(t,e)}function ev(e){typeof e=="bigint"&&(e=_n(e)),p(!J(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),p(B(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),p(_n(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),p(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=fl([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var tv=["true","false","yes","no"],nv=["null","none","nan","na","n/a","","undefined"];function Ts(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=_n(e.value)===e.value:e.isInteger=Ls(e.values,t=>B(t)?_n(t)===t:!0)),e}function Ms(e){if(re(e)){let u=e.copy(),s=Ms(e.values);return u.values=s.values,Ts({type:s.type,values:u})}if(W(e)){let u=e.copy(),s=Ms(e.values);return u.values=s.values,Ts({type:s.type,values:u})}if(!S(e)){let u=Ms([e]);return u.value=u.values[0],delete u.values,Ts(u)}p(S(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=on(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(rn(a))return"date"}}catch{}me(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(nv.indexOf(i)>-1)return"null";if(tv.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return B(a)?"number":typeof a=="object"?S(a)?"string":"object":"string"}catch{let l=new Date(u);return rn(l)?"date":"string"}}),n=Js(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return Ts({type:o,values:Xs(e,u=>Ct(u,o))})}function Bs(e){if(re(e)){let n=e.copy();return n.values=Bs(n.values),n}p(S(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=te(e);if(p(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),p(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),p(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){p(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;p(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return ao(i,1/s)}else if(t[0]>1){let n=(r,o)=>B(r)||B(o)?ao(r,o):Wn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=Bs(o),l=Bs(Ks(i,n(-1,n(n(s,a),u)))),c=Ks(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}p(!1,"This matrix cannot be inverted!")}}var rv=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Ph(e,t,n){try{if(!B(e))return NaN;if(!B(t))return NaN;if(!B(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Ph(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var ov=be(Ph);function Rh(e,t){try{if(t=J(t)?Math.E:t,!B(e))return NaN;if(!B(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Rh(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var uv=be(Rh);function sv(e,t){return Bt(e,{shouldDropNaNs:t}).mean}function iv(e,t){return Bt(e,{shouldDropNaNs:t,median:!0}).median}function kh(e,t){try{if(!B(e))return NaN;if(!B(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=kh(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var av=be(kh);function lv(e,t){return Bt(e,{shouldDropNaNs:t,mode:!0}).mode}function nh(){let e=io(),t=io();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function cv(e){return J(e)?nh():Xs(tn(e),nh)}function fv(e){return Xs(tn(e),()=>1)}function hl(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of Th(r,o)){if(!u.slice)continue;let s=fl(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return re(e)||W(e)?hl(e.values,t):(p(S(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),J(t)&&(t=e.length),p(B(t)&&_n(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(on(e),t))}function hv(e,t){let n=[];for(let r of hl(e,t))n.push(r.slice());return n}function mv(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(S(t))if(du(t))console.log(t);else{let n=te(t);n.length===1?new yt(t).print():n.length==2?new Re(t).print():console.log(t)}else re(t)||W(t)?t.print():console.log(t)})}var dv=be((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!B(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function gv(e,t,n,r,o){if(S(e)&&J(r)&&J(o)){r=t,o=n;let u=Bt(e);t=u.min,n=u.max}return dv(e,t,n,r,o)}function pv(e){try{return B(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var yv=be(pv);function Yh(e){try{return B(e)?typeof e=="bigint"?BigInt(Yh(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var bv=be(Yh);function vv(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Nv=be(vv);function Ga(e,t){if(re(e)||W(e))return Ga(e.values,t);p(S(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),p(Qe(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(S(n)){if(Ga(n,t))return!0}else if(t(n))return!0;return!1}function Jh(e,t){return Bt(e,{shouldDropNaNs:t,stdev:!0}).stdev}function wv(e){return Jh(e)}function Ev(e){try{return B(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var Dv=be(Ev);function rh(e,t){p(Qe(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function Sv(e,t){p(Qe(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function Ov(){return Vt([...arguments].map(e=>S(e)?e:re(e)||W(e)?e.values:[e]))}function Fv(e,t){return Bt(e,{shouldDropNaNs:t,variance:!0}).variance}function _v(){let e=[],t=Object.values(arguments).map(n=>((re(n)||W(n))&&(n=n.values),p(S(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Ye(0,Zs(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(J(u)?void 0:u)}),e.push(r)}),e}var ou={abs:il,add:Ks,apply:Xs,arccos:j1,arcsin:M1,arctan:P1,argmax:Ya,argmin:Ja,assert:p,cast:Ct,ceil:k1,chop:J1,clamp:$1,combinations:Th,combinationsIterator:Us,copy:rt,correl:Ka,cos:U1,count:Js,covariance:iu,DataFrame:Re,dataTypes:L1,decycle:Er,diff:Ua,distance:La,divide:z1,dot:Wn,dropMissing:cl,dropMissingPairwise:js,dropNaN:sl,dropNaNPairwise:Cs,dropUndefined:W1,every:Ls,exp:q1,factorial:H1,find:za,findAll:Wa,flatten:on,float:Z1,floor:x1,identity:ev,IndexMatcher:xs,indexOf:uo,inferType:Ms,int:_n,intersect:Ah,inverse:Bs,isArray:S,isBoolean:Nr,isBrowser:rv,isDataFrame:re,isDate:rn,isEqual:Fn,isFunction:Qe,isJagged:du,isNested:Qs,isNumber:B,isObject:On,isSeries:W,isString:me,isUndefined:J,lerp:ov,log:uv,MathError:ar,max:Zs,mean:sv,median:iv,min:Fh,mod:av,mode:lv,multiply:Mh,ndarray:tn,normal:cv,ones:fv,permutations:hv,permutationsIterator:hl,pow:al,print:mv,product:pu,random:io,range:Ye,remap:gv,reshape:cu,reverse:En,round:yv,scale:ao,seed:Dh,Series:yt,set:Vt,shape:te,shuffle:$s,sign:bv,sin:Nv,some:Ga,sort:Dr,sqrt:Ch,stats:Bt,std:Jh,stdev:wv,subtract:Bh,sum:ll,tan:Dv,timeAsync:Sv,timeSync:rh,time:rh,transpose:qn,union:Ov,variance:Fv,vectorize:be,zeros:fl,zip:_v,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new ou.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(ou).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:ou[t]})}catch{e[t]=ou[t]}})}};typeof window<"u"&&(window.JSMathTools=ou);var Tv=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:void 0;function qa(e){let t=Symbol.for("@TypedArrayConstructor"),n="Symbol(@TypedArrayConstructor)",r=t in e?t:n in e?n:void 0;if(r){if(!("values"in e))throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");return e[r]==="ArrayBuffer"?new Uint8Array(e.values).buffer:new Tv[e[r]](e.values)}if(S(e)&&e.constructor.name==="Array")return e;throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!")}function ro(e){if(e instanceof ArrayBuffer||e instanceof BigInt64Array||e instanceof BigUint64Array||e instanceof Float32Array||e instanceof Float64Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Int8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:e.constructor.name,values:e instanceof ArrayBuffer?Array.from(new Uint8Array(e)):Array.from(e)};if(S(e))return e.map(t=>{try{return ro(t)}catch{return t}});if(typeof e=="object"&e!==null){if(rn(e))return new Date(e.getTime());let t={};return Object.keys(e).forEach(n=>{try{t[n]=ro(e[n])}catch{t[n]=e[n]}}),t}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function $h(e){return e=e.trim(),!!(e.match(/^-?\d+(\.\d+)?$/g)||e.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g)||e.match(/^-?\.\d+$/g)||e==="NaN")}var Kh="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";function Uh(e,t,n){if(typeof e!="string")throw new Error("`text` must be a string!");if(typeof t!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return e.split(t).join(n)}var oh="  ",uh=" ";function ml(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t="";for(let n=0;n<e.length;n++){let r=e[n].toLowerCase();Kh.includes(r)?t+=uh:t+=r}for(;t.includes(oh);)t=Uh(t,oh,uh);return t.trim()}function Av(e,t){return t=t||"",e.split(`
`).map(n=>n.trim().length>0?t+n:n).join(`
`)}function Iv(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=ml(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("-")}var sh={"@Infinity":1/0,"@NegativeInfinity":-1/0,"@NaN":NaN,"@undefined":void 0};function fu(e){if(typeof e=="object"){if(e===null)return e;if(S(e))for(let t=0;t<e.length;t++)e[t]=fu(e[t]);else Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{e[t]=fu(e[t])});return e}else return typeof e>"u"||e==="Symbol(@undefined)"?void 0:e}function jv(e){if(typeof e=="bigint")return e;if(typeof e=="string")if(e.match(/^\s*?-?\d+n\s*?$/g))try{return BigInt(e.split("n")[0])}catch{return NaN}else return NaN;else return NaN}function Cv(e){if(typeof e!="string")return typeof e=="number"?e:void 0;if($h(e))return parseFloat(e)}function Mv(e){if(typeof e!="string")return;let t="@jrc03c/js-text-tools/newline-replacer";if(e=e.replaceAll(`
`,t),e.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)){let n=e.replace("Symbol(@String):","");if(n.match(/^".*?"$/g))try{return JSON.parse(n)}catch{n=n.substring(1,n.length-1)}return n=n.replaceAll(t,`
`),n}}function Bv(e){if(typeof e!="string")return typeof e=="symbol"?{out:e,isASymbol:!0}:void 0;if(e.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)){let t=e.replace(/^.*?Symbol\(/g,"").replace(/\).*?$/g,"");return t in sh?{out:sh[t],isASymbol:!0}:{out:Symbol.for(t),isASymbol:!0}}}function Pv(e){if(typeof e!="string")return e instanceof RegExp?e:void 0;let t=e.trim();if(t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g))try{let n=t.replace(/^\//g,"").replace(/\/(d|g|i|m|s|u|v|y)*?$/g,""),r=t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);return new RegExp(n,r)}catch{}}function Rv(e){if(typeof e!="string")return typeof e=="object"?e:"Symbol(@undefined)";try{let t=JSON.parse(e,(n,r)=>{try{let o=Vs(r);return typeof o>"u"?"Symbol(@undefined)":o}catch{return typeof r>"u"?"Symbol(@undefined)":r}});return S(t)&&(t=fu(t)),t}catch{return e}}function kv(e){if(typeof e!="string")return e instanceof Date&&e.toString()!=="Invalid Date"?e:void 0;try{let t=new Date(Date.parse(e));if(t.toString()!=="Invalid Date")return t}catch{}}function Yv(e){return typeof e=="object"?e!==null?fu(e):void 0:(Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{try{let n=t;try{t=Vs(t)}catch{}e[t]=Vs(e[n]),t!==n&&delete e[n]}catch{}}),fu(e))}function Vs(e){function t(n){if(typeof n=="string"){let r=Mv(n);if(typeof r=="string")return r;let o=Bv(n);return r=o?o.out:void 0,o&&o.isASymbol||(r=Pv(n),r instanceof RegExp)||(r=jv(n),typeof r=="bigint")||(r=Cv(n),typeof r=="number")||(r=kv(n),r instanceof Date)?r:(r=Rv(n),typeof r<"u"?r==="Symbol(@undefined)"?void 0:r:n)}if(typeof n=="object"){if(n===null)return null;let r;try{if(r=qa(n),S(r))return r}catch{}if(r=Yv(n),r)try{return qa(r)}catch{return r}return n}return n}return t(e)}function dl(e){let t=ph(e);return t[0].toUpperCase()+t.slice(1)}function Jv(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=ml(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("_")}function ir(e,t){return!e||t<=0?"":Ye(0,t).map(()=>e).join("")}function $v(e,t){p(me(t)||J(t),"The second parameter to the `stringify` function must be undefined or a string!");let n=t?`
`:"";function r(o,u,s){return s=s||0,typeof o=="bigint"?JSON.stringify(o.toString()+"n"):typeof o=="number"?o===1/0?'"Symbol(@Infinity)"':o===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(o)?'"Symbol(@NaN)"':o.toString():typeof o=="string"?JSON.stringify("Symbol(@String):"+o):typeof o=="boolean"?o.toString():typeof o>"u"?'"Symbol(@undefined)"':typeof o=="symbol"||typeof o=="function"?JSON.stringify(o.toString()):o instanceof RegExp?o.toString():typeof o=="object"?o===null?"null":rn(o)?JSON.stringify(o.toJSON()):S(o)?o.length===0?ir(u,s-1)+"[]":o instanceof Array?ir(u,s-1)+"["+n+o.map(i=>{let a=(()=>{try{return r(ro(i),u,s+1)}catch{return r(i,u,s+1)}})();return me(a)&&(a=a.trim()),ir(u,s+1)+a}).join(","+n)+n+ir(u,s)+"]":r(ro(o),null,u):Object.keys(o).length+Object.getOwnPropertySymbols(o).length===0?ir(u,s-1)+"{}":ir(u,s-1)+"{"+n+Object.keys(o).concat(Object.getOwnPropertySymbols(o)).map(i=>{let a=(()=>{try{return r(ro(o[i]),u,s+1)}catch{return r(o[i],u,s+1)}})();me(a)&&(a=a.trim());let l=typeof i=="symbol"?r(i):JSON.stringify(i);return ir(u,s+1)+l+":"+(u?" ":"")+a}).join(","+n)+n+ir(u,s)+"}":"undefined"}return r(Er(e),t)}function Kv(e){let t=e.split(`
`),n=t.filter(o=>o.trim().length>0).map(o=>o.split("").findIndex(u=>!u.match(/\s/g))),r=Math.min(...n);return t.map(o=>o.substring(r)).join(`
`)}function Uv(e,t){if(typeof e!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof t>"u"||t===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?t=process.stdout.columns>80?80:process.stdout.columns:t=80),isNaN(t)||typeof t!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return e.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let o=r.split(/[^\s]/g)[0],u=r.replace(o,"").split(" "),s=o;u.forEach(i=>{let a=s+(s.trim().length>0?" ":"")+i;a.length>t?(n.push(s),s=o+i):s=a}),s.length>0&&n.push(s)}),n.join(`
`)}typeof window<"u"&&(window.JSTextTools={camelify:ph,convertObjectToTypedArray:qa,convertTypedArrayToObject:ro,indent:Av,isANumberString:$h,kebabify:Iv,parse:Vs,pascalify:dl,punctuation:Kh,replaceAll:Uh,snakeify:Jv,stringify:$v,strip:ml,unindent:Kv,wrap:Uv});function Or(e,t){if(typeof e!="string")throw new Error("The first argument passed into the `createType` function must be a string representing the type's name!");if(typeof t!="function")throw new Error("The second argument passed into the `createType` function must be a function that tests a single value and returns true or false depending on whether or not the value 'matches' the type!");let n=class{constructor(){throw new Error("This class is not meant to be instantiated or subclassed! Its only purpose is type checking.")}static[Symbol.hasInstance](r){try{return!!t(r)}catch{try{return r instanceof t}catch{return!1}}}};return Object.defineProperty(n,"name",{configurable:!1,enumerable:!1,writable:!1,value:dl(e)}),n}var Lv=Object.defineProperty,Vv=(e,t,n)=>t in e?Lv(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Lh=(e,t,n)=>(Vv(e,typeof t!="symbol"?t+"":t,n),n);function P(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var zv=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),lr=class extends Error{constructor(e){zv()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function v(e,t){if(!e)throw new lr(t)}var Vh=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function U(e){return e===null||typeof e>"u"}var Wv=Vh.map(e=>e.name);function F(e){try{return e instanceof Array?!0:U(e.constructor)?!1:Vh.indexOf(e.constructor)>-1||Wv.indexOf(e.constructor.name)>-1}catch{return!1}}function oe(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function Ze(e){return typeof e=="function"}function Tn(e){return typeof e=="object"&&!U(e)&&!F(e)}function G(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function lo(e,t){if(oe(e)){let u=lo(e.values,t);return u.length>0&&P(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&P(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(G(e)){let u=lo(e.values,t);return u.length>0&&P(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(v(Tn(e)||F(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Ze(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Tn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(F(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function ot(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(F(n))return n instanceof Array?n.map(o=>ot(o)):n.slice();if(G(n)){let o=n.copy();return o.values=ot(o.values),o}if(oe(n)){let o=n.copy();return o.values=ot(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=co(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=ot(n[o])}),r}else return n}return t(co(e))}function co(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+lo(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),F(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(oe(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(G(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function Sn(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var ih=["number","int","float","bigint"];function An(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!ih.includes(u)&&!ih.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(Sn(r))return Sn(o)?r.getTime()===o.getTime():!1;if(Sn(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(F(r)!==F(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(co(e),co(t))}}function yu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Gv=yu(16),qv=yu(16),Hv=yu(16),Qv=yu(16),Zv=yu(16),Xv=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)F(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Gv:U(e)?qv:Ze(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Zv:e===1/0?Hv:e===-1/0?Qv:typeof e=="bigint"?e.toString():oe(e)?e.toJSONString():G(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!U(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function Wt(e){if(oe(e)||G(e))return Wt(e.values);v(F(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{F(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Pt(e,t){t=t||{};let n=new Xv,r={},o=Wt(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||P(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function zs(e,t){let{counts:n}=Pt(e);return U(t)||(Ze(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{An(r,t)||n.delete(r)})),n}function Ha(e){if(oe(e)||G(e))return Ha(e.values);if(F(e)){let t=!1,n=!1,r=null;for(let o of e){if(Ha(o))return!0;if(F(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function bu(e){return Ha(co(e))}function ei(e){if(oe(e)||G(e))return ei(e.values);v(F(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(F(e[t]))return!0;return!1}var xr="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function nn(e){v(!U(e),xr),F(e)||(e=[e]),v(!ei(e),xr),v(e.length>0,xr);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),v(P(t),xr),v(t>=0,xr),v(Math.floor(t)===t,xr),v(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(nn(e.slice(1)));return n}}function Dn(e){if(oe(e)||G(e)){let n=e.copy();return n.values=Dn(n.values),n.index=Dn(n.index),n}v(F(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Ve(e,t,n=1){v(!U(e)&&!U(t)&&!U(n),"You must pass two numbers and optionally a step value to the `range` function!"),v(P(e)&&P(t)&&P(n),"You must pass two numbers and optionally a step value to the `range` function!"),v(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=Dn(u)),u}function vu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var xv=vu(256),eN=vu(256),tN=vu(256),nN=vu(256),rN=vu(256);function zt(e){if(oe(e)||G(e))return zt(e.values);v(F(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return Wt(e).forEach(r=>{let o=typeof r=="object"&&r===null?xv:U(r)?eN:Ze(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+rN:r===1/0?tN:r===-1/0?nN:typeof r=="bigint"?r.toString():oe(r)?r.toJSONString():G(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function zh(e){if(F(e)){let t=zh(e[0]);return[e.length].concat(t||[])}else return}function ne(e){return oe(e)||G(e)?ne(e.values):(v(F(e),"The `shape` function only works on arrays, Series, and DataFrames!"),zh(e))}function Wh(e,t,n){if(U(n)&&(n=0),v(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),F(t)){v(!bu(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=ne(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Ve(0,o).forEach(s=>{s>=u._values.length&&u._values.push(nn(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Ve(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(nn(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new lr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(G(t)){let r=Wh(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(oe(t))if(n===0){let r=e.copy(),o=zt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(nn(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(nn(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new lr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function oN(e,t,n,r,o){if(o=o||0,v(Ze(r),"The first parameter to the `apply` method must be a function."),v(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,U(s)&&(s=c instanceof t||F(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return U(u)&&(u=c instanceof t||F(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function Oe(e){return typeof e=="string"}function uN(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(U(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(Tn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new lr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{v(Oe(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),v(F(o)&&!bu(o)&&ne(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function sN(e,t){if(t.isEmpty)return new e;let n=new e(ot(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function iN(e,t,n,r,o){U(r)&&(r=[]),U(o)&&(o=[]),(Oe(r)||P(r))&&(r=[r]),(Oe(o)||P(o))&&(o=[o]),v(F(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),v(F(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),v(ne(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),v(ne(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function Gh(e){return P(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function fo(e){return Gh(e)&&e>=0}function aN(e,t,n,r,o,u){r=r||0,v(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,v(fo(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",v(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(U(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(U(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!U(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(ne(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(U(c))return new e;Oe(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function gl(e){if(oe(e)||G(e))return e.dropNaN(...Object.values(arguments).slice(1));v(F(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(gl(n))}catch{if(P(n))return t.push(n)}}),t}function lN(e,t,n,r,o){n=n||0,v(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,v(fo(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",v(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=gl(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function ah(e){let t={};return Wt(e).forEach((n,r)=>{t[n]=r}),t}function eo(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function cN(e,t,n,r,o){v(Ze(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),U(o)&&(o=0),v(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=ah(u.index),i=ah(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=eo(s)[0],c.index=eo(i),c}u.values=l,u.index=eo(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=eo(i)[0],c.index=eo(s),c}u.values=l,u.index=eo(i),u=u.transpose()}return u}function fN(e,t,n){(Oe(t)||P(t))&&(t=[t]),(Oe(n)||P(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=zt((t||[]).concat(n||[]).map(o=>typeof o));return v(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&v(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(v(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),v(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),U(t)||(t=t.map(o=>{if(Oe(o))return v(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(P(o))return v(o>=0,`Index ${o} is out of bounds!`),v(Math.floor(o)===o,"Row numbers must be integers!"),v(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),U(n)||(n=n.map(o=>{if(Oe(o))return v(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(P(o))return v(o>=0,`Column ${o} is out of bounds!`),v(Math.floor(o)===o,"Column numbers must be integers!"),v(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function hN(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Sr(e,t){if(U(t)&&(t=hN),oe(e)||G(e))return e.sort(...Object.values(arguments).slice(1));v(F(e),"The `sort` function only works on arrays, Series, and DataFrames!"),v(Ze(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function mN(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function lh(e,t,n){U(n)?n=t.columns:Oe(n)&&(n=[n]);let r={};n.forEach(u=>{v(Oe(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);v(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Sr(zt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+mN(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function dN(e,t,n){let r=e.shape;U(t)&&(t=Ve(0,r[0])),U(n)&&(n=Ve(0,r[1])),P(t)&&(t=[t]),P(n)&&(n=[n]),v(F(t)&&F(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),v(ne(t).length===1&&ne(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),v(t.length>0,"The `rowIndices` array must contain at least one index."),v(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{v(fo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),v(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{v(fo(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),v(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function gN(e,t,n,r,o){U(r)&&(r=n.index),U(o)&&(o=n.columns),Oe(r)&&(r=[r]),Oe(o)&&(o=[o]),v(F(r)&&F(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),v(ne(r).length===1&&ne(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),v(r.length>0,"The `rows` array must contain at least one row name."),v(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{v(Oe(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),v(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{v(Oe(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),v(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function pN(e,t,n){function r(h,m){return Oe(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Ve(0,u).concat(Ve(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Ve(0,i).concat(Ve(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Ve(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function oo(e,t){v(P(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function yN(e,t){let n=t?e:e.copy();return n.index=Ve(0,e.shape[0]).map(r=>"row"+oo(r,(n.index.length-1).toString().length)),n}function Nu(e,t){if(oe(e)||G(e))return Nu(e.values,t);v(F(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=Wt(e),r=!1,o=1;for(let u of n){if(!P(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function bN(e){return Gh(e)&&e>0}function hu(e,t){if(oe(e)||G(e))return hu(e.values,t);if(v(F(e),"The first argument passed into the `reshape` function must be an array!"),P(t)&&(t=[t]),v(F(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),v(ne(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),v(bN(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return Wt(e);let n=Wt(e);if(t.length===1&&t[0]===n.length)return n;v(Nu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(hu(s,t.slice(1)))}return r}var qh=Math.pow(2,64),Ae=[];Hh(Math.floor(Math.random()*qh));function vN(e,t){e=ft(e);function n(){e+=ft("0x9e3779b97f4a7c15");let o=ot(e);return o=(o^o>>BigInt(30))*ft("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*ft("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function ft(e){return BigInt.asUintN(64,BigInt(e))}function ch(e,t){return e=ft(e),t=BigInt(t),ft(ft(e<<t)|ft(e>>ft(BigInt(64)-t)))}function Hh(e){if(typeof e=="bigint"&&(e=Number(e)),U(e))return ot(Ae);{v(P(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=vN(Math.floor(e),4);Ae[0]=t[0],Ae[1]=t[1],Ae[2]=t[2],Ae[3]=t[3]}}function fh(){let e=ft(ch(Ae[0]+Ae[3],23)+Ae[0]),t=ft(Ae[1]<<BigInt(17));return Ae[2]=ft(Ae[2]^Ae[0]),Ae[3]=ft(Ae[3]^Ae[1]),Ae[1]=ft(Ae[1]^Ae[2]),Ae[0]=ft(Ae[0]^Ae[3]),Ae[2]=ft(Ae[2]^t),Ae[3]=ch(Ae[3],45),Math.floor(Number(e))/qh}function ho(e){return U(e)?fh():(F(e)||(e=[e]),hu(nn(Nu(e)).map(fh),e))}function Ws(e){if(oe(e)||G(e))return e.shuffle(...Object.values(arguments).slice(1));v(F(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(ho()*n.length);t.push(n.splice(o,1)[0])}return t}function NN(e,t){return U(t)&&(t=0),v(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?Ws(e.index):null,t===1?Ws(e.columns):null)}function wr(e){return typeof e=="boolean"}function wN(e,t,n){return Ze(t)?EN(e,t,n):DN(e,t,n)}function EN(e,t,n){if(n=U(n)?0:n,v(Ze(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),v(P(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Sr(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Sr(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function DN(e,t,n){let r=e.copy(),o=ho().toString();r=r.assign(o,r.index),U(t)&&(t=[o],n=[!0]),(P(t)||Oe(t))&&(t=[t],(wr(n)||Oe(n))&&(n=[n])),v(F(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),v(ne(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),U(n)&&(n=Ve(0,t.length).map(()=>!0)),v(F(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),v(ne(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),v(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(v(Oe(s)||P(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),Oe(s)){let i=r.columns.indexOf(s);return v(i>-1,`The column "${s}" does not exist!`),i}if(P(s))return v(fo(s),"Column indices must be whole numbers!"),v(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(v(Oe(s)||wr(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),Oe(s)){let i=s.trim().toLowerCase();return v(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(wr(s))return s}),r.values=Sr(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function SN(e,t){U(t)?t=0:v(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function Qh(e,t){return JSON.stringify(e.toObject(t))}async function ON(e,t,n){let r=Qh(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new lr(s):typeof module<"u"?new lr(i):new lr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function FN(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function Hn(e){if(oe(e)||G(e))return e.transpose();v(F(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=ne(e);if(v(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return Dn(e);if(t.length===2){let n=nn(Dn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function Zh(e,t,n){if(G(n))return new e(t.values.concat(n.values));if(F(n)){let r=ne(n);v(r.length===1&&!ei(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return Zh(t,[n])}function _N(e,t){v(Ze(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function TN(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>U(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function AN(e,t){let n=[],r=[];t.values.forEach((u,s)=>{P(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function IN(e,t,n){let r=t.copy(),o=ot(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function jN(e,t){(Oe(t)||P(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=zt((t||[]).map(r=>typeof r));return v(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&v(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(v(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),v(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),U(t)||(t=t.map(r=>{if(typeof r=="string")return v(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return v(r>=0,`Index ${r} is out of bounds!`),v(Math.floor(r)===r,"Indices must be integers!"),v(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function CN(e,t){let n=e.shape;U(t)&&(t=Ve(0,n[0])),v(F(t),"The `indices` array must be 1-dimensional array of whole numbers."),v(ne(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),v(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{v(fo(o),"The `indices` array must be a 1-dimensional array of whole numbers."),v(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function MN(e,t,n){U(n)&&(n=t.index),v(F(n),"The `indices` array must be a 1-dimensional array of strings."),v(ne(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),v(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{v(Oe(u),"The `indices` array must contain only strings."),v(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function BN(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Ve(0,n/2).concat(Ve(t.index.length-n/2,t.index.length)));let o=ot(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function PN(e){let t=e.copy();return t.get(Ws(t.index))}function RN(e,t,n){n=n||((a,l)=>a<l?-1:1),v(U(n)||Ze(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=Hn([t.values,t.index]),o=Sr(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function kN(e,t){let n=Hn([t.values,t.index]);n=Hn(Sr(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function YN(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var hh=Symbol.for("@jrc03c/js-math-tools/series");function JN(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===hh}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:hh}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){v(F(o),"The new values must be a 1-dimensional array!");let u=ne(o);v(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Ve(this._index.length,u[0]).map(s=>"item"+oo(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){v(F(o),"The new index must be a 1-dimensional array of strings!"),v(o.length===this.shape[0],"The new index must be the same length as the old index!"),v(ne(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{v(Oe(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=ot(r.values),this.index=ot(r.index);else if(F(r)){let o=ne(r);v(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());v(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];v(ne(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return ne(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!U(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return jN(this,r)}getSubsetByNames(r){return MN(t,this,r)}getSubsetByIndices(r){return CN(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(Dn(this.values));return r.index=Dn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Ve(0,this.shape[0]).map(o=>"item"+oo(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=ot(this.values),r._index=ot(this.index),r.name=this.name,r}append(r){return Zh(t,this,r)}apply(r){return _N(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return TN(this,r,o)}dropNaN(){return AN(t,this)}toObject(){return YN(this)}print(){return BN(this)}shuffle(){return PN(this)}sort(r){return RN(t,this,r)}sortByIndex(){return kN(t,this)}filter(r){return IN(t,this,r)}toDataFrame(){let r=new e(Hn([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=Dn(r.values),r.index=Dn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var mh=Symbol.for("@jrc03c/js-math-tools/dataframe");function As(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(ho()*t.length)];return n}var ke=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===mh}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:mh}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!U(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){v(F(t),"The new values must be a 2-dimensional array!");let n=ne(t);v(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Ve(this._index.length,n[0]).map(r=>"row"+oo(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Ve(this._columns.length,n[1]).map(r=>"col"+oo(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){v(F(t),"The new columns list must be a 1-dimensional array of strings!"),v(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),v(ne(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+As(8):r.trim()));let n=(()=>{let r=zs(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+As(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){v(F(t),"The new index must be a 1-dimensional array of strings!"),v(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),v(ne(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+As(8):r.trim()));let n=(()=>{let r=zs(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+As(8):r),this._index=t}}),v(U(e)||Tn(e)||F(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof ke)this.values=ot(e.values),this.columns=ot(e.columns),this.index=ot(e.index);else if(F(e)){let t=ne(e);v(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),v(!bu(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{U(r)&&(n=u,r=e[u].length),v(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=Hn(t);let o=ne(this.values);this._index=Ve(0,o[0]).map(u=>"row"+oo(u,(o[0]-1).toString().length))}}get shape(){return ne(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new ke(nn(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return fN(this,e,t)}getSubsetByNames(e,t){return gN(ke,bt,this,e,t)}getSubsetByIndices(e,t){return dN(this,e,t)}getDummies(e){return lh(ke,this,e)}oneHotEncode(e){return lh(ke,this,e)}transpose(){let e=new ke(Hn(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return yN(this,e)}copy(){return sN(ke,this)}assign(e,t){return uN(ke,bt,this,e,t)}apply(e,t){return oN(ke,bt,this,e,t)}dropMissing(e,t,n){return aN(ke,bt,this,e,t,n)}dropNaN(e,t,n){return lN(ke,this,e,t,n)}drop(e,t){return iN(ke,bt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return SN(this,e)}toObject(){return FN(this)}toJSONString(e){return Qh(this,e)}saveAsJSON(e,t){return ON(this,e,t)}print(){return pN(ke,bt,this)}sort(e,t){return wN(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return cN(ke,bt,this,e,t)}shuffle(e){return NN(this,e)}append(e,t){return Wh(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},bt=JN(ke);function ti(e,t){return Pt(e,{shouldDropNaNs:t}).max}function ve(e){return v(Ze(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return F(a)?!0:G(a)?(n=!0,o.push(a),!0):oe(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{v(An(F(i)?ne(i):i.shape,F(s[a+1])?ne(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=ti(s.map(l=>l.length?l.length:l.values.length)),a=Ve(0,i).map(l=>{let c=Object.keys(arguments).map(f=>F(arguments[f])?arguments[f][l]:G(arguments[f])||oe(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&An(ne(u[0]),ne(a))){let l=new ke(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new ke(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new bt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new bt(a)}catch{return a}return a}else return e(...arguments)}}function $N(e){try{return P(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var pl=ve($N);function KN(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!P(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Gs=ve(KN);function UN(e,t){try{return t(e)}catch{return NaN}}var ni=ve(UN);function LN(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var VN=ve(LN);function zN(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var WN=ve(zN);function GN(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var qN=ve(GN);function Qa(e,t){if(oe(e)){let n=Qa(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(G(e)){let n=Qa(e.values,t);return e.index[n]}v(F(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=lo(e,ti(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Xh(e,t){return Pt(e,{shouldDropNaNs:t}).min}function Za(e,t){if(oe(e)){let n=Za(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(G(e)){let n=Za(e.values,t);return e.index[n]}v(F(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=lo(e,Xh(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Mt(e,t){if(oe(e)||G(e))return e.apply(n=>Mt(n,t));if(F(e))return e.map(n=>Mt(n,t));if(t==="null")return null;if(t==="number"){if(U(e))return NaN;let n=Mt(e,"boolean");if(wr(n))return n?1:0;try{JSON.parse(e)}catch{let u=Mt(e,"date");if(Sn(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=Mt(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return Mt(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(Mt(e,"int"));if(t==="boolean"){if(wr(e))return e;if(P(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Sn(e))return e;if(U(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return Sn(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Tn(e))return e;let n=Mt(e,"boolean");if(wr(n))return null;try{let o=Mt(e,"number");if(P(o))return JSON.parse(e),null}catch{}let r=Mt(e,"date");if(r)return r;try{let o=JSON.parse(e);return F(o)?o.map(u=>Mt(u,t)):o}catch{return null}}if(t==="string")return U(e)?An(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function HN(e){try{return P(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var QN=ve(HN);function ZN(e,t){try{if(!P(e))return NaN;if(typeof e=="bigint")return e;if(U(t))t=1e-10;else if(!P(t))return NaN;return pl(e)<t?0:e}catch{return NaN}}var XN=ve(ZN);function Xa(e){if(oe(e)||G(e)){let t=e.copy();return t.values=Xa(t.values),t}if(F(e))return e.map(t=>Xa(t));try{let t=JSON.parse(e);return P(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var In=ve(Xa);function xh(e,t,n){try{return P(e)?P(t)?P(n)?typeof e=="bigint"?BigInt(xh(In(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var xN=ve(xh);function qs(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of qs(i,o-1))yield[s].concat(a)}}return oe(e)||G(e)?qs(e.values,t):(v(F(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),v(P(t)&&In(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Wt(e),t))}function em(e,t){let n=[];for(let r of qs(e,t))n.push(r.slice());return n}function tm(){let e=Object.values(arguments).map(n=>oe(n)||G(n)?zt(n.values):(v(F(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),zt(n)));return zt(e).filter(n=>e.every(r=>r.findIndex(o=>An(o,n))>-1))}var uu=class{constructor(e){v(U(e)||e===uu.DROP_NAN_MODE||e===uu.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=U(e)?uu.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(F(t)){let n=ne(t);if(n.length===1)t=new bt(t);else if(n.length===2)t=new ke(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}v(oe(t)||G(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===uu.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=tm(...e),this}transform(){v(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(F(t)){let n=ne(t);if(n.length===1)return new bt(t).get(this.index).values;if(n.length===2)return new ke(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return v(oe(t)||G(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},ri=uu;Lh(ri,"DROP_NAN_MODE","DROP_NAN_MODE");Lh(ri,"DROP_MISSING_MODE","DROP_MISSING_MODE");function au(e,t,n,r){if(G(e))return au(e.values,t,n,r);if(G(t))return au(e,t.values,n,r);if(v(F(e)&&F(t)&&ne(e).length===1&&ne(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),v(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return au(...new ri().fitAndTransform(e,t),!1,r);try{let o=Pt(e,{stdev:r}),u=Pt(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!P(s)||!P(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!P(f))return NaN;if(!P(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function xa(e,t,n){if(G(e))return xa(e.values,t,n);if(G(t))return xa(e,t.values,n);v(F(e)&&F(t)&&ne(e).length===1&&ne(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),v(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=au(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function ew(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var tw=ve(ew),nw=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function el(e,t){if(oe(e)||G(e))return el(e.values,t);if(oe(t)||G(t))return el(e,t.values);v(F(e)&&F(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=zt(e),r=zt(t),o=[];return n.forEach(u=>{r.findIndex(s=>An(s,u))<0&&o.push(u)}),o}function nm(e,t){try{if(!P(e))return NaN;if(!P(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=nm(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var yl=ve(nm);function rm(e){try{if(!P(e))return NaN;if(typeof e=="bigint"){let t=rm(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var om=ve(rm);function rw(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!P(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var um=ve(rw);function mo(){return um(...arguments)}function sm(e,t){return Gs(e,mo(t,-1))}function bl(e,t){return Pt(e,{shouldDropNaNs:t}).sum}function tl(e,t){if(P(e)&&P(t))return pl(e-t);if(oe(e)||G(e))return tl(e.values,t);if(oe(t)||G(t))return tl(e,t.values);F(e)&&F(t)&&v(An(ne(e),ne(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return om(bl(yl(sm(e,t),2)))}catch{return NaN}}function ow(e,t){return mo(e,yl(t,-1))}function Gn(e,t){if(oe(e)){let o=Gn(e.values,t);if(ne(o).length===1){let u=new bt(o);return u.name=G(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new ke(o);return u.index=e.index.slice(),oe(t)&&(u.columns=t.columns.slice()),u}}if(oe(t)){let o=Gn(e,t.values);if(ne(o).length===1){let u=new bt(o);return u.name=G(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new ke(o);return u.columns=t.columns.slice(),u}}if(G(e))return Gn(e.values,t);if(G(t))return Gn(e,t.values);v(F(e)&&F(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=ne(e),r=ne(t);if(v(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),v(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return bl(mo(e,t));if(n.length===1&&r.length===2)return Hn(t).map(o=>Gn(e,o));if(n.length===2&&r.length===1)return e.map(o=>Gn(o,t));if(n.length===2&&r.length===2){let o=Hn(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(Gn(e[s],o[a]));u.push(i)}return u}}function vl(e){if(oe(e)||G(e))return e.dropMissing(...Object.values(arguments).slice(1));v(F(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(vl(n))}catch{U(n)||t.push(n)}}),t}function Ps(e,t){if(oe(e)||G(e))return Ps(e.values,t);if(oe(t)||G(t))return Ps(e,t.values);v(F(e)&&F(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),v(An(ne(e),ne(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Ps(e[o],t[o]);n.push(u),r.push(s)}catch{!U(e[o])&&!U(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function Rs(e,t){if(oe(e)||G(e))return Rs(e.values,t);if(oe(t)||G(t))return Rs(e,t.values);v(F(e)&&F(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),v(An(ne(e),ne(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Rs(e[o],t[o]);n.push(u),r.push(s)}catch{P(e[o])&&P(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function uw(e){return vl(e)}function Hs(e,t){if(oe(e)||G(e))return Hs(e.values,t);v(F(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),v(Ze(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(F(n)){if(!Hs(n,t))return!1}else if(!t(n))return!1;return!0}function sw(e){try{if(!P(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var iw=ve(sw);function nl(e){try{return typeof e=="bigint"?BigInt(nl(In(e))):e!==In(e)?NaN:e<=1?1:e*nl(e-1)}catch{return NaN}}var aw=ve(nl);function rl(e,t){if(oe(e)||G(e))return rl(e.values,t);if(v(Tn(e)||F(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Ze(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(Tn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(F(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function ol(e,t){if(oe(e)||G(e))return ol(e.values,t);if(v(Tn(e)||F(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Ze(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Tn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(F(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function lw(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return P(t)?t:NaN}catch{return NaN}}var cw=ve(lw);function fw(e){try{return P(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var hw=ve(fw);function Nl(e){P(e)&&(e=[e]);let t=[],n=Nu(e);for(let r=0;r<n;r++)t.push(0);return hu(t,e)}function mw(e){typeof e=="bigint"&&(e=In(e)),v(!U(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),v(P(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),v(In(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),v(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Nl([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var dw=["true","false","yes","no"],gw=["null","none","nan","na","n/a","","undefined"];function Is(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=In(e.value)===e.value:e.isInteger=Hs(e.values,t=>P(t)?In(t)===t:!0)),e}function ks(e){if(oe(e)){let u=e.copy(),s=ks(e.values);return u.values=s.values,Is({type:s.type,values:u})}if(G(e)){let u=e.copy(),s=ks(e.values);return u.values=s.values,Is({type:s.type,values:u})}if(!F(e)){let u=ks([e]);return u.value=u.values[0],delete u.values,Is(u)}v(F(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=Wt(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(Sn(a))return"date"}}catch{}Oe(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(gw.indexOf(i)>-1)return"null";if(dw.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return P(a)?"number":typeof a=="object"?F(a)?"string":"object":"string"}catch{let l=new Date(u);return Sn(l)?"date":"string"}}),n=zs(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return Is({type:o,values:ni(e,u=>Mt(u,o))})}function Ys(e){if(oe(e)){let n=e.copy();return n.values=Ys(n.values),n}v(F(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=ne(e);if(v(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),v(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),v(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){v(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;v(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return mo(i,1/s)}else if(t[0]>1){let n=(r,o)=>P(r)||P(o)?mo(r,o):Gn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=Ys(o),l=Ys(Gs(i,n(-1,n(n(s,a),u)))),c=Gs(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}v(!1,"This matrix cannot be inverted!")}}var pw=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function im(e,t,n){try{if(!P(e))return NaN;if(!P(t))return NaN;if(!P(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=im(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var yw=ve(im);function am(e,t){try{if(t=U(t)?Math.E:t,!P(e))return NaN;if(!P(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=am(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var bw=ve(am);function vw(e,t){return Pt(e,{shouldDropNaNs:t}).mean}function Nw(e,t){return Pt(e,{shouldDropNaNs:t,median:!0}).median}function lm(e,t){try{if(!P(e))return NaN;if(!P(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=lm(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var ww=ve(lm);function Ew(e,t){return Pt(e,{shouldDropNaNs:t,mode:!0}).mode}function dh(){let e=ho(),t=ho();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function Dw(e){return U(e)?dh():ni(nn(e),dh)}function Sw(e){return ni(nn(e),()=>1)}function wl(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of em(r,o)){if(!u.slice)continue;let s=Nl(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return oe(e)||G(e)?wl(e.values,t):(v(F(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),U(t)&&(t=e.length),v(P(t)&&In(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Wt(e),t))}function Ow(e,t){let n=[];for(let r of wl(e,t))n.push(r.slice());return n}function Fw(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(F(t))if(bu(t))console.log(t);else{let n=ne(t);n.length===1?new bt(t).print():n.length==2?new ke(t).print():console.log(t)}else oe(t)||G(t)?t.print():console.log(t)})}var _w=ve((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!P(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function Tw(e,t,n,r,o){if(F(e)&&U(r)&&U(o)){r=t,o=n;let u=Pt(e);t=u.min,n=u.max}return _w(e,t,n,r,o)}function Aw(e){try{return P(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var Iw=ve(Aw);function cm(e){try{return P(e)?typeof e=="bigint"?BigInt(cm(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var jw=ve(cm);function Cw(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Mw=ve(Cw);function ul(e,t){if(oe(e)||G(e))return ul(e.values,t);v(F(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),v(Ze(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(F(n)){if(ul(n,t))return!0}else if(t(n))return!0;return!1}function fm(e,t){return Pt(e,{shouldDropNaNs:t,stdev:!0}).stdev}function Bw(e){return fm(e)}function Pw(e){try{return P(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var Rw=ve(Pw);function gh(e,t){v(Ze(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function kw(e,t){v(Ze(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function Yw(){return zt([...arguments].map(e=>F(e)?e:oe(e)||G(e)?e.values:[e]))}function Jw(e,t){return Pt(e,{shouldDropNaNs:t,variance:!0}).variance}function $w(){let e=[],t=Object.values(arguments).map(n=>((oe(n)||G(n))&&(n=n.values),v(F(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Ve(0,ti(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(U(u)?void 0:u)}),e.push(r)}),e}var su={abs:pl,add:Gs,apply:ni,arccos:VN,arcsin:WN,arctan:qN,argmax:Qa,argmin:Za,assert:v,cast:Mt,ceil:QN,chop:XN,clamp:xN,combinations:em,combinationsIterator:qs,copy:ot,correl:xa,cos:tw,count:zs,covariance:au,DataFrame:ke,dataTypes:nw,decycle:co,diff:el,distance:tl,divide:ow,dot:Gn,dropMissing:vl,dropMissingPairwise:Ps,dropNaN:gl,dropNaNPairwise:Rs,dropUndefined:uw,every:Hs,exp:iw,factorial:aw,find:rl,findAll:ol,flatten:Wt,float:cw,floor:hw,identity:mw,IndexMatcher:ri,indexOf:lo,inferType:ks,int:In,intersect:tm,inverse:Ys,isArray:F,isBoolean:wr,isBrowser:pw,isDataFrame:oe,isDate:Sn,isEqual:An,isFunction:Ze,isJagged:bu,isNested:ei,isNumber:P,isObject:Tn,isSeries:G,isString:Oe,isUndefined:U,lerp:yw,log:bw,MathError:lr,max:ti,mean:vw,median:Nw,min:Xh,mod:ww,mode:Ew,multiply:um,ndarray:nn,normal:Dw,ones:Sw,permutations:Ow,permutationsIterator:wl,pow:yl,print:Fw,product:Nu,random:ho,range:Ve,remap:Tw,reshape:hu,reverse:Dn,round:Iw,scale:mo,seed:Hh,Series:bt,set:zt,shape:ne,shuffle:Ws,sign:jw,sin:Mw,some:ul,sort:Sr,sqrt:om,stats:Pt,std:fm,stdev:Bw,subtract:sm,sum:bl,tan:Rw,timeAsync:kw,timeSync:gh,time:gh,transpose:Hn,union:Yw,variance:Jw,vectorize:ve,zeros:Nl,zip:$w,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new su.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(su).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:su[t]})}catch{e[t]=su[t]}})}};typeof window<"u"&&(window.JSMathTools=su);function El(e,t,n){if(typeof n>"u"&&(n=!0),e===null||typeof e>"u"||t==="number"&&typeof e=="number"&&isNaN(e)||t===Date&&Sn(e))return!0;try{return e instanceof t&&(n||e.constructor.name===t.name)}catch{return typeof e===t}}var lu={allowsSubclassInstances:{},doesNotAllowSubclassInstances:{}},to=class hm extends Array{static allowsSubclassInstances=!0;static registry={allowsSubclassInstances:{},doesNotAllowSubclassInstances:{}};static type=null;static from(t){arguments.length>1&&console.warn("WARNING: The `TypedArray.from` static method's implementation differs from the standard `Array.from` static method's implementation. The `TypedArray.from` method only accepts one argument: an array of values. That array can be nested arbitrarily deeply.");let n=this.allowsSubclassInstances?"allowsSubclassInstances":"doesNotAllowSubclassInstances",r=oi(hm.registry[n][this.name]);return arguments.length===0||t.forEach(o=>{if(this.isArray(o)){let u=this.allowsSubclassInstances?"allowsSubclassInstances":"doesNotAllowSubclassInstances";lu[u][this.type]=!0;let s=new this;lu[u][this.type]=!1,o.forEach(i=>s.push(i)),r.push(this.proxify(s))}else r.push(o)}),r}static proxify(t){return new Proxy(t,{get(){return Reflect.get(...arguments)},set(n,r,o,u){let s=parseInt(r);return!isNaN(s)&&parseFloat(r)===s&&s>=0&&u.challenge(o),Reflect.set(...arguments)}})}constructor(t,n){if(super(),t===null||typeof t>"u")throw new Error("A type must be passed as the first argument to the `TypedArray` constructor!");if(t===Array)throw new Error("It's not possible to create a TypedArray<Array>!");Object.defineProperty(this,"type",{configurable:!1,enumerable:!1,writable:!1,value:t}),(typeof n>"u"||n===null)&&(n=!0),Object.defineProperty(this,"allowsSubclassInstances",{configurable:!1,enumerable:!1,writable:!1,value:n})}static get typeString(){return typeof this.constructor.type=="function"?this.constructor.type.name:this.constructor.type}get allowsSubclassInstances(){return this.constructor.allowsSubclassInstances}get type(){return this.constructor.type}canAccept(t){return El(t,this.constructor.type,this.constructor.allowsSubclassInstances)||F(t)&&(t instanceof this.constructor||Wt(t).every(n=>this.canAccept(n)))}challenge(t){if(this.canAccept(t))return!0;throw new Error(`A ${this.constructor.name} cannot contain the value: ${typeof t=="string"||typeof t=="object"?JSON.stringify(t):t}`)}concat(){let t=this.constructor.from(this);return Array.from(arguments).forEach(n=>{n.forEach(r=>{this.challenge(r),t.push(r)})}),t}fill(t,n,r){return this.challenge(t),super.fill(t,n,r)}filter(t,n){typeof n<"u"?t=t.bind(n):t=t.bind(this);let r=Array.from(this).filter(t);try{return this.constructor.from(r)}catch{return Array.from(r)}}from(){return this.constructor.from(...arguments)}map(t,n){typeof n<"u"?t=t.bind(n):t=t.bind(this);let r=Array.from(this).map(t);try{return this.constructor.from(r)}catch{return Array.from(r)}}push(){return Array.from(arguments).forEach(t=>{this.challenge(t)}),super.push(...arguments)}slice(t,n){t||(t=0),n||(n=this.length);let r=this.constructor.from([]);for(let o=t;o<n;o++)r.push(this[o]);return r}splice(){let t=Array.from(arguments).slice(2).filter(u=>(this.challenge(u),!0)),n=t.length-arguments[1],r=this.length+n;for(let u=r-1;u>arguments[0]+arguments[1];u--)this[u]=this[u-n];let o=this.slice(arguments[0],arguments[0]+arguments[1]);return t.forEach((u,s)=>{this[arguments[0]+s]=u}),o}toReversed(){let t=this.constructor.from([]);for(let n=this.length-1;n>=0;n--)t.push(this[n]);return t}toSorted(){let t=Array.from(this);return t.sort(...arguments),this.constructor.from(t)}toSpliced(){let t=Array.from(this);return t.splice(...arguments),this.constructor.from(t)}unshift(){return Array.from(arguments).forEach(t=>{this.challenge(t)}),super.unshift(...arguments)}with(t,n){let r=this.slice();return r[t]=n,r}};function oi(e,t){let n=t?"allowsSubclassInstances":"doesNotAllowSubclassInstances",r=typeof e=="function"?e.name:e,o=(()=>{if(to.registry[n][e])return to.registry[n][e];{class s extends to{constructor(){if(super(e,t),!lu[n][e])throw new Error(`New \`${this.constructor.name}\` instances cannot be created using the \`new\` keyword! They must be created using \`${this.constructor.name}.from([...])\`.`)}}return to.registry[n][e]=s,s}})();lu[n][e]=!0;let u=new o(!0);return lu[n][e]=!1,Object.defineProperty(u.constructor,"name",{configurable:!1,enumerable:!1,writable:!1,value:`${dl(r)}Array`}),Object.defineProperty(o,"allowsSubclassInstances",{configurable:!0,enumerable:!0,writable:!1,value:t}),Object.defineProperty(o,"type",{configurable:!0,enumerable:!0,writable:!1,value:e}),to.registry[n][u.constructor.name]=e,to.proxify(u)}function ze(e,t,n,r){r=r||{configurable:!0,enumerable:!0};let o,u=typeof r.allowsSubclassInstances>"u"?!0:!!r.allowsSubclassInstances;if(typeof n!="function"&&typeof n!="string")throw new Error("A 'type' value (i.e., a class name or a string like \"number\" representing a primitive type) must be passed as the third argument to the `defineTypedProperty` function!");if(n===null||typeof n>"u")throw new Error("A 'type' value (i.e., a class name or a string like \"number\" representing a primitive type) must be passed as the third argument to the `defineTypedProperty` function!");if(n===Array)throw new Error("It's not possible to create a property of type Array (though you *can* create a TypedArray property)!");function s(){return typeof n=="function"?n.name:n}function i(l){return El(l,n,u)}function a(l){if(i(l))return!0;throw new Error(`The '${t}' property can only have ${s()} values assigned to it!`)}Object.defineProperty(e,t,{...r,get(){return o},set(l){a(l),o=l}})}typeof window<"u"&&(window.JSTypeExperiments={createType:Or,createTypedArray:oi,defineTypedProperty:ze,isOfType:El});var Bm=class extends Error{},Kw=class extends Error{},Dl=class extends Error{},Pm=class extends Error{},Rm=class extends Error{},km=class extends Error{},Uw=Object.defineProperty,Lw=(e,t,n)=>t in e?Uw(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Ym=(e,t,n)=>(Lw(e,typeof t!="symbol"?t+"":t,n),n);function j(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Vw=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),fr=class extends Error{constructor(e){Vw()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function N(e,t){if(!e)throw new fr(t)}var Jm=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function k(e){return e===null||typeof e>"u"}var zw=Jm.map(e=>e.name);function T(e){try{return e instanceof Array?!0:k(e.constructor)?!1:Jm.indexOf(e.constructor)>-1||zw.indexOf(e.constructor.name)>-1}catch{return!1}}function ie(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function Xe(e){return typeof e=="function"}function Mn(e){return typeof e=="object"&&!k(e)&&!T(e)}function q(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function Eo(e,t){if(ie(e)){let u=Eo(e.values,t);return u.length>0&&j(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&j(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(q(e)){let u=Eo(e.values,t);return u.length>0&&j(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(N(Mn(e)||T(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!Xe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Mn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(T(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function ut(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(T(n))return n instanceof Array?n.map(o=>ut(o)):n.slice();if(q(n)){let o=n.copy();return o.values=ut(o.values),o}if(ie(n)){let o=n.copy();return o.values=ut(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=Do(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=ut(n[o])}),r}else return n}return t(Do(e))}function Do(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+Eo(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),T(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(ie(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(q(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function Xn(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var mm=["number","int","float","bigint"];function ln(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!mm.includes(u)&&!mm.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(Xn(r))return Xn(o)?r.getTime()===o.getTime():!1;if(Xn(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(T(r)!==T(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Do(e),Do(t))}}function ju(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Ww=ju(16),Gw=ju(16),qw=ju(16),Hw=ju(16),Qw=ju(16),Zw=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)T(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Ww:k(e)?Gw:Xe(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Qw:e===1/0?qw:e===-1/0?Hw:typeof e=="bigint"?e.toString():ie(e)?e.toJSONString():q(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!k(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function cn(e){if(ie(e)||q(e))return cn(e.values);N(T(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{T(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Yt(e,t){t=t||{};let n=new Zw,r={},o=cn(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||j(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function yi(e,t){let{counts:n}=Yt(e);return k(t)||(Xe(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{ln(r,t)||n.delete(r)})),n}function Sl(e){if(ie(e)||q(e))return Sl(e.values);if(T(e)){let t=!1,n=!1,r=null;for(let o of e){if(Sl(o))return!0;if(T(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function Cu(e){return Sl(Do(e))}function _i(e){if(ie(e)||q(e))return _i(e.values);N(T(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(T(e[t]))return!0;return!1}var go="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function un(e){N(!k(e),go),T(e)||(e=[e]),N(!_i(e),go),N(e.length>0,go);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),N(j(t),go),N(t>=0,go),N(Math.floor(t)===t,go),N(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(un(e.slice(1)));return n}}function jn(e){if(ie(e)||q(e)){let n=e.copy();return n.values=jn(n.values),n.index=jn(n.index),n}N(T(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function We(e,t,n=1){N(!k(e)&&!k(t)&&!k(n),"You must pass two numbers and optionally a step value to the `range` function!"),N(j(e)&&j(t)&&j(n),"You must pass two numbers and optionally a step value to the `range` function!"),N(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=jn(u)),u}function Mu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Xw=Mu(256),xw=Mu(256),e2=Mu(256),t2=Mu(256),n2=Mu(256);function Gt(e){if(ie(e)||q(e))return Gt(e.values);N(T(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return cn(e).forEach(r=>{let o=typeof r=="object"&&r===null?Xw:k(r)?xw:Xe(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+n2:r===1/0?e2:r===-1/0?t2:typeof r=="bigint"?r.toString():ie(r)?r.toJSONString():q(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function $m(e){if(T(e)){let t=$m(e[0]);return[e.length].concat(t||[])}else return}function ue(e){return ie(e)||q(e)?ue(e.values):(N(T(e),"The `shape` function only works on arrays, Series, and DataFrames!"),$m(e))}function Km(e,t,n){if(k(n)&&(n=0),N(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),T(t)){N(!Cu(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=ue(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(We(0,o).forEach(s=>{s>=u._values.length&&u._values.push(un(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(We(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(un(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new fr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(q(t)){let r=Km(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(ie(t))if(n===0){let r=e.copy(),o=Gt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(un(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(un(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new fr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function r2(e,t,n,r,o){if(o=o||0,N(Xe(r),"The first parameter to the `apply` method must be a function."),N(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,k(s)&&(s=c instanceof t||T(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return k(u)&&(u=c instanceof t||T(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function fe(e){return typeof e=="string"}function o2(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(k(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(Mn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new fr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{N(fe(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),N(T(o)&&!Cu(o)&&ue(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function u2(e,t){if(t.isEmpty)return new e;let n=new e(ut(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function s2(e,t,n,r,o){k(r)&&(r=[]),k(o)&&(o=[]),(fe(r)||j(r))&&(r=[r]),(fe(o)||j(o))&&(o=[o]),N(T(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),N(T(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),N(ue(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),N(ue(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function Um(e){return j(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function So(e){return Um(e)&&e>=0}function i2(e,t,n,r,o,u){r=r||0,N(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,N(So(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",N(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(k(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(k(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!k(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(ue(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(k(c))return new e;fe(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function Gl(e){if(ie(e)||q(e))return e.dropNaN(...Object.values(arguments).slice(1));N(T(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Gl(n))}catch{if(j(n))return t.push(n)}}),t}function a2(e,t,n,r,o){n=n||0,N(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,N(So(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",N(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=Gl(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function dm(e){let t={};return cn(e).forEach((n,r)=>{t[n]=r}),t}function po(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function l2(e,t,n,r,o){N(Xe(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),k(o)&&(o=0),N(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=dm(u.index),i=dm(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=po(s)[0],c.index=po(i),c}u.values=l,u.index=po(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=po(i)[0],c.index=po(s),c}u.values=l,u.index=po(i),u=u.transpose()}return u}function c2(e,t,n){(fe(t)||j(t))&&(t=[t]),(fe(n)||j(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Gt((t||[]).concat(n||[]).map(o=>typeof o));return N(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&N(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(N(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),N(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),k(t)||(t=t.map(o=>{if(fe(o))return N(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(j(o))return N(o>=0,`Index ${o} is out of bounds!`),N(Math.floor(o)===o,"Row numbers must be integers!"),N(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),k(n)||(n=n.map(o=>{if(fe(o))return N(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(j(o))return N(o>=0,`Column ${o} is out of bounds!`),N(Math.floor(o)===o,"Column numbers must be integers!"),N(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function f2(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Tr(e,t){if(k(t)&&(t=f2),ie(e)||q(e))return e.sort(...Object.values(arguments).slice(1));N(T(e),"The `sort` function only works on arrays, Series, and DataFrames!"),N(Xe(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function h2(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function gm(e,t,n){k(n)?n=t.columns:fe(n)&&(n=[n]);let r={};n.forEach(u=>{N(fe(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);N(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Tr(Gt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+h2(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function m2(e,t,n){let r=e.shape;k(t)&&(t=We(0,r[0])),k(n)&&(n=We(0,r[1])),j(t)&&(t=[t]),j(n)&&(n=[n]),N(T(t)&&T(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),N(ue(t).length===1&&ue(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),N(t.length>0,"The `rowIndices` array must contain at least one index."),N(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{N(So(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),N(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{N(So(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),N(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function d2(e,t,n,r,o){k(r)&&(r=n.index),k(o)&&(o=n.columns),fe(r)&&(r=[r]),fe(o)&&(o=[o]),N(T(r)&&T(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),N(ue(r).length===1&&ue(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),N(r.length>0,"The `rows` array must contain at least one row name."),N(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{N(fe(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),N(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{N(fe(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),N(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function g2(e,t,n){function r(h,m){return fe(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:We(0,u).concat(We(n.index.length-u,n.index.length)),l=s>n.columns.length?null:We(0,i).concat(We(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,We(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function vo(e,t){N(j(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function p2(e,t){let n=t?e:e.copy();return n.index=We(0,e.shape[0]).map(r=>"row"+vo(r,(n.index.length-1).toString().length)),n}function Bu(e,t){if(ie(e)||q(e))return Bu(e.values,t);N(T(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=cn(e),r=!1,o=1;for(let u of n){if(!j(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function y2(e){return Um(e)&&e>0}function Tu(e,t){if(ie(e)||q(e))return Tu(e.values,t);if(N(T(e),"The first argument passed into the `reshape` function must be an array!"),j(t)&&(t=[t]),N(T(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),N(ue(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),N(y2(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return cn(e);let n=cn(e);if(t.length===1&&t[0]===n.length)return n;N(Bu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(Tu(s,t.slice(1)))}return r}var Lm=Math.pow(2,64),Ie=[];Vm(Math.floor(Math.random()*Lm));function b2(e,t){e=ht(e);function n(){e+=ht("0x9e3779b97f4a7c15");let o=ut(e);return o=(o^o>>BigInt(30))*ht("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*ht("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function ht(e){return BigInt.asUintN(64,BigInt(e))}function pm(e,t){return e=ht(e),t=BigInt(t),ht(ht(e<<t)|ht(e>>ht(BigInt(64)-t)))}function Vm(e){if(typeof e=="bigint"&&(e=Number(e)),k(e))return ut(Ie);{N(j(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=b2(Math.floor(e),4);Ie[0]=t[0],Ie[1]=t[1],Ie[2]=t[2],Ie[3]=t[3]}}function ym(){let e=ht(pm(Ie[0]+Ie[3],23)+Ie[0]),t=ht(Ie[1]<<BigInt(17));return Ie[2]=ht(Ie[2]^Ie[0]),Ie[3]=ht(Ie[3]^Ie[1]),Ie[1]=ht(Ie[1]^Ie[2]),Ie[0]=ht(Ie[0]^Ie[3]),Ie[2]=ht(Ie[2]^t),Ie[3]=pm(Ie[3],45),Math.floor(Number(e))/Lm}function Oo(e){return k(e)?ym():(T(e)||(e=[e]),Tu(un(Bu(e)).map(ym),e))}function bi(e){if(ie(e)||q(e))return e.shuffle(...Object.values(arguments).slice(1));N(T(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(Oo()*n.length);t.push(n.splice(o,1)[0])}return t}function v2(e,t){return k(t)&&(t=0),N(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?bi(e.index):null,t===1?bi(e.columns):null)}function Fr(e){return typeof e=="boolean"}function N2(e,t,n){return Xe(t)?w2(e,t,n):E2(e,t,n)}function w2(e,t,n){if(n=k(n)?0:n,N(Xe(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),N(j(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Tr(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Tr(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function E2(e,t,n){let r=e.copy(),o=Oo().toString();r=r.assign(o,r.index),k(t)&&(t=[o],n=[!0]),(j(t)||fe(t))&&(t=[t],(Fr(n)||fe(n))&&(n=[n])),N(T(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),N(ue(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),k(n)&&(n=We(0,t.length).map(()=>!0)),N(T(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),N(ue(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),N(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(N(fe(s)||j(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),fe(s)){let i=r.columns.indexOf(s);return N(i>-1,`The column "${s}" does not exist!`),i}if(j(s))return N(So(s),"Column indices must be whole numbers!"),N(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(N(fe(s)||Fr(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),fe(s)){let i=s.trim().toLowerCase();return N(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(Fr(s))return s}),r.values=Tr(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function D2(e,t){k(t)?t=0:N(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function zm(e,t){return JSON.stringify(e.toObject(t))}async function S2(e,t,n){let r=zm(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new fr(s):typeof module<"u"?new fr(i):new fr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function O2(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function xn(e){if(ie(e)||q(e))return e.transpose();N(T(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=ue(e);if(N(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return jn(e);if(t.length===2){let n=un(jn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function Wm(e,t,n){if(q(n))return new e(t.values.concat(n.values));if(T(n)){let r=ue(n);N(r.length===1&&!_i(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return Wm(t,[n])}function F2(e,t){N(Xe(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function _2(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>k(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function T2(e,t){let n=[],r=[];t.values.forEach((u,s)=>{j(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function A2(e,t,n){let r=t.copy(),o=ut(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function I2(e,t){(fe(t)||j(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Gt((t||[]).map(r=>typeof r));return N(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&N(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(N(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),N(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),k(t)||(t=t.map(r=>{if(typeof r=="string")return N(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return N(r>=0,`Index ${r} is out of bounds!`),N(Math.floor(r)===r,"Indices must be integers!"),N(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function j2(e,t){let n=e.shape;k(t)&&(t=We(0,n[0])),N(T(t),"The `indices` array must be 1-dimensional array of whole numbers."),N(ue(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),N(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{N(So(o),"The `indices` array must be a 1-dimensional array of whole numbers."),N(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function C2(e,t,n){k(n)&&(n=t.index),N(T(n),"The `indices` array must be a 1-dimensional array of strings."),N(ue(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),N(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{N(fe(u),"The `indices` array must contain only strings."),N(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function M2(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(We(0,n/2).concat(We(t.index.length-n/2,t.index.length)));let o=ut(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function B2(e){let t=e.copy();return t.get(bi(t.index))}function P2(e,t,n){n=n||((a,l)=>a<l?-1:1),N(k(n)||Xe(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=xn([t.values,t.index]),o=Tr(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function R2(e,t){let n=xn([t.values,t.index]);n=xn(Tr(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function k2(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var bm=Symbol.for("@jrc03c/js-math-tools/series");function Y2(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===bm}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:bm}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){N(T(o),"The new values must be a 1-dimensional array!");let u=ue(o);N(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(We(this._index.length,u[0]).map(s=>"item"+vo(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){N(T(o),"The new index must be a 1-dimensional array of strings!"),N(o.length===this.shape[0],"The new index must be the same length as the old index!"),N(ue(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{N(fe(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=ut(r.values),this.index=ut(r.index);else if(T(r)){let o=ue(r);N(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());N(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];N(ue(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return ue(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!k(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return I2(this,r)}getSubsetByNames(r){return C2(t,this,r)}getSubsetByIndices(r){return j2(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(jn(this.values));return r.index=jn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=We(0,this.shape[0]).map(o=>"item"+vo(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=ut(this.values),r._index=ut(this.index),r.name=this.name,r}append(r){return Wm(t,this,r)}apply(r){return F2(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return _2(this,r,o)}dropNaN(){return T2(t,this)}toObject(){return k2(this)}print(){return M2(this)}shuffle(){return B2(this)}sort(r){return P2(t,this,r)}sortByIndex(){return R2(t,this)}filter(r){return A2(t,this,r)}toDataFrame(){let r=new e(xn([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=jn(r.values),r.index=jn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var vm=Symbol.for("@jrc03c/js-math-tools/dataframe");function ui(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(Oo()*t.length)];return n}var Je=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===vm}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:vm}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!k(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){N(T(t),"The new values must be a 2-dimensional array!");let n=ue(t);N(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(We(this._index.length,n[0]).map(r=>"row"+vo(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(We(this._columns.length,n[1]).map(r=>"col"+vo(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){N(T(t),"The new columns list must be a 1-dimensional array of strings!"),N(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),N(ue(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ui(8):r.trim()));let n=(()=>{let r=yi(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+ui(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){N(T(t),"The new index must be a 1-dimensional array of strings!"),N(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),N(ue(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ui(8):r.trim()));let n=(()=>{let r=yi(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+ui(8):r),this._index=t}}),N(k(e)||Mn(e)||T(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Je)this.values=ut(e.values),this.columns=ut(e.columns),this.index=ut(e.index);else if(T(e)){let t=ue(e);N(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),N(!Cu(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{k(r)&&(n=u,r=e[u].length),N(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=xn(t);let o=ue(this.values);this._index=We(0,o[0]).map(u=>"row"+vo(u,(o[0]-1).toString().length))}}get shape(){return ue(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Je(un(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return c2(this,e,t)}getSubsetByNames(e,t){return d2(Je,vt,this,e,t)}getSubsetByIndices(e,t){return m2(this,e,t)}getDummies(e){return gm(Je,this,e)}oneHotEncode(e){return gm(Je,this,e)}transpose(){let e=new Je(xn(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return p2(this,e)}copy(){return u2(Je,this)}assign(e,t){return o2(Je,vt,this,e,t)}apply(e,t){return r2(Je,vt,this,e,t)}dropMissing(e,t,n){return i2(Je,vt,this,e,t,n)}dropNaN(e,t,n){return a2(Je,this,e,t,n)}drop(e,t){return s2(Je,vt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return D2(this,e)}toObject(){return O2(this)}toJSONString(e){return zm(this,e)}saveAsJSON(e,t){return S2(this,e,t)}print(){return g2(Je,vt,this)}sort(e,t){return N2(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return l2(Je,vt,this,e,t)}shuffle(e){return v2(this,e)}append(e,t){return Km(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},vt=Y2(Je);function Ti(e,t){return Yt(e,{shouldDropNaNs:t}).max}function Ne(e){return N(Xe(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return T(a)?!0:q(a)?(n=!0,o.push(a),!0):ie(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{N(ln(T(i)?ue(i):i.shape,T(s[a+1])?ue(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=Ti(s.map(l=>l.length?l.length:l.values.length)),a=We(0,i).map(l=>{let c=Object.keys(arguments).map(f=>T(arguments[f])?arguments[f][l]:q(arguments[f])||ie(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&ln(ue(u[0]),ue(a))){let l=new Je(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Je(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new vt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new vt(a)}catch{return a}return a}else return e(...arguments)}}function J2(e){try{return j(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var ql=Ne(J2);function $2(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!j(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var vi=Ne($2);function K2(e,t){try{return t(e)}catch{return NaN}}var Ai=Ne(K2);function U2(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var L2=Ne(U2);function V2(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var z2=Ne(V2);function W2(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var G2=Ne(W2);function Ol(e,t){if(ie(e)){let n=Ol(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(q(e)){let n=Ol(e.values,t);return e.index[n]}N(T(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=Eo(e,Ti(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Gm(e,t){return Yt(e,{shouldDropNaNs:t}).min}function Fl(e,t){if(ie(e)){let n=Fl(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(q(e)){let n=Fl(e.values,t);return e.index[n]}N(T(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=Eo(e,Gm(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Rt(e,t){if(ie(e)||q(e))return e.apply(n=>Rt(n,t));if(T(e))return e.map(n=>Rt(n,t));if(t==="null")return null;if(t==="number"){if(k(e))return NaN;let n=Rt(e,"boolean");if(Fr(n))return n?1:0;try{JSON.parse(e)}catch{let u=Rt(e,"date");if(Xn(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=Rt(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return Rt(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(Rt(e,"int"));if(t==="boolean"){if(Fr(e))return e;if(j(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Xn(e))return e;if(k(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return Xn(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Mn(e))return e;let n=Rt(e,"boolean");if(Fr(n))return null;try{let o=Rt(e,"number");if(j(o))return JSON.parse(e),null}catch{}let r=Rt(e,"date");if(r)return r;try{let o=JSON.parse(e);return T(o)?o.map(u=>Rt(u,t)):o}catch{return null}}if(t==="string")return k(e)?ln(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function q2(e){try{return j(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var H2=Ne(q2);function Q2(e,t){try{if(!j(e))return NaN;if(typeof e=="bigint")return e;if(k(t))t=1e-10;else if(!j(t))return NaN;return ql(e)<t?0:e}catch{return NaN}}var Z2=Ne(Q2);function _l(e){if(ie(e)||q(e)){let t=e.copy();return t.values=_l(t.values),t}if(T(e))return e.map(t=>_l(t));try{let t=JSON.parse(e);return j(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var Bn=Ne(_l);function qm(e,t,n){try{return j(e)?j(t)?j(n)?typeof e=="bigint"?BigInt(qm(Bn(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var X2=Ne(qm);function Ni(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of Ni(i,o-1))yield[s].concat(a)}}return ie(e)||q(e)?Ni(e.values,t):(N(T(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),N(j(t)&&Bn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(cn(e),t))}function Hm(e,t){let n=[];for(let r of Ni(e,t))n.push(r.slice());return n}function Qm(){let e=Object.values(arguments).map(n=>ie(n)||q(n)?Gt(n.values):(N(T(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Gt(n)));return Gt(e).filter(n=>e.every(r=>r.findIndex(o=>ln(o,n))>-1))}var wu=class{constructor(e){N(k(e)||e===wu.DROP_NAN_MODE||e===wu.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=k(e)?wu.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(T(t)){let n=ue(t);if(n.length===1)t=new vt(t);else if(n.length===2)t=new Je(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}N(ie(t)||q(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===wu.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Qm(...e),this}transform(){N(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(T(t)){let n=ue(t);if(n.length===1)return new vt(t).get(this.index).values;if(n.length===2)return new Je(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return N(ie(t)||q(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Ii=wu;Ym(Ii,"DROP_NAN_MODE","DROP_NAN_MODE");Ym(Ii,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Ou(e,t,n,r){if(q(e))return Ou(e.values,t,n,r);if(q(t))return Ou(e,t.values,n,r);if(N(T(e)&&T(t)&&ue(e).length===1&&ue(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),N(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Ou(...new Ii().fitAndTransform(e,t),!1,r);try{let o=Yt(e,{stdev:r}),u=Yt(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!j(s)||!j(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!j(f))return NaN;if(!j(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function Tl(e,t,n){if(q(e))return Tl(e.values,t,n);if(q(t))return Tl(e,t.values,n);N(T(e)&&T(t)&&ue(e).length===1&&ue(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),N(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Ou(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function x2(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var eE=Ne(x2),tE=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Al(e,t){if(ie(e)||q(e))return Al(e.values,t);if(ie(t)||q(t))return Al(e,t.values);N(T(e)&&T(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Gt(e),r=Gt(t),o=[];return n.forEach(u=>{r.findIndex(s=>ln(s,u))<0&&o.push(u)}),o}function Zm(e,t){try{if(!j(e))return NaN;if(!j(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Zm(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var Hl=Ne(Zm);function Xm(e){try{if(!j(e))return NaN;if(typeof e=="bigint"){let t=Xm(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var xm=Ne(Xm);function nE(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!j(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var ed=Ne(nE);function Fo(){return ed(...arguments)}function td(e,t){return vi(e,Fo(t,-1))}function Ql(e,t){return Yt(e,{shouldDropNaNs:t}).sum}function Il(e,t){if(j(e)&&j(t))return ql(e-t);if(ie(e)||q(e))return Il(e.values,t);if(ie(t)||q(t))return Il(e,t.values);T(e)&&T(t)&&N(ln(ue(e),ue(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return xm(Ql(Hl(td(e,t),2)))}catch{return NaN}}function rE(e,t){return Fo(e,Hl(t,-1))}function Qn(e,t){if(ie(e)){let o=Qn(e.values,t);if(ue(o).length===1){let u=new vt(o);return u.name=q(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Je(o);return u.index=e.index.slice(),ie(t)&&(u.columns=t.columns.slice()),u}}if(ie(t)){let o=Qn(e,t.values);if(ue(o).length===1){let u=new vt(o);return u.name=q(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Je(o);return u.columns=t.columns.slice(),u}}if(q(e))return Qn(e.values,t);if(q(t))return Qn(e,t.values);N(T(e)&&T(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=ue(e),r=ue(t);if(N(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),N(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Ql(Fo(e,t));if(n.length===1&&r.length===2)return xn(t).map(o=>Qn(e,o));if(n.length===2&&r.length===1)return e.map(o=>Qn(o,t));if(n.length===2&&r.length===2){let o=xn(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(Qn(e[s],o[a]));u.push(i)}return u}}function Zl(e){if(ie(e)||q(e))return e.dropMissing(...Object.values(arguments).slice(1));N(T(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Zl(n))}catch{k(n)||t.push(n)}}),t}function li(e,t){if(ie(e)||q(e))return li(e.values,t);if(ie(t)||q(t))return li(e,t.values);N(T(e)&&T(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),N(ln(ue(e),ue(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=li(e[o],t[o]);n.push(u),r.push(s)}catch{!k(e[o])&&!k(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function ci(e,t){if(ie(e)||q(e))return ci(e.values,t);if(ie(t)||q(t))return ci(e,t.values);N(T(e)&&T(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),N(ln(ue(e),ue(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=ci(e[o],t[o]);n.push(u),r.push(s)}catch{j(e[o])&&j(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function oE(e){return Zl(e)}function wi(e,t){if(ie(e)||q(e))return wi(e.values,t);N(T(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),N(Xe(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(T(n)){if(!wi(n,t))return!1}else if(!t(n))return!1;return!0}function uE(e){try{if(!j(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var sE=Ne(uE);function jl(e){try{return typeof e=="bigint"?BigInt(jl(Bn(e))):e!==Bn(e)?NaN:e<=1?1:e*jl(e-1)}catch{return NaN}}var iE=Ne(jl);function Cl(e,t){if(ie(e)||q(e))return Cl(e.values,t);if(N(Mn(e)||T(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!Xe(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(Mn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(T(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function Ml(e,t){if(ie(e)||q(e))return Ml(e.values,t);if(N(Mn(e)||T(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!Xe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Mn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(T(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function aE(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return j(t)?t:NaN}catch{return NaN}}var lE=Ne(aE);function cE(e){try{return j(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var fE=Ne(cE);function Xl(e){j(e)&&(e=[e]);let t=[],n=Bu(e);for(let r=0;r<n;r++)t.push(0);return Tu(t,e)}function hE(e){typeof e=="bigint"&&(e=Bn(e)),N(!k(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),N(j(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),N(Bn(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),N(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Xl([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var mE=["true","false","yes","no"],dE=["null","none","nan","na","n/a","","undefined"];function si(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=Bn(e.value)===e.value:e.isInteger=wi(e.values,t=>j(t)?Bn(t)===t:!0)),e}function fi(e){if(ie(e)){let u=e.copy(),s=fi(e.values);return u.values=s.values,si({type:s.type,values:u})}if(q(e)){let u=e.copy(),s=fi(e.values);return u.values=s.values,si({type:s.type,values:u})}if(!T(e)){let u=fi([e]);return u.value=u.values[0],delete u.values,si(u)}N(T(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=cn(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(Xn(a))return"date"}}catch{}fe(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(dE.indexOf(i)>-1)return"null";if(mE.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return j(a)?"number":typeof a=="object"?T(a)?"string":"object":"string"}catch{let l=new Date(u);return Xn(l)?"date":"string"}}),n=yi(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return si({type:o,values:Ai(e,u=>Rt(u,o))})}function hi(e){if(ie(e)){let n=e.copy();return n.values=hi(n.values),n}N(T(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=ue(e);if(N(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),N(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),N(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){N(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;N(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return Fo(i,1/s)}else if(t[0]>1){let n=(r,o)=>j(r)||j(o)?Fo(r,o):Qn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=hi(o),l=hi(vi(i,n(-1,n(n(s,a),u)))),c=vi(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}N(!1,"This matrix cannot be inverted!")}}var gE=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function nd(e,t,n){try{if(!j(e))return NaN;if(!j(t))return NaN;if(!j(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=nd(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var pE=Ne(nd);function rd(e,t){try{if(t=k(t)?Math.E:t,!j(e))return NaN;if(!j(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=rd(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var yE=Ne(rd);function bE(e,t){return Yt(e,{shouldDropNaNs:t}).mean}function vE(e,t){return Yt(e,{shouldDropNaNs:t,median:!0}).median}function od(e,t){try{if(!j(e))return NaN;if(!j(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=od(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var NE=Ne(od);function wE(e,t){return Yt(e,{shouldDropNaNs:t,mode:!0}).mode}function Nm(){let e=Oo(),t=Oo();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function EE(e){return k(e)?Nm():Ai(un(e),Nm)}function DE(e){return Ai(un(e),()=>1)}function xl(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of Hm(r,o)){if(!u.slice)continue;let s=Xl(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return ie(e)||q(e)?xl(e.values,t):(N(T(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),k(t)&&(t=e.length),N(j(t)&&Bn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(cn(e),t))}function SE(e,t){let n=[];for(let r of xl(e,t))n.push(r.slice());return n}function OE(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(T(t))if(Cu(t))console.log(t);else{let n=ue(t);n.length===1?new vt(t).print():n.length==2?new Je(t).print():console.log(t)}else ie(t)||q(t)?t.print():console.log(t)})}var FE=Ne((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!j(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function _E(e,t,n,r,o){if(T(e)&&k(r)&&k(o)){r=t,o=n;let u=Yt(e);t=u.min,n=u.max}return FE(e,t,n,r,o)}function TE(e){try{return j(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var AE=Ne(TE);function ud(e){try{return j(e)?typeof e=="bigint"?BigInt(ud(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var IE=Ne(ud);function jE(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var CE=Ne(jE);function Bl(e,t){if(ie(e)||q(e))return Bl(e.values,t);N(T(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),N(Xe(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(T(n)){if(Bl(n,t))return!0}else if(t(n))return!0;return!1}function sd(e,t){return Yt(e,{shouldDropNaNs:t,stdev:!0}).stdev}function ME(e){return sd(e)}function BE(e){try{return j(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var PE=Ne(BE);function wm(e,t){N(Xe(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function RE(e,t){N(Xe(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function kE(){return Gt([...arguments].map(e=>T(e)?e:ie(e)||q(e)?e.values:[e]))}function YE(e,t){return Yt(e,{shouldDropNaNs:t,variance:!0}).variance}function JE(){let e=[],t=Object.values(arguments).map(n=>((ie(n)||q(n))&&(n=n.values),N(T(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return We(0,Ti(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(k(u)?void 0:u)}),e.push(r)}),e}var Eu={abs:ql,add:vi,apply:Ai,arccos:L2,arcsin:z2,arctan:G2,argmax:Ol,argmin:Fl,assert:N,cast:Rt,ceil:H2,chop:Z2,clamp:X2,combinations:Hm,combinationsIterator:Ni,copy:ut,correl:Tl,cos:eE,count:yi,covariance:Ou,DataFrame:Je,dataTypes:tE,decycle:Do,diff:Al,distance:Il,divide:rE,dot:Qn,dropMissing:Zl,dropMissingPairwise:li,dropNaN:Gl,dropNaNPairwise:ci,dropUndefined:oE,every:wi,exp:sE,factorial:iE,find:Cl,findAll:Ml,flatten:cn,float:lE,floor:fE,identity:hE,IndexMatcher:Ii,indexOf:Eo,inferType:fi,int:Bn,intersect:Qm,inverse:hi,isArray:T,isBoolean:Fr,isBrowser:gE,isDataFrame:ie,isDate:Xn,isEqual:ln,isFunction:Xe,isJagged:Cu,isNested:_i,isNumber:j,isObject:Mn,isSeries:q,isString:fe,isUndefined:k,lerp:pE,log:yE,MathError:fr,max:Ti,mean:bE,median:vE,min:Gm,mod:NE,mode:wE,multiply:ed,ndarray:un,normal:EE,ones:DE,permutations:SE,permutationsIterator:xl,pow:Hl,print:OE,product:Bu,random:Oo,range:We,remap:_E,reshape:Tu,reverse:jn,round:AE,scale:Fo,seed:Vm,Series:vt,set:Gt,shape:ue,shuffle:bi,sign:IE,sin:CE,some:Bl,sort:Tr,sqrt:xm,stats:Yt,std:sd,stdev:ME,subtract:td,sum:Ql,tan:PE,timeAsync:RE,timeSync:wm,time:wm,transpose:xn,union:kE,variance:YE,vectorize:Ne,zeros:Xl,zip:JE,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Eu.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Eu).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Eu[t]})}catch{e[t]=Eu[t]}})}};typeof window<"u"&&(window.JSMathTools=Eu);function id(e){if(typeof e!="string")throw new Error("`text` must be a string!");e=e.trim();let t="",n=!1;for(let r=0;r<e.length;r++){let o=e[r];o.match(/[A-Za-z0-9]/g)?(t.length===0?t+=o.toLowerCase():n?t+=o.toUpperCase():t+=o,n=!1):!o.includes("'")&&!o.includes("\u2019")&&!o.includes("\u275C")&&(n=!0)}return t}var $E=Object.defineProperty,KE=(e,t,n)=>t in e?$E(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,ad=(e,t,n)=>(KE(e,typeof t!="symbol"?t+"":t,n),n);function R(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var UE=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),hr=class extends Error{constructor(e){UE()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function y(e,t){if(!e)throw new hr(t)}var ld=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function $(e){return e===null||typeof e>"u"}var LE=ld.map(e=>e.name);function O(e){try{return e instanceof Array?!0:$(e.constructor)?!1:ld.indexOf(e.constructor)>-1||LE.indexOf(e.constructor.name)>-1}catch{return!1}}function ae(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function xe(e){return typeof e=="function"}function Pn(e){return typeof e=="object"&&!$(e)&&!O(e)}function H(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function _o(e,t){if(ae(e)){let u=_o(e.values,t);return u.length>0&&R(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&R(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(H(e)){let u=_o(e.values,t);return u.length>0&&R(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(y(Pn(e)||O(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!xe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Pn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(O(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function st(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(O(n))return n instanceof Array?n.map(o=>st(o)):n.slice();if(H(n)){let o=n.copy();return o.values=st(o.values),o}if(ae(n)){let o=n.copy();return o.values=st(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=Ar(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=st(n[o])}),r}else return n}return t(Ar(e))}function Ar(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+_o(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),O(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(ae(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(H(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function an(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var Em=["number","int","float","bigint"];function Rn(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!Em.includes(u)&&!Em.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(an(r))return an(o)?r.getTime()===o.getTime():!1;if(an(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(O(r)!==O(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Ar(e),Ar(t))}}function Pu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var VE=Pu(16),zE=Pu(16),WE=Pu(16),GE=Pu(16),qE=Pu(16),HE=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)O(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?VE:$(e)?zE:xe(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+qE:e===1/0?WE:e===-1/0?GE:typeof e=="bigint"?e.toString():ae(e)?e.toJSONString():H(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!$(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function fn(e){if(ae(e)||H(e))return fn(e.values);y(O(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{O(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Jt(e,t){t=t||{};let n=new HE,r={},o=fn(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||R(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function Ei(e,t){let{counts:n}=Jt(e);return $(t)||(xe(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{Rn(r,t)||n.delete(r)})),n}function Pl(e){if(ae(e)||H(e))return Pl(e.values);if(O(e)){let t=!1,n=!1,r=null;for(let o of e){if(Pl(o))return!0;if(O(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function Ru(e){return Pl(Ar(e))}function ji(e){if(ae(e)||H(e))return ji(e.values);y(O(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(O(e[t]))return!0;return!1}var yo="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function sn(e){y(!$(e),yo),O(e)||(e=[e]),y(!ji(e),yo),y(e.length>0,yo);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),y(R(t),yo),y(t>=0,yo),y(Math.floor(t)===t,yo),y(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(sn(e.slice(1)));return n}}function Cn(e){if(ae(e)||H(e)){let n=e.copy();return n.values=Cn(n.values),n.index=Cn(n.index),n}y(O(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Ke(e,t,n=1){y(!$(e)&&!$(t)&&!$(n),"You must pass two numbers and optionally a step value to the `range` function!"),y(R(e)&&R(t)&&R(n),"You must pass two numbers and optionally a step value to the `range` function!"),y(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=Cn(u)),u}function ku(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var QE=ku(256),ZE=ku(256),XE=ku(256),xE=ku(256),eD=ku(256);function qt(e){if(ae(e)||H(e))return qt(e.values);y(O(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return fn(e).forEach(r=>{let o=typeof r=="object"&&r===null?QE:$(r)?ZE:xe(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+eD:r===1/0?XE:r===-1/0?xE:typeof r=="bigint"?r.toString():ae(r)?r.toJSONString():H(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function cd(e){if(O(e)){let t=cd(e[0]);return[e.length].concat(t||[])}else return}function se(e){return ae(e)||H(e)?se(e.values):(y(O(e),"The `shape` function only works on arrays, Series, and DataFrames!"),cd(e))}function fd(e,t,n){if($(n)&&(n=0),y(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),O(t)){y(!Ru(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=se(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Ke(0,o).forEach(s=>{s>=u._values.length&&u._values.push(sn(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Ke(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(sn(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new hr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(H(t)){let r=fd(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(ae(t))if(n===0){let r=e.copy(),o=qt(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(sn(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(sn(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new hr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function tD(e,t,n,r,o){if(o=o||0,y(xe(r),"The first parameter to the `apply` method must be a function."),y(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,$(s)&&(s=c instanceof t||O(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return $(u)&&(u=c instanceof t||O(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function de(e){return typeof e=="string"}function nD(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if($(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(Pn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new hr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{y(de(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),y(O(o)&&!Ru(o)&&se(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function rD(e,t){if(t.isEmpty)return new e;let n=new e(st(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function oD(e,t,n,r,o){$(r)&&(r=[]),$(o)&&(o=[]),(de(r)||R(r))&&(r=[r]),(de(o)||R(o))&&(o=[o]),y(O(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),y(O(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),y(se(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),y(se(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function hd(e){return R(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function To(e){return hd(e)&&e>=0}function uD(e,t,n,r,o,u){r=r||0,y(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,y(To(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",y(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if($(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if($(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!$(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(se(l).length<2)return new e;i.values=l;let c=i.get(null,a);if($(c))return new e;de(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function ec(e){if(ae(e)||H(e))return e.dropNaN(...Object.values(arguments).slice(1));y(O(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(ec(n))}catch{if(R(n))return t.push(n)}}),t}function sD(e,t,n,r,o){n=n||0,y(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,y(To(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",y(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=ec(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function Dm(e){let t={};return fn(e).forEach((n,r)=>{t[n]=r}),t}function bo(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function iD(e,t,n,r,o){y(xe(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),$(o)&&(o=0),y(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=Dm(u.index),i=Dm(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=bo(s)[0],c.index=bo(i),c}u.values=l,u.index=bo(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=bo(i)[0],c.index=bo(s),c}u.values=l,u.index=bo(i),u=u.transpose()}return u}function aD(e,t,n){(de(t)||R(t))&&(t=[t]),(de(n)||R(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=qt((t||[]).concat(n||[]).map(o=>typeof o));return y(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&y(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(y(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),y(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),$(t)||(t=t.map(o=>{if(de(o))return y(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(R(o))return y(o>=0,`Index ${o} is out of bounds!`),y(Math.floor(o)===o,"Row numbers must be integers!"),y(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),$(n)||(n=n.map(o=>{if(de(o))return y(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(R(o))return y(o>=0,`Column ${o} is out of bounds!`),y(Math.floor(o)===o,"Column numbers must be integers!"),y(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function lD(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Ir(e,t){if($(t)&&(t=lD),ae(e)||H(e))return e.sort(...Object.values(arguments).slice(1));y(O(e),"The `sort` function only works on arrays, Series, and DataFrames!"),y(xe(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function cD(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function Sm(e,t,n){$(n)?n=t.columns:de(n)&&(n=[n]);let r={};n.forEach(u=>{y(de(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);y(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Ir(qt(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+cD(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function fD(e,t,n){let r=e.shape;$(t)&&(t=Ke(0,r[0])),$(n)&&(n=Ke(0,r[1])),R(t)&&(t=[t]),R(n)&&(n=[n]),y(O(t)&&O(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),y(se(t).length===1&&se(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),y(t.length>0,"The `rowIndices` array must contain at least one index."),y(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{y(To(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),y(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{y(To(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),y(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function hD(e,t,n,r,o){$(r)&&(r=n.index),$(o)&&(o=n.columns),de(r)&&(r=[r]),de(o)&&(o=[o]),y(O(r)&&O(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),y(se(r).length===1&&se(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),y(r.length>0,"The `rows` array must contain at least one row name."),y(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{y(de(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),y(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{y(de(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),y(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function mD(e,t,n){function r(h,m){return de(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Ke(0,u).concat(Ke(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Ke(0,i).concat(Ke(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Ke(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function No(e,t){y(R(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function dD(e,t){let n=t?e:e.copy();return n.index=Ke(0,e.shape[0]).map(r=>"row"+No(r,(n.index.length-1).toString().length)),n}function Yu(e,t){if(ae(e)||H(e))return Yu(e.values,t);y(O(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=fn(e),r=!1,o=1;for(let u of n){if(!R(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function gD(e){return hd(e)&&e>0}function Au(e,t){if(ae(e)||H(e))return Au(e.values,t);if(y(O(e),"The first argument passed into the `reshape` function must be an array!"),R(t)&&(t=[t]),y(O(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),y(se(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),y(gD(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return fn(e);let n=fn(e);if(t.length===1&&t[0]===n.length)return n;y(Yu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(Au(s,t.slice(1)))}return r}var md=Math.pow(2,64),je=[];dd(Math.floor(Math.random()*md));function pD(e,t){e=mt(e);function n(){e+=mt("0x9e3779b97f4a7c15");let o=st(e);return o=(o^o>>BigInt(30))*mt("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*mt("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function mt(e){return BigInt.asUintN(64,BigInt(e))}function Om(e,t){return e=mt(e),t=BigInt(t),mt(mt(e<<t)|mt(e>>mt(BigInt(64)-t)))}function dd(e){if(typeof e=="bigint"&&(e=Number(e)),$(e))return st(je);{y(R(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=pD(Math.floor(e),4);je[0]=t[0],je[1]=t[1],je[2]=t[2],je[3]=t[3]}}function Fm(){let e=mt(Om(je[0]+je[3],23)+je[0]),t=mt(je[1]<<BigInt(17));return je[2]=mt(je[2]^je[0]),je[3]=mt(je[3]^je[1]),je[1]=mt(je[1]^je[2]),je[0]=mt(je[0]^je[3]),je[2]=mt(je[2]^t),je[3]=Om(je[3],45),Math.floor(Number(e))/md}function Ao(e){return $(e)?Fm():(O(e)||(e=[e]),Au(sn(Yu(e)).map(Fm),e))}function Di(e){if(ae(e)||H(e))return e.shuffle(...Object.values(arguments).slice(1));y(O(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(Ao()*n.length);t.push(n.splice(o,1)[0])}return t}function yD(e,t){return $(t)&&(t=0),y(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?Di(e.index):null,t===1?Di(e.columns):null)}function _r(e){return typeof e=="boolean"}function bD(e,t,n){return xe(t)?vD(e,t,n):ND(e,t,n)}function vD(e,t,n){if(n=$(n)?0:n,y(xe(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),y(R(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Ir(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Ir(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function ND(e,t,n){let r=e.copy(),o=Ao().toString();r=r.assign(o,r.index),$(t)&&(t=[o],n=[!0]),(R(t)||de(t))&&(t=[t],(_r(n)||de(n))&&(n=[n])),y(O(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),y(se(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),$(n)&&(n=Ke(0,t.length).map(()=>!0)),y(O(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),y(se(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),y(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(y(de(s)||R(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),de(s)){let i=r.columns.indexOf(s);return y(i>-1,`The column "${s}" does not exist!`),i}if(R(s))return y(To(s),"Column indices must be whole numbers!"),y(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(y(de(s)||_r(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),de(s)){let i=s.trim().toLowerCase();return y(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(_r(s))return s}),r.values=Ir(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function wD(e,t){$(t)?t=0:y(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function gd(e,t){return JSON.stringify(e.toObject(t))}async function ED(e,t,n){let r=gd(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new hr(s):typeof module<"u"?new hr(i):new hr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function DD(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function er(e){if(ae(e)||H(e))return e.transpose();y(O(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=se(e);if(y(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return Cn(e);if(t.length===2){let n=sn(Cn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function pd(e,t,n){if(H(n))return new e(t.values.concat(n.values));if(O(n)){let r=se(n);y(r.length===1&&!ji(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return pd(t,[n])}function SD(e,t){y(xe(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function OD(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>$(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function FD(e,t){let n=[],r=[];t.values.forEach((u,s)=>{R(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function _D(e,t,n){let r=t.copy(),o=st(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function TD(e,t){(de(t)||R(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=qt((t||[]).map(r=>typeof r));return y(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&y(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(y(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),y(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),$(t)||(t=t.map(r=>{if(typeof r=="string")return y(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return y(r>=0,`Index ${r} is out of bounds!`),y(Math.floor(r)===r,"Indices must be integers!"),y(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function AD(e,t){let n=e.shape;$(t)&&(t=Ke(0,n[0])),y(O(t),"The `indices` array must be 1-dimensional array of whole numbers."),y(se(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),y(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{y(To(o),"The `indices` array must be a 1-dimensional array of whole numbers."),y(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function ID(e,t,n){$(n)&&(n=t.index),y(O(n),"The `indices` array must be a 1-dimensional array of strings."),y(se(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),y(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{y(de(u),"The `indices` array must contain only strings."),y(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function jD(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Ke(0,n/2).concat(Ke(t.index.length-n/2,t.index.length)));let o=st(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function CD(e){let t=e.copy();return t.get(Di(t.index))}function MD(e,t,n){n=n||((a,l)=>a<l?-1:1),y($(n)||xe(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=er([t.values,t.index]),o=Ir(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function BD(e,t){let n=er([t.values,t.index]);n=er(Ir(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function PD(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var _m=Symbol.for("@jrc03c/js-math-tools/series");function RD(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===_m}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:_m}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){y(O(o),"The new values must be a 1-dimensional array!");let u=se(o);y(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Ke(this._index.length,u[0]).map(s=>"item"+No(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){y(O(o),"The new index must be a 1-dimensional array of strings!"),y(o.length===this.shape[0],"The new index must be the same length as the old index!"),y(se(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{y(de(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=st(r.values),this.index=st(r.index);else if(O(r)){let o=se(r);y(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());y(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];y(se(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return se(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!$(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return TD(this,r)}getSubsetByNames(r){return ID(t,this,r)}getSubsetByIndices(r){return AD(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(Cn(this.values));return r.index=Cn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Ke(0,this.shape[0]).map(o=>"item"+No(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=st(this.values),r._index=st(this.index),r.name=this.name,r}append(r){return pd(t,this,r)}apply(r){return SD(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return OD(this,r,o)}dropNaN(){return FD(t,this)}toObject(){return PD(this)}print(){return jD(this)}shuffle(){return CD(this)}sort(r){return MD(t,this,r)}sortByIndex(){return BD(t,this)}filter(r){return _D(t,this,r)}toDataFrame(){let r=new e(er([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=Cn(r.values),r.index=Cn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Tm=Symbol.for("@jrc03c/js-math-tools/dataframe");function ii(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(Ao()*t.length)];return n}var $e=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Tm}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Tm}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!$(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){y(O(t),"The new values must be a 2-dimensional array!");let n=se(t);y(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Ke(this._index.length,n[0]).map(r=>"row"+No(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Ke(this._columns.length,n[1]).map(r=>"col"+No(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){y(O(t),"The new columns list must be a 1-dimensional array of strings!"),y(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),y(se(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ii(8):r.trim()));let n=(()=>{let r=Ei(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+ii(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){y(O(t),"The new index must be a 1-dimensional array of strings!"),y(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),y(se(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ii(8):r.trim()));let n=(()=>{let r=Ei(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+ii(8):r),this._index=t}}),y($(e)||Pn(e)||O(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof $e)this.values=st(e.values),this.columns=st(e.columns),this.index=st(e.index);else if(O(e)){let t=se(e);y(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),y(!Ru(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{$(r)&&(n=u,r=e[u].length),y(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=er(t);let o=se(this.values);this._index=Ke(0,o[0]).map(u=>"row"+No(u,(o[0]-1).toString().length))}}get shape(){return se(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new $e(sn(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return aD(this,e,t)}getSubsetByNames(e,t){return hD($e,Nt,this,e,t)}getSubsetByIndices(e,t){return fD(this,e,t)}getDummies(e){return Sm($e,this,e)}oneHotEncode(e){return Sm($e,this,e)}transpose(){let e=new $e(er(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return dD(this,e)}copy(){return rD($e,this)}assign(e,t){return nD($e,Nt,this,e,t)}apply(e,t){return tD($e,Nt,this,e,t)}dropMissing(e,t,n){return uD($e,Nt,this,e,t,n)}dropNaN(e,t,n){return sD($e,this,e,t,n)}drop(e,t){return oD($e,Nt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return wD(this,e)}toObject(){return DD(this)}toJSONString(e){return gd(this,e)}saveAsJSON(e,t){return ED(this,e,t)}print(){return mD($e,Nt,this)}sort(e,t){return bD(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return iD($e,Nt,this,e,t)}shuffle(e){return yD(this,e)}append(e,t){return fd(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},Nt=RD($e);function Ci(e,t){return Jt(e,{shouldDropNaNs:t}).max}function we(e){return y(xe(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return O(a)?!0:H(a)?(n=!0,o.push(a),!0):ae(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{y(Rn(O(i)?se(i):i.shape,O(s[a+1])?se(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=Ci(s.map(l=>l.length?l.length:l.values.length)),a=Ke(0,i).map(l=>{let c=Object.keys(arguments).map(f=>O(arguments[f])?arguments[f][l]:H(arguments[f])||ae(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&Rn(se(u[0]),se(a))){let l=new $e(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new $e(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new Nt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new Nt(a)}catch{return a}return a}else return e(...arguments)}}function kD(e){try{return R(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var tc=we(kD);function YD(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!R(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Si=we(YD);function JD(e,t){try{return t(e)}catch{return NaN}}var Mi=we(JD);function $D(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var KD=we($D);function UD(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var LD=we(UD);function VD(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var zD=we(VD);function Rl(e,t){if(ae(e)){let n=Rl(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(H(e)){let n=Rl(e.values,t);return e.index[n]}y(O(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=_o(e,Ci(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function yd(e,t){return Jt(e,{shouldDropNaNs:t}).min}function kl(e,t){if(ae(e)){let n=kl(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(H(e)){let n=kl(e.values,t);return e.index[n]}y(O(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=_o(e,yd(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function kt(e,t){if(ae(e)||H(e))return e.apply(n=>kt(n,t));if(O(e))return e.map(n=>kt(n,t));if(t==="null")return null;if(t==="number"){if($(e))return NaN;let n=kt(e,"boolean");if(_r(n))return n?1:0;try{JSON.parse(e)}catch{let u=kt(e,"date");if(an(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=kt(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return kt(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(kt(e,"int"));if(t==="boolean"){if(_r(e))return e;if(R(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(an(e))return e;if($(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return an(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Pn(e))return e;let n=kt(e,"boolean");if(_r(n))return null;try{let o=kt(e,"number");if(R(o))return JSON.parse(e),null}catch{}let r=kt(e,"date");if(r)return r;try{let o=JSON.parse(e);return O(o)?o.map(u=>kt(u,t)):o}catch{return null}}if(t==="string")return $(e)?Rn(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function WD(e){try{return R(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var GD=we(WD);function qD(e,t){try{if(!R(e))return NaN;if(typeof e=="bigint")return e;if($(t))t=1e-10;else if(!R(t))return NaN;return tc(e)<t?0:e}catch{return NaN}}var HD=we(qD);function Yl(e){if(ae(e)||H(e)){let t=e.copy();return t.values=Yl(t.values),t}if(O(e))return e.map(t=>Yl(t));try{let t=JSON.parse(e);return R(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var kn=we(Yl);function bd(e,t,n){try{return R(e)?R(t)?R(n)?typeof e=="bigint"?BigInt(bd(kn(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var QD=we(bd);function Oi(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of Oi(i,o-1))yield[s].concat(a)}}return ae(e)||H(e)?Oi(e.values,t):(y(O(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),y(R(t)&&kn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(fn(e),t))}function vd(e,t){let n=[];for(let r of Oi(e,t))n.push(r.slice());return n}function Nd(){let e=Object.values(arguments).map(n=>ae(n)||H(n)?qt(n.values):(y(O(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),qt(n)));return qt(e).filter(n=>e.every(r=>r.findIndex(o=>Rn(o,n))>-1))}var Du=class{constructor(e){y($(e)||e===Du.DROP_NAN_MODE||e===Du.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=$(e)?Du.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(O(t)){let n=se(t);if(n.length===1)t=new Nt(t);else if(n.length===2)t=new $e(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}y(ae(t)||H(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===Du.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Nd(...e),this}transform(){y(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(O(t)){let n=se(t);if(n.length===1)return new Nt(t).get(this.index).values;if(n.length===2)return new $e(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return y(ae(t)||H(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Bi=Du;ad(Bi,"DROP_NAN_MODE","DROP_NAN_MODE");ad(Bi,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Fu(e,t,n,r){if(H(e))return Fu(e.values,t,n,r);if(H(t))return Fu(e,t.values,n,r);if(y(O(e)&&O(t)&&se(e).length===1&&se(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),y(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Fu(...new Bi().fitAndTransform(e,t),!1,r);try{let o=Jt(e,{stdev:r}),u=Jt(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!R(s)||!R(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!R(f))return NaN;if(!R(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function Jl(e,t,n){if(H(e))return Jl(e.values,t,n);if(H(t))return Jl(e,t.values,n);y(O(e)&&O(t)&&se(e).length===1&&se(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),y(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Fu(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function ZD(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var XD=we(ZD),xD=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function $l(e,t){if(ae(e)||H(e))return $l(e.values,t);if(ae(t)||H(t))return $l(e,t.values);y(O(e)&&O(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=qt(e),r=qt(t),o=[];return n.forEach(u=>{r.findIndex(s=>Rn(s,u))<0&&o.push(u)}),o}function wd(e,t){try{if(!R(e))return NaN;if(!R(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=wd(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var nc=we(wd);function Ed(e){try{if(!R(e))return NaN;if(typeof e=="bigint"){let t=Ed(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Dd=we(Ed);function eS(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!R(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var Sd=we(eS);function Io(){return Sd(...arguments)}function Od(e,t){return Si(e,Io(t,-1))}function rc(e,t){return Jt(e,{shouldDropNaNs:t}).sum}function Kl(e,t){if(R(e)&&R(t))return tc(e-t);if(ae(e)||H(e))return Kl(e.values,t);if(ae(t)||H(t))return Kl(e,t.values);O(e)&&O(t)&&y(Rn(se(e),se(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Dd(rc(nc(Od(e,t),2)))}catch{return NaN}}function tS(e,t){return Io(e,nc(t,-1))}function Zn(e,t){if(ae(e)){let o=Zn(e.values,t);if(se(o).length===1){let u=new Nt(o);return u.name=H(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new $e(o);return u.index=e.index.slice(),ae(t)&&(u.columns=t.columns.slice()),u}}if(ae(t)){let o=Zn(e,t.values);if(se(o).length===1){let u=new Nt(o);return u.name=H(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new $e(o);return u.columns=t.columns.slice(),u}}if(H(e))return Zn(e.values,t);if(H(t))return Zn(e,t.values);y(O(e)&&O(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=se(e),r=se(t);if(y(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),y(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return rc(Io(e,t));if(n.length===1&&r.length===2)return er(t).map(o=>Zn(e,o));if(n.length===2&&r.length===1)return e.map(o=>Zn(o,t));if(n.length===2&&r.length===2){let o=er(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(Zn(e[s],o[a]));u.push(i)}return u}}function oc(e){if(ae(e)||H(e))return e.dropMissing(...Object.values(arguments).slice(1));y(O(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(oc(n))}catch{$(n)||t.push(n)}}),t}function mi(e,t){if(ae(e)||H(e))return mi(e.values,t);if(ae(t)||H(t))return mi(e,t.values);y(O(e)&&O(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),y(Rn(se(e),se(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=mi(e[o],t[o]);n.push(u),r.push(s)}catch{!$(e[o])&&!$(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function di(e,t){if(ae(e)||H(e))return di(e.values,t);if(ae(t)||H(t))return di(e,t.values);y(O(e)&&O(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),y(Rn(se(e),se(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=di(e[o],t[o]);n.push(u),r.push(s)}catch{R(e[o])&&R(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function nS(e){return oc(e)}function Fi(e,t){if(ae(e)||H(e))return Fi(e.values,t);y(O(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),y(xe(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(O(n)){if(!Fi(n,t))return!1}else if(!t(n))return!1;return!0}function rS(e){try{if(!R(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var oS=we(rS);function Ul(e){try{return typeof e=="bigint"?BigInt(Ul(kn(e))):e!==kn(e)?NaN:e<=1?1:e*Ul(e-1)}catch{return NaN}}var uS=we(Ul);function Ll(e,t){if(ae(e)||H(e))return Ll(e.values,t);if(y(Pn(e)||O(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!xe(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(Pn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(O(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function Vl(e,t){if(ae(e)||H(e))return Vl(e.values,t);if(y(Pn(e)||O(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!xe(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Pn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(O(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function sS(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return R(t)?t:NaN}catch{return NaN}}var iS=we(sS);function aS(e){try{return R(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var lS=we(aS);function uc(e){R(e)&&(e=[e]);let t=[],n=Yu(e);for(let r=0;r<n;r++)t.push(0);return Au(t,e)}function cS(e){typeof e=="bigint"&&(e=kn(e)),y(!$(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),y(R(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),y(kn(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),y(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=uc([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var fS=["true","false","yes","no"],hS=["null","none","nan","na","n/a","","undefined"];function ai(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=kn(e.value)===e.value:e.isInteger=Fi(e.values,t=>R(t)?kn(t)===t:!0)),e}function gi(e){if(ae(e)){let u=e.copy(),s=gi(e.values);return u.values=s.values,ai({type:s.type,values:u})}if(H(e)){let u=e.copy(),s=gi(e.values);return u.values=s.values,ai({type:s.type,values:u})}if(!O(e)){let u=gi([e]);return u.value=u.values[0],delete u.values,ai(u)}y(O(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=fn(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(an(a))return"date"}}catch{}de(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(hS.indexOf(i)>-1)return"null";if(fS.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return R(a)?"number":typeof a=="object"?O(a)?"string":"object":"string"}catch{let l=new Date(u);return an(l)?"date":"string"}}),n=Ei(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return ai({type:o,values:Mi(e,u=>kt(u,o))})}function pi(e){if(ae(e)){let n=e.copy();return n.values=pi(n.values),n}y(O(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=se(e);if(y(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),y(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),y(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){y(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;y(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return Io(i,1/s)}else if(t[0]>1){let n=(r,o)=>R(r)||R(o)?Io(r,o):Zn(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=pi(o),l=pi(Si(i,n(-1,n(n(s,a),u)))),c=Si(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}y(!1,"This matrix cannot be inverted!")}}var mS=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Fd(e,t,n){try{if(!R(e))return NaN;if(!R(t))return NaN;if(!R(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Fd(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var dS=we(Fd);function _d(e,t){try{if(t=$(t)?Math.E:t,!R(e))return NaN;if(!R(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=_d(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var gS=we(_d);function pS(e,t){return Jt(e,{shouldDropNaNs:t}).mean}function yS(e,t){return Jt(e,{shouldDropNaNs:t,median:!0}).median}function Td(e,t){try{if(!R(e))return NaN;if(!R(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Td(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var bS=we(Td);function vS(e,t){return Jt(e,{shouldDropNaNs:t,mode:!0}).mode}function Am(){let e=Ao(),t=Ao();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function NS(e){return $(e)?Am():Mi(sn(e),Am)}function wS(e){return Mi(sn(e),()=>1)}function sc(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of vd(r,o)){if(!u.slice)continue;let s=uc(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return ae(e)||H(e)?sc(e.values,t):(y(O(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),$(t)&&(t=e.length),y(R(t)&&kn(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(fn(e),t))}function ES(e,t){let n=[];for(let r of sc(e,t))n.push(r.slice());return n}function DS(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(O(t))if(Ru(t))console.log(t);else{let n=se(t);n.length===1?new Nt(t).print():n.length==2?new $e(t).print():console.log(t)}else ae(t)||H(t)?t.print():console.log(t)})}var SS=we((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!R(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function OS(e,t,n,r,o){if(O(e)&&$(r)&&$(o)){r=t,o=n;let u=Jt(e);t=u.min,n=u.max}return SS(e,t,n,r,o)}function FS(e){try{return R(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var _S=we(FS);function Ad(e){try{return R(e)?typeof e=="bigint"?BigInt(Ad(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var TS=we(Ad);function AS(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var IS=we(AS);function zl(e,t){if(ae(e)||H(e))return zl(e.values,t);y(O(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),y(xe(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(O(n)){if(zl(n,t))return!0}else if(t(n))return!0;return!1}function Id(e,t){return Jt(e,{shouldDropNaNs:t,stdev:!0}).stdev}function jS(e){return Id(e)}function CS(e){try{return R(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var MS=we(CS);function Im(e,t){y(xe(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function BS(e,t){y(xe(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function PS(){return qt([...arguments].map(e=>O(e)?e:ae(e)||H(e)?e.values:[e]))}function RS(e,t){return Jt(e,{shouldDropNaNs:t,variance:!0}).variance}function kS(){let e=[],t=Object.values(arguments).map(n=>((ae(n)||H(n))&&(n=n.values),y(O(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Ke(0,Ci(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push($(u)?void 0:u)}),e.push(r)}),e}var Su={abs:tc,add:Si,apply:Mi,arccos:KD,arcsin:LD,arctan:zD,argmax:Rl,argmin:kl,assert:y,cast:kt,ceil:GD,chop:HD,clamp:QD,combinations:vd,combinationsIterator:Oi,copy:st,correl:Jl,cos:XD,count:Ei,covariance:Fu,DataFrame:$e,dataTypes:xD,decycle:Ar,diff:$l,distance:Kl,divide:tS,dot:Zn,dropMissing:oc,dropMissingPairwise:mi,dropNaN:ec,dropNaNPairwise:di,dropUndefined:nS,every:Fi,exp:oS,factorial:uS,find:Ll,findAll:Vl,flatten:fn,float:iS,floor:lS,identity:cS,IndexMatcher:Bi,indexOf:_o,inferType:gi,int:kn,intersect:Nd,inverse:pi,isArray:O,isBoolean:_r,isBrowser:mS,isDataFrame:ae,isDate:an,isEqual:Rn,isFunction:xe,isJagged:Ru,isNested:ji,isNumber:R,isObject:Pn,isSeries:H,isString:de,isUndefined:$,lerp:dS,log:gS,MathError:hr,max:Ci,mean:pS,median:yS,min:yd,mod:bS,mode:vS,multiply:Sd,ndarray:sn,normal:NS,ones:wS,permutations:ES,permutationsIterator:sc,pow:nc,print:DS,product:Yu,random:Ao,range:Ke,remap:OS,reshape:Au,reverse:Cn,round:_S,scale:Io,seed:dd,Series:Nt,set:qt,shape:se,shuffle:Di,sign:TS,sin:IS,some:zl,sort:Ir,sqrt:Dd,stats:Jt,std:Id,stdev:jS,subtract:Od,sum:rc,tan:MS,timeAsync:BS,timeSync:Im,time:Im,transpose:er,union:PS,variance:RS,vectorize:we,zeros:uc,zip:kS,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Su.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Su).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Su[t]})}catch{e[t]=Su[t]}})}};typeof window<"u"&&(window.JSMathTools=Su);var YS=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:void 0;function Wl(e){let t=Symbol.for("@TypedArrayConstructor"),n="Symbol(@TypedArrayConstructor)",r=t in e?t:n in e?n:void 0;if(r){if(!("values"in e))throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");return e[r]==="ArrayBuffer"?new Uint8Array(e.values).buffer:new YS[e[r]](e.values)}if(O(e)&&e.constructor.name==="Array")return e;throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!")}function wo(e){if(e instanceof ArrayBuffer||e instanceof BigInt64Array||e instanceof BigUint64Array||e instanceof Float32Array||e instanceof Float64Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Int8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:e.constructor.name,values:e instanceof ArrayBuffer?Array.from(new Uint8Array(e)):Array.from(e)};if(O(e))return e.map(t=>{try{return wo(t)}catch{return t}});if(typeof e=="object"&e!==null){if(an(e))return new Date(e.getTime());let t={};return Object.keys(e).forEach(n=>{try{t[n]=wo(e[n])}catch{t[n]=e[n]}}),t}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function jd(e){return e=e.trim(),!!(e.match(/^-?\d+(\.\d+)?$/g)||e.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g)||e.match(/^-?\.\d+$/g)||e==="NaN")}var Cd="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";function Md(e,t,n){if(typeof e!="string")throw new Error("`text` must be a string!");if(typeof t!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return e.split(t).join(n)}var jm="  ",Cm=" ";function ic(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t="";for(let n=0;n<e.length;n++){let r=e[n].toLowerCase();Cd.includes(r)?t+=Cm:t+=r}for(;t.includes(jm);)t=Md(t,jm,Cm);return t.trim()}function JS(e,t){return t=t||"",e.split(`
`).map(n=>n.trim().length>0?t+n:n).join(`
`)}function $S(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=ic(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("-")}var Mm={"@Infinity":1/0,"@NegativeInfinity":-1/0,"@NaN":NaN,"@undefined":void 0};function Iu(e){if(typeof e=="object"){if(e===null)return e;if(O(e))for(let t=0;t<e.length;t++)e[t]=Iu(e[t]);else Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{e[t]=Iu(e[t])});return e}else return typeof e>"u"||e==="Symbol(@undefined)"?void 0:e}function KS(e){if(typeof e=="bigint")return e;if(typeof e=="string")if(e.match(/^\s*?-?\d+n\s*?$/g))try{return BigInt(e.split("n")[0])}catch{return NaN}else return NaN;else return NaN}function US(e){if(typeof e!="string")return typeof e=="number"?e:void 0;if(jd(e))return parseFloat(e)}function LS(e){if(typeof e!="string")return;let t="@jrc03c/js-text-tools/newline-replacer";if(e=e.replaceAll(`
`,t),e.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)){let n=e.replace("Symbol(@String):","");if(n.match(/^".*?"$/g))try{return JSON.parse(n)}catch{n=n.substring(1,n.length-1)}return n=n.replaceAll(t,`
`),n}}function VS(e){if(typeof e!="string")return typeof e=="symbol"?{out:e,isASymbol:!0}:void 0;if(e.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)){let t=e.replace(/^.*?Symbol\(/g,"").replace(/\).*?$/g,"");return t in Mm?{out:Mm[t],isASymbol:!0}:{out:Symbol.for(t),isASymbol:!0}}}function zS(e){if(typeof e!="string")return e instanceof RegExp?e:void 0;let t=e.trim();if(t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g))try{let n=t.replace(/^\//g,"").replace(/\/(d|g|i|m|s|u|v|y)*?$/g,""),r=t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);return new RegExp(n,r)}catch{}}function WS(e){if(typeof e!="string")return typeof e=="object"?e:"Symbol(@undefined)";try{let t=JSON.parse(e,(n,r)=>{try{let o=mr(r);return typeof o>"u"?"Symbol(@undefined)":o}catch{return typeof r>"u"?"Symbol(@undefined)":r}});return O(t)&&(t=Iu(t)),t}catch{return e}}function GS(e){if(typeof e!="string")return e instanceof Date&&e.toString()!=="Invalid Date"?e:void 0;try{let t=new Date(Date.parse(e));if(t.toString()!=="Invalid Date")return t}catch{}}function qS(e){return typeof e=="object"?e!==null?Iu(e):void 0:(Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{try{let n=t;try{t=mr(t)}catch{}e[t]=mr(e[n]),t!==n&&delete e[n]}catch{}}),Iu(e))}function mr(e){function t(n){if(typeof n=="string"){let r=LS(n);if(typeof r=="string")return r;let o=VS(n);return r=o?o.out:void 0,o&&o.isASymbol||(r=zS(n),r instanceof RegExp)||(r=KS(n),typeof r=="bigint")||(r=US(n),typeof r=="number")||(r=GS(n),r instanceof Date)?r:(r=WS(n),typeof r<"u"?r==="Symbol(@undefined)"?void 0:r:n)}if(typeof n=="object"){if(n===null)return null;let r;try{if(r=Wl(n),O(r))return r}catch{}if(r=qS(n),r)try{return Wl(r)}catch{return r}return n}return n}return t(e)}function HS(e){let t=id(e);return t[0].toUpperCase()+t.slice(1)}function QS(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=ic(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("_")}function cr(e,t){return!e||t<=0?"":Ke(0,t).map(()=>e).join("")}function jo(e,t){y(de(t)||$(t),"The second parameter to the `stringify` function must be undefined or a string!");let n=t?`
`:"";function r(o,u,s){return s=s||0,typeof o=="bigint"?JSON.stringify(o.toString()+"n"):typeof o=="number"?o===1/0?'"Symbol(@Infinity)"':o===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(o)?'"Symbol(@NaN)"':o.toString():typeof o=="string"?JSON.stringify("Symbol(@String):"+o):typeof o=="boolean"?o.toString():typeof o>"u"?'"Symbol(@undefined)"':typeof o=="symbol"||typeof o=="function"?JSON.stringify(o.toString()):o instanceof RegExp?o.toString():typeof o=="object"?o===null?"null":an(o)?JSON.stringify(o.toJSON()):O(o)?o.length===0?cr(u,s-1)+"[]":o instanceof Array?cr(u,s-1)+"["+n+o.map(i=>{let a=(()=>{try{return r(wo(i),u,s+1)}catch{return r(i,u,s+1)}})();return de(a)&&(a=a.trim()),cr(u,s+1)+a}).join(","+n)+n+cr(u,s)+"]":r(wo(o),null,u):Object.keys(o).length+Object.getOwnPropertySymbols(o).length===0?cr(u,s-1)+"{}":cr(u,s-1)+"{"+n+Object.keys(o).concat(Object.getOwnPropertySymbols(o)).map(i=>{let a=(()=>{try{return r(wo(o[i]),u,s+1)}catch{return r(o[i],u,s+1)}})();de(a)&&(a=a.trim());let l=typeof i=="symbol"?r(i):JSON.stringify(i);return cr(u,s+1)+l+":"+(u?" ":"")+a}).join(","+n)+n+cr(u,s)+"}":"undefined"}return r(Ar(e),t)}function ZS(e){let t=e.split(`
`),n=t.filter(o=>o.trim().length>0).map(o=>o.split("").findIndex(u=>!u.match(/\s/g))),r=Math.min(...n);return t.map(o=>o.substring(r)).join(`
`)}function XS(e,t){if(typeof e!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof t>"u"||t===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?t=process.stdout.columns>80?80:process.stdout.columns:t=80),isNaN(t)||typeof t!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return e.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let o=r.split(/[^\s]/g)[0],u=r.replace(o,"").split(" "),s=o;u.forEach(i=>{let a=s+(s.trim().length>0?" ":"")+i;a.length>t?(n.push(s),s=o+i):s=a}),s.length>0&&n.push(s)}),n.join(`
`)}typeof window<"u"&&(window.JSTextTools={camelify:id,convertObjectToTypedArray:Wl,convertTypedArrayToObject:wo,indent:JS,isANumberString:jd,kebabify:$S,parse:mr,pascalify:HS,punctuation:Cd,replaceAll:Md,snakeify:QS,stringify:jo,strip:ic,unindent:ZS,wrap:XS});function Bd(e){if(!fe(e))throw new Error("The value passed into the `base64Decode` must be a string!");try{let t=decodeURIComponent(atob(e)),n=t,r=!0;for(;r;)try{t=mr(t),ln(t,n)&&(r=!1),n=t}catch{r=!1}return t}catch(t){throw new Bm(t.toString())}}function Pd(e){return fe(e)||(e=jo(e)),btoa(encodeURIComponent(e))}function _u(e){return j(e)&&e>0&&parseInt(e)===e}async function xS(e,t,n){n=n||{};let r=n.keyIterations||21e4;if(!fe(e))throw new Error("The first argument passed into the `decrypt` function must be a string (i.e., the same string returned from the `encrypt` function)!");if(!fe(t)||t.length===0)throw new Error("The second argument passed into the `decrypt` function must be a string representing the password with which to decrypt the encrypted data.");if(!_u(r))throw new Error("The 'keyIterations' option passed into the `decrypt` function must be undefined or a natural number (i.e., a positive integer) representing the number of iterations used during the key derivation. NOTE: For decryption to be successful, this number must match the number of iterations that was used during the encryption of the data.");e=mr(Bd(e));let{iv:o,salt:u,value:s}=e;if(!o||!u||!s)throw new Error("The first argument passed into the `decrypt` function must be an object with properties 'iv', 'salt', and 'value' (i.e., the same object returned from the `encrypt` function)!");let i,a;try{let l=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveBits","deriveKey"]);a=await crypto.subtle.deriveKey({name:"PBKDF2",salt:u,iterations:r,hash:"SHA-512"},l,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"])}catch(l){throw new Dl(l.toString())}try{i=new TextDecoder().decode(await crypto.subtle.decrypt({name:"AES-GCM",iv:o},a,s))}catch{throw new Dl("Invalid password!")}try{return mr(i)}catch{return i}}async function eO(e,t,n){n=n||{};let r=n.saltLength||32,o=n.ivLength||32,u=n.keyIterations||21e4;if(!fe(t)&&t.length>0)throw new Error("The second argument passed into the `encrypt` function must be a string representing the password with which the data will be encrypted!");if(!_u(r))throw new Error("The 'saltLength' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the length of the new salt to be generated.");if(!_u(o))throw new Error("The 'ivLength' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the length of the initialization vector to be generated.");if(!_u(u))throw new Error("The 'keyIterations' option passed into the `encrypt` function must be undefined or a natural number (i.e., a positive integer) representing the number of iterations used during the key derivation.");let s,i,a;try{i=crypto.getRandomValues(new Uint8Array(r));let l=await crypto.subtle.importKey("raw",new TextEncoder().encode(t),"PBKDF2",!1,["deriveBits","deriveKey"]),c=await crypto.subtle.deriveKey({name:"PBKDF2",salt:i,iterations:u,hash:"SHA-512"},l,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]);a=crypto.getRandomValues(new Uint8Array(o)),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:a},c,new TextEncoder().encode(jo(e)))}catch(l){throw new Pm(l.toString())}return Pd(jo({salt:i,iv:a,value:s}))}async function ac(e,t){if(k(t))t="";else if(!fe(t))throw new Error("The second value passed into the `hash` function must be undefined or a string representing a salt to be added to the first value before hashing!");fe(e)||(e=jo(e));try{return Array.from(new Uint8Array(await crypto.subtle.digest("SHA-512",new TextEncoder().encode(e+t)))).map(n=>n.toString(16).padStart(2,"0")).join("")}catch(n){throw new Rm(n.toString())}}function tO(e,t){if(k(e))e=256;else if(!_u(e))throw new Error("The first value passed into the `randomString` function must be undefined or a positive integer representing the length of the returned string! If no length is passed, then the default length will be 256.");if(k(t))t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";else if(!fe(t)||t.length<=1)throw new Error("The second value passed into the `randomString` function must be undefined or a string representing the set of characters of which the returned string will be comprised! Note that a given character set must contain at least 2 characters in order to be secure. If the character set is undefined, then the default value is the lower- and upper-case Latin alphabet and the digits 0-9.");try{let n="";for(let r=0;r<e;r++){let o=crypto.getRandomValues(new Uint32Array(1))[0]%t.length;n+=t[o]}return n}catch(n){throw new km(n.toString())}}typeof window<"u"&&(window.JSCryptoHelpers={base64Decode:Bd,Base64DecodingError:Bm,base64Encode:Pd,Base64EncodingError:Kw,decrypt:xS,DecryptionError:Dl,encrypt:eO,EncryptionError:Pm,hash:ac,HashingError:Rm,parse:mr,randomString:tO,RandomStringGenerationError:km,stringify:jo});var nO=Object.defineProperty,rO=(e,t,n)=>t in e?nO(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,zd=(e,t,n)=>(rO(e,typeof t!="symbol"?t+"":t,n),n);function I(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var oO=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),dr=class extends Error{constructor(e){oO()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function d(e,t){if(!e)throw new dr(t)}var Wd=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function L(e){return e===null||typeof e>"u"}var uO=Wd.map(e=>e.name);function A(e){try{return e instanceof Array?!0:L(e.constructor)?!1:Wd.indexOf(e.constructor)>-1||uO.indexOf(e.constructor.name)>-1}catch{return!1}}function ce(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function et(e){return typeof e=="function"}function Jn(e){return typeof e=="object"&&!L(e)&&!A(e)}function Q(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function Po(e,t){if(ce(e)){let u=Po(e.values,t);return u.length>0&&I(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u.length>1&&I(u[1])&&u[1]>=0&&u[1]<e.columns.length&&(u[1]=e.columns[u[1]]),u}if(Q(e)){let u=Po(e.values,t);return u.length>0&&I(u[0])&&u[0]>=0&&u[0]<e.index.length&&(u[0]=e.index[u[0]]),u}if(d(Jn(e)||A(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!et(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Jn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u));for(let l=0;l<a.length;l++){let c=a[l],f=u[c];if(s(f))return[c];let h=n(f,s,i);if(h&&h.length>0)return[c].concat(h)}}else if(A(u)){i.push(u);for(let a=0;a<u.length;a++){let l=u[a];if(s(l))return[a];let c=n(l,s,i);if(c&&c.length>0)return[a].concat(c)}}else if(s(u))return[];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function it(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(A(n))return n instanceof Array?n.map(o=>it(o)):n.slice();if(Q(n)){let o=n.copy();return o.values=it(o.values),o}if(ce(n)){let o=n.copy();return o.values=it(n.values),o}if(n instanceof Date)return new Date(n.getTime());n=Ro(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(o=>{r[o]=it(n[o])}),r}else return n}return t(Ro(e))}function Ro(e){function t(o,u,s){if(u=u||[],s=s||"",u.indexOf(o)>-1){let i=s.split("/").slice(s.startsWith("/")?1:0);if(i.some((l,c)=>{let f=i.slice(0,i.length-c-1),h=n;return f.forEach(m=>{h=h[m]}),h===o}))return`<reference to "${n===o?"/":"/"+Po(n,o).join("/")}">`}return typeof o=="object"?o===null?null:(u.push(o),A(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((i,a)=>t(i,u,s+"/"+a)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(i=>{o[i]=t(o[i],u,s+"/"+i.toString())}),o)):o}let n=e,r=t(n);if(ce(e)){let o=e.copy();o._values=r.values,o._columns=r.columns,o._index=r.index,r=o}if(Q(e)){let o=e.copy();o.name=r.name,o._values=r.values,o._index=r.index,r=o}return r}function nr(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var Rd=["number","int","float","bigint"];function $n(e,t){function n(r,o){let u=typeof r,s=typeof o;if(u!==s&&!Rd.includes(u)&&!Rd.includes(s))return!1;if(u==="undefined"&&s==="undefined")return!0;if(u==="boolean"||u==="symbol")return r===o;if(u==="number"||u==="bigint")try{let i=r.toString(),a=o.toString();return i===a}catch{return!1}if(u==="string"||u==="function")return r===o;if(u==="object"){if(r===null||o===null)return r===null&&o===null;{if(nr(r))return nr(o)?r.getTime()===o.getTime():!1;if(nr(o))return!1;if(r instanceof RegExp&&o instanceof RegExp)return r.toString()===o.toString();if(A(r)!==A(o))return!1;let i=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(i.length!==a.length)return!1;for(let l=0;l<i.length;l++){let c=i[l];if(!n(r[c],o[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Ro(e),Ro(t))}}function Lu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var sO=Lu(16),iO=Lu(16),aO=Lu(16),lO=Lu(16),cO=Lu(16),fO=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)A(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?sO:L(e)?iO:et(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+cO:e===1/0?aO:e===-1/0?lO:typeof e=="bigint"?e.toString():ce(e)?e.toJSONString():Q(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!L(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function mn(e){if(ce(e)||Q(e))return mn(e.values);d(A(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(o=>{A(o)?r=r.concat(t(o)):r.push(o)}),r}return t(e)}function Ut(e,t){t=t||{};let n=new fO,r={},o=mn(e),u=[],s=-1/0,i=1/0,a=!1,l=0;for(let f of o){if(typeof f=="bigint"&&(a=!0),!t.shouldDropNaNs||I(f))try{f>s&&(s=f),f<i&&(i=f),l+=Number(f),u.push(f)}catch{s=NaN,i=NaN,l=NaN}n.increment(f)}let c=l/u.length;if(r.counts=n,r.max=s,r.mean=c,r.min=i,r.n=o.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=u.length),t.mode){let f=Array.from(n.values.map(w=>[w,n.get(w)])).toSorted((w,E)=>E[1]-w[1]),h=f[0][1],m=[];for(let w of f)if(w[1]==h)m.push(w[0]);else break;r.mode=m.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let f=u.toSorted((m,w)=>Number(m)-Number(w)),h=Math.floor(f.length/2);if(f.length%2===0){let m=f[h-1],w=f[h];if(r.median=(Number(m)+Number(w))/2,a&&typeof m=="bigint"&&typeof w=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=f[h]}if(t.stdev||t.variance){let f=0;for(let m of u)f+=Math.pow(Number(m)-c,2);f/=u.length;let h=Math.sqrt(f);r.stdev=h,r.variance=f}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(f=>{try{return BigInt(f)}catch{return f}}))}return r}function Ki(e,t){let{counts:n}=Ut(e);return L(t)||(et(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{$n(r,t)||n.delete(r)})),n}function lc(e){if(ce(e)||Q(e))return lc(e.values);if(A(e)){let t=!1,n=!1,r=null;for(let o of e){if(lc(o))return!0;if(A(o)){if(r===null)r=o.length;else if(o.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function Vu(e){return lc(Ro(e))}function Wi(e){if(ce(e)||Q(e))return Wi(e.values);d(A(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(A(e[t]))return!0;return!1}var Co="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function hn(e){d(!L(e),Co),A(e)||(e=[e]),d(!Wi(e),Co),d(e.length>0,Co);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),d(I(t),Co),d(t>=0,Co),d(Math.floor(t)===t,Co),d(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(hn(e.slice(1)));return n}}function Yn(e){if(ce(e)||Q(e)){let n=e.copy();return n.values=Yn(n.values),n.index=Yn(n.index),n}d(A(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function Ge(e,t,n=1){d(!L(e)&&!L(t)&&!L(n),"You must pass two numbers and optionally a step value to the `range` function!"),d(I(e)&&I(t)&&I(n),"You must pass two numbers and optionally a step value to the `range` function!"),d(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,o=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let s=e;e=t+n,t=s+n}let u=[];for(let s=e;s<t;s+=n)if(o)try{u.push(BigInt(s))}catch{u.push(s)}else u.push(s);return r&&(u=Yn(u)),u}function zu(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var hO=zu(256),mO=zu(256),dO=zu(256),gO=zu(256),pO=zu(256);function Ht(e){if(ce(e)||Q(e))return Ht(e.values);d(A(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return mn(e).forEach(r=>{let o=typeof r=="object"&&r===null?hO:L(r)?mO:et(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+pO:r===1/0?dO:r===-1/0?gO:typeof r=="bigint"?r.toString():ce(r)?r.toJSONString():Q(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[o]||t.push(r),n[o]=!0}),t}function Gd(e){if(A(e)){let t=Gd(e[0]);return[e.length].concat(t||[])}else return}function le(e){return ce(e)||Q(e)?le(e.values):(d(A(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Gd(e))}function qd(e,t,n){if(L(n)&&(n=0),d(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),A(t)){d(!Vu(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=le(t);if(r.length===1)if(n===0){let o=e.copy();o._values.push(t);let u=Math.max(e.shape[1],r[0]);for(o._values.forEach(s=>{for(;s.length<u;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<u;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(e.shape[0],r[0]),u=e.copy();for(Ge(0,o).forEach(s=>{s>=u._values.length&&u._values.push(hn(e.shape[1])),u._values[s].push(t[s])});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<u._values[0].length;)u._columns.push("col"+u._columns.length);return u}else if(r.length===2)if(n===0){let o=Math.max(...t.map(s=>s.length).concat([e.shape[1]])),u=e.copy();for(u._values=u._values.concat(t).map(s=>{for(;s.length<o;)s.push(void 0);return s});u._index.length<u._values.length;)u._index.push("row"+u._index.length);for(;u._columns.length<o;)u._columns.push("col"+u._columns.length);return u}else{let o=Math.max(...t.map(i=>i.length))+e.shape[1],u=Math.max(e.shape[0],r[0]),s=e.copy();for(Ge(0,u).forEach(i=>{for(i>=s._values.length&&s._values.push(hn(e.shape[1])),s._values[i]=s._values[i].concat(t[i]);s._values[i].length<o;)s._values[i].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new dr("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(Q(t)){let r=qd(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(ce(t))if(n===0){let r=e.copy(),o=Ht(r._columns.concat(t._columns)).length;for(r._values.forEach(u=>{for(;u.length<o;)u.push(void 0)}),t.apply(u=>{let s=u.copy(),i=[];r._columns.forEach(a=>{let l=s._index.indexOf(a);l>-1?(i.push(s._values[l]),s._values.splice(l,1),s._index.splice(l,1)):i.push(void 0)}),r._values.push(i.concat(s._values))},1),r._columns=r._columns.concat(t._columns.filter(u=>r._columns.indexOf(u)<0));r._index.length<r._values.length;){let u="row"+r._index.length;r._index.push(u+(e._index.indexOf(u)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((o,u)=>{let s=t._index.indexOf(o);s>-1?r._values[u]=r._values[u].concat(t._values[s]):r._values[u]=r._values[u].concat(hn(t.shape[1]))}),t._index.forEach((o,u)=>{r._index.indexOf(o)<0&&(r._index.push(o),r._values.push(hn(r._columns.length).concat(t._values[u])))}),r._columns=r._columns.concat(t._columns.map(o=>o+(r._columns.indexOf(o)>-1?" (2)":""))),r}else throw new dr("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function yO(e,t,n,r,o){if(o=o||0,d(et(r),"The first parameter to the `apply` method must be a function."),d(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let u={},s;if(n.columns.forEach((i,a)=>{let l=new t(n.values.map(f=>f[a]));l.name=i,l.index=n.index;let c=r(l,a,n);c instanceof t?u[i]=c.values:u[i]=c,L(s)&&(s=c instanceof t||A(c))}),s){let i=new e(u);return i.index=n.index,i}else{let i=new t(n.columns.map(a=>u[a]));return i.index=n.columns,i}}else if(o===1){let u,s=n.values.map((i,a)=>{let l=new t(i);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return L(u)&&(u=c instanceof t||A(c)),c instanceof t?c.values:c});if(u){let i=new e(s);return i.index=n.index,i.columns=n.columns,i}else{let i=new t(s);return i.index=n.index,i}}}function Ee(e){return typeof e=="string"}function bO(e,t,n,r,o){let u=i=>i instanceof e,s=i=>i instanceof t;if(L(o)){if(u(r))return n.append(r,1);if(s(r))return n.append(r,1);if(Jn(r)){let i=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<i;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new dr("You must pass a DataFrame, Series, or object into the `assign` method!")}else{d(Ee(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),d(A(o)&&!Vu(o)&&le(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let i=n.append(o,1);return i.columns[i.columns.length-1]=r,i}}function vO(e,t){if(t.isEmpty)return new e;let n=new e(it(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function NO(e,t,n,r,o){L(r)&&(r=[]),L(o)&&(o=[]),(Ee(r)||I(r))&&(r=[r]),(Ee(o)||I(o))&&(o=[o]),d(A(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),d(A(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),d(le(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),d(le(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let u,s;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(u||(u=[]),u.push(a))}),n.columns.forEach((a,l)=>{o.indexOf(a)<0&&o.indexOf(l)<0&&(s||(s=[]),s.push(a))});let i=n.get(u,s);if(i instanceof t){let a=new e;a=a.assign(i),n.index.indexOf(i.name)>-1&&(a=a.transpose()),i=a}return i}function Hd(e){return I(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function ko(e){return Hd(e)&&e>=0}function wO(e,t,n,r,o,u){r=r||0,d(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),u=u||0,d(ko(u),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=u>0?"none":o||"any",d(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(l){if(u>0){let c=0;for(let f=0;f<l.length;f++){let h=l[f];if(L(h)&&c++,c>=u)return[]}}else if(o==="any")for(let c=0;c<l.length;c++){let f=l[c];if(L(f))return[]}else if(o==="all"){for(let c=0;c<l.length;c++){let f=l[c];if(!L(f))return l}return[]}return l}let i=n.copy(),a=Math.random().toString();if(r===0){i=i.assign(a,i.index);let l=i.values.map(s).filter(f=>f.length>0);if(le(l).length<2)return new e;i.values=l;let c=i.get(null,a);if(L(c))return new e;Ee(c)&&(c=[c]),c instanceof t&&(c=c.values),i.index=c,i=i.drop(null,a)}else if(r===1){let l={};if(i.columns.forEach((f,h)=>{let m=i.values.map(E=>E[h]),w=s(m);w.length>0&&(l[f]=w)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=i.index,c}return i}function Nc(e){if(ce(e)||Q(e))return e.dropNaN(...Object.values(arguments).slice(1));d(A(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Nc(n))}catch{if(I(n))return t.push(n)}}),t}function EO(e,t,n,r,o){n=n||0,d(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,d(ko(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=o>0?"none":r||"any",d(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function u(i){let a=Nc(i);return o>0?i.length-a.length<o:r==="any"?a.length===i.length:r==="all"?a.length>0:!0}let s=t.copy();if(n===0){let i=s.index.filter(a=>{let l=s.get(a,null).values;return u(l)});return i.length>0?s.get(i,null):new e}else if(n===1){let i=s.columns.filter(a=>{let l=s.get(null,a).values;return u(l)});return i.length>0?s.get(null,i):new e}return s}function kd(e){let t={};return mn(e).forEach((n,r)=>{t[n]=r}),t}function Mo(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function DO(e,t,n,r,o){d(et(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),L(o)&&(o=0),d(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let u=n.copy();if(u.isEmpty)return u;let s=kd(u.index),i=kd(u.columns);if(o===0){let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.index[f],h.index=n.columns;let m=r(h,f,n);return m?a++:delete s[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Mo(s)[0],c.index=Mo(i),c}u.values=l,u.index=Mo(s)}else if(o===1){u=u.transpose();let a=0,l=u.values.filter((c,f)=>{let h=new t(c);h.name=n.columns[f],h.index=n.index;let m=r(h,f,n);return m?a++:delete i[u.index[f]],m});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Mo(i)[0],c.index=Mo(s),c}u.values=l,u.index=Mo(i),u=u.transpose()}return u}function SO(e,t,n){(Ee(t)||I(t))&&(t=[t]),(Ee(n)||I(n))&&(n=[n]);for(let o in t)typeof t[o]=="bigint"&&(t[o]=Number(t[o]));for(let o in n)typeof n[o]=="bigint"&&(n[o]=Number(n[o]));let r=Ht((t||[]).concat(n||[]).map(o=>typeof o));return d(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&d(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(d(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),d(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),L(t)||(t=t.map(o=>{if(Ee(o))return d(e.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(I(o))return d(o>=0,`Index ${o} is out of bounds!`),d(Math.floor(o)===o,"Row numbers must be integers!"),d(o<e.index.length,`Index ${o} is out of bounds!`),e.index[o]})),L(n)||(n=n.map(o=>{if(Ee(o))return d(e.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(I(o))return d(o>=0,`Column ${o} is out of bounds!`),d(Math.floor(o)===o,"Column numbers must be integers!"),d(o<e.columns.length,`Column ${o} is out of bounds!`),e.columns[o]})),e.getSubsetByNames(t,n)}function OO(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Cr(e,t){if(L(t)&&(t=OO),ce(e)||Q(e))return e.sort(...Object.values(arguments).slice(1));d(A(e),"The `sort` function only works on arrays, Series, and DataFrames!"),d(et(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function FO(e){let t=e.toLowerCase(),n="";for(let o=0;o<t.length;o++){let u=t[o];u.match(/[a-z0-9]/g)?n+=u:n+=" "}let r=n.split(" ").filter(o=>o.length>0);return r[0]+r.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function Yd(e,t,n){L(n)?n=t.columns:Ee(n)&&(n=[n]);let r={};n.forEach(u=>{d(Ee(u),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=t.columns.indexOf(u);d(s>-1,`The given DataFrame does not have a column called "${u}"!`);let i=t.values.map(l=>l[s]),a=Cr(Ht(i));i.forEach(l=>{a.forEach(c=>{let f=u+"_"+FO(c.toString());r[f]||(r[f]=[]),l===c?r[f].push(1):r[f].push(0)})})});let o=new e(r);return o.index=t.index,o}function _O(e,t,n){let r=e.shape;L(t)&&(t=Ge(0,r[0])),L(n)&&(n=Ge(0,r[1])),I(t)&&(t=[t]),I(n)&&(n=[n]),d(A(t)&&A(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),d(le(t).length===1&&le(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),d(t.length>0,"The `rowIndices` array must contain at least one index."),d(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(s=>{d(ko(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),d(s<e.index.length,`The row index ${s} is out of bounds.`)}),n.forEach(s=>{d(ko(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),d(s<e.columns.length,`The column index ${s} is out of bounds.`)});let o=t.map(s=>e.index[s]),u=n.map(s=>e.columns[s]);return e.getSubsetByNames(o,u)}function TO(e,t,n,r,o){L(r)&&(r=n.index),L(o)&&(o=n.columns),Ee(r)&&(r=[r]),Ee(o)&&(o=[o]),d(A(r)&&A(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),d(le(r).length===1&&le(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),d(r.length>0,"The `rows` array must contain at least one row name."),d(o.length>0,"The `cols` array must contain at least one column name."),r.forEach(i=>{d(Ee(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),d(n.index.indexOf(i)>-1,`The row name "${i}" does not exist in the list of rows.`)}),o.forEach(i=>{d(Ee(i),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),d(n.columns.indexOf(i)>-1,`The column name "${i}" does not exist in the list of columns.`)});let u=r.map(i=>o.map(a=>n.values[n.index.indexOf(i)][n.columns.indexOf(a)]));if(r.length===1&&o.length===1)return u[0][0];if(r.length===1){let i=new t(u[0]);return i.name=r[0],i.index=o,i}if(o.length===1){let i=new t(u.map(a=>a[0]));return i.name=o[0],i.index=r,i}let s=new e(u);return s.columns=o,s.index=r,s}function AO(e,t,n){function r(h,m){return Ee(h)&&h.length>m?h.substring(0,m-3)+"...":h}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let o=typeof window>"u"?20:10,u=Math.floor(o/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,i=Math.floor(s/2),a=o>n.index.length?null:Ge(0,u).concat(Ge(n.index.length-u,n.index.length)),l=s>n.columns.length?null:Ge(0,i).concat(Ge(n.columns.length-i,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),o<=n.index.length&&(c._index.splice(u,0,"..."),c._values.splice(u,0,Ge(0,c.columns.length).map(()=>"..."))),s<=n.columns.length&&(c._columns.splice(i,0,"..."),c._values=c._values.map(h=>(h.splice(i,0,"..."),h)));let f=28;return c instanceof t?(c.values=c.values.map(h=>r(h,f)),c.name=r(c.name,f),c.index=c.index.map(h=>r(h,f))):(c.values=c.values.map(h=>h.map(m=>r(m,f))),c.columns=c.columns.map(h=>r(h,f)),c.index=c.index.map(h=>r(h,f))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function Bo(e,t){d(I(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function IO(e,t){let n=t?e:e.copy();return n.index=Ge(0,e.shape[0]).map(r=>"row"+Bo(r,(n.index.length-1).toString().length)),n}function Wu(e,t){if(ce(e)||Q(e))return Wu(e.values,t);d(A(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=mn(e),r=!1,o=1;for(let u of n){if(!I(u))if(t)u=1;else return NaN;typeof u=="bigint"&&(r=!0,u=Number(u)),o*=u}if(r)try{return BigInt(o)}catch{}return o}catch{return NaN}}function jO(e){return Hd(e)&&e>0}function Uu(e,t){if(ce(e)||Q(e))return Uu(e.values,t);if(d(A(e),"The first argument passed into the `reshape` function must be an array!"),I(t)&&(t=[t]),d(A(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),d(le(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(u=>(typeof u=="bigint"&&(u=Number(u)),d(jO(u),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(u))),t.length===0)return mn(e);let n=mn(e);if(t.length===1&&t[0]===n.length)return n;d(Wu(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],o=Math.floor(n.length/t[0]);for(let u=0;u<t[0];u++){let s=n.slice(u*o,(u+1)*o);r.push(Uu(s,t.slice(1)))}return r}var Qd=Math.pow(2,64),Ce=[];wc(Math.floor(Math.random()*Qd));function CO(e,t){e=dt(e);function n(){e+=dt("0x9e3779b97f4a7c15");let o=it(e);return o=(o^o>>BigInt(30))*dt("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*dt("0x94d049bb133111eb"),o^o>>BigInt(31)}let r=[];for(let o=0;o<t;o++)r.push(n());return r}function dt(e){return BigInt.asUintN(64,BigInt(e))}function Jd(e,t){return e=dt(e),t=BigInt(t),dt(dt(e<<t)|dt(e>>dt(BigInt(64)-t)))}function wc(e){if(typeof e=="bigint"&&(e=Number(e)),L(e))return it(Ce);{d(I(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=CO(Math.floor(e),4);Ce[0]=t[0],Ce[1]=t[1],Ce[2]=t[2],Ce[3]=t[3]}}function $d(){let e=dt(Jd(Ce[0]+Ce[3],23)+Ce[0]),t=dt(Ce[1]<<BigInt(17));return Ce[2]=dt(Ce[2]^Ce[0]),Ce[3]=dt(Ce[3]^Ce[1]),Ce[1]=dt(Ce[1]^Ce[2]),Ce[0]=dt(Ce[0]^Ce[3]),Ce[2]=dt(Ce[2]^t),Ce[3]=Jd(Ce[3],45),Math.floor(Number(e))/Qd}function Mr(e){return L(e)?$d():(A(e)||(e=[e]),Uu(hn(Wu(e)).map($d),e))}function Ui(e){if(ce(e)||Q(e))return e.shuffle(...Object.values(arguments).slice(1));d(A(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let o=Math.floor(Mr()*n.length);t.push(n.splice(o,1)[0])}return t}function MO(e,t){return L(t)&&(t=0),d(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?Ui(e.index):null,t===1?Ui(e.columns):null)}function jr(e){return typeof e=="boolean"}function BO(e,t,n){return et(t)?PO(e,t,n):RO(e,t,n)}function PO(e,t,n){if(n=L(n)?0:n,d(et(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),d(I(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Cr(e.index,(o,u)=>t(e.get(o,null),e.get(u,null)));return e.get(r,null)}else{let r=Cr(e.columns,(o,u)=>t(e.get(null,o),e.get(null,u)));return e.get(null,r)}}function RO(e,t,n){let r=e.copy(),o=Mr().toString();r=r.assign(o,r.index),L(t)&&(t=[o],n=[!0]),(I(t)||Ee(t))&&(t=[t],(jr(n)||Ee(n))&&(n=[n])),d(A(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),d(le(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),L(n)&&(n=Ge(0,t.length).map(()=>!0)),d(A(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),d(le(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),d(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(s=>{if(d(Ee(s)||I(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),Ee(s)){let i=r.columns.indexOf(s);return d(i>-1,`The column "${s}" does not exist!`),i}if(I(s))return d(ko(s),"Column indices must be whole numbers!"),d(s<r.columns.length,`The index ${s} is out of bounds!`),s}),n=n.map(s=>{if(d(Ee(s)||jr(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),Ee(s)){let i=s.trim().toLowerCase();return d(i==="ascending"||i==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),i==="ascending"}if(jr(s))return s}),r.values=Cr(r.values,(s,i)=>{let a=0;for(;s[t[a]]===i[t[a]]&&a<t.length;)a++;let l=n[a];if(s[t[a]]===i[t[a]])return 0;if(s[t[a]]<i[t[a]])return l?-1:1;if(s[t[a]]>i[t[a]])return l?1:-1});let u=r.columns.indexOf(o);return r.index=r.values.map(s=>s[u]),r=r.dropColumns(o),r}function kO(e,t){L(t)?t=0:d(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,o)=>{let u={};e.columns.forEach((s,i)=>{u[s]=e.values[o][i]}),n[r]=u}):e.columns.forEach((r,o)=>{let u={};e.index.forEach((s,i)=>{u[s]=e.values[i][o]}),n[r]=u}),n}function Zd(e,t){return JSON.stringify(e.toObject(t))}async function YO(e,t,n){let r=Zd(e,n),o=!1,u=!1,s,i;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),o=!0}catch(a){s=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),u=!0}catch(a){i=a}if(!o&&!u)throw typeof window<"u"?new dr(s):typeof module<"u"?new dr(i):new dr("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function JO(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function rr(e){if(ce(e)||Q(e))return e.transpose();d(A(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=le(e);if(d(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return Yn(e);if(t.length===2){let n=hn(Yn(t));for(let r=0;r<t[0];r++)for(let o=0;o<t[1];o++)n[o][r]=e[r][o];return n}}function Xd(e,t,n){if(Q(n))return new e(t.values.concat(n.values));if(A(n)){let r=le(n);d(r.length===1&&!Wi(r),"Only vectors can be appended to Series!");let o=t.copy();return n.forEach((u,s)=>{o._values.push(u),o._index.push("item"+(t.values.length+s))}),o}return Xd(t,[n])}function $O(e,t){d(et(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,o)=>t(r,o)),n}function KO(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,o)=>L(r)?!1:(n.push(t.index[o]),!0)),t._index=n,t}function UO(e,t){let n=[],r=[];t.values.forEach((u,s)=>{I(u)&&(r.push(u),n.push(t.index[s]))});let o=new e(r);return o.name=t.name,o.index=n,o}function LO(e,t,n){let r=t.copy(),o=it(r.index),u=[],s=r.values.filter((i,a)=>{let l=n(i,a,r.values);return l||u.push(r.index[a]),l});return u.forEach(i=>{o.splice(o.indexOf(i),1)}),s.length===0?(r=new e,r.name=t.name,r):(r.values=s,r.index=o,r)}function VO(e,t){(Ee(t)||I(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=Ht((t||[]).map(r=>typeof r));return d(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&d(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(d(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),d(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),L(t)||(t=t.map(r=>{if(typeof r=="string")return d(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return d(r>=0,`Index ${r} is out of bounds!`),d(Math.floor(r)===r,"Indices must be integers!"),d(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function zO(e,t){let n=e.shape;L(t)&&(t=Ge(0,n[0])),d(A(t),"The `indices` array must be 1-dimensional array of whole numbers."),d(le(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),d(t.length>0,"The `indices` array must contain at least one index."),t.forEach(o=>{d(ko(o),"The `indices` array must be a 1-dimensional array of whole numbers."),d(o<e.index.length,`The row index ${o} is out of bounds.`)});let r=t.map(o=>e.index[o]);return e.getSubsetByNames(r)}function WO(e,t,n){L(n)&&(n=t.index),d(A(n),"The `indices` array must be a 1-dimensional array of strings."),d(le(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),d(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(u=>{d(Ee(u),"The `indices` array must contain only strings."),d(t.index.indexOf(u)>-1,`The name "${u}" does not exist in the index.`)});let r=n.map(u=>t.values[t.index.indexOf(u)]);if(r.length===1)return r[0];let o=new e(r);return o.index=n,o.name=t.name,o}function GO(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(Ge(0,n/2).concat(Ge(t.index.length-n/2,t.index.length)));let o=it(t.index);o.splice(Math.floor(o.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(o)}let r={};return t.values.forEach((o,u)=>{let s={};s[t.name]=o,r[t.index[u]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}function qO(e){let t=e.copy();return t.get(Ui(t.index))}function HO(e,t,n){n=n||((a,l)=>a<l?-1:1),d(L(n)||et(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=rr([t.values,t.index]),o=Cr(r,(a,l)=>n(a[0],l[0])),u=[],s=[];o.forEach(a=>{u.push(a[0]),s.push(a[1])});let i=new e;return i._values=u,i._index=s,i.name=t.name,i}function QO(e,t){let n=rr([t.values,t.index]);n=rr(Cr(n,(o,u)=>{if(o[1]===u[1])return 0;if(o[1]<u[1])return-1;if(o[1]>u[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function ZO(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Kd=Symbol.for("@jrc03c/js-math-tools/series");function XO(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Kd}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Kd}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){d(A(o),"The new values must be a 1-dimensional array!");let u=le(o);d(u.length===1,"The new array of values must be 1-dimensional!"),u[0]<this._index.length?this._index=this._index.slice(0,u[0]):u[0]>this._index.length&&(this._index=this._index.concat(Ge(this._index.length,u[0]).map(s=>"item"+Bo(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){d(A(o),"The new index must be a 1-dimensional array of strings!"),d(o.length===this.shape[0],"The new index must be the same length as the old index!"),d(le(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(u=>{d(Ee(u),"All of the row names must be strings!")}),this._index=o}}),r){if(r instanceof t)this.name=r.name,this.values=it(r.values),this.index=it(r.index);else if(A(r)){let o=le(r);d(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(i=>i.toString());d(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let u=o[0],s=r[u];d(le(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=u,this.values=s.slice()}}}get shape(){return le(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!L(r)).length===0}clear(){let r=this.copy();return r.values.forEach((o,u)=>{r.values[u]=void 0}),r}get(r){return VO(this,r)}getSubsetByNames(r){return WO(t,this,r)}getSubsetByIndices(r){return zO(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(Yn(this.values));return r.index=Yn(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=Ge(0,this.shape[0]).map(o=>"item"+Bo(o,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=it(this.values),r._index=it(this.index),r.name=this.name,r}append(r){return Xd(t,this,r)}apply(r){return $O(this,r)}concat(r){return this.append(r)}dropMissing(r,o){return KO(this,r,o)}dropNaN(){return UO(t,this)}toObject(){return ZO(this)}print(){return GO(this)}shuffle(){return qO(this)}sort(r){return HO(t,this,r)}sortByIndex(){return QO(t,this)}filter(r){return LO(t,this,r)}toDataFrame(){let r=new e(rr([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=Yn(r.values),r.index=Yn(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Ud=Symbol.for("@jrc03c/js-math-tools/dataframe");function Pi(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(Mr()*t.length)];return n}var Ue=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Ud}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Ud}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!L(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){d(A(t),"The new values must be a 2-dimensional array!");let n=le(t);d(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(Ge(this._index.length,n[0]).map(r=>"row"+Bo(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(Ge(this._columns.length,n[1]).map(r=>"col"+Bo(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){d(A(t),"The new columns list must be a 1-dimensional array of strings!"),d(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),d(le(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Pi(8):r.trim()));let n=(()=>{let r=Ki(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+Pi(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){d(A(t),"The new index must be a 1-dimensional array of strings!"),d(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),d(le(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Pi(8):r.trim()));let n=(()=>{let r=Ki(t),o={};return r.values.forEach(u=>{o[u]=r.get(u)}),o})();t=t.map(r=>n[r]>1?r+"_"+Pi(8):r),this._index=t}}),d(L(e)||Jn(e)||A(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof Ue)this.values=it(e.values),this.columns=it(e.columns),this.index=it(e.index);else if(A(e)){let t=le(e);d(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),d(!Vu(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(u=>u.toString());let t=[],n=null,r=null;this._columns.forEach(u=>{L(r)&&(n=u,r=e[u].length),d(e[u].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${u}" points to an array containing ${e[u].length} items.`),r=e[u].length;let s=e[u];t.push(s)}),this._values=rr(t);let o=le(this.values);this._index=Ge(0,o[0]).map(u=>"row"+Bo(u,(o[0]-1).toString().length))}}get shape(){return le(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new Ue(hn(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return SO(this,e,t)}getSubsetByNames(e,t){return TO(Ue,wt,this,e,t)}getSubsetByIndices(e,t){return _O(this,e,t)}getDummies(e){return Yd(Ue,this,e)}oneHotEncode(e){return Yd(Ue,this,e)}transpose(){let e=new Ue(rr(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return IO(this,e)}copy(){return vO(Ue,this)}assign(e,t){return bO(Ue,wt,this,e,t)}apply(e,t){return yO(Ue,wt,this,e,t)}dropMissing(e,t,n){return wO(Ue,wt,this,e,t,n)}dropNaN(e,t,n){return EO(Ue,this,e,t,n)}drop(e,t){return NO(Ue,wt,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return kO(this,e)}toObject(){return JO(this)}toJSONString(e){return Zd(this,e)}saveAsJSON(e,t){return YO(this,e,t)}print(){return AO(Ue,wt,this)}sort(e,t){return BO(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return DO(Ue,wt,this,e,t)}shuffle(e){return MO(this,e)}append(e,t){return qd(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},wt=XO(Ue);function Gi(e,t){return Ut(e,{shouldDropNaNs:t}).max}function De(e){return d(et(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,o=[],u=[],s=Object.keys(arguments).filter(i=>{let a=arguments[i];return A(a)?!0:Q(a)?(n=!0,o.push(a),!0):ce(a)?(r=!0,u.push(a),!0):!1}).map(i=>arguments[i]);if(s.slice(0,-1).forEach((i,a)=>{d($n(A(i)?le(i):i.shape,A(s[a+1])?le(s[a+1]):s[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let i=Gi(s.map(l=>l.length?l.length:l.values.length)),a=Ge(0,i).map(l=>{let c=Object.keys(arguments).map(f=>A(arguments[f])?arguments[f][l]:Q(arguments[f])||ce(arguments[f])?arguments[f].values[l]:arguments[f]);return t(...c)});if(r)try{if(u.length===1&&$n(le(u[0]),le(a))){let l=new Ue(a);return l.index=u[0].index.slice(),l.columns=u[0].columns.slice(),l}else return new Ue(a)}catch{return a}if(n)try{if(o.length===1&&o[0].length===a.length){let l=new wt(a);return l.name=o[0].name,l.index=o[0].index.slice(),l}else return new wt(a)}catch{return a}return a}else return e(...arguments)}}function xO(e){try{return I(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var Ec=De(xO);function eF(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!I(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Li=De(eF);function tF(e,t){try{return t(e)}catch{return NaN}}var qi=De(tF);function nF(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var rF=De(nF);function oF(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var uF=De(oF);function sF(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var iF=De(sF);function cc(e,t){if(ce(e)){let n=cc(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(Q(e)){let n=cc(e.values,t);return e.index[n]}d(A(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=Po(e,Gi(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function xd(e,t){return Ut(e,{shouldDropNaNs:t}).min}function fc(e,t){if(ce(e)){let n=fc(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(Q(e)){let n=fc(e.values,t);return e.index[n]}d(A(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=Po(e,xd(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function $t(e,t){if(ce(e)||Q(e))return e.apply(n=>$t(n,t));if(A(e))return e.map(n=>$t(n,t));if(t==="null")return null;if(t==="number"){if(L(e))return NaN;let n=$t(e,"boolean");if(jr(n))return n?1:0;try{JSON.parse(e)}catch{let u=$t(e,"date");if(nr(u))return u.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=$t(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return $t(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt($t(e,"int"));if(t==="boolean"){if(jr(e))return e;if(I(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(nr(e))return e;if(L(e))return null;let n=parseFloat(e);if(!isNaN(n)){let o=new Date(e);return nr(o)?o:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Jn(e))return e;let n=$t(e,"boolean");if(jr(n))return null;try{let o=$t(e,"number");if(I(o))return JSON.parse(e),null}catch{}let r=$t(e,"date");if(r)return r;try{let o=JSON.parse(e);return A(o)?o.map(u=>$t(u,t)):o}catch{return null}}if(t==="string")return L(e)?$n(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function aF(e){try{return I(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var lF=De(aF);function cF(e,t){try{if(!I(e))return NaN;if(typeof e=="bigint")return e;if(L(t))t=1e-10;else if(!I(t))return NaN;return Ec(e)<t?0:e}catch{return NaN}}var fF=De(cF);function hc(e){if(ce(e)||Q(e)){let t=e.copy();return t.values=hc(t.values),t}if(A(e))return e.map(t=>hc(t));try{let t=JSON.parse(e);return I(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var Kt=De(hc);function eg(e,t,n){try{return I(e)?I(t)?I(n)?typeof e=="bigint"?BigInt(eg(Kt(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var hF=De(eg);function Vi(e,t){function*n(r,o){if(o>r.length)yield r;else if(o<=0)yield[];else if(r.length<2)yield r;else for(let u=0;u<r.length;u++){let s=r[u],i=r.slice(u+1);if(!(i.length<o-1)&&o-1>=0)for(let a of Vi(i,o-1))yield[s].concat(a)}}return ce(e)||Q(e)?Vi(e.values,t):(d(A(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),d(I(t)&&Kt(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(mn(e),t))}function tg(e,t){let n=[];for(let r of Vi(e,t))n.push(r.slice());return n}function ng(){let e=Object.values(arguments).map(n=>ce(n)||Q(n)?Ht(n.values):(d(A(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),Ht(n)));return Ht(e).filter(n=>e.every(r=>r.findIndex(o=>$n(o,n))>-1))}var Ju=class{constructor(e){d(L(e)||e===Ju.DROP_NAN_MODE||e===Ju.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=L(e)?Ju.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(A(t)){let n=le(t);if(n.length===1)t=new wt(t);else if(n.length===2)t=new Ue(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}d(ce(t)||Q(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===Ju.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=ng(...e),this}transform(){d(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(A(t)){let n=le(t);if(n.length===1)return new wt(t).get(this.index).values;if(n.length===2)return new Ue(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return d(ce(t)||Q(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Hi=Ju;zd(Hi,"DROP_NAN_MODE","DROP_NAN_MODE");zd(Hi,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Ku(e,t,n,r){if(Q(e))return Ku(e.values,t,n,r);if(Q(t))return Ku(e,t.values,n,r);if(d(A(e)&&A(t)&&le(e).length===1&&le(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),d(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Ku(...new Hi().fitAndTransform(e,t),!1,r);try{let o=Ut(e,{stdev:r}),u=Ut(t,{stdev:r}),s=Number(o.mean),i=Number(u.mean);if(!I(s)||!I(i))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let f=e[c],h=t[c];if(!I(f))return NaN;if(!I(h))return NaN;typeof f=="bigint"&&(f=Number(f)),typeof h=="bigint"&&(h=Number(h)),l+=(f-s)*(h-i)}return r?[l/e.length,o,u]:l/e.length}catch{return NaN}}function mc(e,t,n){if(Q(e))return mc(e.values,t,n);if(Q(t))return mc(e,t.values,n);d(A(e)&&A(t)&&le(e).length===1&&le(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),d(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,u,s]=Ku(e,t,n,!0),i=u.stdev*s.stdev;return o/i}catch{return NaN}}function mF(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var dF=De(mF),gF=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function dc(e,t){if(ce(e)||Q(e))return dc(e.values,t);if(ce(t)||Q(t))return dc(e,t.values);d(A(e)&&A(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=Ht(e),r=Ht(t),o=[];return n.forEach(u=>{r.findIndex(s=>$n(s,u))<0&&o.push(u)}),o}function rg(e,t){try{if(!I(e))return NaN;if(!I(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=rg(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var Dc=De(rg);function og(e){try{if(!I(e))return NaN;if(typeof e=="bigint"){let t=og(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var ug=De(og);function pF(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!I(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var sg=De(pF);function Yo(){return sg(...arguments)}function ig(e,t){return Li(e,Yo(t,-1))}function Sc(e,t){return Ut(e,{shouldDropNaNs:t}).sum}function gc(e,t){if(I(e)&&I(t))return Ec(e-t);if(ce(e)||Q(e))return gc(e.values,t);if(ce(t)||Q(t))return gc(e,t.values);A(e)&&A(t)&&d($n(le(e),le(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return ug(Sc(Dc(ig(e,t),2)))}catch{return NaN}}function yF(e,t){return Yo(e,Dc(t,-1))}function tr(e,t){if(ce(e)){let o=tr(e.values,t);if(le(o).length===1){let u=new wt(o);return u.name=Q(t)?t.name:u.name,u.index=e.index.slice(),u}else{let u=new Ue(o);return u.index=e.index.slice(),ce(t)&&(u.columns=t.columns.slice()),u}}if(ce(t)){let o=tr(e,t.values);if(le(o).length===1){let u=new wt(o);return u.name=Q(e)?e.name:u.name,u.index=t.columns.slice(),u}else{let u=new Ue(o);return u.columns=t.columns.slice(),u}}if(Q(e))return tr(e.values,t);if(Q(t))return tr(e,t.values);d(A(e)&&A(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=le(e),r=le(t);if(d(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),d(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Sc(Yo(e,t));if(n.length===1&&r.length===2)return rr(t).map(o=>tr(e,o));if(n.length===2&&r.length===1)return e.map(o=>tr(o,t));if(n.length===2&&r.length===2){let o=rr(t),u=[];for(let s=0;s<e.length;s++){let i=[];for(let a=0;a<o.length;a++)i.push(tr(e[s],o[a]));u.push(i)}return u}}function Oc(e){if(ce(e)||Q(e))return e.dropMissing(...Object.values(arguments).slice(1));d(A(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Oc(n))}catch{L(n)||t.push(n)}}),t}function ki(e,t){if(ce(e)||Q(e))return ki(e.values,t);if(ce(t)||Q(t))return ki(e,t.values);d(A(e)&&A(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),d($n(le(e),le(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=ki(e[o],t[o]);n.push(u),r.push(s)}catch{!L(e[o])&&!L(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function Yi(e,t){if(ce(e)||Q(e))return Yi(e.values,t);if(ce(t)||Q(t))return Yi(e,t.values);d(A(e)&&A(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),d($n(le(e),le(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let o=0;o<e.length;o++)try{let[u,s]=Yi(e[o],t[o]);n.push(u),r.push(s)}catch{I(e[o])&&I(t[o])&&(n.push(e[o]),r.push(t[o]))}return[n,r]}function bF(e){return Oc(e)}function zi(e,t){if(ce(e)||Q(e))return zi(e.values,t);d(A(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),d(et(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(A(n)){if(!zi(n,t))return!1}else if(!t(n))return!1;return!0}function vF(e){try{if(!I(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var NF=De(vF);function pc(e){try{return typeof e=="bigint"?BigInt(pc(Kt(e))):e!==Kt(e)?NaN:e<=1?1:e*pc(e-1)}catch{return NaN}}var wF=De(pc);function yc(e,t){if(ce(e)||Q(e))return yc(e.values,t);if(d(Jn(e)||A(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!et(t)){let o=t;t=u=>u===o}function n(o,u,s){if(s=s||[],s.indexOf(o)>-1)return null;if(Jn(o)){s.push(o);let i=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let a=0;a<i.length;a++){let l=i[a],c=o[l];if(u(c))return c;let f=n(c,u,s);if(f)return f}}else if(A(o)){s.push(o);for(let i=0;i<o.length;i++){let a=o[i];if(u(a))return a;let l=n(a,u,s);if(l)return l}}else if(u(o))return o;return null}function r(o){try{return t(o)}catch{return!1}}return n(e,r)}function bc(e,t){if(ce(e)||Q(e))return bc(e.values,t);if(d(Jn(e)||A(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!et(t)){let u=t;t=s=>s===u}function n(u,s,i){if(i=i||[],i.indexOf(u)>-1)return null;if(Jn(u)){i.push(u);let a=Object.keys(u).concat(Object.getOwnPropertySymbols(u)),l=[];for(let c=0;c<a.length;c++){let f=a[c],h=u[f],m=!1;s(h)&&(l.push(h),m=!0);let w=n(h,s,i);w&&w.length>0&&w.slice(m?1:0).forEach(E=>l.push(E))}return l}else if(A(u)){i.push(u);let a=[];for(let l=0;l<u.length;l++){let c=u[l],f=!1;s(c)&&(a.push(c),f=!0);let h=n(c,s,i);h&&h.length>0&&h.slice(f?1:0).forEach(m=>a.push(m))}return a}else if(s(u))return[u];return null}function r(u){try{return t(u)}catch{return!1}}let o=n(e,r);return o&&o.length>0?o:null}function EF(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return I(t)?t:NaN}catch{return NaN}}var DF=De(EF);function SF(e){try{return I(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var OF=De(SF);function Fc(e){I(e)&&(e=[e]);let t=[],n=Wu(e);for(let r=0;r<n;r++)t.push(0);return Uu(t,e)}function FF(e){typeof e=="bigint"&&(e=Kt(e)),d(!L(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),d(I(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),d(Kt(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),d(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Fc([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var _F=["true","false","yes","no"],TF=["null","none","nan","na","n/a","","undefined"];function Ri(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=Kt(e.value)===e.value:e.isInteger=zi(e.values,t=>I(t)?Kt(t)===t:!0)),e}function Ji(e){if(ce(e)){let u=e.copy(),s=Ji(e.values);return u.values=s.values,Ri({type:s.type,values:u})}if(Q(e)){let u=e.copy(),s=Ji(e.values);return u.values=s.values,Ri({type:s.type,values:u})}if(!A(e)){let u=Ji([e]);return u.value=u.values[0],delete u.values,Ri(u)}d(A(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=mn(e).map(u=>{if(u===void 0)return"null";try{if(typeof u=="object"){let a=new Date(u.getTime());if(nr(a))return"date"}}catch{}Ee(u)||(typeof u=="bigint"?u=u.toString()+"n":u=JSON.stringify(u));let i=u.toLowerCase().trim();if(TF.indexOf(i)>-1)return"null";if(_F.indexOf(i)>-1)return"boolean";try{if(u.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(u);return I(a)?"number":typeof a=="object"?A(a)?"string":"object":"string"}catch{let l=new Date(u);return nr(l)?"date":"string"}}),n=Ki(t),o=n.values.toSorted((u,s)=>n.get(s)-n.get(u))[0];return Ri({type:o,values:qi(e,u=>$t(u,o))})}function $i(e){if(ce(e)){let n=e.copy();return n.values=$i(n.values),n}d(A(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=le(e);if(d(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),d(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),d(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){d(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],o=e[1][0],u=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof o=="bigint"&&(o=Number(o)),typeof u=="bigint"&&(u=Number(u));let s=n*u-r*o;d(s!==0,"This matrix cannot be inverted!");let i=[[u,-r],[-o,n]];return Yo(i,1/s)}else if(t[0]>1){let n=(r,o)=>I(r)||I(o)?Yo(r,o):tr(r,o);for(let r=1;r<t[0]-1;r++)try{let o=e.slice(0,r).map(E=>E.slice(0,r)),u=e.slice(0,r).map(E=>E.slice(r,t[0])),s=e.slice(r,t[0]).map(E=>E.slice(0,r)),i=e.slice(r,t[0]).map(E=>E.slice(r,t[0])),a=$i(o),l=$i(Li(i,n(-1,n(n(s,a),u)))),c=Li(a,n(n(n(n(a,u),l),s),a)),f=n(-1,n(n(a,u),l)),h=n(-1,n(n(l,s),a)),m=l;return c.map((E,ge)=>E.concat(f[ge])).concat(h.map((E,ge)=>E.concat(m[ge])))}catch{}d(!1,"This matrix cannot be inverted!")}}var AF=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function ag(e,t,n){try{if(!I(e))return NaN;if(!I(t))return NaN;if(!I(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=ag(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var IF=De(ag);function lg(e,t){try{if(t=L(t)?Math.E:t,!I(e))return NaN;if(!I(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=lg(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var jF=De(lg);function CF(e,t){return Ut(e,{shouldDropNaNs:t}).mean}function MF(e,t){return Ut(e,{shouldDropNaNs:t,median:!0}).median}function cg(e,t){try{if(!I(e))return NaN;if(!I(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=cg(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var BF=De(cg);function PF(e,t){return Ut(e,{shouldDropNaNs:t,mode:!0}).mode}function Ld(){let e=Mr(),t=Mr();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function RF(e){return L(e)?Ld():qi(hn(e),Ld)}function kF(e){return qi(hn(e),()=>1)}function _c(e,t){function*n(r,o){if(o=o||r.length,r.length===1){yield[r];return}for(let u of tg(r,o)){if(!u.slice)continue;let s=Fc(u.length);yield u;let i=1;for(;i<u.length;)if(s[i]<i){if(i%2===0){let a=u[0];u[0]=u[i],u[i]=a}else{let a=u[s[i]];u[s[i]]=u[i],u[i]=a}yield u,s[i]+=1,i=1}else s[i]=0,i+=1}}return ce(e)||Q(e)?_c(e.values,t):(d(A(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),L(t)&&(t=e.length),d(I(t)&&Kt(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(mn(e),t))}function YF(e,t){let n=[];for(let r of _c(e,t))n.push(r.slice());return n}function JF(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(A(t))if(Vu(t))console.log(t);else{let n=le(t);n.length===1?new wt(t).print():n.length==2?new Ue(t).print():console.log(t)}else ce(t)||Q(t)?t.print():console.log(t)})}var $F=De((e,t,n,r,o)=>{try{let u=!1;for(let l of[e,t,n,r,o]){if(!I(l))return NaN;typeof l=="bigint"&&(u=!0)}u&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),o=Number(o));let s=(o-r)*(e-t),i=n-t;if(i===0)return NaN;let a=s/i+r;if(u)try{return BigInt(a)}catch{}return a}catch{return NaN}});function KF(e,t,n,r,o){if(A(e)&&L(r)&&L(o)){r=t,o=n;let u=Ut(e);t=u.min,n=u.max}return $F(e,t,n,r,o)}function UF(e){try{return I(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var LF=De(UF);function fg(e){try{return I(e)?typeof e=="bigint"?BigInt(fg(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var VF=De(fg);function zF(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var WF=De(zF);function vc(e,t){if(ce(e)||Q(e))return vc(e.values,t);d(A(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),d(et(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(A(n)){if(vc(n,t))return!0}else if(t(n))return!0;return!1}function hg(e,t){return Ut(e,{shouldDropNaNs:t,stdev:!0}).stdev}function GF(e){return hg(e)}function qF(e){try{return I(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var HF=De(qF);function Vd(e,t){d(et(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function QF(e,t){d(et(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function ZF(){return Ht([...arguments].map(e=>A(e)?e:ce(e)||Q(e)?e.values:[e]))}function XF(e,t){return Ut(e,{shouldDropNaNs:t,variance:!0}).variance}function xF(){let e=[],t=Object.values(arguments).map(n=>((ce(n)||Q(n))&&(n=n.values),d(A(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return Ge(0,Gi(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(o=>{let u=o[n];r.push(L(u)?void 0:u)}),e.push(r)}),e}var $u={abs:Ec,add:Li,apply:qi,arccos:rF,arcsin:uF,arctan:iF,argmax:cc,argmin:fc,assert:d,cast:$t,ceil:lF,chop:fF,clamp:hF,combinations:tg,combinationsIterator:Vi,copy:it,correl:mc,cos:dF,count:Ki,covariance:Ku,DataFrame:Ue,dataTypes:gF,decycle:Ro,diff:dc,distance:gc,divide:yF,dot:tr,dropMissing:Oc,dropMissingPairwise:ki,dropNaN:Nc,dropNaNPairwise:Yi,dropUndefined:bF,every:zi,exp:NF,factorial:wF,find:yc,findAll:bc,flatten:mn,float:DF,floor:OF,identity:FF,IndexMatcher:Hi,indexOf:Po,inferType:Ji,int:Kt,intersect:ng,inverse:$i,isArray:A,isBoolean:jr,isBrowser:AF,isDataFrame:ce,isDate:nr,isEqual:$n,isFunction:et,isJagged:Vu,isNested:Wi,isNumber:I,isObject:Jn,isSeries:Q,isString:Ee,isUndefined:L,lerp:IF,log:jF,MathError:dr,max:Gi,mean:CF,median:MF,min:xd,mod:BF,mode:PF,multiply:sg,ndarray:hn,normal:RF,ones:kF,permutations:YF,permutationsIterator:_c,pow:Dc,print:JF,product:Wu,random:Mr,range:Ge,remap:KF,reshape:Uu,reverse:Yn,round:LF,scale:Yo,seed:wc,Series:wt,set:Ht,shape:le,shuffle:Ui,sign:VF,sin:WF,some:vc,sort:Cr,sqrt:ug,stats:Ut,std:hg,stdev:GF,subtract:ig,sum:Sc,tan:HF,timeAsync:QF,timeSync:Vd,time:Vd,transpose:rr,union:ZF,variance:XF,vectorize:De,zeros:Fc,zip:xF,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new $u.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys($u).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:$u[t]})}catch{e[t]=$u[t]}})}};typeof window<"u"&&(window.JSMathTools=$u);function Tc(e,t,n){arguments.length===2&&(I(arguments[1])?n=null:(n=t,t=null)),d(I(e)&&Kt(e)===e,"`keyLength` must be an integer!"),t&&(d(I(t)&&Kt(t)===t,"`keySeed` must be an integer!"),wc(t)),n&&d(Ee(n),"`charset` must be a string!");let r="";n=n||"abcdefg1234567890";for(let o=0;o<e;o++)r+=n[Kt(Mr()*n.length)];return r}typeof window<"u"&&(window.makeKey=Tc);var Gu=class extends Map{constructor(t){super(),t=t||{},Object.keys(t).forEach(n=>{this.set(n,t[n])})}delete(t){if(typeof t!="string")throw new Error("The `delete` method of a `WordCountMap` instance can only accept keys that are strings!");return super.delete(t)}get(t){if(typeof t!="string")throw new Error("The `get` method of a `WordCountMap` instance can only accept keys that are strings!");return super.get(t)}has(t){if(typeof t!="string")throw new Error("The `has` method of a `WordCountMap` instance can only accept keys that are strings!");return super.has(t)}set(t,n){if(typeof t!="string")throw new Error("The `set` method of a `WordCountMap` instance can only accept keys that are strings!");if(!vr(n))throw new Error("The `set` method of a `WordCountMap` instance can only accept values that are whole numbers (i.e., non-negative integers)!");return super.set(t,n)}stringify(){return JSON.stringify(this.toObject(),...arguments)}toObject(){let t={};return Array.from(this.keys()).forEach(n=>{t[n]=this.get(n)}),t}};var mg=Or("WholeNumber",vr),Br=class{constructor(t){t=t||{},ze(this,"cleaned","string"),this.cleaned=t.cleaned||"",ze(this,"hasBeenIndexed","boolean"),this.hasBeenIndexed=t.hasBeenIndexed||!1,ze(this,"id","string"),this.id=t.id||"",ze(this,"maxNgramLength",mg),this.maxNgramLength=typeof t.maxNgramLength>"u"?1/0:t.maxNgramLength,ze(this,"name","string"),this.name=t.name||Tc(32),ze(this,"ngrams",Ot),this.ngrams=new Ot(t.ngrams||[]),ze(this,"raw","string"),this.raw=t.raw||"",ze(this,"totalWordCount",mg),this.totalWordCount=t.totalWordCount||0,ze(this,"wordCounts",Gu),this.wordCounts=new Gu(t.wordCounts||{}),ze(this,"words",Ot),this.words=new Ot(t.words||[])}getWordCount(t){if(!this.hasBeenIndexed)throw new Error(`The document "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);return this.wordCounts.get(t)||0}async index(t){this.id=await ac(this.raw),this.cleaned=pa(this.raw);let n=this.cleaned.split(" ");this.totalWordCount=n.length;let r=St(n);this.words=new Ot(r),n.forEach((u,s)=>{let i=this.wordCounts.get(u);typeof i>"u"?this.wordCounts.set(u,1):this.wordCounts.set(u,i+1),t&&t(.5*s/n.length)});let o=Math.min(r.length,this.maxNgramLength);for(let u=2;u<=o;u++)for(let s=0;s<r.length-u;s++){let i=r.slice(s,s+u).join(" ");this.ngrams.add(i),t&&t(.5+.5*((u+s/(r.length-u))/o))}return t&&t(1),this.hasBeenIndexed=!0,this}stringify(){return JSON.stringify(this.toObject(),...arguments)}toObject(){return{cleaned:this.cleaned,hasBeenIndexed:this.hasBeenIndexed,id:this.id,maxNgramLength:this.maxNgramLength,name:this.name,ngrams:this.ngrams.toSortedArray(),raw:this.raw,totalWordCount:this.totalWordCount,wordCounts:this.wordCounts.toObject(),words:this.words.toSortedArray()}}};var e_=Or("WholeNumber",vr),Ft={TF_BINARY:"TF_BINARY",TF_RAW_COUNT:"TF_RAW_COUNT",TF_TERM_FREQUENCY:"TF_TERM_FREQUENCY",TF_LOG_NORMALIZATION:"TF_LOG_NORMALIZATION",TF_DOUBLE_NORMALIZATION_K:"TF_DOUBLE_NORMALIZATION_K",IDF_UNARY:"IDF_UNARY",IDF_INVERSE_DOCUMENT_FREQUENCY:"IDF_INVERSE_DOCUMENT_FREQUENCY",IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH:"IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH",IDF_INVERSE_DOCUMENT_FREQUENCY_MAX:"IDF_INVERSE_DOCUMENT_FREQUENCY_MAX",IDF_PROBABILISTIC_INVERSE_DOCUMENT_FREQUENCY:"IDF_PROBABILISTIC_INVERSE_DOCUMENT_FREQUENCY"},dg=Or("Scoring",e=>!!Ft[e]),t_=Or("ZeroToOneNumber",e=>typeof e=="number"&&!isNaN(e)&&e>=0&&e<=1),Qi=class{static Scoring=Ft;constructor(t){t=t||{};let n=oi(Br).from(t.docs?t.docs.map(r=>new Br(r)):[]);ze(this,"docs",n.constructor),this.docs=n,ze(this,"hasBeenIndexed","boolean"),this.hasBeenIndexed=t.hasBeenIndexed||!1,ze(this,"maxNgramLength",e_),this.maxNgramLength=typeof t.maxNgramLength>"u"?0:t.maxNgramLength,ze(this,"name","string"),this.name=t.name||"Untitled corpus",ze(this,"ngrams",Ot),this.ngrams=new Ot(t.ngrams||[]),ze(this,"words",Ot),this.words=new Ot(t.words||[]),ze(this,"tfScoringMethod",dg),this.tfScoringMethod=t.tfScoringMethod||Ft.TF_LOG_NORMALIZATION,ze(this,"tfScoringDoubleNormalizationK",t_),this.tfScoringDoubleNormalizationK=typeof t.tfScoringDoubleNormalizationK>"u"?.5:t.tfScoringDoubleNormalizationK,ze(this,"idfScoringMethod",dg),this.idfScoringMethod=t.idfScoringMethod||Ft.IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH}computeDocumentSimilarity(t,n){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);let r=[],o=[];return this.words.forEach(u=>{r.push(this.computeTFIDFScore(u,t)),o.push(this.computeTFIDFScore(u,n))}),Ra(r,o)}computeIDFScore(t){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);if(this.idfScoringMethod===Ft.IDF_UNARY)return 1;let n=this.docs.filter(r=>r.getWordCount(t)>0).length;if(this.idfScoringMethod===Ft.IDF_INVERSE_DOCUMENT_FREQUENCY)return Math.log(this.docs.length/(n+1));if(this.idfScoringMethod===Ft.IDF_INVERSE_DOCUMENT_FREQUENCY_SMOOTH)return Math.log(this.docs.length/(n+1))+1;if(this.idfScoringMethod===Ft.IDF_INVERSE_DOCUMENT_FREQUENCY_MAX){let r=0;return this.words.toArray().forEach(o=>{let u=this.docs.filter(s=>s.getWordCount(o)>0).length;u>r&&(r=u)}),Math.log(r/(n+1))}if(this.idfScoringMethod===Ft.IDF_PROBABILISTIC_INVERSE_DOCUMENT_FREQUENCY)return Math.log((this.docs.length-n+1)/(n+1))}computeTFIDFScore(t,n){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);return this.computeTFScore(t,n)*this.computeIDFScore(t)}computeTFScore(t,n){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);if(this.tfScoringMethod===Ft.TF_BINARY)return n.getWordCount(t)>0?1:0;if(this.tfScoringMethod===Ft.TF_RAW_COUNT)return n.getWordCount(t);if(this.tfScoringMethod===Ft.TF_TERM_FREQUENCY)return n.getWordCount(t)/n.totalWordCount;if(this.tfScoringMethod===Ft.TF_LOG_NORMALIZATION)return Math.log(1+n.getWordCount(t));if(this.tfScoringMethod===Ft.TF_DOUBLE_NORMALIZATION_K){let r=0;return n.words.forEach(o=>{let u=n.getWordCount(o);u>r&&(r=u)}),this.tfScoringDoubleNormalizationK+(1-this.tfScoringDoubleNormalizationK)*n.getWordCount(t)/r}}getWordCounts(t){if(!this.hasBeenIndexed)throw new Error(`The corpus "${this.name}" has not yet been indexed! Please invoke its \`index\` method before doing anything else with it.`);return this.docs.map(n=>({doc:{name:n.name,id:n.id},count:n.getWordCount(t)}))}async index(t){for(let n=0;n<this.docs.length;n++)await this.docs[n].index(t?o=>t((n+o)/this.docs.length):null);return this.hasBeenIndexed=!0,this}stringify(){return JSON.stringify(this.toObject(),...arguments)}toObject(){return{docs:this.docs.map(t=>t.toObject(...arguments)),hasBeenIndexed:this.hasBeenIndexed,idfScoringMethod:this.idfScoringMethod,maxNgramLength:this.maxNgramLength,name:this.name,ngrams:this.ngrams.toSortedArray(),tfScoringDoubleNormalizationK:this.tfScoringDoubleNormalizationK,tfScoringMethod:this.tfScoringMethod,words:this.words.toSortedArray()}}};typeof window<"u"&&(window.JSNLPTools={Corpus:Qi,Document:Br});})();
