(()=>{var Yr=Object.defineProperty;var $r=(t,e)=>{for(var r in e)Yr(t,r,{get:e[r],enumerable:!0})};var jt={};$r(jt,{IndexMatcher:()=>Ze,KMeans:()=>Rr,MathError:()=>H,OutlierMitigator:()=>tt,StandardScaler:()=>rt,cohensd:()=>Le,convertToNumerical:()=>St,diagonalize:()=>wt,getCorrelationMatrix:()=>He,getHighlyCorrelatedColumns:()=>Cr,getMagnitude:()=>Ve,getOneHotEncodings:()=>Je,getPValueMatrix:()=>Xe,getPercentages:()=>kr,hunterChainSort:()=>Dt,isBinary:()=>It,isCorrelationMatrix:()=>Br,isWholeNumber:()=>L,normalize:()=>qe,orthonormalize:()=>Ft,pValue:()=>Te,project:()=>Ae,rScore:()=>zr,rSquared:()=>Be,standardize:()=>Jr,trainTestSplit:()=>Vr});function p(t){return typeof t=="number"&&!isNaN(t)||typeof t=="bigint"}var ot=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);var H=class extends Error{constructor(e){ot()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function a(t,e){if(!t)throw new H(e)}var it=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function h(t){return t===null||typeof t>"u"}var Kr=it.map(t=>t.name);function f(t){try{return t instanceof Array?!0:h(t.constructor)?!1:it.indexOf(t.constructor)>-1||Kr.indexOf(t.constructor.name)>-1}catch{return!1}}function d(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function D(t){return typeof t=="function"}function X(t){return typeof t=="object"&&!h(t)&&!f(t)}function y(t){try{return!!t._symbol&&t._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function fe(t,e){if(d(t)){let i=fe(t.values,e);return i.length>0&&p(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i.length>1&&p(i[1])&&i[1]>=0&&i[1]<t.columns.length&&(i[1]=t.columns[i[1]]),i}if(y(t)){let i=fe(t.values,e);return i.length>0&&p(i[0])&&i[0]>=0&&i[0]<t.index.length&&(i[0]=t.index[i[0]]),i}if(a(X(t)||f(t),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!D(e)){let i=e;e=s=>s===i}function r(i,s,u){if(u=u||[],u.indexOf(i)>-1)return null;if(X(i)){u.push(i);let m=Object.keys(i).concat(Object.getOwnPropertySymbols(i));for(let c=0;c<m.length;c++){let l=m[c],g=i[l];if(s(g))return[l];let N=r(g,s,u);if(N&&N.length>0)return[l].concat(N)}}else if(f(i)){u.push(i);for(let m=0;m<i.length;m++){let c=i[m];if(s(c))return[m];let l=r(c,s,u);if(l&&l.length>0)return[m].concat(l)}}else if(s(i))return[];return null}function n(i){try{return e(i)}catch{return!1}}let o=r(t,n);return o&&o.length>0?o:null}function j(t){function e(r){if(typeof r=="object"){if(r===null)return null;if(f(r))return r instanceof Array?r.map(o=>j(o)):r.slice();if(y(r)){let o=r.copy();return o.values=j(o.values),o}if(d(r)){let o=r.copy();return o.values=j(r.values),o}if(r instanceof Date)return new Date(r.getTime());r=se(r);let n={};return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(o=>{n[o]=j(r[o])}),n}else return r}return e(se(t))}function se(t){function e(o,i,s){if(i=i||[],s=s||"",i.indexOf(o)>-1){let u=s.split("/").slice(s.startsWith("/")?1:0);if(u.some((c,l)=>{let g=u.slice(0,u.length-l-1),N=r;return g.forEach(O=>{N=N[O]}),N===o}))return`<reference to "${r===o?"/":"/"+fe(r,o).join("/")}">`}return typeof o=="object"?o===null?null:(i.push(o),f(o)?typeof o.constructor<"u"&&o.constructor.name!=="Array"?o.slice():o.map((u,m)=>e(u,i,s+"/"+m)):(Object.keys(o).concat(Object.getOwnPropertySymbols(o)).forEach(u=>{o[u]=e(o[u],i,s+"/"+u.toString())}),o)):o}let r=t,n=e(r);if(d(t)){let o=t.copy();o._values=n.values,o._columns=n.columns,o._index=n.index,n=o}if(y(t)){let o=t.copy();o.name=n.name,o._values=n.values,o._index=n.index,n=o}return n}function R(t){return t instanceof Date&&t.toString()!=="Invalid Date"}var Et=["number","int","float","bigint"];function M(t,e){function r(n,o){let i=typeof n,s=typeof o;if(i!==s&&!Et.includes(i)&&!Et.includes(s))return!1;if(i==="undefined"&&s==="undefined")return!0;if(i==="boolean"||i==="symbol")return n===o;if(i==="number"||i==="bigint")try{let u=n.toString(),m=o.toString();return u===m}catch{return!1}if(i==="string"||i==="function")return n===o;if(i==="object"){if(n===null||o===null)return n===null&&o===null;{if(R(n))return R(o)?n.getTime()===o.getTime():!1;if(R(o))return!1;if(n instanceof RegExp&&o instanceof RegExp)return n.toString()===o.toString();if(f(n)!==f(o))return!1;let u=Object.keys(n).concat(Object.getOwnPropertySymbols(n)),m=Object.keys(o).concat(Object.getOwnPropertySymbols(o));if(u.length!==m.length)return!1;for(let c=0;c<u.length;c++){let l=u[c];if(!r(n[l],o[l]))return!1}return!0}}}try{return r(t,e)}catch{return r(se(t),se(e))}}function Ue(t){let e="abcdefg1234567890",r="";for(;r.length<t;)r+=e[Math.floor(Math.random()*e.length)];return r}var Gr=Ue(16),Wr=Ue(16),Lr=Ue(16),Hr=Ue(16),Xr=Ue(16),Ye=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let r of e)f(r)?this.count(r):this.increment(r);return this}delete(e){let r=this.getStandardizedKey(e);return delete this.countsDict[r],delete this.valuesDict[r],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Gr:h(e)?Wr:D(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Xr:e===1/0?Lr:e===-1/0?Hr:typeof e=="bigint"?e.toString():d(e)?e.toJSONString():y(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!h(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,r){let n=this.getStandardizedKey(e);return this.countsDict[n]=r,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(r=>{e[r]=this.get(r)}),e}};function F(t){if(d(t)||y(t))return F(t.values);a(f(t),"The `flatten` function only works on arrays, Series, and DataFrames!");function e(r){let n=[];return r.forEach(o=>{f(o)?n=n.concat(e(o)):n.push(o)}),n}return e(t)}function T(t,e){e=e||{};let r=new Ye,n={},o=F(t),i=[],s=-1/0,u=1/0,m=!1,c=0;for(let g of o){if(typeof g=="bigint"&&(m=!0),!e.shouldDropNaNs||p(g))try{g>s&&(s=g),g<u&&(u=g),c+=Number(g),i.push(g)}catch{s=NaN,u=NaN,c=NaN}r.increment(g)}let l=c/i.length;if(n.counts=r,n.max=s,n.mean=l,n.min=u,n.n=o.length,n.sum=c,isNaN(n.mean)&&(n.max=NaN,n.min=NaN),e.shouldDropNaNs&&(n.nWithoutNaNs=i.length),e.mode){let g=Array.from(r.values.map(I=>[I,r.get(I)])).toSorted((I,G)=>G[1]-I[1]),N=g[0][1],O=[];for(let I of g)if(I[1]==N)O.push(I[0]);else break;n.mode=O.toSorted()}if(e.median)if(isNaN(l))n.median=NaN;else{let g=i.toSorted((O,I)=>Number(O)-Number(I)),N=Math.floor(g.length/2);if(g.length%2===0){let O=g[N-1],I=g[N];if(n.median=(Number(O)+Number(I))/2,m&&typeof O=="bigint"&&typeof I=="bigint")try{n.median=BigInt(n.median)}catch{}}else n.median=g[N]}if(e.stdev||e.variance){let g=0;for(let O of i)g+=Math.pow(Number(O)-l,2);g/=i.length;let N=Math.sqrt(g);n.stdev=N,n.variance=g}if(m){try{n.sum=BigInt(n.sum)}catch{}try{n.mean=BigInt(n.mean)}catch{}e.mode&&(n.mode=n.mode.map(g=>{try{return BigInt(g)}catch{return g}}))}return n}function ae(t,e){let{counts:r}=T(t);return h(e)||(D(e)?r.values.forEach(n=>{e(n)||r.delete(n)}):r.values.forEach(n=>{M(n,e)||r.delete(n)})),r}function st(t){if(d(t)||y(t))return st(t.values);if(f(t)){let e=!1,r=!1,n=null;for(let o of t){if(st(o))return!0;if(f(o)){if(n===null)n=o.length;else if(o.length!==n)return!0;e=!0}else r=!0;if(e&&r)return!0}}return!1}function C(t){return st(se(t))}function De(t){if(d(t)||y(t))return De(t.values);a(f(t),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let e=0;e<t.length;e++)if(f(t[e]))return!0;return!1}var Ie="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function k(t){a(!h(t),Ie),f(t)||(t=[t]),a(!De(t),Ie),a(t.length>0,Ie);let e=t[0];if(typeof e=="bigint"&&(e=Number(e)),a(p(e),Ie),a(e>=0,Ie),a(Math.floor(e)===e,Ie),a(e!==1/0,"We can't create an array containing an infinite number of values!"),t.length===1){let r=[];for(let n=0;n<e;n++)r.push(void 0);return r}else{let r=[];for(let n=0;n<e;n++)r.push(k(t.slice(1)));return r}}function J(t){if(d(t)||y(t)){let r=t.copy();return r.values=J(r.values),r.index=J(r.index),r}a(f(t),"The `reverse` function only works on arrays, Series, and DataFrames!");let e=[];for(let r=t.length-1;r>=0;r--)e.push(t[r]);return e}function w(t,e,r=1){a(!h(t)&&!h(e)&&!h(r),"You must pass two numbers and optionally a step value to the `range` function!"),a(p(t)&&p(e)&&p(r),"You must pass two numbers and optionally a step value to the `range` function!"),a(r>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let n=!1,o=typeof t=="bigint"||typeof e=="bigint"||typeof r=="bigint";if(t=Number(t),e=Number(e),r=Number(r),t>e){n=!0;let s=t;t=e+r,e=s+r}let i=[];for(let s=t;s<e;s+=r)if(o)try{i.push(BigInt(s))}catch{i.push(s)}else i.push(s);return n&&(i=J(i)),i}function Pe(t){let e="abcdefg1234567890",r="";for(;r.length<t;)r+=e[Math.floor(Math.random()*e.length)];return r}var Zr=Pe(256),Qr=Pe(256),en=Pe(256),tn=Pe(256),rn=Pe(256);function B(t){if(d(t)||y(t))return B(t.values);a(f(t),"The `set` function only works on arrays, Series, and DataFrames!");let e=[],r={};return F(t).forEach(n=>{let o=typeof n=="object"&&n===null?Zr:h(n)?Qr:D(n)?n.toString():typeof n=="symbol"?n.toString()+" - "+rn:n===1/0?en:n===-1/0?tn:typeof n=="bigint"?n.toString():d(n)?n.toJSONString():y(n)?JSON.stringify(n.toObject()):JSON.stringify(n);r[o]||e.push(n),r[o]=!0}),e}function Ct(t){if(f(t)){let e=Ct(t[0]);return[t.length].concat(e||[])}else return}function b(t){return d(t)||y(t)?b(t.values):(a(f(t),"The `shape` function only works on arrays, Series, and DataFrames!"),Ct(t))}function at(t,e,r){if(h(r)&&(r=0),a(r===0||r===1||r==="vertical"||r==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),f(e)){a(!C(e),"The array of data you're trying to append to this DataFrame is jagged!");let n=b(e);if(n.length===1)if(r===0){let o=t.copy();o._values.push(e);let i=Math.max(t.shape[1],n[0]);for(o._values.forEach(s=>{for(;s.length<i;)s.push(void 0)});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<i;)o._columns.push("col"+o._columns.length);return o}else{let o=Math.max(t.shape[0],n[0]),i=t.copy();for(w(0,o).forEach(s=>{s>=i._values.length&&i._values.push(k(t.shape[1])),i._values[s].push(e[s])});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<i._values[0].length;)i._columns.push("col"+i._columns.length);return i}else if(n.length===2)if(r===0){let o=Math.max(...e.map(s=>s.length).concat([t.shape[1]])),i=t.copy();for(i._values=i._values.concat(e).map(s=>{for(;s.length<o;)s.push(void 0);return s});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<o;)i._columns.push("col"+i._columns.length);return i}else{let o=Math.max(...e.map(u=>u.length))+t.shape[1],i=Math.max(t.shape[0],n[0]),s=t.copy();for(w(0,i).forEach(u=>{for(u>=s._values.length&&s._values.push(k(t.shape[1])),s._values[u]=s._values[u].concat(e[u]);s._values[u].length<o;)s._values[u].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else throw new H("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(y(e)){let n=at(t,e.values,r);return r===0?n.index[n.index.length-1]=n.index.indexOf(e.name)>-1?e.name+" (2)":e.name:n.columns[n.columns.length-1]=n.columns.indexOf(e.name)>-1?e.name+" (2)":e.name,n}else if(d(e))if(r===0){let n=t.copy(),o=B(n._columns.concat(e._columns)).length;for(n._values.forEach(i=>{for(;i.length<o;)i.push(void 0)}),e.apply(i=>{let s=i.copy(),u=[];n._columns.forEach(m=>{let c=s._index.indexOf(m);c>-1?(u.push(s._values[c]),s._values.splice(c,1),s._index.splice(c,1)):u.push(void 0)}),n._values.push(u.concat(s._values))},1),n._columns=n._columns.concat(e._columns.filter(i=>n._columns.indexOf(i)<0));n._index.length<n._values.length;){let i="row"+n._index.length;n._index.push(i+(t._index.indexOf(i)>-1?" (2)":""))}return n}else{let n=t.copy();return n._index.forEach((o,i)=>{let s=e._index.indexOf(o);s>-1?n._values[i]=n._values[i].concat(e._values[s]):n._values[i]=n._values[i].concat(k(e.shape[1]))}),e._index.forEach((o,i)=>{n._index.indexOf(o)<0&&(n._index.push(o),n._values.push(k(n._columns.length).concat(e._values[i])))}),n._columns=n._columns.concat(e._columns.map(o=>o+(n._columns.indexOf(o)>-1?" (2)":""))),n}else throw new H("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function kt(t,e,r,n,o){if(o=o||0,a(D(n),"The first parameter to the `apply` method must be a function."),a(o===0||o===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),o===0){let i={},s;if(r.columns.forEach((u,m)=>{let c=new e(r.values.map(g=>g[m]));c.name=u,c.index=r.index;let l=n(c,m,r);l instanceof e?i[u]=l.values:i[u]=l,h(s)&&(s=l instanceof e||f(l))}),s){let u=new t(i);return u.index=r.index,u}else{let u=new e(r.columns.map(m=>i[m]));return u.index=r.columns,u}}else if(o===1){let i,s=r.values.map((u,m)=>{let c=new e(u);c.name=r.index[m],c.index=r.columns;let l=n(c,m,r);return h(i)&&(i=l instanceof e||f(l)),l instanceof e?l.values:l});if(i){let u=new t(s);return u.index=r.index,u.columns=r.columns,u}else{let u=new e(s);return u.index=r.index,u}}}function S(t){return typeof t=="string"}function Bt(t,e,r,n,o){let i=u=>u instanceof t,s=u=>u instanceof e;if(h(o))if(i(n)){let u=r.copy(),m=u.shape,c=n.shape;for(let l=0;l<c[1];l++){let g=n.columns[l],N=u.columns.includes(g)?u.columns.indexOf(g):u.columns.length;u.columns.includes(g)||u._columns.push(g);for(let O=0;O<m[0];O++)u._values[O][N]=n._values[O][l]}return u}else{if(s(n))return r.assign(n.name,n.values);if(X(n))return r.assign(new t(n));throw new H("You must pass a DataFrame, Series, or object into the `assign` method!")}else{a(S(n),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),a(f(o)&&!C(o)&&b(o).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=r.copy();if(u.columns.includes(n)){let m=u.columns.indexOf(n);return u.columns[m]=n,u.values.forEach((c,l)=>c[m]=o[l]),u}else return u._columns.push(n),u._values.forEach((m,c)=>m.push(o[c])),u}}function Ut(t,e){if(e.isEmpty)return new t;let r=new t(j(e.values));return r.columns=e.columns.slice(),r.index=e.index.slice(),r}function Pt(t,e,r,n,o){h(n)&&(n=[]),h(o)&&(o=[]),(S(n)||p(n))&&(n=[n]),(S(o)||p(o))&&(o=[o]),a(f(n),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),a(f(o),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),a(b(n).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),a(b(o).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let i,s;r.index.forEach((m,c)=>{n.indexOf(m)<0&&n.indexOf(c)<0&&(i||(i=[]),i.push(m))}),r.columns.forEach((m,c)=>{o.indexOf(m)<0&&o.indexOf(c)<0&&(s||(s=[]),s.push(m))});let u=r.get(i,s);if(u instanceof e){let m=new t;m=m.assign(u),r.index.indexOf(u.name)>-1&&(m=m.transpose()),u=m}return u}function $e(t){return p(t)&&(t>=0?Math.floor(t)===t:Math.ceil(t)===t)}function re(t){return $e(t)&&t>=0}function Rt(t,e,r,n,o,i){n=n||0,a(n===0||n===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),i=i||0,a(re(i),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),o=i>0?"none":o||"any",a(o==="any"||o==="all"||o==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(c){if(i>0){let l=0;for(let g=0;g<c.length;g++){let N=c[g];if(h(N)&&l++,l>=i)return[]}}else if(o==="any")for(let l=0;l<c.length;l++){let g=c[l];if(h(g))return[]}else if(o==="all"){for(let l=0;l<c.length;l++){let g=c[l];if(!h(g))return c}return[]}return c}let u=r.copy(),m=Math.random().toString();if(n===0){u=u.assign(m,u.index);let c=u.values.map(s).filter(g=>g.length>0);if(b(c).length<2)return new t;u.values=c;let l=u.get(null,m);if(h(l))return new t;S(l)&&(l=[l]),l instanceof e&&(l=l.values),u.index=l,u=u.drop(null,m)}else if(n===1){let c={};if(u.columns.forEach((g,N)=>{let O=u.values.map(G=>G[N]),I=s(O);I.length>0&&(c[g]=I)}),Object.keys(c).length+Object.getOwnPropertySymbols(c).length===0)return new t;let l=new t(c);return l.index=u.index,l}return u}function he(t){if(d(t)||y(t))return t.dropNaN(...Object.values(arguments).slice(1));a(f(t),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let e=[];return t.forEach(r=>{try{return e.push(he(r))}catch{if(p(r))return e.push(r)}}),e}function xt(t,e,r,n,o){r=r||0,a(r===0||r===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),o=o||0,a(re(o),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),n=o>0?"none":n||"any",a(n==="any"||n==="all"||n==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function i(u){let m=he(u);return o>0?u.length-m.length<o:n==="any"?m.length===u.length:n==="all"?m.length>0:!0}let s=e.copy();if(r===0){let u=s.index.filter(m=>{let c=s.get(m,null).values;return i(c)});return u.length>0?s.get(u,null):new t}else if(r===1){let u=s.columns.filter(m=>{let c=s.get(null,m).values;return i(c)});return u.length>0?s.get(null,u):new t}return s}function zt(t){let e={};return F(t).forEach((r,n)=>{e[r]=n}),e}function Fe(t){return Object.keys(t).concat(Object.getOwnPropertySymbols(t)).sort((e,r)=>t[e]-t[r])}function Jt(t,e,r,n,o){a(D(n),"The `filter` method takes a single parameter: a function that is used to filter the values."),h(o)&&(o=0),a(o===0||o===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let i=r.copy();if(i.isEmpty)return i;let s=zt(i.index),u=zt(i.columns);if(o===0){let m=0,c=i.values.filter((l,g)=>{let N=new e(l);N.name=r.index[g],N.index=r.columns;let O=n(N,g,r);return O?m++:delete s[i.index[g]],O});if(m===0)return new t;if(m===1){let l=new e(c[0]);return l.name=Fe(s)[0],l.index=Fe(u),l}i.values=c,i.index=Fe(s)}else if(o===1){i=i.transpose();let m=0,c=i.values.filter((l,g)=>{let N=new e(l);N.name=r.columns[g],N.index=r.index;let O=n(N,g,r);return O?m++:delete u[i.index[g]],O});if(m===0)return new t;if(m===1){let l=new e(c[0]);return l.name=Fe(u)[0],l.index=Fe(s),l}i.values=c,i.index=Fe(u),i=i.transpose()}return i}function Vt(t,e,r){(S(e)||p(e))&&(e=[e]),(S(r)||p(r))&&(r=[r]);for(let o in e)typeof e[o]=="bigint"&&(e[o]=Number(e[o]));for(let o in r)typeof r[o]=="bigint"&&(r[o]=Number(r[o]));let n=B((e||[]).concat(r||[]).map(o=>typeof o));return a(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&a(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(a(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),a(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),h(e)||(e=e.map(o=>{if(S(o))return a(t.index.indexOf(o)>-1,`Row "${o}" does not exist!`),o;if(p(o))return a(o>=0,`Index ${o} is out of bounds!`),a(Math.floor(o)===o,"Row numbers must be integers!"),a(o<t.index.length,`Index ${o} is out of bounds!`),t.index[o]})),h(r)||(r=r.map(o=>{if(S(o))return a(t.columns.indexOf(o)>-1,`Column "${o}" does not exist!`),o;if(p(o))return a(o>=0,`Column ${o} is out of bounds!`),a(Math.floor(o)===o,"Column numbers must be integers!"),a(o<t.columns.length,`Column ${o} is out of bounds!`),t.columns[o]})),t.getSubsetByNames(e,r)}function nn(t,e){try{return t<e?-1:t>e?1:0}catch{return t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t<e?-1:t>e?1:0}}function P(t,e){if(h(e)&&(e=nn),d(t)||y(t))return t.sort(...Object.values(arguments).slice(1));a(f(t),"The `sort` function only works on arrays, Series, and DataFrames!"),a(D(e),"The second parameter of the `sort` function must be a comparison function!");let r=t.slice();return r.sort(e),r}function on(t){let e=t.toLowerCase(),r="";for(let o=0;o<e.length;o++){let i=e[o];i.match(/[a-z0-9]/g)?r+=i:r+=" "}let n=r.split(" ").filter(o=>o.length>0);return n[0]+n.slice(1).map(o=>o[0].toUpperCase()+o.substring(1)).join("")}function ut(t,e,r){h(r)?r=e.columns:S(r)&&(r=[r]);let n={};r.forEach(i=>{a(S(i),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=e.columns.indexOf(i);a(s>-1,`The given DataFrame does not have a column called "${i}"!`);let u=e.values.map(c=>c[s]),m=P(B(u));u.forEach(c=>{m.forEach(l=>{let g=i+"_"+on(l.toString());n[g]||(n[g]=[]),c===l?n[g].push(1):n[g].push(0)})})});let o=new t(n);return o.index=e.index,o}function qt(t,e,r){let n=t.shape;h(e)&&(e=w(0,n[0])),h(r)&&(r=w(0,n[1])),p(e)&&(e=[e]),p(r)&&(r=[r]),a(f(e)&&f(r),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),a(b(e).length===1&&b(r).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),a(e.length>0,"The `rowIndices` array must contain at least one index."),a(r.length>0,"The `colIndices` array must contain at least one index."),e.forEach(s=>{a(re(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),a(s<t.index.length,`The row index ${s} is out of bounds.`)}),r.forEach(s=>{a(re(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),a(s<t.columns.length,`The column index ${s} is out of bounds.`)});let o=e.map(s=>t.index[s]),i=r.map(s=>t.columns[s]);return t.getSubsetByNames(o,i)}function Yt(t,e,r,n,o){h(n)&&(n=r.index),h(o)&&(o=r.columns),S(n)&&(n=[n]),S(o)&&(o=[o]),a(f(n)&&f(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),a(b(n).length===1&&b(o).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),a(n.length>0,"The `rows` array must contain at least one row name."),a(o.length>0,"The `cols` array must contain at least one column name."),n.forEach(u=>{a(S(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),a(r.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),o.forEach(u=>{a(S(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),a(r.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let i=n.map(u=>o.map(m=>r.values[r.index.indexOf(u)][r.columns.indexOf(m)]));if(n.length===1&&o.length===1)return i[0][0];if(n.length===1){let u=new e(i[0]);return u.name=n[0],u.index=o,u}if(o.length===1){let u=new e(i.map(m=>m[0]));return u.name=o[0],u.index=n,u}let s=new t(i);return s.columns=o,s.index=n,s}function $t(t,e,r){function n(N,O){return S(N)&&N.length>O?N.substring(0,O-3)+"...":N}if(r.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),r;let o=typeof window>"u"?20:10,i=Math.floor(o/2),s=4,u=Math.floor(s/2),m=o>r.index.length?null:w(0,i).concat(w(r.index.length-i,r.index.length)),c=s>r.columns.length?null:w(0,u).concat(w(r.columns.length-u,r.columns.length)),l=r.get(m,c);l instanceof e&&(r.shape[0]===1?(l=new t([l.values]),l.index=r.index,l.columns=new e(r.columns).get(c).values):r.shape[1]===1&&(l=new t([l.values]).transpose(),l.index=new e(r.index).get(m).values,l.columns=r.columns)),o<=r.index.length&&(l._index.splice(i,0,"..."),l._values.splice(i,0,w(0,l.columns.length).map(()=>"..."))),s<=r.columns.length&&(l._columns.splice(u,0,"..."),l._values=l._values.map(N=>(N.splice(u,0,"..."),N)));let g=28;return l instanceof e?(l.values=l.values.map(N=>n(N,g)),l.name=n(l.name,g),l.index=l.index.map(N=>n(N,g))):(l.values=l.values.map(N=>N.map(O=>n(O,g))),l.columns=l.columns.map(N=>n(N,g)),l.index=l.index.map(N=>n(N,g))),console.table(l.toDetailedObject()),console.log("Shape:",r.shape,`
`),r}function le(t,e){a(p(t),"The `leftPad` function only works on numbers!");let r=t.toString();for(;r.length<e;)r="0"+r;return r}function Kt(t,e){let r=e?t:t.copy();return r.index=w(0,t.shape[0]).map(n=>"row"+le(n,(r.index.length-1).toString().length)),r}function de(t,e){if(d(t)||y(t))return de(t.values,e);a(f(t),"The `product` function only works on arrays, Series, and DataFrames!");try{if(t.length===0)return NaN;let r=F(t),n=!1,o=1;for(let i of r){if(!p(i))if(e)i=1;else return NaN;typeof i=="bigint"&&(n=!0,i=Number(i)),o*=i}if(n)try{return BigInt(o)}catch{}return o}catch{return NaN}}function Gt(t){return $e(t)&&t>0}function ve(t,e){if(d(t)||y(t))return ve(t.values,e);if(a(f(t),"The first argument passed into the `reshape` function must be an array!"),p(e)&&(e=[e]),a(f(e),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),a(b(e).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),e=e.map(i=>(typeof i=="bigint"&&(i=Number(i)),a(Gt(i),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(i))),e.length===0)return F(t);let r=F(t);if(e.length===1&&e[0]===r.length)return r;a(de(e)===r.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let n=[],o=Math.floor(r.length/e[0]);for(let i=0;i<e[0];i++){let s=r.slice(i*o,(i+1)*o);n.push(ve(s,e.slice(1)))}return n}var Ht=Math.pow(2,64),_=[];Xt(Math.floor(Math.random()*Ht));function sn(t,e){t=x(t);function r(){t+=x("0x9e3779b97f4a7c15");let o=j(t);return o=(o^o>>BigInt(30))*x("0xbf58476d1ce4e5b9"),o=(o^o>>BigInt(27))*x("0x94d049bb133111eb"),o^o>>BigInt(31)}let n=[];for(let o=0;o<e;o++)n.push(r());return n}function x(t){return BigInt.asUintN(64,BigInt(t))}function Wt(t,e){return t=x(t),e=BigInt(e),x(x(t<<e)|x(t>>x(BigInt(64)-e)))}function Xt(t){if(typeof t=="bigint"&&(t=Number(t)),h(t))return j(_);{a(p(t),"If passing a value into the `seed` function, then that value must be an integer!");let e=sn(Math.floor(t),4);_[0]=e[0],_[1]=e[1],_[2]=e[2],_[3]=e[3]}}function Lt(){let t=x(Wt(_[0]+_[3],23)+_[0]),e=x(_[1]<<BigInt(17));return _[2]=x(_[2]^_[0]),_[3]=x(_[3]^_[1]),_[1]=x(_[1]^_[2]),_[0]=x(_[0]^_[3]),_[2]=x(_[2]^e),_[3]=Wt(_[3],45),Math.floor(Number(t))/Ht}function V(t){return h(t)?Lt():(f(t)||(t=[t]),ve(k(de(t)).map(Lt),t))}function ue(t){if(d(t)||y(t))return t.shuffle(...Object.values(arguments).slice(1));a(f(t),"The `shuffle` function only works on arrays, Series, and DataFrames!");let e=[],r=t.slice();for(let n=0;n<t.length;n++){let o=Math.floor(V()*r.length);e.push(r.splice(o,1)[0])}return e}function Zt(t,e){return h(e)&&(e=0),a(e===0||e===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),t.get(e===0?ue(t.index):null,e===1?ue(t.columns):null)}function q(t){return typeof t=="boolean"}function Qt(t,e,r){return D(e)?an(t,e,r):un(t,e,r)}function an(t,e,r){if(r=h(r)?0:r,a(D(e),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),a(p(r),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),r===0){let n=P(t.index,(o,i)=>e(t.get(o,null),t.get(i,null)));return t.get(n,null)}else{let n=P(t.columns,(o,i)=>e(t.get(null,o),t.get(null,i)));return t.get(null,n)}}function un(t,e,r){let n=t.copy(),o=V().toString();n=n.assign(o,n.index),h(e)&&(e=[o],r=[!0]),(p(e)||S(e))&&(e=[e],(q(r)||S(r))&&(r=[r])),a(f(e),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),a(b(e).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),h(r)&&(r=w(0,e.length).map(()=>!0)),a(f(r),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),a(b(r).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),a(e.length===r.length,"The arrays passed into the `sort` method must be equal in length."),e=e.map(s=>{if(a(S(s)||p(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),S(s)){let u=n.columns.indexOf(s);return a(u>-1,`The column "${s}" does not exist!`),u}if(p(s))return a(re(s),"Column indices must be whole numbers!"),a(s<n.columns.length,`The index ${s} is out of bounds!`),s}),r=r.map(s=>{if(a(S(s)||q(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),S(s)){let u=s.trim().toLowerCase();return a(u==="ascending"||u==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),u==="ascending"}if(q(s))return s}),n.values=P(n.values,(s,u)=>{let m=0;for(;s[e[m]]===u[e[m]]&&m<e.length;)m++;let c=r[m];if(s[e[m]]===u[e[m]])return 0;if(s[e[m]]<u[e[m]])return c?-1:1;if(s[e[m]]>u[e[m]])return c?1:-1});let i=n.columns.indexOf(o);return n.index=n.values.map(s=>s[i]),n=n.dropColumns(o),n}function er(t,e){h(e)?e=0:a(e===0||e===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let r={};return e===0?t.index.forEach((n,o)=>{let i={};t.columns.forEach((s,u)=>{i[s]=t.values[o][u]}),r[n]=i}):t.columns.forEach((n,o)=>{let i={};t.index.forEach((s,u)=>{i[s]=t.values[u][o]}),r[n]=i}),r}function Ke(t,e){return JSON.stringify(t.toObject(e))}async function tr(t,e){return JSON.parse(Ke(t,e))}function rr(t){let e={};return t.columns.forEach(r=>{e[r]=t.get(r).values}),e}function U(t){if(d(t)||y(t))return t.transpose();a(f(t),"The `transpose` function only works on arrays, Series, and DataFrames!");let e=b(t);if(a(e.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),e.length===1)return J(t);if(e.length===2){let r=k(J(e));for(let n=0;n<e[0];n++)for(let o=0;o<e[1];o++)r[o][n]=t[n][o];return r}}function mt(t,e,r){if(y(r))return new t(e.values.concat(r.values));if(f(r)){let n=b(r);a(n.length===1&&!De(n),"Only vectors can be appended to Series!");let o=e.copy();return r.forEach((i,s)=>{o._values.push(i),o._index.push("item"+(e.values.length+s))}),o}return mt(e,[r])}function nr(t,e){a(D(e),"The parameter to the `apply` method must be a function.");let r=t.copy();return r._values=r._values.map((n,o)=>e(n,o)),r}function or(t){let e=t.copy(),r=[];return e._values=e.values.filter((n,o)=>h(n)?!1:(r.push(e.index[o]),!0)),e._index=r,e}function ir(t,e){let r=[],n=[];e.values.forEach((i,s)=>{p(i)&&(n.push(i),r.push(e.index[s]))});let o=new t(n);return o.name=e.name,o.index=r,o}function sr(t,e,r){let n=e.copy(),o=j(n.index),i=[],s=n.values.filter((u,m)=>{let c=r(u,m,n.values);return c||i.push(n.index[m]),c});return i.forEach(u=>{o.splice(o.indexOf(u),1)}),s.length===0?(n=new t,n.name=e.name,n):(n.values=s,n.index=o,n)}function ar(t,e){(S(e)||p(e))&&(e=[e]);for(let n in e)typeof e[n]=="bigint"&&(e[n]=Number(e[n]));let r=B((e||[]).map(n=>typeof n));return a(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&a(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(a(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),a(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),h(e)||(e=e.map(n=>{if(typeof n=="string")return a(t.index.indexOf(n)>-1,`Index "${n}" does not exist!`),n;if(typeof n=="number")return a(n>=0,`Index ${n} is out of bounds!`),a(Math.floor(n)===n,"Indices must be integers!"),a(n<t.index.length,`Index ${n} is out of bounds!`),t.index[n]})),t.getSubsetByNames(e)}function ur(t,e){let r=t.shape;h(e)&&(e=w(0,r[0])),a(f(e),"The `indices` array must be 1-dimensional array of whole numbers."),a(b(e).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),a(e.length>0,"The `indices` array must contain at least one index."),e.forEach(o=>{a(re(o),"The `indices` array must be a 1-dimensional array of whole numbers."),a(o<t.index.length,`The row index ${o} is out of bounds.`)});let n=e.map(o=>t.index[o]);return t.getSubsetByNames(n)}function mr(t,e,r){h(r)&&(r=e.index),a(f(r),"The `indices` array must be a 1-dimensional array of strings."),a(b(r).length===1,"The `indices` array must be a 1-dimensional array of strings."),a(r.length>0,"The `indices` array must contain at least one index name."),r.forEach(i=>{a(S(i),"The `indices` array must contain only strings."),a(e.index.indexOf(i)>-1,`The name "${i}" does not exist in the index.`)});let n=r.map(i=>e.values[e.index.indexOf(i)]);if(n.length===1)return n[0];let o=new t(n);return o.index=r,o.name=e.name,o}function fr(t){let e=t.copy(),r=typeof window>"u"?20:10;if(e.index.length>r){e=e.get(w(0,r/2).concat(w(e.index.length-r/2,e.index.length)));let o=j(e.index);o.splice(Math.floor(o.length/2),0,"..."),e.values.push("..."),e.index.push("..."),e=e.get(o)}let n={};return e.values.forEach((o,i)=>{let s={};s[e.name]=o,n[e.index[i]]=s}),console.table(n),console.log("Shape:",t.shape,`
`),t}function lr(t){let e=t.copy();return e.get(ue(e.index))}function cr(t,e,r){r=r||((m,c)=>m<c?-1:1),a(h(r)||D(r),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let n=U([e.values,e.index]),o=P(n,(m,c)=>r(m[0],c[0])),i=[],s=[];o.forEach(m=>{i.push(m[0]),s.push(m[1])});let u=new t;return u._values=i,u._index=s,u.name=e.name,u}function pr(t,e){let r=U([e.values,e.index]);r=U(P(r,(o,i)=>{if(o[1]===i[1])return 0;if(o[1]<i[1])return-1;if(o[1]>i[1])return 1}));let n=new t(r[0]);return n.index=r[1],n.name=e.name,n}function hr(t){let e={};return e[t.name]={},t.index.forEach((r,n)=>{e[t.name][r]=t.values[n]}),e}var dr=Symbol.for("@jrc03c/js-math-tools/series");function gr(t){class e{static[Symbol.hasInstance](n){try{return!!n._symbol&&n._symbol===dr}catch{return!1}}constructor(n){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:dr}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(o){a(f(o),"The new values must be a 1-dimensional array!");let i=b(o);a(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<this._index.length?this._index=this._index.slice(0,i[0]):i[0]>this._index.length&&(this._index=this._index.concat(w(this._index.length,i[0]).map(s=>"item"+le(s,(o.length-1).toString().length)))),this._values=o}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(o){a(f(o),"The new index must be a 1-dimensional array of strings!"),a(o.length===this.shape[0],"The new index must be the same length as the old index!"),a(b(o).length===1,"The new index must be a 1-dimensional array of strings!"),o.forEach(i=>{a(S(i),"All of the row names must be strings!")}),this._index=o}}),n){if(n instanceof e)this.name=n.name,this.values=j(n.values),this.index=j(n.index);else if(f(n)){let o=b(n);a(o.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=n}else if(n instanceof Object){let o=Object.keys(n).concat(Object.getOwnPropertySymbols(n)).map(u=>u.toString());a(o.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=o[0],s=n[i];a(b(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=i,this.values=s.slice()}}}get shape(){return b(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(n=>!h(n)).length===0}clear(){let n=this.copy();return n.values.forEach((o,i)=>{n.values[i]=void 0}),n}get(n){return ar(this,n)}getSubsetByNames(n){return mr(e,this,n)}getSubsetByIndices(n){return ur(this,n)}loc(n){return this.getSubsetByNames(n)}iloc(n){return this.getSubsetByIndices(n)}reverse(){let n=new e(J(this.values));return n.index=J(this.index),n.name=this.name,n}resetIndex(){let n=this.copy();return n.index=w(0,this.shape[0]).map(o=>"item"+le(o,(n.index.length-1).toString().length)),n}copy(){let n=new e;return n._values=j(this.values),n._index=j(this.index),n.name=this.name,n}append(n){return mt(e,this,n)}apply(n){return nr(this,n)}concat(n){return this.append(n)}dropMissing(n,o){return or(this,n,o)}dropNaN(){return ir(e,this)}toObject(){return hr(this)}print(){return fr(this)}shuffle(){return lr(this)}sort(n){return cr(e,this,n)}sortByIndex(){return pr(e,this)}filter(n){return sr(e,this,n)}toDataFrame(){let n=new t(U([this.values]));return n.columns=[this.name],n.index=this.index,n}transpose(){let n=this.copy();return n.values=J(n.values),n.index=J(n.index),n}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return e}var yr=Symbol.for("@jrc03c/js-math-tools/dataframe");function Ge(t){let e="abcdefghijklmnopqrstuvwxyz1234567890",r="";for(let n=0;n<t;n++)r+=e[Math.floor(V()*e.length)];return r}var A=class t{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===yr}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:yr}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!h(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(r){a(f(r),"The new values must be a 2-dimensional array!");let n=b(r);a(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(w(this._index.length,n[0]).map(o=>"row"+le(o,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(w(this._columns.length,n[1]).map(o=>"col"+le(o,(n[1]-1).toString().length)))),this._values=r}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(r){a(f(r),"The new columns list must be a 1-dimensional array of strings!"),a(this.isEmpty||r.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),a(b(r).length===1,"The new columns list must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+Ge(8):o.trim()));let n=(()=>{let o=ae(r),i={};return o.values.forEach(s=>{i[s]=o.get(s)}),i})();r=r.map(o=>n[o]>1?o+"_"+Ge(8):o),this._columns=r}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(r){a(f(r),"The new index must be a 1-dimensional array of strings!"),a(this.isEmpty||r.length===this.shape[0],"The new index must be the same length as the old index!"),a(b(r).length===1,"The new index must be a 1-dimensional array of strings!"),r=r.map(o=>(typeof o!="string"&&(o=JSON.stringify(o)||o.toString()),o.trim().length===0?"untitled_"+Ge(8):o.trim()));let n=(()=>{let o=ae(r),i={};return o.values.forEach(s=>{i[s]=o.get(s)}),i})();r=r.map(o=>n[o]>1?o+"_"+Ge(8):o),this._index=r}}),a(h(e)||X(e)||f(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof t)this.values=j(e.values),this.columns=j(e.columns),this.index=j(e.index);else if(f(e)){let r=b(e);a(r.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),a(!C(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(s=>s.toString());let r=[],n=null,o=null;this._columns.forEach(s=>{h(o)&&(n=s,o=e[s].length),a(e[s].length===o,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${o} items, and the key "${s}" points to an array containing ${e[s].length} items.`),o=e[s].length;let u=e[s];r.push(u)}),this._values=U(r);let i=b(this.values);this._index=w(0,i[0]).map(s=>"row"+le(s,(i[0]-1).toString().length))}}get shape(){return b(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new t(k(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,r){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return Vt(this,e,r)}getSubsetByNames(e,r){return Yt(t,E,this,e,r)}getSubsetByIndices(e,r){return qt(this,e,r)}getDummies(e){return ut(t,this,e)}oneHotEncode(e){return ut(t,this,e)}transpose(){let e=new t(U(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return Kt(this,e)}copy(){return Ut(t,this)}assign(e,r){return Bt(t,E,this,e,r)}apply(e,r){return kt(t,E,this,e,r)}dropMissing(e,r,n){return Rt(t,E,this,e,r,n)}dropNaN(e,r,n){return xt(t,this,e,r,n)}drop(e,r){return Pt(t,E,this,e,r)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return er(this,e)}toObject(){return rr(this)}toJSONString(e){return Ke(this,e)}saveAsJSON(e,r){return tr(this,e,r)}print(){return $t(t,E,this)}sort(e,r){return Qt(this,e,r)}sortByIndex(){return this.sort()}filter(e,r){return Jt(t,E,this,e,r)}shuffle(e){return Zt(this,e)}append(e,r){return at(this,e,r)}concat(e,r){return this.append(e,r)}join(e,r){return this.append(e,r)}toString(){return JSON.stringify(this)}},E=gr(A);function me(t,e){return T(t,{shouldDropNaNs:e}).max}function v(t){return a(D(t),"You must pass a function into the `vectorize` function!"),function e(){let r,n,o=[],i=[],s=Object.keys(arguments).filter(u=>{let m=arguments[u];return f(m)?!0:y(m)?(r=!0,o.push(m),!0):d(m)?(n=!0,i.push(m),!0):!1}).map(u=>arguments[u]);if(s.slice(0,-1).forEach((u,m)=>{a(M(f(u)?b(u):u.shape,f(s[m+1])?b(s[m+1]):s[m+1].shape),`When passing multiple arrays into the \`${t.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let u=me(s.map(c=>c.length?c.length:c.values.length)),m=w(0,u).map(c=>{let l=Object.keys(arguments).map(g=>f(arguments[g])?arguments[g][c]:y(arguments[g])||d(arguments[g])?arguments[g].values[c]:arguments[g]);return e(...l)});if(n)try{if(i.length===1&&M(b(i[0]),b(m))){let c=new A(m);return c.index=i[0].index.slice(),c.columns=i[0].columns.slice(),c}else return new A(m)}catch{return m}if(r)try{if(o.length===1&&o[0].length===m.length){let c=new E(m);return c.name=o[0].name,c.index=o[0].index.slice(),c}else return new E(m)}catch{return m}return m}else return t(...arguments)}}function mn(t){try{return p(t)?typeof t=="bigint"?t<0?-t:t:Math.abs(t):NaN}catch{return NaN}}var Y=v(mn);function fn(){try{let t=0,e=!1,r=Object.values(arguments);for(let n of r){if(!p(n))return NaN;typeof n=="bigint"&&(e=!0,n=Number(n)),t+=n}if(e)try{return BigInt(t)}catch{}return t}catch{return NaN}}var Se=v(fn);function ln(t,e){try{return e(t)}catch{return NaN}}var ne=v(ln);function cn(t){try{return p(t)?(typeof t=="bigint"&&(t=Number(t)),Math.acos(t)):NaN}catch{return NaN}}var pn=v(cn);function hn(t){try{return p(t)?(typeof t=="bigint"&&(t=Number(t)),Math.asin(t)):NaN}catch{return NaN}}var dn=v(hn);function gn(t){try{return p(t)?(typeof t=="bigint"&&(t=Number(t)),Math.atan(t)):NaN}catch{return NaN}}var yn=v(gn);function je(t,e){if(d(t)){let r=je(t.values,e);return[t.index[r[0]],t.columns[r[1]]]}if(y(t)){let r=je(t.values,e);return t.index[r]}a(f(t),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let r=fe(t,me(t,e));return r?r.length===0?void 0:r.length===1?r[0]:r:void 0}catch{return}}function ft(t,e){return T(t,{shouldDropNaNs:e}).min}function ce(t,e){if(d(t)){let r=ce(t.values,e);return[t.index[r[0]],t.columns[r[1]]]}if(y(t)){let r=ce(t.values,e);return t.index[r]}a(f(t),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let r=fe(t,ft(t,e));return r?r.length===0?void 0:r.length===1?r[0]:r:void 0}catch{return}}function $(t,e){if(d(t)||y(t))return t.apply(r=>$(r,e));if(f(t))return t.map(r=>$(r,e));if(e==="null")return null;if(e==="number"){if(h(t))return NaN;let r=$(t,"boolean");if(q(r))return r?1:0;try{JSON.parse(t)}catch{let i=$(t,"date");if(R(i))return i.getTime()}let n=parseFloat(t);return isNaN(n)?NaN:n}if(e==="int"){let r=$(t,"number");return r>=0?Math.floor(r):Math.ceil(r)}if(e==="float")return $(t,"number");if(e==="bigint")return typeof t=="bigint"?t:BigInt($(t,"int"));if(e==="boolean"){if(q(t))return t;if(p(t))return t===0?!1:t===1?!0:null;try{let r=(typeof t=="object"?t.toString()==="null"?"false":JSON.stringify(t):t.toString()).trim().toLowerCase();return r==="true"||r==="yes"||r==="y"?!0:r==="false"||r==="no"||r==="n"?!1:null}catch{return null}}if(e==="date"){if(R(t))return t;if(h(t))return null;let r=parseFloat(t);if(!isNaN(r)){let o=new Date(t);return R(o)?o:null}let n=Date.parse(t);return isNaN(n)?null:new Date(n)}if(e==="object"){if(X(t))return t;let r=$(t,"boolean");if(q(r))return null;try{let o=$(t,"number");if(p(o))return JSON.parse(t),null}catch{}let n=$(t,"date");if(n)return n;try{let o=JSON.parse(t);return f(o)?o.map(i=>$(i,e)):o}catch{return null}}if(e==="string")return h(t)?M(t,void 0)?"undefined":"null":t instanceof Date?t.toJSON():typeof t=="object"?t===null?"null":JSON.stringify(t):t.toString()}function bn(t){try{return p(t)?typeof t=="bigint"?t:Math.ceil(t):NaN}catch{return NaN}}var Nn=v(bn);function vn(t,e){try{if(!p(t))return NaN;if(typeof t=="bigint")return t;if(h(e))e=1e-10;else if(!p(e))return NaN;return Y(t)<e?0:t}catch{return NaN}}var Sn=v(vn);function lt(t){if(d(t)||y(t)){let e=t.copy();return e.values=lt(e.values),e}if(f(t))return t.map(e=>lt(e));try{let e=JSON.parse(t);return p(e)?typeof e=="bigint"?Number(e):e>=0?Math.floor(e):Math.ceil(e):NaN}catch{return NaN}}var K=v(lt);function br(t,e,r){try{return p(t)?p(e)?p(r)?typeof t=="bigint"?BigInt(br(K(t),e,r)):t<e?e:t>r?r:t:NaN:NaN:NaN}catch{return NaN}}var we=v(br);function Re(){let t=Object.values(arguments).map(r=>d(r)||y(r)?B(r.values):(a(f(r),"The `intersect` function only works on arrays, Series, and DataFrames!"),B(r)));return B(t).filter(r=>t.every(n=>n.findIndex(o=>M(o,r))>-1))}var Oe=class t{static DROP_NAN_MODE="DROP_NAN_MODE";static DROP_MISSING_MODE="DROP_MISSING_MODE";constructor(e){a(h(e)||e===t.DROP_NAN_MODE||e===t.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=h(e)?t.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(r=>{if(f(r)){let n=b(r);if(n.length===1)r=new E(r);else if(n.length===2)r=new A(r);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}a(d(r)||y(r),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===t.DROP_MISSING_MODE?e.push(r.dropMissing().index):e.push(r.dropNaN().index)}),this.index=Re(...e),this}transform(){a(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(r=>{if(f(r)){let n=b(r);if(n.length===1)return new E(r).get(this.index).values;if(n.length===2)return new A(r).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return a(d(r)||y(r),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),r.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}};function Me(t,e,r,n){if(y(t))return Me(t.values,e,r,n);if(y(e))return Me(t,e.values,r,n);if(a(f(t)&&f(e)&&b(t).length===1&&b(e).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),a(t.length===e.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),r)return Me(...new Oe().fitAndTransform(t,e),!1,n);try{let o=T(t,{stdev:n}),i=T(e,{stdev:n}),s=Number(o.mean),u=Number(i.mean);if(!p(s)||!p(u))return NaN;let m=Math.max(t.length,e.length),c=0;for(let l=0;l<m;l++){let g=t[l],N=e[l];if(!p(g))return NaN;if(!p(N))return NaN;typeof g=="bigint"&&(g=Number(g)),typeof N=="bigint"&&(N=Number(N)),c+=(g-s)*(N-u)}return n?[c/t.length,o,i]:c/t.length}catch{return NaN}}function oe(t,e,r){if(y(t))return oe(t.values,e,r);if(y(e))return oe(t,e.values,r);a(f(t)&&f(e)&&b(t).length===1&&b(e).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),a(t.length===e.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[o,i,s]=Me(t,e,r,!0),u=i.stdev*s.stdev;return o/u}catch{return NaN}}function wn(t){try{return p(t)?(typeof t=="bigint"&&(t=Number(t)),Math.cos(t)):NaN}catch{return NaN}}var On=v(wn);var Tn=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Nr(t,e){try{if(!p(t))return NaN;if(!p(e))return NaN;if(typeof t=="bigint"||typeof e=="bigint"){let r=Nr(Number(t),Number(e));try{return BigInt(r)}catch{return r}}return Math.pow(t,e)}catch{return NaN}}var W=v(Nr);function vr(t){try{if(!p(t))return NaN;if(typeof t=="bigint"){let e=vr(Number(t));try{return BigInt(e)}catch{return e}}return Math.sqrt(t)}catch{return NaN}}var ge=v(vr);function An(){try{let t=Object.values(arguments);if(t.length===0)return NaN;let e=!1,r=1;for(let n of t){if(!p(n))return NaN;typeof n=="bigint"&&(e=!0,n=Number(n)),r*=n}if(e)try{return BigInt(r)}catch{}return r}catch{return NaN}}var ct=v(An);function Z(){return ct(...arguments)}function Q(t,e){return Se(t,Z(e,-1))}function z(t,e){return T(t,{shouldDropNaNs:e}).sum}function pe(t,e){return Z(t,W(e,-1))}function ee(t,e){if(d(t)){let o=ee(t.values,e);if(b(o).length===1){let i=new E(o);return i.name=y(e)?e.name:i.name,i.index=t.index.slice(),i}else{let i=new A(o);return i.index=t.index.slice(),d(e)&&(i.columns=e.columns.slice()),i}}if(d(e)){let o=ee(t,e.values);if(b(o).length===1){let i=new E(o);return i.name=y(t)?t.name:i.name,i.index=e.columns.slice(),i}else{let i=new A(o);return i.columns=e.columns.slice(),i}}if(y(t))return ee(t.values,e);if(y(e))return ee(t,e.values);a(f(t)&&f(e),"The `dot` function only works on arrays, Series, and DataFrames!");let r=b(t),n=b(e);if(a(r.length<=2&&n.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),a(r[r.length-1]===n[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${r[r.length-1]} !== ${n[0]})`),r.length===1&&n.length===1)return z(Z(t,e));if(r.length===1&&n.length===2)return U(e).map(o=>ee(t,o));if(r.length===2&&n.length===1)return t.map(o=>ee(o,e));if(r.length===2&&n.length===2){let o=U(e),i=[];for(let s=0;s<t.length;s++){let u=[];for(let m=0;m<o.length;m++)u.push(ee(t[s],o[m]));i.push(u)}return i}}function te(t,e){if(d(t)||y(t))return te(t.values,e);if(d(e)||y(e))return te(t,e.values);a(f(t)&&f(e),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),a(M(b(t),b(e)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let r=[],n=[];for(let o=0;o<t.length;o++)try{let[i,s]=te(t[o],e[o]);r.push(i),n.push(s)}catch{p(t[o])&&p(e[o])&&(r.push(t[o]),n.push(e[o]))}return[r,n]}function xe(t,e){if(d(t)||y(t))return xe(t.values,e);a(f(t),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),a(D(e),"The second argument passed into the `every` function must be a function!");for(let r of t)if(f(r)){if(!xe(r,e))return!1}else if(!e(r))return!1;return!0}function In(t){try{if(!p(t))return NaN;if(typeof t=="bigint"){if(t===0n)return 1n;t=Number(t)}return Math.exp(t)}catch{return NaN}}var Fn=v(In);function pt(t){try{return typeof t=="bigint"?BigInt(pt(K(t))):t!==K(t)?NaN:t<=1?1:t*pt(t-1)}catch{return NaN}}var jn=v(pt);function Mn(t){try{if(t==="Infinity")return 1/0;if(t==="-Infinity")return-1/0;let e=JSON.parse(t);return p(e)?e:NaN}catch{return NaN}}var _n=v(Mn);function En(t){try{return p(t)?typeof t=="bigint"?t:Math.floor(t):NaN}catch{return NaN}}var Cn=v(En);function ye(t){p(t)&&(t=[t]);let e=[],r=de(t);for(let n=0;n<r;n++)e.push(0);return ve(e,t)}var Sr=["true","false","yes","no"];var wr=["null","none","nan","na","n/a","","undefined"];function We(t){return t.type==="number"&&(typeof t.value<"u"?t.isInteger=K(t.value)===t.value:t.isInteger=xe(t.values,e=>p(e)?K(e)===e:!0)),t}function _e(t){if(d(t)){let i=t.copy(),s=_e(t.values);return i.values=s.values,We({type:s.type,values:i})}if(y(t)){let i=t.copy(),s=_e(t.values);return i.values=s.values,We({type:s.type,values:i})}if(!f(t)){let i=_e([t]);return i.value=i.values[0],delete i.values,We(i)}a(f(t),"The `inferType` function only works on arrays, Series, and DataFrames!");let e=F(t).map(i=>{if(i===void 0)return"null";try{if(typeof i=="object"){let m=new Date(i.getTime());if(R(m))return"date"}}catch{}S(i)||(typeof i=="bigint"?i=i.toString()+"n":i=JSON.stringify(i));let u=i.toLowerCase().trim();if(wr.indexOf(u)>-1)return"null";if(Sr.indexOf(u)>-1)return"boolean";try{if(i.match(/^-?\d+n$/g))return"bigint";let m=JSON.parse(i);return p(m)?"number":typeof m=="object"?f(m)?"string":"object":"string"}catch{let c=new Date(i);return R(c)?"date":"string"}}),r=ae(e),o=r.values.toSorted((i,s)=>r.get(s)-r.get(i))[0];return We({type:o,values:ne(t,i=>$(i,o))})}function Or(t,e,r){try{if(!p(t))return NaN;if(!p(e))return NaN;if(!p(r))return NaN;if(typeof t=="bigint"||typeof e=="bigint"){let n=Or(Number(t),Number(e),r);try{return BigInt(n)}catch{return n}}return r*(e-t)+t}catch{return NaN}}var kn=v(Or);function Tr(t,e){try{if(e=h(e)?Math.E:e,!p(t))return NaN;if(!p(e))return NaN;if(typeof t=="bigint"||typeof e=="bigint"){let r=Tr(Number(t),Number(e));try{return BigInt(r)}catch{return r}}return Math.log(t)/Math.log(e)}catch{return NaN}}var ht=v(Tr);function ze(t,e){return T(t,{shouldDropNaNs:e}).mean}function Ar(t,e){try{if(!p(t))return NaN;if(!p(e))return NaN;if(typeof t=="bigint"||typeof e=="bigint"){let r=Ar(Number(t),Number(e));try{return BigInt(r)}catch{return r}}return t%e}catch{return NaN}}var Bn=v(Ar);function Dr(){let t=V(),e=V();return Math.sqrt(-2*Math.log(t))*Math.cos(2*Math.PI*e)}function dt(t){return h(t)?Dr():ne(k(t),Dr)}var Pn=v((t,e,r,n,o)=>{try{let i=!1;for(let c of[t,e,r,n,o]){if(!p(c))return NaN;typeof c=="bigint"&&(i=!0)}i&&(t=Number(t),e=Number(e),r=Number(r),n=Number(n),o=Number(o));let s=(o-n)*(t-e),u=r-e;if(u===0)return NaN;let m=s/u+n;if(i)try{return BigInt(m)}catch{}return m}catch{return NaN}});function gt(t,e,r,n,o){if(f(t)&&h(n)&&h(o)){n=e,o=r;let i=T(t);e=i.min,r=i.max}return Pn(t,e,r,n,o)}function Rn(t){try{return p(t)?typeof t=="bigint"?t:Math.round(t):NaN}catch{return NaN}}var yt=v(Rn);function Ir(t){try{return p(t)?typeof t=="bigint"?BigInt(Ir(Number(t))):t<0?-1:t>0?1:0:NaN}catch{return NaN}}var bt=v(Ir);function xn(t){try{return p(t)?(typeof t=="bigint"&&(t=Number(t)),Math.sin(t)):NaN}catch{return NaN}}var zn=v(xn);function Vn(t){try{return p(t)?(typeof t=="bigint"&&(t=Number(t)),Math.tan(t)):NaN}catch{return NaN}}var qn=v(Vn);function Le(t,e,r){if(y(t))return Le(t.values,e);if(y(e))return Le(t,e.values);if(a(f(t)&&f(e)&&b(t).length===1&&b(e).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),a(t.length===e.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),r){let n=new Oe().fitAndTransform(t,e);t=n[0],e=n[1]}try{let n=T(t,{variance:!0}),o=T(e,{variance:!0}),i=n.mean,s=o.mean;return(i-s)/Math.sqrt((n.variance+o.variance)/2)}catch{return NaN}}function Fr(t){return typeof t=="bigint"?t.toString()+"n":t}function Je(){if(arguments.length===1&&y(arguments[0])){let{name:o,values:i}=arguments[0],s=Je(o,i),u=new A(s);return u.index=arguments[0].index.slice(),u}let[t,e]=arguments;a(S(t),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),a(f(e)&&b(e).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let r={};return P(B(e)).filter(o=>typeof o!="number"||o.toString()!=="NaN").filter(o=>!h(o)).map(o=>t+"_"+Fr(o)).slice(0,-1).forEach(o=>{r[o]=e.map(i=>o===t+"_"+Fr(i)?1:typeof i=="number"&&i.toString()==="NaN"?NaN:h(i)?NaN:0)}),r}function L(t){return p(t)&&t>=0&&Math.floor(t)===t&&t<1/0}function be(t){if(t instanceof ArrayBuffer||t instanceof BigInt64Array||t instanceof BigUint64Array||t instanceof Float32Array||t instanceof Float64Array||t instanceof Int16Array||t instanceof Int32Array||t instanceof Int8Array||t instanceof Uint16Array||t instanceof Uint32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:t.constructor.name,values:t instanceof ArrayBuffer?Array.from(new Uint8Array(t)):Array.from(t)};if(f(t))return t.map(e=>{try{return be(e)}catch{return e}});if(typeof t=="object"&t!==null){if(R(t))return new Date(t.getTime());let e={};return Object.keys(t).forEach(r=>{try{e[r]=be(t[r])}catch{e[r]=t[r]}}),e}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function Ne(t,e){return!t||e<=0?"":w(0,e).map(()=>t).join("")}function vt(t,e){a(S(e)||h(e),"The second parameter to the `stringify` function must be undefined or a string!");let r=e?`
`:"";function n(o,i,s){return s=s||0,typeof o=="bigint"?JSON.stringify(o.toString()+"n"):typeof o=="number"?o===1/0?'"Symbol(@Infinity)"':o===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(o)?'"Symbol(@NaN)"':o.toString():typeof o=="string"?JSON.stringify("Symbol(@String):"+o):typeof o=="boolean"?o.toString():typeof o>"u"?'"Symbol(@undefined)"':typeof o=="symbol"||typeof o=="function"?JSON.stringify(o.toString()):o instanceof RegExp?o.toString():typeof o=="object"?o===null?"null":R(o)?JSON.stringify(o.toJSON()):f(o)?o.length===0?Ne(i,s-1)+"[]":o instanceof Array?Ne(i,s-1)+"["+r+o.map(u=>{let m=(()=>{try{return n(be(u),i,s+1)}catch{return n(u,i,s+1)}})();return S(m)&&(m=m.trim()),Ne(i,s+1)+m}).join(","+r)+r+Ne(i,s)+"]":n(be(o),null,i):Object.keys(o).length+Object.getOwnPropertySymbols(o).length===0?Ne(i,s-1)+"{}":Ne(i,s-1)+"{"+r+Object.keys(o).concat(Object.getOwnPropertySymbols(o)).map(u=>{let m=(()=>{try{return n(be(o[u]),i,s+1)}catch{return n(o[u],i,s+1)}})();S(m)&&(m=m.trim());let c=typeof u=="symbol"?n(u):JSON.stringify(u);return Ne(i,s+1)+c+":"+(i?" ":"")+m}).join(","+r)+r+Ne(i,s)+"}":"undefined"}return n(se(t),e)}function St(t,e){e=e||{};let r=p(e.maxUniqueValues)?e.maxUniqueValues:7,n=p(e.minNonMissingValues)?e.minNonMissingValues:15,o=p(e.maxCorrelationThreshold)?e.maxCorrelationThreshold:1-1e-5,i=e.progress||null;if(f(t))return a(b(t).length===2&&!C(t),"The `convertToNumerical` function only works on non-jagged 2-dimensional arrays and DataFrames!"),St(new A(t));a(d(t),"You must pass a DataFrame into the `convertToNumerical` function!"),a(L(r),"`maxUniqueValues` must be a whole number!"),a(L(n),"`minNonMissingValues` must be a whole number!"),a(p(o),"`maxCorrelationThreshold` must be a number!"),h(i)||a(D(i),"If defined, `progress` must be a function!");let s={},u=!0;return t.apply((m,c)=>{i&&i(c/t.columns.length);let l=_e(m.values);if(l.type==="boolean"&&(l.values=l.values.map(N=>N?1:0)),l.type==="date"&&(l.values=l.values.map(N=>{try{return N.getTime()}catch{return NaN}})),l.type==="null")return;l.type==="number"||l.type,l.type==="object"&&(l.values=l.values.map(N=>vt(N))),l.type;let g=l.values.filter(N=>!h(N));if(!(l.values.length-g.length>n.length)){if(l.type!=="boolean"){let N=P(ae(g).toArray().filter(I=>!h(I.value)&&p(I.count)),(I,G)=>G.count-I.count);if(z(N.slice(0,r).map(I=>I.count),u)/g.length>=.9){if(N.length<2)return;let I=Je(m.name,l.values);for(;Object.keys(I).length>0;){let G=Object.keys(I)[0],Mt=I[G];delete I[G];let _t=Object.keys(s);for(let nt=0;nt<_t.length;nt++){let qr=s[_t[nt]];if(oe(Mt,qr,u)>o)return}s[G]=Mt}return}if(l.type==="object"||l.type==="string")return}if(l.type==="boolean"||l.type==="date"||l.type==="number"||l.type==="bigint"){let N=Object.keys(s);for(let O=0;O<N.length;O++){let I=s[N[O]];if(oe(l.values,I,u)>o)return}s[m.name]=l.values}}}),new A(s)}function wt(t){if(y(t)){let o=new A(wt(t.values));return o.index=t.index.slice(),o.columns=t.index.slice(),o}a(f(t),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let e=b(t);a(e.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let r=t.every(o=>typeof o=="bigint"),n=ye([e[0],e[0]]);if(t.forEach((o,i)=>n[i][i]=o),r)for(let o=0;o<n.length;o++)for(let i=0;i<n[o].length;i++)try{n[o][i]=BigInt(n[o][i])}catch{}return n}function Ot(t){let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function He(t,e,r){if(h(e)&&(e=t),d(t)){let o=new A(He(t.values,e));return o.index=t.columns.slice(),o.columns=d(e)?e.columns.slice():new A(e).columns.slice(),Ot(o)}if(d(e)){let o=new A(He(t,e.values));return o.index=d(t)?t.columns.slice():new A(t).columns.slice(),o.columns=e.columns.slice(),Ot(o)}a(f(t)&&f(e),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),a(!C(t)&&!C(e),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),a(t.length===e.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=k([t[0].length,e[0].length]);for(let o=0;o<t[0].length;o++){let i=t.map(s=>s[o]);for(let s=0;s<e[0].length;s++){let u=e.map(m=>m[s]);r?n[o][s]=oe(...te(i,u)):n[o][s]=oe(i,u)}}return Ot(we(n,-1,1))}function Cr(t,e,r){e=h(e)?1-1e-5:e,d(t)||(t=new A(t));let n=b(t);a((f(t)||d(t))&&n.length===2,"The first argument passed into the `getHighlyCorrelatedColumns` function must be a 2-dimensional array or DataFrame!"),a(p(e)&&e>=-1&&e<=1,"The second argument passed into the `getHighlyCorrelatedColumns` must be a number in the range [-1, 1] representing the threshold above which two columns will be considered to be highly correlated!");let o={};r&&(t=t.dropNaN());for(let i=0;i<n[1]-1;i++)for(let s=i+1;s<n[1];s++){let u=t.columns[i],m=t.columns[s],c=oe(t.get(u),t.get(m));c>e&&(o[u]||(o[u]=[]),o[u].push({column:m,correlation:c}),o[m]||(o[m]=[]),o[m].push({column:u,correlation:c}))}return Object.keys(o).forEach(i=>{o[i]=P(o[i],(s,u)=>s.column<u.column?-1:1)}),o}function Ve(t,e){return d(t)||y(t)?Ve(t.values):p(t)?Y(t):f(t)?(e&&(t=he(t)),ge(z(W(t,2)))):NaN}function kr(t,e){let r=T(t,{shouldDropNaNs:e}),n=e?r.nWithoutNaNs:r.n;return r.counts.values.filter(o=>p(o)||!e).map(o=>{let i=r.counts.get(o);return{value:o,count:i,percentage:i/n}})}var Tt=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5];function $n(t){return Y(t)>4.1?0:Tt[yt(gt(Y(t),0,4.1,0,Tt.length))]}function Te(t,e,r){if(d(t)||y(t))return Te(t.values,e);if(d(e)||y(e))return Te(t,e.values);a(f(t)&&f(e)&&M(b(t),b(e)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[n,o]=r?te(F(t),F(e)):[F(t),F(e)];if(n.length===0||o.length===0)return NaN;let i=T(n,{stdev:!0}),s=T(o,{stdev:!0}),u=i.mean,m=s.mean,c=i.stdev,l=s.stdev,g=n.length,N=o.length,O=(u-m)/ge(c*c/g+l*l/N);return 2*$n(O)}function At(t){let e="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(t,e,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(e)}),t}function Xe(t,e,r){if(h(e)&&(e=t),d(t)){let o=new A(Xe(t.values,e));return o.index=t.columns.slice(),o.columns=d(e)?e.columns.slice():new A(e).columns.slice(),At(o)}if(d(e)){let o=new A(Xe(t,e.values));return o.index=d(t)?t.columns.slice():new A(t).columns.slice(),o.columns=e.columns.slice(),At(o)}a(f(t)&&f(e),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),a(!C(t)&&!C(e),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),a(t.length===e.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let n=k([t[0].length,e[0].length]);for(let o=0;o<t[0].length;o++){let i=t.map(s=>s[o]);for(let s=0;s<e[0].length;s++){let u=e.map(m=>m[s]);r?n[o][s]=Te(...te(i,u)):n[o][s]=Te(i,u)}}return At(we(n,0,1))}function Dt(t){if(f(t)){a(b(t).length===2&&!C(t),"The `hunterChainSort` function only works on non-jagged 2-dimensional arrays and DataFrames!");let s=new A(t);return s.index=s.columns.slice(),Dt(s).values}a(d(t),"You must pass a 2-dimensional array or DataFrame into the `hunterChainSort` function!");let e=!0,r=t.index.slice(),n=[];for(;r.length>1;)if(n.length===0){let s=r[je(r.map(u=>z(W(t.values[t.index.indexOf(u)],2),e)),e)];r.splice(r.indexOf(s),1),n.push(s)}else{let s=n.at(-1),u=t.values[t.index.indexOf(s)].filter((c,l)=>r.includes(t.index[l])),m=r[je(u,e)];r.splice(r.indexOf(m),1),n.push(m)}n.push(r[0]);let o=J(n);return t.get(o,null)}var Ze=class t{static DROP_NAN_MODE="DROP_NAN_MODE";static DROP_MISSING_MODE="DROP_MISSING_MODE";constructor(e){let r=this;a(h(e)||e===t.DROP_NAN_MODE||e===t.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),r.mode=h(e)?t.DROP_MISSING_MODE:e,r.index=null}fit(){let e=this,r=[];return Object.values(arguments).forEach(n=>{a(d(n)||y(n),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),e.mode===t.DROP_MISSING_MODE?r.push(n.dropMissing().index):r.push(n.dropNaN().index)}),e.index=Re(...r),e}transform(){let e=this;a(!!e.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let r=Object.values(arguments).map(n=>(a(d(n)||y(n),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),n.get(e.index,null)));return r.length===1?r[0]:r}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}};function It(t,e){if(typeof t=="number")return t===0||t===1;if(typeof t=="bigint")return t===0n||t===1n;if(d(t)||y(t))return It(t.values,e);if(f(t)){e&&(t=he(t));let n=ae(t).values.toSorted();return n.length===2&&Number(n[0])===0&&Number(n[1])===1||n.length===1&&(Number(n[0])===0||Number(n[0])===1)}return!1}function Br(t){try{let e="@jrc03c/js-data-science-helpers/get-correlation-matrix";if(t[e]===Symbol.for(e))return!0;let r=T(t,{shouldDropNaNs:!0});return r.min>=-1&&r.max<=1}catch{return!1}}function Ur(t,e){(d(t)||y(t))&&(t=t.values),(d(e)||y(e))&&(e=e.values),a(M(b(t),b(e)),"`yPred` and `yTrue` must have the same shape!");let r=F(t),n=F(e),o=0;return r.forEach((i,s)=>{i===n[s]&&o++}),o/r.length}function Ee(t){return f(t)&&b(t).length===2}function Pr(t,e){return t.map(r=>e[ce(e.map(n=>ie(r,n)))])}function Qe(t,e){t=t.map(o=>o.map(i=>Number(i)));let r={},n=new Set;return e.forEach((o,i)=>{r[o]||(r[o]=[]),r[o].push(t[i]),n.add(o)}),ze(t.map((o,i)=>{let s=e[i],u=1/0,m=1/0;return n.forEach(c=>{let l=r[c],g=l.length<2?0:z(l.map(N=>ie(o,N)));c===s?u=g:g<m&&(m=g)}),(m-u)/me([u,m])}))}function ie(t,e){return z(W(Q(t,e),2),!0)}var Ce=class{constructor(e){a(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),a(L(e.k),"`k` must be a whole number!"),a(L(e.maxIterations)||h(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),a(L(e.maxRestarts)||h(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),a(typeof e.tolerance=="number"||h(e.tolerance),"`tolerance` must be a number or undefined!"),this.k=e.k,this.maxRestarts=e.maxRestarts||25,this.maxIterations=e.maxIterations||100,this.tolerance=e.tolerance||1e-4,this.centroids=null}initializeCentroids(e){return ue(e).slice(0,this.k)}getFitStepFunction(e,r){a(Ee(e),"`x` must be a matrix!"),d(e)&&(e=e.values),h(r)||a(D(r),"If defined, `progress` must be a function!");let n=this.initializeCentroids(e),o={currentRestart:0,currentIteration:0,currentCentroids:n,bestCentroids:n,bestScore:-1/0,isFinished:!1};return()=>{let i=this.predict(e,o.currentCentroids),s=[],u=ye(this.k);e.forEach((c,l)=>{let g=i[l];s[g]||(s[g]=ye(c.length)),s[g]=Se(s[g],c),u[g]++});let m=w(0,this.k).map(c=>u[c]===0?Se(o.currentCentroids[Math.floor(V()*o.currentCentroids.length)],Z(.001,dt(o.currentCentroids[0].length))):pe(s[c],u[c]));if(ie(o.currentCentroids,m)<this.tolerance?o.currentIteration=this.maxIterations-1:o.currentCentroids=m,r&&r((o.currentRestart+o.currentIteration/this.maxIterations)/this.maxRestarts,this),o.currentIteration++,o.currentIteration>=this.maxIterations){let c=this.score(e,o.currentCentroids);if(c>o.bestScore&&(o.bestScore=c,o.bestCentroids=j(o.currentCentroids)),o.currentIteration=0,o.currentRestart++,o.currentRestart>=this.maxRestarts)o.isFinished=!0,this.centroids=o.bestCentroids,r&&r(1,this);else{let l=this.initializeCentroids(e);o.currentCentroids=l}}return o}}fit(e,r){let n=this.getFitStepFunction(e,r),o;for(;!o||!o.isFinished;)o=n();return this}predict(e,r){if(r=r||this.centroids,!r)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return e.map(n=>ce(r.map(o=>ie(n,o))))}score(e,r){if(r=r||this.centroids,!r)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let o=this.predict(e,r).map(i=>r[i]);return-ie(e,o)}};var ke=class extends Ce{initializeCentroids(e){let n=[e[Math.floor(V()*e.length)]];for(;n.length<this.k;){let o=e.map(s=>ie(s,n[ce(n.map(u=>ie(s,u)),!0)])),i=pe(o,me(o,!0));n.push(e[i.findIndex(s=>V()<s)])}return n}};var et=class{constructor(e){h(e)&&(e={}),a(typeof e=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),h(e.ks)&&(e.ks=w(2,16)),a(f(e.ks),"`ks` must be an array of whole numbers!"),e.ks.forEach(r=>{a(L(r),"`ks` must be an array of whole numbers!")}),a(L(e.maxIterations)||h(e.maxIterations),"`maxIterations` must be a whole number or undefined!"),a(L(e.maxRestarts)||h(e.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),this.finalMaxIterations=e.finalMaxIterations||100,this.finalMaxRestarts=e.finalMaxRestarts||25,this.fittedModel=null,this.ks=e.ks,this.maxIterations=e.maxIterations||10,this.maxRestarts=e.maxRestarts||5,this.modelClass=e.modelClass||ke,this.tolerance=e.tolerance||1e-4}getFitStepFunction(e,r){d(e)&&(e=e.values),a(Ee(e),"`x` must be a matrix!"),h(r)||a(D(r),"If defined, `progress` must be a function!");let n={currentIndex:0,isFinished:!1,scores:[]};return()=>{let o=this.ks[n.currentIndex],i=new this.modelClass({k:o,maxRestarts:10,maxIterations:20});i.fit(e,m=>r?r((n.currentIndex+m)/(this.ks.length+1)):null);let s=i.predict(e),u=Qe(e,s);if(n.scores.length>=this.ks.length||u>1-this.tolerance?n.isFinished=!0:(n.scores.push({k:o,score:u}),n.currentIndex+1>=this.ks.length?n.isFinished=!0:n.currentIndex++),n.isFinished){let m=1,c=-1;n.scores.forEach(l=>{!isNaN(l.score)&&l.score>c&&(c=l.score,m=l.k)}),this.fittedModel=new this.modelClass({k:m,maxRestarts:this.finalMaxRestarts,maxIterations:this.finalMaxIterations}),this.fittedModel.fit(e,l=>r?r((this.ks.length+l)/(this.ks.length+1)):null),r&&r(1)}return n}}fit(e,r){let n=this.getFitStepFunction(e,r),o;for(;!o||!o.isFinished;)o=n();return this}predict(e,r){return this.fittedModel.predict(e,r)}score(e,r){return this.fittedModel.score(e,r)}get k(){return this.fittedModel.k}set k(e){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(e){a(M(b(e),b(this.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),this.fittedModel.centroids=e}};var Kn={accuracy:Ur,isMatrix:Ee,orderCentroids:Pr,silhouette:Qe,sse:ie},Rr={helpers:Kn,KMeansMeta:et,KMeansNaive:Ce,KMeansPlusPlus:ke};function qe(t,e){if(d(t)||y(t)){let i=t.copy();return i.values=qe(i.values),i}a(f(t),"The `normalize` function only works on arrays, Series, and DataFrames!");let r=T(t,{shouldDropNaNs:e,stdev:!0}),n=r.mean,o=r.stdev;return ne(t,i=>(Number(i)-n)/o)}function Ae(t,e){if(y(t)){if(y(e))return new E(Ae(t.values,e.values));{let r=t.copy();return r.values=Ae(t.values,e),r}}if(y(e)){let r=e.copy();return r.values=Ae(t,e.values),r}return a(f(t),"`project` only works on vectors!"),a(f(e),"`project` only works on vectors!"),a(b(t).length===1,"`project` only works on vectors!"),a(b(e).length===1,"`project` only works on vectors!"),Z(Number(ee(e,t))/Number(ee(e,e)),e)}function Ft(t){if(d(t)){let i=new A(Ft(t.values));return i.index=t.index.slice(),i.columns=t.columns.slice(),i}a(f(t)&&!C(t)&&b(t).length===2,"`orthonormalize` only works on matrices!");let e=U(t),r=[];e.forEach(i=>{let s=i;r.forEach(u=>{s=Q(s,Ae(s,u))}),r.push(s)});let n=!0,o=r.map(i=>pe(i,Ve(i,n)));return U(o)}function Gn(t){let e=t.counts.values;return e.length<3&&(e.length===2&&M(e.toSorted(),[0,1])||e.length===1&&(e[0]===0||e[0]===1))}function xr(t){let e=[];return t.counts.values.forEach(r=>{if(p(r)){let n=t.counts.get(r);for(let o=0;o<n;o++)e.push(r)}}),e}var tt=class{constructor(e){e=e||{},this.isAllowedToClip=h(e.isAllowedToClip)?!0:e.isAllowedToClip,this.isAllowedToTakeTheLog=h(e.isAllowedToTakeTheLog)?!1:e.isAllowedToTakeTheLog,this.maxScore=e.maxScore||5,a(q(this.isAllowedToClip),"The `isAllowedToClip` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"),a(q(this.isAllowedToTakeTheLog),"The `isAllowedToTakeTheLog` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"),a(p(this.maxScore)&&this.maxScore>=0,"The `maxScore` property on the options object passed into the `OutlierMitigator` constructor must have a non-negative number value!"),this.mad=0,this.median=0}fit(e){if(d(e)||y(e))return this.fit(e.values);if(a(f(e),"The `OutlierMitigator.fit` method only works on arrays, Series, and DataFrames!"),e.length===0)return;let r=T(e,{shouldDropNaNs:!0,median:!0});if(Gn(r))return this;let n=xr(r);return this.median=Number(r.median),this.mad=Number(T(Y(Q(n,this.median)),{median:!0}).median),this}fitAndTransform(){return this.fit(arguments[0]).transform(...arguments)}transform(){if(arguments.length>1)return Array.from(arguments).map(s=>this.transform(s));let e=arguments[0];if(d(e)||y(e))return this.transform(e.values);a(f(e),"The `OutlierMitigator.transform` method only works on arrays, Series, and DataFrames!");let r=T(e,{shouldDropNaNs:!0}),n=xr(r),o=!1;if(this.mad===0){let s=[],u=[],m=-1/0,c=1/0;n.forEach(N=>{N<this.median?(s.push(N),N>m&&(m=N)):N>this.median&&(u.push(N),N<c&&(c=N))});let l=this.median,g=this.median;if(s.length>0&&(l=m),u.length>0&&(g=c),this.mad=(g-l)/2,this.mad===0)return e;o=(this.median-l)/this.mad>this.maxScore||(g-this.median)/this.mad>this.maxScore}if(T(pe(Y(Q(n,this.median)),this.mad)).max>this.maxScore||o){let s=null,u=j(e);return this.isAllowedToClip&&(u=ne(u,m=>(m=p(m)?we(m,this.median-this.maxScore*this.mad,this.median+this.maxScore*this.mad):m,this.isAllowedToTakeTheLog&&p(m)&&(s===null||m<s)&&(s=m),m))),this.isAllowedToTakeTheLog&&(s===null&&(s=T(u).min),u=ne(u,m=>p(m)?ht(m-s+1):m)),u}else return e}};function Be(t,e,r){if(d(t)||y(t))return Be(t.values,e);if(d(e)||y(e))return Be(t,e.values);if(a(f(t),"You must pass two same-shaped numerical arrays into the `rSquared` function!"),a(f(e),"You must pass two same-shaped numerical arrays into the `rSquared` function!"),a(M(b(t),b(e)),"You must pass two same-shaped numerical arrays into the `rSquared` function!"),r){let i=te(t,e);t=i[0],e=i[1]}let n=Number(z(W(Q(t,e),2))),o=Number(z(W(Q(t,ze(t)),2)));return o===0?NaN:1-n/o}function zr(t,e,r){let n=Be(t,e,r);return bt(n)*ge(Y(n))}function Jr(){return qe(...arguments)}var rt=class{constructor(e){e=e||{},this.means=[],this.stdevs=[],this.wasFittedOnAVector=!1,this.hasBeenFitted=!1,this.shouldIgnoreNaNs=typeof e.shouldIgnoreNaNs>"u"?!1:e.shouldIgnoreNaNs}_getDataArrayAndShape(e){if(d(e))return[e.values,e.shape];if(y(e)){let n=U([e.values]);return[n,b(n)]}a(f(e),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let r=b(e);return a(r.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),r.length===1&&(r.push(1),e=U([e])),[e,r]}fit(e){let r=this._getDataArrayAndShape(e);e=r[0];let n=r[1];return this.wasFittedOnAVector=n.indexOf(1)>-1,this.means=[],this.stdevs=[],w(0,n[1]).forEach(o=>{let i=e.map(u=>u[o]),s=T(i,{shouldDropNaNs:this.shouldIgnoreNaNs,stdev:!0});this.means.push(s.mean),this.stdevs.push(s.stdev)}),this.hasBeenFitted=!0,this}fitAndTransform(){return this.fit(arguments[0]).transform(...arguments)}transform(){let e=Array.from(arguments);if(e.length>1)return e.map(s=>this.transform(s));let r=e[0];if(!this.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(d(r)){let s=new A(this.transform(r.values));return s.columns=r.columns,s.index=r.index,s}if(y(r)){let s=new E(this.transform(r.values));return s.name=r.name,s.index=r.index,s}let n=this._getDataArrayAndShape(r);r=n[0];let o=n[1];a(o[1]===this.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let i=r.map(s=>s.map((u,m)=>(Number(u)-Number(this.means[m]))/Number(this.stdevs[m])));return this.wasFittedOnAVector?F(i):i}untransform(e){if(!this.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(d(e)){let i=new A(this.untransform(e.values));return i.columns=e.columns,i.index=e.index,i}if(y(e)){let i=new E(this.untransform(e.values));return i.name=e.name,i.index=e.index,i}let r=this._getDataArrayAndShape(e);e=r[0];let n=r[1];a(n[1]===this.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=e.map(i=>i.map((s,u)=>s*this.stdevs[u]+this.means[u]));return this.wasFittedOnAVector?F(o):o}};function Vr(){let t=Array.from(arguments),e=t.filter(g=>f(g)||d(g)||y(g)),r=t.find(g=>!e.includes(g)&&typeof g=="object")||{},n=h(r.shouldShuffle)?!0:r.shouldShuffle,o=h(r.testSize)?.1:r.testSize;a(q(n),"If passing an options object to the `trainTestSplit` function and including a `shouldShuffle` property on that object, then the value of that property must be a boolean!"),a(p(o)&&o>0&&o<1,"If passing an options object to the `trainTestSplit` function and including a `testSize` property on that object, then the value of that property must be a number between 0 and 1 (exclusive on both ends)!"),a(e.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let i=e.map(g=>b(g)[0]);a(B(i).length===1,`All datasets passed into the \`trainTestSplit\` function must have the same length at their shallowest dimension! The lengths of the datasets you provided, though, are: ${i.join(", ")}`);let s=[],u=n?ue(w(0,i[0])):w(0,i[0]),m=K((1-o)*u.length),c=u.slice(0,m),l=u.slice(m);return e.forEach(g=>{if(d(g))s.push(g.get(c,null)),s.push(g.get(l,null));else if(y(g))s.push(g.get(c)),s.push(g.get(l));else{let N=[],O=[];g.forEach((I,G)=>{c.includes(G)?N.push(I):O.push(I)}),s.push(N),s.push(O)}}),s}typeof globalThis<"u"&&(globalThis.JSDataScienceHelpers=jt);})();
