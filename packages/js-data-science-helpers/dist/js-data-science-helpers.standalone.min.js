(()=>{var Js=Object.create;var fr=Object.defineProperty;var Ys=Object.getOwnPropertyDescriptor;var Vs=Object.getOwnPropertyNames;var $s=Object.getPrototypeOf,Ks=Object.prototype.hasOwnProperty;var Jt=(e=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(e,{get:(t,n)=>(typeof require<"u"?require:t)[n]}):e)(function(e){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+e+'" is not supported')});var Us=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of Vs(t))!Ks.call(e,s)&&s!==n&&fr(e,s,{get:()=>t[s],enumerable:!(r=Ys(t,s))||r.enumerable});return e};var Yt=(e,t,n)=>(n=e!=null?Js($s(e)):{},Us(t||!e||!e.__esModule?fr(n,"default",{value:e,enumerable:!0}):n,e));var zs=Object.defineProperty,Ls=(e,t,n)=>t in e?zs(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,wr=(e,t,n)=>(Ls(e,typeof t!="symbol"?t+"":t,n),n);function b(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var qs=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),Ee=class extends Error{constructor(e){qs()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function f(e,t){if(!e)throw new Ee(t)}var Dr=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function v(e){return e===null||typeof e>"u"}var Gs=Dr.map(e=>e.name);function g(e){try{return e instanceof Array?!0:v(e.constructor)?!1:Dr.indexOf(e.constructor)>-1||Gs.indexOf(e.constructor.name)>-1}catch{return!1}}function p(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function J(e){return typeof e=="function"}function Se(e){return typeof e=="object"&&!v(e)&&!g(e)}function N(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function tt(e,t){if(p(e)){let o=tt(e.values,t);return o.length>0&&b(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o.length>1&&b(o[1])&&o[1]>=0&&o[1]<e.columns.length&&(o[1]=e.columns[o[1]]),o}if(N(e)){let o=tt(e.values,t);return o.length>0&&b(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o}if(f(Se(e)||g(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!J(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Se(o)){u.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let l=0;l<a.length;l++){let c=a[l],h=o[c];if(i(h))return[c];let d=n(h,i,u);if(d&&d.length>0)return[c].concat(d)}}else if(g(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let c=n(l,i,u);if(c&&c.length>0)return[a].concat(c)}}else if(i(o))return[];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}function U(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(g(n))return n instanceof Array?n.map(s=>U(s)):n.slice();if(N(n)){let s=n.copy();return s.values=U(s.values),s}if(p(n)){let s=n.copy();return s.values=U(n.values),s}if(n instanceof Date)return new Date(n.getTime());n=nt(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(s=>{r[s]=U(n[s])}),r}else return n}return t(nt(e))}function nt(e){function t(s,o,i){if(o=o||[],i=i||"",o.indexOf(s)>-1){let u=i.split("/").slice(i.startsWith("/")?1:0);if(u.some((l,c)=>{let h=u.slice(0,u.length-c-1),d=n;return h.forEach(E=>{d=d[E]}),d===s}))return`<reference to "${n===s?"/":"/"+tt(n,s).join("/")}">`}return typeof s=="object"?s===null?null:(o.push(s),g(s)?typeof s.constructor<"u"&&s.constructor.name!=="Array"?s.slice():s.map((u,a)=>t(u,o,i+"/"+a)):(Object.keys(s).concat(Object.getOwnPropertySymbols(s)).forEach(u=>{s[u]=t(s[u],o,i+"/"+u.toString())}),s)):s}let n=e,r=t(n);if(p(e)){let s=e.copy();s._values=r.values,s._columns=r.columns,s._index=r.index,r=s}if(N(e)){let s=e.copy();s.name=r.name,s._values=r.values,s._index=r.index,r=s}return r}function Ie(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var hr=["number","int","float","bigint"];function L(e,t){function n(r,s){let o=typeof r,i=typeof s;if(o!==i&&!hr.includes(o)&&!hr.includes(i))return!1;if(o==="undefined"&&i==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")try{let u=r.toString(),a=s.toString();return u===a}catch{return!1}if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{if(Ie(r))return Ie(s)?r.getTime()===s.getTime():!1;if(Ie(s))return!1;if(r instanceof RegExp&&s instanceof RegExp)return r.toString()===s.toString();if(g(r)!==g(s))return!1;let u=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(s).concat(Object.getOwnPropertySymbols(s));if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let c=u[l];if(!n(r[c],s[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(nt(e),nt(t))}}function Dt(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Ws=Dt(16),Hs=Dt(16),Xs=Dt(16),Zs=Dt(16),Qs=Dt(16),xs=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)g(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Ws:v(e)?Hs:J(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Qs:e===1/0?Xs:e===-1/0?Zs:typeof e=="bigint"?e.toString():p(e)?e.toJSONString():N(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!v(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function K(e){if(p(e)||N(e))return K(e.values);f(g(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(s=>{g(s)?r=r.concat(t(s)):r.push(s)}),r}return t(e)}function M(e,t){t=t||{};let n=new xs,r={},s=K(e),o=[],i=-1/0,u=1/0,a=!1,l=0;for(let h of s){if(typeof h=="bigint"&&(a=!0),!t.shouldDropNaNs||b(h))try{h>i&&(i=h),h<u&&(u=h),l+=Number(h),o.push(h)}catch{i=NaN,u=NaN,l=NaN}n.increment(h)}let c=l/o.length;if(r.counts=n,r.max=i,r.mean=c,r.min=u,r.n=s.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=o.length),t.mode){let h=Array.from(n.values.map(F=>[F,n.get(F)])).toSorted((F,I)=>I[1]-F[1]),d=h[0][1],E=[];for(let F of h)if(F[1]==d)E.push(F[0]);else break;r.mode=E.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let h=o.toSorted((E,F)=>Number(E)-Number(F)),d=Math.floor(h.length/2);if(h.length%2===0){let E=h[d-1],F=h[d];if(r.median=(Number(E)+Number(F))/2,a&&typeof E=="bigint"&&typeof F=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=h[d]}if(t.stdev||t.variance){let h=0;for(let E of o)h+=Math.pow(Number(E)-c,2);h/=o.length;let d=Math.sqrt(h);r.stdev=d,r.variance=h}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(h=>{try{return BigInt(h)}catch{return h}}))}return r}function Pe(e,t){let{counts:n}=M(e);return v(t)||(J(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{L(r,t)||n.delete(r)})),n}function Nn(e){if(p(e)||N(e))return Nn(e.values);if(g(e)){let t=!1,n=!1,r=null;for(let s of e){if(Nn(s))return!0;if(g(s)){if(r===null)r=s.length;else if(s.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function G(e){return Nn(nt(e))}function qt(e){if(p(e)||N(e))return qt(e.values);f(g(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(g(e[t]))return!0;return!1}var Ze="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Q(e){f(!v(e),Ze),g(e)||(e=[e]),f(!qt(e),Ze),f(e.length>0,Ze);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),f(b(t),Ze),f(t>=0,Ze),f(Math.floor(t)===t,Ze),f(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(Q(e.slice(1)));return n}}function le(e){if(p(e)||N(e)){let n=e.copy();return n.values=le(n.values),n.index=le(n.index),n}f(g(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function C(e,t,n=1){f(!v(e)&&!v(t)&&!v(n),"You must pass two numbers and optionally a step value to the `range` function!"),f(b(e)&&b(t)&&b(n),"You must pass two numbers and optionally a step value to the `range` function!"),f(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,s=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let i=e;e=t+n,t=i+n}let o=[];for(let i=e;i<t;i+=n)if(s)try{o.push(BigInt(i))}catch{o.push(i)}else o.push(i);return r&&(o=le(o)),o}function Et(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var eo=Et(256),to=Et(256),no=Et(256),ro=Et(256),so=Et(256);function X(e){if(p(e)||N(e))return X(e.values);f(g(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return K(e).forEach(r=>{let s=typeof r=="object"&&r===null?eo:v(r)?to:J(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+so:r===1/0?no:r===-1/0?ro:typeof r=="bigint"?r.toString():p(r)?r.toJSONString():N(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||t.push(r),n[s]=!0}),t}function Er(e){if(g(e)){let t=Er(e[0]);return[e.length].concat(t||[])}else return}function w(e){return p(e)||N(e)?w(e.values):(f(g(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Er(e))}function Sr(e,t,n){if(v(n)&&(n=0),f(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),g(t)){f(!G(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=w(t);if(r.length===1)if(n===0){let s=e.copy();s._values.push(t);let o=Math.max(e.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(e.shape[0],r[0]),o=e.copy();for(C(0,s).forEach(i=>{i>=o._values.length&&o._values.push(Q(e.shape[1])),o._values[i].push(t[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...t.map(i=>i.length).concat([e.shape[1]])),o=e.copy();for(o._values=o._values.concat(t).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...t.map(u=>u.length))+e.shape[1],o=Math.max(e.shape[0],r[0]),i=e.copy();for(C(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(Q(e.shape[1])),i._values[u]=i._values[u].concat(t[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new Ee("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(N(t)){let r=Sr(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(p(t))if(n===0){let r=e.copy(),s=X(r._columns.concat(t._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),t.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(t._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(e._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((s,o)=>{let i=t._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(t._values[i]):r._values[o]=r._values[o].concat(Q(t.shape[1]))}),t._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Q(r._columns.length).concat(t._values[o])))}),r._columns=r._columns.concat(t._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new Ee("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function oo(e,t,n,r,s){if(s=s||0,f(J(r),"The first parameter to the `apply` method must be a function."),f(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new t(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let c=r(l,a,n);c instanceof t?o[u]=c.values:o[u]=c,v(i)&&(i=c instanceof t||g(c))}),i){let u=new e(o);return u.index=n.index,u}else{let u=new t(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new t(u);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return v(o)&&(o=c instanceof t||g(c)),c instanceof t?c.values:c});if(o){let u=new e(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new t(i);return u.index=n.index,u}}}function B(e){return typeof e=="string"}function io(e,t,n,r,s){let o=u=>u instanceof e,i=u=>u instanceof t;if(v(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(Se(r)){let u=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new Ee("You must pass a DataFrame, Series, or object into the `assign` method!")}else{f(B(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),f(g(s)&&!G(s)&&w(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}function uo(e,t){if(t.isEmpty)return new e;let n=new e(U(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function ao(e,t,n,r,s){v(r)&&(r=[]),v(s)&&(s=[]),(B(r)||b(r))&&(r=[r]),(B(s)||b(s))&&(s=[s]),f(g(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(g(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(w(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(w(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof t){let a=new e;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}function Fr(e){return b(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function rt(e){return Fr(e)&&e>=0}function lo(e,t,n,r,s,o){r=r||0,f(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,f(rt(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",f(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let c=0;for(let h=0;h<l.length;h++){let d=l[h];if(v(d)&&c++,c>=o)return[]}}else if(s==="any")for(let c=0;c<l.length;c++){let h=l[c];if(v(h))return[]}else if(s==="all"){for(let c=0;c<l.length;c++){let h=l[c];if(!v(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(w(l).length<2)return new e;u.values=l;let c=u.get(null,a);if(v(c))return new e;B(c)&&(c=[c]),c instanceof t&&(c=c.values),u.index=c,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let E=u.values.map(I=>I[d]),F=i(E);F.length>0&&(l[h]=F)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=u.index,c}return u}function ze(e){if(p(e)||N(e))return e.dropNaN(...Object.values(arguments).slice(1));f(g(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(ze(n))}catch{if(b(n))return t.push(n)}}),t}function co(e,t,n,r,s){n=n||0,f(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,f(rt(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",f(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=ze(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=t.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new e}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new e}return i}function mr(e){let t={};return K(e).forEach((n,r)=>{t[n]=r}),t}function Qe(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function fo(e,t,n,r,s){f(J(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),v(s)&&(s=0),f(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=mr(o.index),u=mr(o.columns);if(s===0){let a=0,l=o.values.filter((c,h)=>{let d=new t(c);d.name=n.index[h],d.index=n.columns;let E=r(d,h,n);return E?a++:delete i[o.index[h]],E});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Qe(i)[0],c.index=Qe(u),c}o.values=l,o.index=Qe(i)}else if(s===1){o=o.transpose();let a=0,l=o.values.filter((c,h)=>{let d=new t(c);d.name=n.columns[h],d.index=n.index;let E=r(d,h,n);return E?a++:delete u[o.index[h]],E});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=Qe(u)[0],c.index=Qe(i),c}o.values=l,o.index=Qe(u),o=o.transpose()}return o}function ho(e,t,n){(B(t)||b(t))&&(t=[t]),(B(n)||b(n))&&(n=[n]);for(let s in t)typeof t[s]=="bigint"&&(t[s]=Number(t[s]));for(let s in n)typeof n[s]=="bigint"&&(n[s]=Number(n[s]));let r=X((t||[]).concat(n||[]).map(s=>typeof s));return f(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&f(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(f(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),f(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),v(t)||(t=t.map(s=>{if(B(s))return f(e.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(b(s))return f(s>=0,`Index ${s} is out of bounds!`),f(Math.floor(s)===s,"Row numbers must be integers!"),f(s<e.index.length,`Index ${s} is out of bounds!`),e.index[s]})),v(n)||(n=n.map(s=>{if(B(s))return f(e.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(b(s))return f(s>=0,`Column ${s} is out of bounds!`),f(Math.floor(s)===s,"Column numbers must be integers!"),f(s<e.columns.length,`Column ${s} is out of bounds!`),e.columns[s]})),e.getSubsetByNames(t,n)}function mo(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function re(e,t){if(v(t)&&(t=mo),p(e)||N(e))return e.sort(...Object.values(arguments).slice(1));f(g(e),"The `sort` function only works on arrays, Series, and DataFrames!"),f(J(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function go(e){let t=e.toLowerCase(),n="";for(let s=0;s<t.length;s++){let o=t[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function dr(e,t,n){v(n)?n=t.columns:B(n)&&(n=[n]);let r={};n.forEach(o=>{f(B(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=t.columns.indexOf(o);f(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=t.values.map(l=>l[i]),a=re(X(u));u.forEach(l=>{a.forEach(c=>{let h=o+"_"+go(c.toString());r[h]||(r[h]=[]),l===c?r[h].push(1):r[h].push(0)})})});let s=new e(r);return s.index=t.index,s}function po(e,t,n){let r=e.shape;v(t)&&(t=C(0,r[0])),v(n)&&(n=C(0,r[1])),b(t)&&(t=[t]),b(n)&&(n=[n]),f(g(t)&&g(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(w(t).length===1&&w(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(t.length>0,"The `rowIndices` array must contain at least one index."),f(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(i=>{f(rt(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(i<e.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{f(rt(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(i<e.columns.length,`The column index ${i} is out of bounds.`)});let s=t.map(i=>e.index[i]),o=n.map(i=>e.columns[i]);return e.getSubsetByNames(s,o)}function yo(e,t,n,r,s){v(r)&&(r=n.index),v(s)&&(s=n.columns),B(r)&&(r=[r]),B(s)&&(s=[s]),f(g(r)&&g(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(w(r).length===1&&w(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(r.length>0,"The `rows` array must contain at least one row name."),f(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{f(B(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{f(B(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return o[0][0];if(r.length===1){let u=new t(o[0]);return u.name=r[0],u.index=s,u}if(s.length===1){let u=new t(o.map(a=>a[0]));return u.name=s[0],u.index=r,u}let i=new e(o);return i.columns=s,i.index=r,i}function bo(e,t,n){function r(d,E){return B(d)&&d.length>E?d.substring(0,E-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=Math.floor(s/2),i=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,u=Math.floor(i/2),a=s>n.index.length?null:C(0,o).concat(C(n.index.length-o,n.index.length)),l=i>n.columns.length?null:C(0,u).concat(C(n.columns.length-u,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),s<=n.index.length&&(c._index.splice(o,0,"..."),c._values.splice(o,0,C(0,c.columns.length).map(()=>"..."))),i<=n.columns.length&&(c._columns.splice(u,0,"..."),c._values=c._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return c instanceof t?(c.values=c.values.map(d=>r(d,h)),c.name=r(c.name,h),c.index=c.index.map(d=>r(d,h))):(c.values=c.values.map(d=>d.map(E=>r(E,h))),c.columns=c.columns.map(d=>r(d,h)),c.index=c.index.map(d=>r(d,h))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function xe(e,t){f(b(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function vo(e,t){let n=t?e:e.copy();return n.index=C(0,e.shape[0]).map(r=>"row"+xe(r,(n.index.length-1).toString().length)),n}function St(e,t){if(p(e)||N(e))return St(e.values,t);f(g(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=K(e),r=!1,s=1;for(let o of n){if(!b(o))if(t)o=1;else return NaN;typeof o=="bigint"&&(r=!0,o=Number(o)),s*=o}if(r)try{return BigInt(s)}catch{}return s}catch{return NaN}}function No(e){return Fr(e)&&e>0}function wt(e,t){if(p(e)||N(e))return wt(e.values,t);if(f(g(e),"The first argument passed into the `reshape` function must be an array!"),b(t)&&(t=[t]),f(g(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),f(w(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(o=>(typeof o=="bigint"&&(o=Number(o)),f(No(o),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(o))),t.length===0)return K(e);let n=K(e);if(t.length===1&&t[0]===n.length)return n;f(St(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=Math.floor(n.length/t[0]);for(let o=0;o<t[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(wt(i,t.slice(1)))}return r}var Or=Math.pow(2,64),R=[];Tr(Math.floor(Math.random()*Or));function wo(e,t){e=H(e);function n(){e+=H("0x9e3779b97f4a7c15");let s=U(e);return s=(s^s>>BigInt(30))*H("0xbf58476d1ce4e5b9"),s=(s^s>>BigInt(27))*H("0x94d049bb133111eb"),s^s>>BigInt(31)}let r=[];for(let s=0;s<t;s++)r.push(n());return r}function H(e){return BigInt.asUintN(64,BigInt(e))}function gr(e,t){return e=H(e),t=BigInt(t),H(H(e<<t)|H(e>>H(BigInt(64)-t)))}function Tr(e){if(typeof e=="bigint"&&(e=Number(e)),v(e))return U(R);{f(b(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=wo(Math.floor(e),4);R[0]=t[0],R[1]=t[1],R[2]=t[2],R[3]=t[3]}}function pr(){let e=H(gr(R[0]+R[3],23)+R[0]),t=H(R[1]<<BigInt(17));return R[2]=H(R[2]^R[0]),R[3]=H(R[3]^R[1]),R[1]=H(R[1]^R[2]),R[0]=H(R[0]^R[3]),R[2]=H(R[2]^t),R[3]=gr(R[3],45),Math.floor(Number(e))/Or}function pe(e){return v(e)?pr():(g(e)||(e=[e]),wt(Q(St(e)).map(pr),e))}function Re(e){if(p(e)||N(e))return e.shuffle(...Object.values(arguments).slice(1));f(g(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let s=Math.floor(pe()*n.length);t.push(n.splice(s,1)[0])}return t}function Do(e,t){return v(t)&&(t=0),f(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?Re(e.index):null,t===1?Re(e.columns):null)}function ce(e){return typeof e=="boolean"}function Eo(e,t,n){return J(t)?So(e,t,n):Fo(e,t,n)}function So(e,t,n){if(n=v(n)?0:n,f(J(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),f(b(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=re(e.index,(s,o)=>t(e.get(s,null),e.get(o,null)));return e.get(r,null)}else{let r=re(e.columns,(s,o)=>t(e.get(null,s),e.get(null,o)));return e.get(null,r)}}function Fo(e,t,n){let r=e.copy(),s=pe().toString();r=r.assign(s,r.index),v(t)&&(t=[s],n=[!0]),(b(t)||B(t))&&(t=[t],(ce(n)||B(n))&&(n=[n])),f(g(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),f(w(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),v(n)&&(n=C(0,t.length).map(()=>!0)),f(g(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),f(w(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),f(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(i=>{if(f(B(i)||b(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),B(i)){let u=r.columns.indexOf(i);return f(u>-1,`The column "${i}" does not exist!`),u}if(b(i))return f(rt(i),"Column indices must be whole numbers!"),f(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(f(B(i)||ce(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),B(i)){let u=i.trim().toLowerCase();return f(u==="ascending"||u==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),u==="ascending"}if(ce(i))return i}),r.values=re(r.values,(i,u)=>{let a=0;for(;i[t[a]]===u[t[a]]&&a<t.length;)a++;let l=n[a];if(i[t[a]]===u[t[a]])return 0;if(i[t[a]]<u[t[a]])return l?-1:1;if(i[t[a]]>u[t[a]])return l?1:-1});let o=r.columns.indexOf(s);return r.index=r.values.map(i=>i[o]),r=r.dropColumns(s),r}function Oo(e,t){v(t)?t=0:f(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,s)=>{let o={};e.columns.forEach((i,u)=>{o[i]=e.values[s][u]}),n[r]=o}):e.columns.forEach((r,s)=>{let o={};e.index.forEach((i,u)=>{o[i]=e.values[u][s]}),n[r]=o}),n}function _r(e,t){return JSON.stringify(e.toObject(t))}async function To(e,t,n){let r=_r(e,n),s=!1,o=!1,i,u;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new Ee(i):typeof module<"u"?new Ee(u):new Ee("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function _o(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function x(e){if(p(e)||N(e))return e.transpose();f(g(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=w(e);if(f(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return le(e);if(t.length===2){let n=Q(le(t));for(let r=0;r<t[0];r++)for(let s=0;s<t[1];s++)n[s][r]=e[r][s];return n}}function Ar(e,t,n){if(N(n))return new e(t.values.concat(n.values));if(g(n)){let r=w(n);f(r.length===1&&!qt(r),"Only vectors can be appended to Series!");let s=t.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(t.values.length+i))}),s}return Ar(t,[n])}function Ao(e,t){f(J(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,s)=>t(r,s)),n}function Io(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,s)=>v(r)?!1:(n.push(t.index[s]),!0)),t._index=n,t}function Mo(e,t){let n=[],r=[];t.values.forEach((o,i)=>{b(o)&&(r.push(o),n.push(t.index[i]))});let s=new e(r);return s.name=t.name,s.index=n,s}function Co(e,t,n){let r=t.copy(),s=U(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new e,r.name=t.name,r):(r.values=i,r.index=s,r)}function jo(e,t){(B(t)||b(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=X((t||[]).map(r=>typeof r));return f(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&f(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(f(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),f(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),v(t)||(t=t.map(r=>{if(typeof r=="string")return f(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return f(r>=0,`Index ${r} is out of bounds!`),f(Math.floor(r)===r,"Indices must be integers!"),f(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function Bo(e,t){let n=e.shape;v(t)&&(t=C(0,n[0])),f(g(t),"The `indices` array must be 1-dimensional array of whole numbers."),f(w(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),f(t.length>0,"The `indices` array must contain at least one index."),t.forEach(s=>{f(rt(s),"The `indices` array must be a 1-dimensional array of whole numbers."),f(s<e.index.length,`The row index ${s} is out of bounds.`)});let r=t.map(s=>e.index[s]);return e.getSubsetByNames(r)}function ko(e,t,n){v(n)&&(n=t.index),f(g(n),"The `indices` array must be a 1-dimensional array of strings."),f(w(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),f(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{f(B(o),"The `indices` array must contain only strings."),f(t.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>t.values[t.index.indexOf(o)]);if(r.length===1)return r[0];let s=new e(r);return s.index=n,s.name=t.name,s}function Po(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(C(0,n/2).concat(C(t.index.length-n/2,t.index.length)));let s=U(t.index);s.splice(Math.floor(s.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(s)}let r={};return t.values.forEach((s,o)=>{let i={};i[t.name]=s,r[t.index[o]]=i}),console.table(r),console.log("Shape:",e.shape,`
`),e}function Ro(e){let t=e.copy();return t.get(Re(t.index))}function Jo(e,t,n){n=n||((a,l)=>a<l?-1:1),f(v(n)||J(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=x([t.values,t.index]),s=re(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new e;return u._values=o,u._index=i,u.name=t.name,u}function Yo(e,t){let n=x([t.values,t.index]);n=x(re(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function Vo(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var yr=Symbol.for("@jrc03c/js-math-tools/series");function $o(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===yr}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:yr}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(s){f(g(s),"The new values must be a 1-dimensional array!");let o=w(s);f(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<this._index.length?this._index=this._index.slice(0,o[0]):o[0]>this._index.length&&(this._index=this._index.concat(C(this._index.length,o[0]).map(i=>"item"+xe(i,(s.length-1).toString().length)))),this._values=s}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(s){f(g(s),"The new index must be a 1-dimensional array of strings!"),f(s.length===this.shape[0],"The new index must be the same length as the old index!"),f(w(s).length===1,"The new index must be a 1-dimensional array of strings!"),s.forEach(o=>{f(B(o),"All of the row names must be strings!")}),this._index=s}}),r){if(r instanceof t)this.name=r.name,this.values=U(r.values),this.index=U(r.index);else if(g(r)){let s=w(r);f(s.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let s=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(u=>u.toString());f(s.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=s[0],i=r[o];f(w(i).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=o,this.values=i.slice()}}}get shape(){return w(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!v(r)).length===0}clear(){let r=this.copy();return r.values.forEach((s,o)=>{r.values[o]=void 0}),r}get(r){return jo(this,r)}getSubsetByNames(r){return ko(t,this,r)}getSubsetByIndices(r){return Bo(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(le(this.values));return r.index=le(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=C(0,this.shape[0]).map(s=>"item"+xe(s,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=U(this.values),r._index=U(this.index),r.name=this.name,r}append(r){return Ar(t,this,r)}apply(r){return Ao(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Io(this,r,s)}dropNaN(){return Mo(t,this)}toObject(){return Vo(this)}print(){return Po(this)}shuffle(){return Ro(this)}sort(r){return Jo(t,this,r)}sortByIndex(){return Yo(t,this)}filter(r){return Co(t,this,r)}toDataFrame(){let r=new e(x([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=le(r.values),r.index=le(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var br=Symbol.for("@jrc03c/js-math-tools/dataframe");function Vt(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(pe()*t.length)];return n}var A=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===br}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:br}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!v(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){f(g(t),"The new values must be a 2-dimensional array!");let n=w(t);f(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(C(this._index.length,n[0]).map(r=>"row"+xe(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(C(this._columns.length,n[1]).map(r=>"col"+xe(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){f(g(t),"The new columns list must be a 1-dimensional array of strings!"),f(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),f(w(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Vt(8):r.trim()));let n=(()=>{let r=Pe(t),s={};return r.values.forEach(o=>{s[o]=r.get(o)}),s})();t=t.map(r=>n[r]>1?r+"_"+Vt(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){f(g(t),"The new index must be a 1-dimensional array of strings!"),f(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),f(w(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Vt(8):r.trim()));let n=(()=>{let r=Pe(t),s={};return r.values.forEach(o=>{s[o]=r.get(o)}),s})();t=t.map(r=>n[r]>1?r+"_"+Vt(8):r),this._index=t}}),f(v(e)||Se(e)||g(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof A)this.values=U(e.values),this.columns=U(e.columns),this.index=U(e.index);else if(g(e)){let t=w(e);f(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),f(!G(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(o=>o.toString());let t=[],n=null,r=null;this._columns.forEach(o=>{v(r)&&(n=o,r=e[o].length),f(e[o].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${o}" points to an array containing ${e[o].length} items.`),r=e[o].length;let i=e[o];t.push(i)}),this._values=x(t);let s=w(this.values);this._index=C(0,s[0]).map(o=>"row"+xe(o,(s[0]-1).toString().length))}}get shape(){return w(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new A(Q(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return ho(this,e,t)}getSubsetByNames(e,t){return yo(A,z,this,e,t)}getSubsetByIndices(e,t){return po(this,e,t)}getDummies(e){return dr(A,this,e)}oneHotEncode(e){return dr(A,this,e)}transpose(){let e=new A(x(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return vo(this,e)}copy(){return uo(A,this)}assign(e,t){return io(A,z,this,e,t)}apply(e,t){return oo(A,z,this,e,t)}dropMissing(e,t,n){return lo(A,z,this,e,t,n)}dropNaN(e,t,n){return co(A,this,e,t,n)}drop(e,t){return ao(A,z,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return Oo(this,e)}toObject(){return _o(this)}toJSONString(e){return _r(this,e)}saveAsJSON(e,t){return To(this,e,t)}print(){return bo(A,z,this)}sort(e,t){return Eo(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return fo(A,z,this,e,t)}shuffle(e){return Do(this,e)}append(e,t){return Sr(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},z=$o(A);function Je(e,t){return M(e,{shouldDropNaNs:t}).max}function k(e){return f(J(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return g(a)?!0:N(a)?(n=!0,s.push(a),!0):p(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{f(L(g(u)?w(u):u.shape,g(i[a+1])?w(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=Je(i.map(l=>l.length?l.length:l.values.length)),a=C(0,u).map(l=>{let c=Object.keys(arguments).map(h=>g(arguments[h])?arguments[h][l]:N(arguments[h])||p(arguments[h])?arguments[h].values[l]:arguments[h]);return t(...c)});if(r)try{if(o.length===1&&L(w(o[0]),w(a))){let l=new A(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new A(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new z(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new z(a)}catch{return a}return a}else return e(...arguments)}}function Ko(e){try{return b(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var se=k(Ko);function Uo(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!b(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Ue=k(Uo);function zo(e,t){try{return t(e)}catch{return NaN}}var Ce=k(zo);function Lo(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var qo=k(Lo);function Go(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var Wo=k(Go);function Ho(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var Xo=k(Ho);function st(e,t){if(p(e)){let n=st(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(N(e)){let n=st(e.values,t);return e.index[n]}f(g(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=tt(e,Je(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Ir(e,t){return M(e,{shouldDropNaNs:t}).min}function Me(e,t){if(p(e)){let n=Me(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(N(e)){let n=Me(e.values,t);return e.index[n]}f(g(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=tt(e,Ir(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function ne(e,t){if(p(e)||N(e))return e.apply(n=>ne(n,t));if(g(e))return e.map(n=>ne(n,t));if(t==="null")return null;if(t==="number"){if(v(e))return NaN;let n=ne(e,"boolean");if(ce(n))return n?1:0;try{JSON.parse(e)}catch{let o=ne(e,"date");if(Ie(o))return o.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=ne(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return ne(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(ne(e,"int"));if(t==="boolean"){if(ce(e))return e;if(b(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Ie(e))return e;if(v(e))return null;let n=parseFloat(e);if(!isNaN(n)){let s=new Date(e);return Ie(s)?s:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Se(e))return e;let n=ne(e,"boolean");if(ce(n))return null;try{let s=ne(e,"number");if(b(s))return JSON.parse(e),null}catch{}let r=ne(e,"date");if(r)return r;try{let s=JSON.parse(e);return g(s)?s.map(o=>ne(o,t)):s}catch{return null}}if(t==="string")return v(e)?L(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function Zo(e){try{return b(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var Qo=k(Zo);function xo(e,t){try{if(!b(e))return NaN;if(typeof e=="bigint")return e;if(v(t))t=1e-10;else if(!b(t))return NaN;return se(e)<t?0:e}catch{return NaN}}var ei=k(xo);function wn(e){if(p(e)||N(e)){let t=e.copy();return t.values=wn(t.values),t}if(g(e))return e.map(t=>wn(t));try{let t=JSON.parse(e);return b(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var he=k(wn);function Mr(e,t,n){try{return b(e)?b(t)?b(n)?typeof e=="bigint"?BigInt(Mr(he(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var Le=k(Mr);function zt(e,t){function*n(r,s){if(s>r.length)yield r;else if(s<=0)yield[];else if(r.length<2)yield r;else for(let o=0;o<r.length;o++){let i=r[o],u=r.slice(o+1);if(!(u.length<s-1)&&s-1>=0)for(let a of zt(u,s-1))yield[i].concat(a)}}return p(e)||N(e)?zt(e.values,t):(f(g(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),f(b(t)&&he(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(K(e),t))}function Cr(e,t){let n=[];for(let r of zt(e,t))n.push(r.slice());return n}function Gt(){let e=Object.values(arguments).map(n=>p(n)||N(n)?X(n.values):(f(g(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),X(n)));return X(e).filter(n=>e.every(r=>r.findIndex(s=>L(s,n))>-1))}var bt=class{constructor(e){f(v(e)||e===bt.DROP_NAN_MODE||e===bt.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=v(e)?bt.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(g(t)){let n=w(t);if(n.length===1)t=new z(t);else if(n.length===2)t=new A(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}f(p(t)||N(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===bt.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=Gt(...e),this}transform(){f(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(g(t)){let n=w(t);if(n.length===1)return new z(t).get(this.index).values;if(n.length===2)return new A(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return f(p(t)||N(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},ot=bt;wr(ot,"DROP_NAN_MODE","DROP_NAN_MODE");wr(ot,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Nt(e,t,n,r){if(N(e))return Nt(e.values,t,n,r);if(N(t))return Nt(e,t.values,n,r);if(f(g(e)&&g(t)&&w(e).length===1&&w(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),f(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Nt(...new ot().fitAndTransform(e,t),!1,r);try{let s=M(e,{stdev:r}),o=M(t,{stdev:r}),i=Number(s.mean),u=Number(o.mean);if(!b(i)||!b(u))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let h=e[c],d=t[c];if(!b(h))return NaN;if(!b(d))return NaN;typeof h=="bigint"&&(h=Number(h)),typeof d=="bigint"&&(d=Number(d)),l+=(h-i)*(d-u)}return r?[l/e.length,s,o]:l/e.length}catch{return NaN}}function ye(e,t,n){if(N(e))return ye(e.values,t,n);if(N(t))return ye(e,t.values,n);f(g(e)&&g(t)&&w(e).length===1&&w(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),f(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[s,o,i]=Nt(e,t,n,!0),u=o.stdev*i.stdev;return s/u}catch{return NaN}}function ti(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var ni=k(ti),ri=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Dn(e,t){if(p(e)||N(e))return Dn(e.values,t);if(p(t)||N(t))return Dn(e,t.values);f(g(e)&&g(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=X(e),r=X(t),s=[];return n.forEach(o=>{r.findIndex(i=>L(i,o))<0&&s.push(o)}),s}function jr(e,t){try{if(!b(e))return NaN;if(!b(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=jr(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var me=k(jr);function Br(e){try{if(!b(e))return NaN;if(typeof e=="bigint"){let t=Br(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Ye=k(Br);function si(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!b(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var kr=k(si);function Fe(){return kr(...arguments)}function de(e,t){return Ue(e,Fe(t,-1))}function ee(e,t){return M(e,{shouldDropNaNs:t}).sum}function En(e,t){if(b(e)&&b(t))return se(e-t);if(p(e)||N(e))return En(e.values,t);if(p(t)||N(t))return En(e,t.values);g(e)&&g(t)&&f(L(w(e),w(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Ye(ee(me(de(e,t),2)))}catch{return NaN}}function je(e,t){return Fe(e,me(t,-1))}function ae(e,t){if(p(e)){let s=ae(e.values,t);if(w(s).length===1){let o=new z(s);return o.name=N(t)?t.name:o.name,o.index=e.index.slice(),o}else{let o=new A(s);return o.index=e.index.slice(),p(t)&&(o.columns=t.columns.slice()),o}}if(p(t)){let s=ae(e,t.values);if(w(s).length===1){let o=new z(s);return o.name=N(e)?e.name:o.name,o.index=t.columns.slice(),o}else{let o=new A(s);return o.columns=t.columns.slice(),o}}if(N(e))return ae(e.values,t);if(N(t))return ae(e,t.values);f(g(e)&&g(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=w(e),r=w(t);if(f(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),f(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return ee(Fe(e,t));if(n.length===1&&r.length===2)return x(t).map(s=>ae(e,s));if(n.length===2&&r.length===1)return e.map(s=>ae(s,t));if(n.length===2&&r.length===2){let s=x(t),o=[];for(let i=0;i<e.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(ae(e[i],s[a]));o.push(u)}return o}}function _n(e){if(p(e)||N(e))return e.dropMissing(...Object.values(arguments).slice(1));f(g(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(_n(n))}catch{v(n)||t.push(n)}}),t}function Kt(e,t){if(p(e)||N(e))return Kt(e.values,t);if(p(t)||N(t))return Kt(e,t.values);f(g(e)&&g(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),f(L(w(e),w(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=Kt(e[s],t[s]);n.push(o),r.push(i)}catch{!v(e[s])&&!v(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}function fe(e,t){if(p(e)||N(e))return fe(e.values,t);if(p(t)||N(t))return fe(e,t.values);f(g(e)&&g(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),f(L(w(e),w(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=fe(e[s],t[s]);n.push(o),r.push(i)}catch{b(e[s])&&b(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}function oi(e){return _n(e)}function Lt(e,t){if(p(e)||N(e))return Lt(e.values,t);f(g(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),f(J(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(g(n)){if(!Lt(n,t))return!1}else if(!t(n))return!1;return!0}function ii(e){try{if(!b(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var ui=k(ii);function Sn(e){try{return typeof e=="bigint"?BigInt(Sn(he(e))):e!==he(e)?NaN:e<=1?1:e*Sn(e-1)}catch{return NaN}}var ai=k(Sn);function Fn(e,t){if(p(e)||N(e))return Fn(e.values,t);if(f(Se(e)||g(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!J(t)){let s=t;t=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Se(s)){i.push(s);let u=Object.keys(s).concat(Object.getOwnPropertySymbols(s));for(let a=0;a<u.length;a++){let l=u[a],c=s[l];if(o(c))return c;let h=n(c,o,i);if(h)return h}}else if(g(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return t(s)}catch{return!1}}return n(e,r)}function On(e,t){if(p(e)||N(e))return On(e.values,t);if(f(Se(e)||g(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!J(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Se(o)){u.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o)),l=[];for(let c=0;c<a.length;c++){let h=a[c],d=o[h],E=!1;i(d)&&(l.push(d),E=!0);let F=n(d,i,u);F&&F.length>0&&F.slice(E?1:0).forEach(I=>l.push(I))}return l}else if(g(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let c=o[l],h=!1;i(c)&&(a.push(c),h=!0);let d=n(c,i,u);d&&d.length>0&&d.slice(h?1:0).forEach(E=>a.push(E))}return a}else if(i(o))return[o];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}function li(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return b(t)?t:NaN}catch{return NaN}}var ci=k(li);function fi(e){try{return b(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var hi=k(fi);function Ve(e){b(e)&&(e=[e]);let t=[],n=St(e);for(let r=0;r<n;r++)t.push(0);return wt(t,e)}function mi(e){typeof e=="bigint"&&(e=he(e)),f(!v(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),f(b(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),f(he(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),f(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Ve([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var di=["true","false","yes","no"],gi=["null","none","nan","na","n/a","","undefined"];function $t(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=he(e.value)===e.value:e.isInteger=Lt(e.values,t=>b(t)?he(t)===t:!0)),e}function et(e){if(p(e)){let o=e.copy(),i=et(e.values);return o.values=i.values,$t({type:i.type,values:o})}if(N(e)){let o=e.copy(),i=et(e.values);return o.values=i.values,$t({type:i.type,values:o})}if(!g(e)){let o=et([e]);return o.value=o.values[0],delete o.values,$t(o)}f(g(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=K(e).map(o=>{if(o===void 0)return"null";try{if(typeof o=="object"){let a=new Date(o.getTime());if(Ie(a))return"date"}}catch{}B(o)||(typeof o=="bigint"?o=o.toString()+"n":o=JSON.stringify(o));let u=o.toLowerCase().trim();if(gi.indexOf(u)>-1)return"null";if(di.indexOf(u)>-1)return"boolean";try{if(o.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(o);return b(a)?"number":typeof a=="object"?g(a)?"string":"object":"string"}catch{let l=new Date(o);return Ie(l)?"date":"string"}}),n=Pe(t),s=n.values.toSorted((o,i)=>n.get(i)-n.get(o))[0];return $t({type:s,values:Ce(e,o=>ne(o,s))})}function Ut(e){if(p(e)){let n=e.copy();return n.values=Ut(n.values),n}f(g(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=w(e);if(f(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),f(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),f(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){f(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],s=e[1][0],o=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof s=="bigint"&&(s=Number(s)),typeof o=="bigint"&&(o=Number(o));let i=n*o-r*s;f(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return Fe(u,1/i)}else if(t[0]>1){let n=(r,s)=>b(r)||b(s)?Fe(r,s):ae(r,s);for(let r=1;r<t[0]-1;r++)try{let s=e.slice(0,r).map(I=>I.slice(0,r)),o=e.slice(0,r).map(I=>I.slice(r,t[0])),i=e.slice(r,t[0]).map(I=>I.slice(0,r)),u=e.slice(r,t[0]).map(I=>I.slice(r,t[0])),a=Ut(s),l=Ut(Ue(u,n(-1,n(n(i,a),o)))),c=Ue(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),E=l;return c.map((I,De)=>I.concat(h[De])).concat(d.map((I,De)=>I.concat(E[De])))}catch{}f(!1,"This matrix cannot be inverted!")}}var pi=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Pr(e,t,n){try{if(!b(e))return NaN;if(!b(t))return NaN;if(!b(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Pr(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var yi=k(Pr);function Rr(e,t){try{if(t=v(t)?Math.E:t,!b(e))return NaN;if(!b(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Rr(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var An=k(Rr);function Ft(e,t){return M(e,{shouldDropNaNs:t}).mean}function bi(e,t){return M(e,{shouldDropNaNs:t,median:!0}).median}function Jr(e,t){try{if(!b(e))return NaN;if(!b(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Jr(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var vi=k(Jr);function Ni(e,t){return M(e,{shouldDropNaNs:t,mode:!0}).mode}function vr(){let e=pe(),t=pe();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function In(e){return v(e)?vr():Ce(Q(e),vr)}function wi(e){return Ce(Q(e),()=>1)}function Mn(e,t){function*n(r,s){if(s=s||r.length,r.length===1){yield[r];return}for(let o of Cr(r,s)){if(!o.slice)continue;let i=Ve(o.length);yield o;let u=1;for(;u<o.length;)if(i[u]<u){if(u%2===0){let a=o[0];o[0]=o[u],o[u]=a}else{let a=o[i[u]];o[i[u]]=o[u],o[u]=a}yield o,i[u]+=1,u=1}else i[u]=0,u+=1}}return p(e)||N(e)?Mn(e.values,t):(f(g(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),v(t)&&(t=e.length),f(b(t)&&he(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(K(e),t))}function Di(e,t){let n=[];for(let r of Mn(e,t))n.push(r.slice());return n}function Ei(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(g(t))if(G(t))console.log(t);else{let n=w(t);n.length===1?new z(t).print():n.length==2?new A(t).print():console.log(t)}else p(t)||N(t)?t.print():console.log(t)})}var Si=k((e,t,n,r,s)=>{try{let o=!1;for(let l of[e,t,n,r,s]){if(!b(l))return NaN;typeof l=="bigint"&&(o=!0)}o&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),s=Number(s));let i=(s-r)*(e-t),u=n-t;if(u===0)return NaN;let a=i/u+r;if(o)try{return BigInt(a)}catch{}return a}catch{return NaN}});function Cn(e,t,n,r,s){if(g(e)&&v(r)&&v(s)){r=t,s=n;let o=M(e);t=o.min,n=o.max}return Si(e,t,n,r,s)}function Fi(e){try{return b(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var jn=k(Fi);function Yr(e){try{return b(e)?typeof e=="bigint"?BigInt(Yr(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var Bn=k(Yr);function Oi(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Ti=k(Oi);function Tn(e,t){if(p(e)||N(e))return Tn(e.values,t);f(g(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),f(J(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(g(n)){if(Tn(n,t))return!0}else if(t(n))return!0;return!1}function Vr(e,t){return M(e,{shouldDropNaNs:t,stdev:!0}).stdev}function _i(e){return Vr(e)}function Ai(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var Ii=k(Ai);function Nr(e,t){f(J(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function Mi(e,t){f(J(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function Ci(){return X([...arguments].map(e=>g(e)?e:p(e)||N(e)?e.values:[e]))}function ji(e,t){return M(e,{shouldDropNaNs:t,variance:!0}).variance}function Bi(){let e=[],t=Object.values(arguments).map(n=>((p(n)||N(n))&&(n=n.values),f(g(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return C(0,Je(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(s=>{let o=s[n];r.push(v(o)?void 0:o)}),e.push(r)}),e}var vt={abs:se,add:Ue,apply:Ce,arccos:qo,arcsin:Wo,arctan:Xo,argmax:st,argmin:Me,assert:f,cast:ne,ceil:Qo,chop:ei,clamp:Le,combinations:Cr,combinationsIterator:zt,copy:U,correl:ye,cos:ni,count:Pe,covariance:Nt,DataFrame:A,dataTypes:ri,decycle:nt,diff:Dn,distance:En,divide:je,dot:ae,dropMissing:_n,dropMissingPairwise:Kt,dropNaN:ze,dropNaNPairwise:fe,dropUndefined:oi,every:Lt,exp:ui,factorial:ai,find:Fn,findAll:On,flatten:K,float:ci,floor:hi,identity:mi,IndexMatcher:ot,indexOf:tt,inferType:et,int:he,intersect:Gt,inverse:Ut,isArray:g,isBoolean:ce,isBrowser:pi,isDataFrame:p,isDate:Ie,isEqual:L,isFunction:J,isJagged:G,isNested:qt,isNumber:b,isObject:Se,isSeries:N,isString:B,isUndefined:v,lerp:yi,log:An,MathError:Ee,max:Je,mean:Ft,median:bi,min:Ir,mod:vi,mode:Ni,multiply:kr,ndarray:Q,normal:In,ones:wi,permutations:Di,permutationsIterator:Mn,pow:me,print:Ei,product:St,random:pe,range:C,remap:Cn,reshape:wt,reverse:le,round:jn,scale:Fe,seed:Tr,Series:z,set:X,shape:w,shuffle:Re,sign:Bn,sin:Ti,some:Tn,sort:re,sqrt:Ye,stats:M,std:Vr,stdev:_i,subtract:de,sum:ee,tan:Ii,timeAsync:Mi,timeSync:Nr,time:Nr,transpose:x,union:Ci,variance:ji,vectorize:k,zeros:Ve,zip:Bi,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new vt.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(vt).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:vt[t]})}catch{e[t]=vt[t]}})}};typeof window<"u"&&(window.JSMathTools=vt);function Wt(e,t,n){if(N(e))return Wt(e.values,t);if(N(t))return Wt(e,t.values);if(f(g(e)&&g(t)&&w(e).length===1&&w(t).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),f(e.length===t.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),n){let r=new ot().fitAndTransform(e,t);e=r[0],t=r[1]}try{let r=M(e,{variance:!0}),s=M(t,{variance:!0}),o=r.mean,i=s.mean;return(o-i)/Math.sqrt((r.variance+s.variance)/2)}catch{return NaN}}function $r(e){return typeof e=="bigint"?e.toString()+"n":e}function Ot(){if(arguments.length===1&&N(arguments[0])){let{name:s,values:o}=arguments[0],i=Ot(s,o),u=new A(i);return u.index=arguments[0].index.slice(),u}let[e,t]=arguments;f(B(e),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),f(g(t)&&w(t).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={};return re(X(t)).filter(s=>typeof s!="number"||s.toString()!=="NaN").filter(s=>!v(s)).map(s=>e+"_"+$r(s)).slice(0,-1).forEach(s=>{n[s]=t.map(o=>s===e+"_"+$r(o)?1:typeof o=="number"&&o.toString()==="NaN"?NaN:v(o)?NaN:0)}),n}function oe(e){return b(e)&&e>=0&&Math.floor(e)===e&&e<1/0}function es(e){if(typeof e!="string")throw new Error("`text` must be a string!");e=e.trim();let t="",n=!1;for(let r=0;r<e.length;r++){let s=e[r];s.match(/[A-Za-z0-9]/g)?(t.length===0?t+=s.toLowerCase():n?t+=s.toUpperCase():t+=s,n=!1):!s.includes("'")&&!s.includes("\u2019")&&!s.includes("\u275C")&&(n=!0)}return t}var ki=Object.defineProperty,Pi=(e,t,n)=>t in e?ki(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,ts=(e,t,n)=>(Pi(e,typeof t!="symbol"?t+"":t,n),n);function D(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Ri=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),Ke=class extends Error{constructor(e){Ri()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function m(e,t){if(!e)throw new Ke(t)}var ns=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function S(e){return e===null||typeof e>"u"}var Ji=ns.map(e=>e.name);function y(e){try{return e instanceof Array?!0:S(e.constructor)?!1:ns.indexOf(e.constructor)>-1||Ji.indexOf(e.constructor.name)>-1}catch{return!1}}function _(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function q(e){return typeof e=="function"}function Te(e){return typeof e=="object"&&!S(e)&&!y(e)}function O(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function ct(e,t){if(_(e)){let o=ct(e.values,t);return o.length>0&&D(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o.length>1&&D(o[1])&&o[1]>=0&&o[1]<e.columns.length&&(o[1]=e.columns[o[1]]),o}if(O(e)){let o=ct(e.values,t);return o.length>0&&D(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o}if(m(Te(e)||y(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!q(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Te(o)){u.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let l=0;l<a.length;l++){let c=a[l],h=o[c];if(i(h))return[c];let d=n(h,i,u);if(d&&d.length>0)return[c].concat(d)}}else if(y(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let c=n(l,i,u);if(c&&c.length>0)return[a].concat(c)}}else if(i(o))return[];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}function W(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(y(n))return n instanceof Array?n.map(s=>W(s)):n.slice();if(O(n)){let s=n.copy();return s.values=W(s.values),s}if(_(n)){let s=n.copy();return s.values=W(n.values),s}if(n instanceof Date)return new Date(n.getTime());n=Ge(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(s=>{r[s]=W(n[s])}),r}else return n}return t(Ge(e))}function Ge(e){function t(s,o,i){if(o=o||[],i=i||"",o.indexOf(s)>-1){let u=i.split("/").slice(i.startsWith("/")?1:0);if(u.some((l,c)=>{let h=u.slice(0,u.length-c-1),d=n;return h.forEach(E=>{d=d[E]}),d===s}))return`<reference to "${n===s?"/":"/"+ct(n,s).join("/")}">`}return typeof s=="object"?s===null?null:(o.push(s),y(s)?typeof s.constructor<"u"&&s.constructor.name!=="Array"?s.slice():s.map((u,a)=>t(u,o,i+"/"+a)):(Object.keys(s).concat(Object.getOwnPropertySymbols(s)).forEach(u=>{s[u]=t(s[u],o,i+"/"+u.toString())}),s)):s}let n=e,r=t(n);if(_(e)){let s=e.copy();s._values=r.values,s._columns=r.columns,s._index=r.index,r=s}if(O(e)){let s=e.copy();s.name=r.name,s._values=r.values,s._index=r.index,r=s}return r}function ve(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var Kr=["number","int","float","bigint"];function _e(e,t){function n(r,s){let o=typeof r,i=typeof s;if(o!==i&&!Kr.includes(o)&&!Kr.includes(i))return!1;if(o==="undefined"&&i==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")try{let u=r.toString(),a=s.toString();return u===a}catch{return!1}if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{if(ve(r))return ve(s)?r.getTime()===s.getTime():!1;if(ve(s))return!1;if(r instanceof RegExp&&s instanceof RegExp)return r.toString()===s.toString();if(y(r)!==y(s))return!1;let u=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(s).concat(Object.getOwnPropertySymbols(s));if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let c=u[l];if(!n(r[c],s[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(Ge(e),Ge(t))}}function Ct(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Yi=Ct(16),Vi=Ct(16),$i=Ct(16),Ki=Ct(16),Ui=Ct(16),zi=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)y(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Yi:S(e)?Vi:q(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+Ui:e===1/0?$i:e===-1/0?Ki:typeof e=="bigint"?e.toString():_(e)?e.toJSONString():O(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!S(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function Ne(e){if(_(e)||O(e))return Ne(e.values);m(y(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(s=>{y(s)?r=r.concat(t(s)):r.push(s)}),r}return t(e)}function ue(e,t){t=t||{};let n=new zi,r={},s=Ne(e),o=[],i=-1/0,u=1/0,a=!1,l=0;for(let h of s){if(typeof h=="bigint"&&(a=!0),!t.shouldDropNaNs||D(h))try{h>i&&(i=h),h<u&&(u=h),l+=Number(h),o.push(h)}catch{i=NaN,u=NaN,l=NaN}n.increment(h)}let c=l/o.length;if(r.counts=n,r.max=i,r.mean=c,r.min=u,r.n=s.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=o.length),t.mode){let h=Array.from(n.values.map(F=>[F,n.get(F)])).toSorted((F,I)=>I[1]-F[1]),d=h[0][1],E=[];for(let F of h)if(F[1]==d)E.push(F[0]);else break;r.mode=E.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let h=o.toSorted((E,F)=>Number(E)-Number(F)),d=Math.floor(h.length/2);if(h.length%2===0){let E=h[d-1],F=h[d];if(r.median=(Number(E)+Number(F))/2,a&&typeof E=="bigint"&&typeof F=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=h[d]}if(t.stdev||t.variance){let h=0;for(let E of o)h+=Math.pow(Number(E)-c,2);h/=o.length;let d=Math.sqrt(h);r.stdev=d,r.variance=h}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(h=>{try{return BigInt(h)}catch{return h}}))}return r}function tn(e,t){let{counts:n}=ue(e);return S(t)||(q(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{_e(r,t)||n.delete(r)})),n}function kn(e){if(_(e)||O(e))return kn(e.values);if(y(e)){let t=!1,n=!1,r=null;for(let s of e){if(kn(s))return!0;if(y(s)){if(r===null)r=s.length;else if(s.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function jt(e){return kn(Ge(e))}function an(e){if(_(e)||O(e))return an(e.values);m(y(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(y(e[t]))return!0;return!1}var it="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function be(e){m(!S(e),it),y(e)||(e=[e]),m(!an(e),it),m(e.length>0,it);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),m(D(t),it),m(t>=0,it),m(Math.floor(t)===t,it),m(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(be(e.slice(1)));return n}}function Oe(e){if(_(e)||O(e)){let n=e.copy();return n.values=Oe(n.values),n.index=Oe(n.index),n}m(y(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function $(e,t,n=1){m(!S(e)&&!S(t)&&!S(n),"You must pass two numbers and optionally a step value to the `range` function!"),m(D(e)&&D(t)&&D(n),"You must pass two numbers and optionally a step value to the `range` function!"),m(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,s=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let i=e;e=t+n,t=i+n}let o=[];for(let i=e;i<t;i+=n)if(s)try{o.push(BigInt(i))}catch{o.push(i)}else o.push(i);return r&&(o=Oe(o)),o}function Bt(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Li=Bt(256),qi=Bt(256),Gi=Bt(256),Wi=Bt(256),Hi=Bt(256);function ge(e){if(_(e)||O(e))return ge(e.values);m(y(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return Ne(e).forEach(r=>{let s=typeof r=="object"&&r===null?Li:S(r)?qi:q(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Hi:r===1/0?Gi:r===-1/0?Wi:typeof r=="bigint"?r.toString():_(r)?r.toJSONString():O(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||t.push(r),n[s]=!0}),t}function rs(e){if(y(e)){let t=rs(e[0]);return[e.length].concat(t||[])}else return}function T(e){return _(e)||O(e)?T(e.values):(m(y(e),"The `shape` function only works on arrays, Series, and DataFrames!"),rs(e))}function ss(e,t,n){if(S(n)&&(n=0),m(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),y(t)){m(!jt(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=T(t);if(r.length===1)if(n===0){let s=e.copy();s._values.push(t);let o=Math.max(e.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(e.shape[0],r[0]),o=e.copy();for($(0,s).forEach(i=>{i>=o._values.length&&o._values.push(be(e.shape[1])),o._values[i].push(t[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...t.map(i=>i.length).concat([e.shape[1]])),o=e.copy();for(o._values=o._values.concat(t).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...t.map(u=>u.length))+e.shape[1],o=Math.max(e.shape[0],r[0]),i=e.copy();for($(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(be(e.shape[1])),i._values[u]=i._values[u].concat(t[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new Ke("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(O(t)){let r=ss(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(_(t))if(n===0){let r=e.copy(),s=ge(r._columns.concat(t._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),t.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(t._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(e._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((s,o)=>{let i=t._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(t._values[i]):r._values[o]=r._values[o].concat(be(t.shape[1]))}),t._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(be(r._columns.length).concat(t._values[o])))}),r._columns=r._columns.concat(t._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new Ke("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function Xi(e,t,n,r,s){if(s=s||0,m(q(r),"The first parameter to the `apply` method must be a function."),m(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new t(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let c=r(l,a,n);c instanceof t?o[u]=c.values:o[u]=c,S(i)&&(i=c instanceof t||y(c))}),i){let u=new e(o);return u.index=n.index,u}else{let u=new t(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new t(u);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return S(o)&&(o=c instanceof t||y(c)),c instanceof t?c.values:c});if(o){let u=new e(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new t(i);return u.index=n.index,u}}}function j(e){return typeof e=="string"}function Zi(e,t,n,r,s){let o=u=>u instanceof e,i=u=>u instanceof t;if(S(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(Te(r)){let u=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new Ke("You must pass a DataFrame, Series, or object into the `assign` method!")}else{m(j(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),m(y(s)&&!jt(s)&&T(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}function Qi(e,t){if(t.isEmpty)return new e;let n=new e(W(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function xi(e,t,n,r,s){S(r)&&(r=[]),S(s)&&(s=[]),(j(r)||D(r))&&(r=[r]),(j(s)||D(s))&&(s=[s]),m(y(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),m(y(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),m(T(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),m(T(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof t){let a=new e;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}function os(e){return D(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function ft(e){return os(e)&&e>=0}function eu(e,t,n,r,s,o){r=r||0,m(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,m(ft(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",m(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let c=0;for(let h=0;h<l.length;h++){let d=l[h];if(S(d)&&c++,c>=o)return[]}}else if(s==="any")for(let c=0;c<l.length;c++){let h=l[c];if(S(h))return[]}else if(s==="all"){for(let c=0;c<l.length;c++){let h=l[c];if(!S(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(T(l).length<2)return new e;u.values=l;let c=u.get(null,a);if(S(c))return new e;j(c)&&(c=[c]),c instanceof t&&(c=c.values),u.index=c,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let E=u.values.map(I=>I[d]),F=i(E);F.length>0&&(l[h]=F)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=u.index,c}return u}function Gn(e){if(_(e)||O(e))return e.dropNaN(...Object.values(arguments).slice(1));m(y(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Gn(n))}catch{if(D(n))return t.push(n)}}),t}function tu(e,t,n,r,s){n=n||0,m(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,m(ft(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",m(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=Gn(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=t.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new e}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new e}return i}function Ur(e){let t={};return Ne(e).forEach((n,r)=>{t[n]=r}),t}function ut(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function nu(e,t,n,r,s){m(q(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),S(s)&&(s=0),m(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=Ur(o.index),u=Ur(o.columns);if(s===0){let a=0,l=o.values.filter((c,h)=>{let d=new t(c);d.name=n.index[h],d.index=n.columns;let E=r(d,h,n);return E?a++:delete i[o.index[h]],E});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=ut(i)[0],c.index=ut(u),c}o.values=l,o.index=ut(i)}else if(s===1){o=o.transpose();let a=0,l=o.values.filter((c,h)=>{let d=new t(c);d.name=n.columns[h],d.index=n.index;let E=r(d,h,n);return E?a++:delete u[o.index[h]],E});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=ut(u)[0],c.index=ut(i),c}o.values=l,o.index=ut(u),o=o.transpose()}return o}function ru(e,t,n){(j(t)||D(t))&&(t=[t]),(j(n)||D(n))&&(n=[n]);for(let s in t)typeof t[s]=="bigint"&&(t[s]=Number(t[s]));for(let s in n)typeof n[s]=="bigint"&&(n[s]=Number(n[s]));let r=ge((t||[]).concat(n||[]).map(s=>typeof s));return m(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&m(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(m(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),m(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),S(t)||(t=t.map(s=>{if(j(s))return m(e.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(D(s))return m(s>=0,`Index ${s} is out of bounds!`),m(Math.floor(s)===s,"Row numbers must be integers!"),m(s<e.index.length,`Index ${s} is out of bounds!`),e.index[s]})),S(n)||(n=n.map(s=>{if(j(s))return m(e.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(D(s))return m(s>=0,`Column ${s} is out of bounds!`),m(Math.floor(s)===s,"Column numbers must be integers!"),m(s<e.columns.length,`Column ${s} is out of bounds!`),e.columns[s]})),e.getSubsetByNames(t,n)}function su(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function We(e,t){if(S(t)&&(t=su),_(e)||O(e))return e.sort(...Object.values(arguments).slice(1));m(y(e),"The `sort` function only works on arrays, Series, and DataFrames!"),m(q(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function ou(e){let t=e.toLowerCase(),n="";for(let s=0;s<t.length;s++){let o=t[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function zr(e,t,n){S(n)?n=t.columns:j(n)&&(n=[n]);let r={};n.forEach(o=>{m(j(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=t.columns.indexOf(o);m(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=t.values.map(l=>l[i]),a=We(ge(u));u.forEach(l=>{a.forEach(c=>{let h=o+"_"+ou(c.toString());r[h]||(r[h]=[]),l===c?r[h].push(1):r[h].push(0)})})});let s=new e(r);return s.index=t.index,s}function iu(e,t,n){let r=e.shape;S(t)&&(t=$(0,r[0])),S(n)&&(n=$(0,r[1])),D(t)&&(t=[t]),D(n)&&(n=[n]),m(y(t)&&y(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),m(T(t).length===1&&T(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),m(t.length>0,"The `rowIndices` array must contain at least one index."),m(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(i=>{m(ft(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),m(i<e.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{m(ft(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),m(i<e.columns.length,`The column index ${i} is out of bounds.`)});let s=t.map(i=>e.index[i]),o=n.map(i=>e.columns[i]);return e.getSubsetByNames(s,o)}function uu(e,t,n,r,s){S(r)&&(r=n.index),S(s)&&(s=n.columns),j(r)&&(r=[r]),j(s)&&(s=[s]),m(y(r)&&y(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),m(T(r).length===1&&T(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),m(r.length>0,"The `rows` array must contain at least one row name."),m(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{m(j(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),m(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{m(j(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),m(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return o[0][0];if(r.length===1){let u=new t(o[0]);return u.name=r[0],u.index=s,u}if(s.length===1){let u=new t(o.map(a=>a[0]));return u.name=s[0],u.index=r,u}let i=new e(o);return i.columns=s,i.index=r,i}function au(e,t,n){function r(d,E){return j(d)&&d.length>E?d.substring(0,E-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=Math.floor(s/2),i=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,u=Math.floor(i/2),a=s>n.index.length?null:$(0,o).concat($(n.index.length-o,n.index.length)),l=i>n.columns.length?null:$(0,u).concat($(n.columns.length-u,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),s<=n.index.length&&(c._index.splice(o,0,"..."),c._values.splice(o,0,$(0,c.columns.length).map(()=>"..."))),i<=n.columns.length&&(c._columns.splice(u,0,"..."),c._values=c._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return c instanceof t?(c.values=c.values.map(d=>r(d,h)),c.name=r(c.name,h),c.index=c.index.map(d=>r(d,h))):(c.values=c.values.map(d=>d.map(E=>r(E,h))),c.columns=c.columns.map(d=>r(d,h)),c.index=c.index.map(d=>r(d,h))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function at(e,t){m(D(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function lu(e,t){let n=t?e:e.copy();return n.index=$(0,e.shape[0]).map(r=>"row"+at(r,(n.index.length-1).toString().length)),n}function kt(e,t){if(_(e)||O(e))return kt(e.values,t);m(y(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=Ne(e),r=!1,s=1;for(let o of n){if(!D(o))if(t)o=1;else return NaN;typeof o=="bigint"&&(r=!0,o=Number(o)),s*=o}if(r)try{return BigInt(s)}catch{}return s}catch{return NaN}}function cu(e){return os(e)&&e>0}function It(e,t){if(_(e)||O(e))return It(e.values,t);if(m(y(e),"The first argument passed into the `reshape` function must be an array!"),D(t)&&(t=[t]),m(y(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),m(T(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(o=>(typeof o=="bigint"&&(o=Number(o)),m(cu(o),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(o))),t.length===0)return Ne(e);let n=Ne(e);if(t.length===1&&t[0]===n.length)return n;m(kt(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=Math.floor(n.length/t[0]);for(let o=0;o<t[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(It(i,t.slice(1)))}return r}var is=Math.pow(2,64),Y=[];us(Math.floor(Math.random()*is));function fu(e,t){e=Z(e);function n(){e+=Z("0x9e3779b97f4a7c15");let s=W(e);return s=(s^s>>BigInt(30))*Z("0xbf58476d1ce4e5b9"),s=(s^s>>BigInt(27))*Z("0x94d049bb133111eb"),s^s>>BigInt(31)}let r=[];for(let s=0;s<t;s++)r.push(n());return r}function Z(e){return BigInt.asUintN(64,BigInt(e))}function Lr(e,t){return e=Z(e),t=BigInt(t),Z(Z(e<<t)|Z(e>>Z(BigInt(64)-t)))}function us(e){if(typeof e=="bigint"&&(e=Number(e)),S(e))return W(Y);{m(D(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=fu(Math.floor(e),4);Y[0]=t[0],Y[1]=t[1],Y[2]=t[2],Y[3]=t[3]}}function qr(){let e=Z(Lr(Y[0]+Y[3],23)+Y[0]),t=Z(Y[1]<<BigInt(17));return Y[2]=Z(Y[2]^Y[0]),Y[3]=Z(Y[3]^Y[1]),Y[1]=Z(Y[1]^Y[2]),Y[0]=Z(Y[0]^Y[3]),Y[2]=Z(Y[2]^t),Y[3]=Lr(Y[3],45),Math.floor(Number(e))/is}function ht(e){return S(e)?qr():(y(e)||(e=[e]),It(be(kt(e)).map(qr),e))}function nn(e){if(_(e)||O(e))return e.shuffle(...Object.values(arguments).slice(1));m(y(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let s=Math.floor(ht()*n.length);t.push(n.splice(s,1)[0])}return t}function hu(e,t){return S(t)&&(t=0),m(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?nn(e.index):null,t===1?nn(e.columns):null)}function qe(e){return typeof e=="boolean"}function mu(e,t,n){return q(t)?du(e,t,n):gu(e,t,n)}function du(e,t,n){if(n=S(n)?0:n,m(q(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),m(D(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=We(e.index,(s,o)=>t(e.get(s,null),e.get(o,null)));return e.get(r,null)}else{let r=We(e.columns,(s,o)=>t(e.get(null,s),e.get(null,o)));return e.get(null,r)}}function gu(e,t,n){let r=e.copy(),s=ht().toString();r=r.assign(s,r.index),S(t)&&(t=[s],n=[!0]),(D(t)||j(t))&&(t=[t],(qe(n)||j(n))&&(n=[n])),m(y(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),m(T(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),S(n)&&(n=$(0,t.length).map(()=>!0)),m(y(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),m(T(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),m(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(i=>{if(m(j(i)||D(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),j(i)){let u=r.columns.indexOf(i);return m(u>-1,`The column "${i}" does not exist!`),u}if(D(i))return m(ft(i),"Column indices must be whole numbers!"),m(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(m(j(i)||qe(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),j(i)){let u=i.trim().toLowerCase();return m(u==="ascending"||u==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),u==="ascending"}if(qe(i))return i}),r.values=We(r.values,(i,u)=>{let a=0;for(;i[t[a]]===u[t[a]]&&a<t.length;)a++;let l=n[a];if(i[t[a]]===u[t[a]])return 0;if(i[t[a]]<u[t[a]])return l?-1:1;if(i[t[a]]>u[t[a]])return l?1:-1});let o=r.columns.indexOf(s);return r.index=r.values.map(i=>i[o]),r=r.dropColumns(s),r}function pu(e,t){S(t)?t=0:m(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,s)=>{let o={};e.columns.forEach((i,u)=>{o[i]=e.values[s][u]}),n[r]=o}):e.columns.forEach((r,s)=>{let o={};e.index.forEach((i,u)=>{o[i]=e.values[u][s]}),n[r]=o}),n}function as(e,t){return JSON.stringify(e.toObject(t))}async function yu(e,t,n){let r=as(e,n),s=!1,o=!1,i,u;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new Ke(i):typeof module<"u"?new Ke(u):new Ke("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function bu(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function ke(e){if(_(e)||O(e))return e.transpose();m(y(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=T(e);if(m(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return Oe(e);if(t.length===2){let n=be(Oe(t));for(let r=0;r<t[0];r++)for(let s=0;s<t[1];s++)n[s][r]=e[r][s];return n}}function ls(e,t,n){if(O(n))return new e(t.values.concat(n.values));if(y(n)){let r=T(n);m(r.length===1&&!an(r),"Only vectors can be appended to Series!");let s=t.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(t.values.length+i))}),s}return ls(t,[n])}function vu(e,t){m(q(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,s)=>t(r,s)),n}function Nu(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,s)=>S(r)?!1:(n.push(t.index[s]),!0)),t._index=n,t}function wu(e,t){let n=[],r=[];t.values.forEach((o,i)=>{D(o)&&(r.push(o),n.push(t.index[i]))});let s=new e(r);return s.name=t.name,s.index=n,s}function Du(e,t,n){let r=t.copy(),s=W(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new e,r.name=t.name,r):(r.values=i,r.index=s,r)}function Eu(e,t){(j(t)||D(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=ge((t||[]).map(r=>typeof r));return m(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&m(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(m(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),m(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),S(t)||(t=t.map(r=>{if(typeof r=="string")return m(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return m(r>=0,`Index ${r} is out of bounds!`),m(Math.floor(r)===r,"Indices must be integers!"),m(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function Su(e,t){let n=e.shape;S(t)&&(t=$(0,n[0])),m(y(t),"The `indices` array must be 1-dimensional array of whole numbers."),m(T(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),m(t.length>0,"The `indices` array must contain at least one index."),t.forEach(s=>{m(ft(s),"The `indices` array must be a 1-dimensional array of whole numbers."),m(s<e.index.length,`The row index ${s} is out of bounds.`)});let r=t.map(s=>e.index[s]);return e.getSubsetByNames(r)}function Fu(e,t,n){S(n)&&(n=t.index),m(y(n),"The `indices` array must be a 1-dimensional array of strings."),m(T(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),m(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{m(j(o),"The `indices` array must contain only strings."),m(t.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>t.values[t.index.indexOf(o)]);if(r.length===1)return r[0];let s=new e(r);return s.index=n,s.name=t.name,s}function Ou(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get($(0,n/2).concat($(t.index.length-n/2,t.index.length)));let s=W(t.index);s.splice(Math.floor(s.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(s)}let r={};return t.values.forEach((s,o)=>{let i={};i[t.name]=s,r[t.index[o]]=i}),console.table(r),console.log("Shape:",e.shape,`
`),e}function Tu(e){let t=e.copy();return t.get(nn(t.index))}function _u(e,t,n){n=n||((a,l)=>a<l?-1:1),m(S(n)||q(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=ke([t.values,t.index]),s=We(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new e;return u._values=o,u._index=i,u.name=t.name,u}function Au(e,t){let n=ke([t.values,t.index]);n=ke(We(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function Iu(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Gr=Symbol.for("@jrc03c/js-math-tools/series");function Mu(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Gr}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Gr}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(s){m(y(s),"The new values must be a 1-dimensional array!");let o=T(s);m(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<this._index.length?this._index=this._index.slice(0,o[0]):o[0]>this._index.length&&(this._index=this._index.concat($(this._index.length,o[0]).map(i=>"item"+at(i,(s.length-1).toString().length)))),this._values=s}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(s){m(y(s),"The new index must be a 1-dimensional array of strings!"),m(s.length===this.shape[0],"The new index must be the same length as the old index!"),m(T(s).length===1,"The new index must be a 1-dimensional array of strings!"),s.forEach(o=>{m(j(o),"All of the row names must be strings!")}),this._index=s}}),r){if(r instanceof t)this.name=r.name,this.values=W(r.values),this.index=W(r.index);else if(y(r)){let s=T(r);m(s.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let s=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(u=>u.toString());m(s.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=s[0],i=r[o];m(T(i).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=o,this.values=i.slice()}}}get shape(){return T(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!S(r)).length===0}clear(){let r=this.copy();return r.values.forEach((s,o)=>{r.values[o]=void 0}),r}get(r){return Eu(this,r)}getSubsetByNames(r){return Fu(t,this,r)}getSubsetByIndices(r){return Su(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(Oe(this.values));return r.index=Oe(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=$(0,this.shape[0]).map(s=>"item"+at(s,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=W(this.values),r._index=W(this.index),r.name=this.name,r}append(r){return ls(t,this,r)}apply(r){return vu(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Nu(this,r,s)}dropNaN(){return wu(t,this)}toObject(){return Iu(this)}print(){return Ou(this)}shuffle(){return Tu(this)}sort(r){return _u(t,this,r)}sortByIndex(){return Au(t,this)}filter(r){return Du(t,this,r)}toDataFrame(){let r=new e(ke([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=Oe(r.values),r.index=Oe(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Wr=Symbol.for("@jrc03c/js-math-tools/dataframe");function Ht(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(ht()*t.length)];return n}var V=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Wr}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Wr}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!S(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){m(y(t),"The new values must be a 2-dimensional array!");let n=T(t);m(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat($(this._index.length,n[0]).map(r=>"row"+at(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat($(this._columns.length,n[1]).map(r=>"col"+at(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){m(y(t),"The new columns list must be a 1-dimensional array of strings!"),m(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),m(T(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Ht(8):r.trim()));let n=(()=>{let r=tn(t),s={};return r.values.forEach(o=>{s[o]=r.get(o)}),s})();t=t.map(r=>n[r]>1?r+"_"+Ht(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){m(y(t),"The new index must be a 1-dimensional array of strings!"),m(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),m(T(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+Ht(8):r.trim()));let n=(()=>{let r=tn(t),s={};return r.values.forEach(o=>{s[o]=r.get(o)}),s})();t=t.map(r=>n[r]>1?r+"_"+Ht(8):r),this._index=t}}),m(S(e)||Te(e)||y(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof V)this.values=W(e.values),this.columns=W(e.columns),this.index=W(e.index);else if(y(e)){let t=T(e);m(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),m(!jt(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(o=>o.toString());let t=[],n=null,r=null;this._columns.forEach(o=>{S(r)&&(n=o,r=e[o].length),m(e[o].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${o}" points to an array containing ${e[o].length} items.`),r=e[o].length;let i=e[o];t.push(i)}),this._values=ke(t);let s=T(this.values);this._index=$(0,s[0]).map(o=>"row"+at(o,(s[0]-1).toString().length))}}get shape(){return T(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new V(be(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return ru(this,e,t)}getSubsetByNames(e,t){return uu(V,te,this,e,t)}getSubsetByIndices(e,t){return iu(this,e,t)}getDummies(e){return zr(V,this,e)}oneHotEncode(e){return zr(V,this,e)}transpose(){let e=new V(ke(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return lu(this,e)}copy(){return Qi(V,this)}assign(e,t){return Zi(V,te,this,e,t)}apply(e,t){return Xi(V,te,this,e,t)}dropMissing(e,t,n){return eu(V,te,this,e,t,n)}dropNaN(e,t,n){return tu(V,this,e,t,n)}drop(e,t){return xi(V,te,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return pu(this,e)}toObject(){return bu(this)}toJSONString(e){return as(this,e)}saveAsJSON(e,t){return yu(this,e,t)}print(){return au(V,te,this)}sort(e,t){return mu(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return nu(V,te,this,e,t)}shuffle(e){return hu(this,e)}append(e,t){return ss(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},te=Mu(V);function ln(e,t){return ue(e,{shouldDropNaNs:t}).max}function P(e){return m(q(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return y(a)?!0:O(a)?(n=!0,s.push(a),!0):_(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{m(_e(y(u)?T(u):u.shape,y(i[a+1])?T(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=ln(i.map(l=>l.length?l.length:l.values.length)),a=$(0,u).map(l=>{let c=Object.keys(arguments).map(h=>y(arguments[h])?arguments[h][l]:O(arguments[h])||_(arguments[h])?arguments[h].values[l]:arguments[h]);return t(...c)});if(r)try{if(o.length===1&&_e(T(o[0]),T(a))){let l=new V(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new V(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new te(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new te(a)}catch{return a}return a}else return e(...arguments)}}function Cu(e){try{return D(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var Wn=P(Cu);function ju(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!D(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var rn=P(ju);function Bu(e,t){try{return t(e)}catch{return NaN}}var cn=P(Bu);function ku(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var Pu=P(ku);function Ru(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var Ju=P(Ru);function Yu(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var Vu=P(Yu);function Pn(e,t){if(_(e)){let n=Pn(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(O(e)){let n=Pn(e.values,t);return e.index[n]}m(y(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=ct(e,ln(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function cs(e,t){return ue(e,{shouldDropNaNs:t}).min}function Rn(e,t){if(_(e)){let n=Rn(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(O(e)){let n=Rn(e.values,t);return e.index[n]}m(y(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=ct(e,cs(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function ie(e,t){if(_(e)||O(e))return e.apply(n=>ie(n,t));if(y(e))return e.map(n=>ie(n,t));if(t==="null")return null;if(t==="number"){if(S(e))return NaN;let n=ie(e,"boolean");if(qe(n))return n?1:0;try{JSON.parse(e)}catch{let o=ie(e,"date");if(ve(o))return o.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=ie(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return ie(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(ie(e,"int"));if(t==="boolean"){if(qe(e))return e;if(D(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(ve(e))return e;if(S(e))return null;let n=parseFloat(e);if(!isNaN(n)){let s=new Date(e);return ve(s)?s:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Te(e))return e;let n=ie(e,"boolean");if(qe(n))return null;try{let s=ie(e,"number");if(D(s))return JSON.parse(e),null}catch{}let r=ie(e,"date");if(r)return r;try{let s=JSON.parse(e);return y(s)?s.map(o=>ie(o,t)):s}catch{return null}}if(t==="string")return S(e)?_e(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function $u(e){try{return D(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var Ku=P($u);function Uu(e,t){try{if(!D(e))return NaN;if(typeof e=="bigint")return e;if(S(t))t=1e-10;else if(!D(t))return NaN;return Wn(e)<t?0:e}catch{return NaN}}var zu=P(Uu);function Jn(e){if(_(e)||O(e)){let t=e.copy();return t.values=Jn(t.values),t}if(y(e))return e.map(t=>Jn(t));try{let t=JSON.parse(e);return D(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var Ae=P(Jn);function fs(e,t,n){try{return D(e)?D(t)?D(n)?typeof e=="bigint"?BigInt(fs(Ae(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var Lu=P(fs);function sn(e,t){function*n(r,s){if(s>r.length)yield r;else if(s<=0)yield[];else if(r.length<2)yield r;else for(let o=0;o<r.length;o++){let i=r[o],u=r.slice(o+1);if(!(u.length<s-1)&&s-1>=0)for(let a of sn(u,s-1))yield[i].concat(a)}}return _(e)||O(e)?sn(e.values,t):(m(y(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),m(D(t)&&Ae(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Ne(e),t))}function hs(e,t){let n=[];for(let r of sn(e,t))n.push(r.slice());return n}function ms(){let e=Object.values(arguments).map(n=>_(n)||O(n)?ge(n.values):(m(y(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),ge(n)));return ge(e).filter(n=>e.every(r=>r.findIndex(s=>_e(s,n))>-1))}var Tt=class{constructor(e){m(S(e)||e===Tt.DROP_NAN_MODE||e===Tt.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=S(e)?Tt.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(y(t)){let n=T(t);if(n.length===1)t=new te(t);else if(n.length===2)t=new V(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}m(_(t)||O(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===Tt.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=ms(...e),this}transform(){m(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(y(t)){let n=T(t);if(n.length===1)return new te(t).get(this.index).values;if(n.length===2)return new V(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return m(_(t)||O(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},fn=Tt;ts(fn,"DROP_NAN_MODE","DROP_NAN_MODE");ts(fn,"DROP_MISSING_MODE","DROP_MISSING_MODE");function At(e,t,n,r){if(O(e))return At(e.values,t,n,r);if(O(t))return At(e,t.values,n,r);if(m(y(e)&&y(t)&&T(e).length===1&&T(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),m(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return At(...new fn().fitAndTransform(e,t),!1,r);try{let s=ue(e,{stdev:r}),o=ue(t,{stdev:r}),i=Number(s.mean),u=Number(o.mean);if(!D(i)||!D(u))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let h=e[c],d=t[c];if(!D(h))return NaN;if(!D(d))return NaN;typeof h=="bigint"&&(h=Number(h)),typeof d=="bigint"&&(d=Number(d)),l+=(h-i)*(d-u)}return r?[l/e.length,s,o]:l/e.length}catch{return NaN}}function Yn(e,t,n){if(O(e))return Yn(e.values,t,n);if(O(t))return Yn(e,t.values,n);m(y(e)&&y(t)&&T(e).length===1&&T(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),m(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[s,o,i]=At(e,t,n,!0),u=o.stdev*i.stdev;return s/u}catch{return NaN}}function qu(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var Gu=P(qu),Wu=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Vn(e,t){if(_(e)||O(e))return Vn(e.values,t);if(_(t)||O(t))return Vn(e,t.values);m(y(e)&&y(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=ge(e),r=ge(t),s=[];return n.forEach(o=>{r.findIndex(i=>_e(i,o))<0&&s.push(o)}),s}function ds(e,t){try{if(!D(e))return NaN;if(!D(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=ds(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var Hn=P(ds);function gs(e){try{if(!D(e))return NaN;if(typeof e=="bigint"){let t=gs(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var ps=P(gs);function Hu(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!D(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var ys=P(Hu);function mt(){return ys(...arguments)}function bs(e,t){return rn(e,mt(t,-1))}function Xn(e,t){return ue(e,{shouldDropNaNs:t}).sum}function $n(e,t){if(D(e)&&D(t))return Wn(e-t);if(_(e)||O(e))return $n(e.values,t);if(_(t)||O(t))return $n(e,t.values);y(e)&&y(t)&&m(_e(T(e),T(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return ps(Xn(Hn(bs(e,t),2)))}catch{return NaN}}function Xu(e,t){return mt(e,Hn(t,-1))}function Be(e,t){if(_(e)){let s=Be(e.values,t);if(T(s).length===1){let o=new te(s);return o.name=O(t)?t.name:o.name,o.index=e.index.slice(),o}else{let o=new V(s);return o.index=e.index.slice(),_(t)&&(o.columns=t.columns.slice()),o}}if(_(t)){let s=Be(e,t.values);if(T(s).length===1){let o=new te(s);return o.name=O(e)?e.name:o.name,o.index=t.columns.slice(),o}else{let o=new V(s);return o.columns=t.columns.slice(),o}}if(O(e))return Be(e.values,t);if(O(t))return Be(e,t.values);m(y(e)&&y(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=T(e),r=T(t);if(m(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),m(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return Xn(mt(e,t));if(n.length===1&&r.length===2)return ke(t).map(s=>Be(e,s));if(n.length===2&&r.length===1)return e.map(s=>Be(s,t));if(n.length===2&&r.length===2){let s=ke(t),o=[];for(let i=0;i<e.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(Be(e[i],s[a]));o.push(u)}return o}}function Zn(e){if(_(e)||O(e))return e.dropMissing(...Object.values(arguments).slice(1));m(y(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Zn(n))}catch{S(n)||t.push(n)}}),t}function Zt(e,t){if(_(e)||O(e))return Zt(e.values,t);if(_(t)||O(t))return Zt(e,t.values);m(y(e)&&y(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),m(_e(T(e),T(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=Zt(e[s],t[s]);n.push(o),r.push(i)}catch{!S(e[s])&&!S(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}function Qt(e,t){if(_(e)||O(e))return Qt(e.values,t);if(_(t)||O(t))return Qt(e,t.values);m(y(e)&&y(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),m(_e(T(e),T(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=Qt(e[s],t[s]);n.push(o),r.push(i)}catch{D(e[s])&&D(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}function Zu(e){return Zn(e)}function on(e,t){if(_(e)||O(e))return on(e.values,t);m(y(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),m(q(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(y(n)){if(!on(n,t))return!1}else if(!t(n))return!1;return!0}function Qu(e){try{if(!D(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var xu=P(Qu);function Kn(e){try{return typeof e=="bigint"?BigInt(Kn(Ae(e))):e!==Ae(e)?NaN:e<=1?1:e*Kn(e-1)}catch{return NaN}}var ea=P(Kn);function Un(e,t){if(_(e)||O(e))return Un(e.values,t);if(m(Te(e)||y(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!q(t)){let s=t;t=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Te(s)){i.push(s);let u=Object.keys(s).concat(Object.getOwnPropertySymbols(s));for(let a=0;a<u.length;a++){let l=u[a],c=s[l];if(o(c))return c;let h=n(c,o,i);if(h)return h}}else if(y(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return t(s)}catch{return!1}}return n(e,r)}function zn(e,t){if(_(e)||O(e))return zn(e.values,t);if(m(Te(e)||y(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!q(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Te(o)){u.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o)),l=[];for(let c=0;c<a.length;c++){let h=a[c],d=o[h],E=!1;i(d)&&(l.push(d),E=!0);let F=n(d,i,u);F&&F.length>0&&F.slice(E?1:0).forEach(I=>l.push(I))}return l}else if(y(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let c=o[l],h=!1;i(c)&&(a.push(c),h=!0);let d=n(c,i,u);d&&d.length>0&&d.slice(h?1:0).forEach(E=>a.push(E))}return a}else if(i(o))return[o];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}function ta(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return D(t)?t:NaN}catch{return NaN}}var na=P(ta);function ra(e){try{return D(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var sa=P(ra);function Qn(e){D(e)&&(e=[e]);let t=[],n=kt(e);for(let r=0;r<n;r++)t.push(0);return It(t,e)}function oa(e){typeof e=="bigint"&&(e=Ae(e)),m(!S(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),m(D(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),m(Ae(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),m(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Qn([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var ia=["true","false","yes","no"],ua=["null","none","nan","na","n/a","","undefined"];function Xt(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=Ae(e.value)===e.value:e.isInteger=on(e.values,t=>D(t)?Ae(t)===t:!0)),e}function xt(e){if(_(e)){let o=e.copy(),i=xt(e.values);return o.values=i.values,Xt({type:i.type,values:o})}if(O(e)){let o=e.copy(),i=xt(e.values);return o.values=i.values,Xt({type:i.type,values:o})}if(!y(e)){let o=xt([e]);return o.value=o.values[0],delete o.values,Xt(o)}m(y(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=Ne(e).map(o=>{if(o===void 0)return"null";try{if(typeof o=="object"){let a=new Date(o.getTime());if(ve(a))return"date"}}catch{}j(o)||(typeof o=="bigint"?o=o.toString()+"n":o=JSON.stringify(o));let u=o.toLowerCase().trim();if(ua.indexOf(u)>-1)return"null";if(ia.indexOf(u)>-1)return"boolean";try{if(o.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(o);return D(a)?"number":typeof a=="object"?y(a)?"string":"object":"string"}catch{let l=new Date(o);return ve(l)?"date":"string"}}),n=tn(t),s=n.values.toSorted((o,i)=>n.get(i)-n.get(o))[0];return Xt({type:s,values:cn(e,o=>ie(o,s))})}function en(e){if(_(e)){let n=e.copy();return n.values=en(n.values),n}m(y(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=T(e);if(m(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),m(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),m(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){m(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],s=e[1][0],o=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof s=="bigint"&&(s=Number(s)),typeof o=="bigint"&&(o=Number(o));let i=n*o-r*s;m(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return mt(u,1/i)}else if(t[0]>1){let n=(r,s)=>D(r)||D(s)?mt(r,s):Be(r,s);for(let r=1;r<t[0]-1;r++)try{let s=e.slice(0,r).map(I=>I.slice(0,r)),o=e.slice(0,r).map(I=>I.slice(r,t[0])),i=e.slice(r,t[0]).map(I=>I.slice(0,r)),u=e.slice(r,t[0]).map(I=>I.slice(r,t[0])),a=en(s),l=en(rn(u,n(-1,n(n(i,a),o)))),c=rn(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),E=l;return c.map((I,De)=>I.concat(h[De])).concat(d.map((I,De)=>I.concat(E[De])))}catch{}m(!1,"This matrix cannot be inverted!")}}var aa=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function vs(e,t,n){try{if(!D(e))return NaN;if(!D(t))return NaN;if(!D(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=vs(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var la=P(vs);function Ns(e,t){try{if(t=S(t)?Math.E:t,!D(e))return NaN;if(!D(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Ns(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var ca=P(Ns);function fa(e,t){return ue(e,{shouldDropNaNs:t}).mean}function ha(e,t){return ue(e,{shouldDropNaNs:t,median:!0}).median}function ws(e,t){try{if(!D(e))return NaN;if(!D(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=ws(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var ma=P(ws);function da(e,t){return ue(e,{shouldDropNaNs:t,mode:!0}).mode}function Hr(){let e=ht(),t=ht();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function ga(e){return S(e)?Hr():cn(be(e),Hr)}function pa(e){return cn(be(e),()=>1)}function xn(e,t){function*n(r,s){if(s=s||r.length,r.length===1){yield[r];return}for(let o of hs(r,s)){if(!o.slice)continue;let i=Qn(o.length);yield o;let u=1;for(;u<o.length;)if(i[u]<u){if(u%2===0){let a=o[0];o[0]=o[u],o[u]=a}else{let a=o[i[u]];o[i[u]]=o[u],o[u]=a}yield o,i[u]+=1,u=1}else i[u]=0,u+=1}}return _(e)||O(e)?xn(e.values,t):(m(y(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),S(t)&&(t=e.length),m(D(t)&&Ae(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(Ne(e),t))}function ya(e,t){let n=[];for(let r of xn(e,t))n.push(r.slice());return n}function ba(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(y(t))if(jt(t))console.log(t);else{let n=T(t);n.length===1?new te(t).print():n.length==2?new V(t).print():console.log(t)}else _(t)||O(t)?t.print():console.log(t)})}var va=P((e,t,n,r,s)=>{try{let o=!1;for(let l of[e,t,n,r,s]){if(!D(l))return NaN;typeof l=="bigint"&&(o=!0)}o&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),s=Number(s));let i=(s-r)*(e-t),u=n-t;if(u===0)return NaN;let a=i/u+r;if(o)try{return BigInt(a)}catch{}return a}catch{return NaN}});function Na(e,t,n,r,s){if(y(e)&&S(r)&&S(s)){r=t,s=n;let o=ue(e);t=o.min,n=o.max}return va(e,t,n,r,s)}function wa(e){try{return D(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var Da=P(wa);function Ds(e){try{return D(e)?typeof e=="bigint"?BigInt(Ds(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var Ea=P(Ds);function Sa(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Fa=P(Sa);function Ln(e,t){if(_(e)||O(e))return Ln(e.values,t);m(y(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),m(q(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(y(n)){if(Ln(n,t))return!0}else if(t(n))return!0;return!1}function Es(e,t){return ue(e,{shouldDropNaNs:t,stdev:!0}).stdev}function Oa(e){return Es(e)}function Ta(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var _a=P(Ta);function Xr(e,t){m(q(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function Aa(e,t){m(q(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function Ia(){return ge([...arguments].map(e=>y(e)?e:_(e)||O(e)?e.values:[e]))}function Ma(e,t){return ue(e,{shouldDropNaNs:t,variance:!0}).variance}function Ca(){let e=[],t=Object.values(arguments).map(n=>((_(n)||O(n))&&(n=n.values),m(y(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return $(0,ln(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(s=>{let o=s[n];r.push(S(o)?void 0:o)}),e.push(r)}),e}var _t={abs:Wn,add:rn,apply:cn,arccos:Pu,arcsin:Ju,arctan:Vu,argmax:Pn,argmin:Rn,assert:m,cast:ie,ceil:Ku,chop:zu,clamp:Lu,combinations:hs,combinationsIterator:sn,copy:W,correl:Yn,cos:Gu,count:tn,covariance:At,DataFrame:V,dataTypes:Wu,decycle:Ge,diff:Vn,distance:$n,divide:Xu,dot:Be,dropMissing:Zn,dropMissingPairwise:Zt,dropNaN:Gn,dropNaNPairwise:Qt,dropUndefined:Zu,every:on,exp:xu,factorial:ea,find:Un,findAll:zn,flatten:Ne,float:na,floor:sa,identity:oa,IndexMatcher:fn,indexOf:ct,inferType:xt,int:Ae,intersect:ms,inverse:en,isArray:y,isBoolean:qe,isBrowser:aa,isDataFrame:_,isDate:ve,isEqual:_e,isFunction:q,isJagged:jt,isNested:an,isNumber:D,isObject:Te,isSeries:O,isString:j,isUndefined:S,lerp:la,log:ca,MathError:Ke,max:ln,mean:fa,median:ha,min:cs,mod:ma,mode:da,multiply:ys,ndarray:be,normal:ga,ones:pa,permutations:ya,permutationsIterator:xn,pow:Hn,print:ba,product:kt,random:ht,range:$,remap:Na,reshape:It,reverse:Oe,round:Da,scale:mt,seed:us,Series:te,set:ge,shape:T,shuffle:nn,sign:Ea,sin:Fa,some:Ln,sort:We,sqrt:ps,stats:ue,std:Es,stdev:Oa,subtract:bs,sum:Xn,tan:_a,timeAsync:Aa,timeSync:Xr,time:Xr,transpose:ke,union:Ia,variance:Ma,vectorize:P,zeros:Qn,zip:Ca,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new _t.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(_t).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:_t[t]})}catch{e[t]=_t[t]}})}};typeof window<"u"&&(window.JSMathTools=_t);var ja=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:void 0;function qn(e){let t=Symbol.for("@TypedArrayConstructor"),n="Symbol(@TypedArrayConstructor)",r=t in e?t:n in e?n:void 0;if(r){if(!("values"in e))throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");return e[r]==="ArrayBuffer"?new Uint8Array(e.values).buffer:new ja[e[r]](e.values)}if(y(e)&&e.constructor.name==="Array")return e;throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!")}function lt(e){if(e instanceof ArrayBuffer||e instanceof BigInt64Array||e instanceof BigUint64Array||e instanceof Float32Array||e instanceof Float64Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Int8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:e.constructor.name,values:e instanceof ArrayBuffer?Array.from(new Uint8Array(e)):Array.from(e)};if(y(e))return e.map(t=>{try{return lt(t)}catch{return t}});if(typeof e=="object"&e!==null){if(ve(e))return new Date(e.getTime());let t={};return Object.keys(e).forEach(n=>{try{t[n]=lt(e[n])}catch{t[n]=e[n]}}),t}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function Ss(e){return e=e.trim(),!!(e.match(/^-?\d+(\.\d+)?$/g)||e.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g)||e.match(/^-?\.\d+$/g)||e==="NaN")}var Fs="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";function Os(e,t,n){if(typeof e!="string")throw new Error("`text` must be a string!");if(typeof t!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return e.split(t).join(n)}var Zr="  ",Qr=" ";function er(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t="";for(let n=0;n<e.length;n++){let r=e[n].toLowerCase();Fs.includes(r)?t+=Qr:t+=r}for(;t.includes(Zr);)t=Os(t,Zr,Qr);return t.trim()}function Ba(e,t){return t=t||"",e.split(`
`).map(n=>n.trim().length>0?t+n:n).join(`
`)}function ka(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=er(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("-")}var xr={"@Infinity":1/0,"@NegativeInfinity":-1/0,"@NaN":NaN,"@undefined":void 0};function Mt(e){if(typeof e=="object"){if(e===null)return e;if(y(e))for(let t=0;t<e.length;t++)e[t]=Mt(e[t]);else Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{e[t]=Mt(e[t])});return e}else return typeof e>"u"||e==="Symbol(@undefined)"?void 0:e}function Pa(e){if(typeof e=="bigint")return e;if(typeof e=="string")if(e.match(/^\s*?-?\d+n\s*?$/g))try{return BigInt(e.split("n")[0])}catch{return NaN}else return NaN;else return NaN}function Ra(e){if(typeof e!="string")return typeof e=="number"?e:void 0;if(Ss(e))return parseFloat(e)}function Ja(e){if(typeof e!="string")return;let t="@jrc03c/js-text-tools/newline-replacer";if(e=e.replaceAll(`
`,t),e.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)){let n=e.replace("Symbol(@String):","");if(n.match(/^".*?"$/g))try{return JSON.parse(n)}catch{n=n.substring(1,n.length-1)}return n=n.replaceAll(t,`
`),n}}function Ya(e){if(typeof e!="string")return typeof e=="symbol"?{out:e,isASymbol:!0}:void 0;if(e.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)){let t=e.replace(/^.*?Symbol\(/g,"").replace(/\).*?$/g,"");return t in xr?{out:xr[t],isASymbol:!0}:{out:Symbol.for(t),isASymbol:!0}}}function Va(e){if(typeof e!="string")return e instanceof RegExp?e:void 0;let t=e.trim();if(t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g))try{let n=t.replace(/^\//g,"").replace(/\/(d|g|i|m|s|u|v|y)*?$/g,""),r=t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);return new RegExp(n,r)}catch{}}function $a(e){if(typeof e!="string")return typeof e=="object"?e:"Symbol(@undefined)";try{let t=JSON.parse(e,(n,r)=>{try{let s=un(r);return typeof s>"u"?"Symbol(@undefined)":s}catch{return typeof r>"u"?"Symbol(@undefined)":r}});return y(t)&&(t=Mt(t)),t}catch{return e}}function Ka(e){if(typeof e!="string")return e instanceof Date&&e.toString()!=="Invalid Date"?e:void 0;try{let t=new Date(Date.parse(e));if(t.toString()!=="Invalid Date")return t}catch{}}function Ua(e){return typeof e=="object"?e!==null?Mt(e):void 0:(Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{try{let n=t;try{t=un(t)}catch{}e[t]=un(e[n]),t!==n&&delete e[n]}catch{}}),Mt(e))}function un(e){function t(n){if(typeof n=="string"){let r=Ja(n);if(typeof r=="string")return r;let s=Ya(n);return r=s?s.out:void 0,s&&s.isASymbol||(r=Va(n),r instanceof RegExp)||(r=Pa(n),typeof r=="bigint")||(r=Ra(n),typeof r=="number")||(r=Ka(n),r instanceof Date)?r:(r=$a(n),typeof r<"u"?r==="Symbol(@undefined)"?void 0:r:n)}if(typeof n=="object"){if(n===null)return null;let r;try{if(r=qn(n),y(r))return r}catch{}if(r=Ua(n),r)try{return qn(r)}catch{return r}return n}return n}return t(e)}function za(e){let t=es(e);return t[0].toUpperCase()+t.slice(1)}function La(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=er(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("_")}function $e(e,t){return!e||t<=0?"":$(0,t).map(()=>e).join("")}function tr(e,t){m(j(t)||S(t),"The second parameter to the `stringify` function must be undefined or a string!");let n=t?`
`:"";function r(s,o,i){return i=i||0,typeof s=="bigint"?JSON.stringify(s.toString()+"n"):typeof s=="number"?s===1/0?'"Symbol(@Infinity)"':s===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(s)?'"Symbol(@NaN)"':s.toString():typeof s=="string"?JSON.stringify("Symbol(@String):"+s):typeof s=="boolean"?s.toString():typeof s>"u"?'"Symbol(@undefined)"':typeof s=="symbol"||typeof s=="function"?JSON.stringify(s.toString()):s instanceof RegExp?s.toString():typeof s=="object"?s===null?"null":ve(s)?JSON.stringify(s.toJSON()):y(s)?s.length===0?$e(o,i-1)+"[]":s instanceof Array?$e(o,i-1)+"["+n+s.map(u=>{let a=(()=>{try{return r(lt(u),o,i+1)}catch{return r(u,o,i+1)}})();return j(a)&&(a=a.trim()),$e(o,i+1)+a}).join(","+n)+n+$e(o,i)+"]":r(lt(s),null,o):Object.keys(s).length+Object.getOwnPropertySymbols(s).length===0?$e(o,i-1)+"{}":$e(o,i-1)+"{"+n+Object.keys(s).concat(Object.getOwnPropertySymbols(s)).map(u=>{let a=(()=>{try{return r(lt(s[u]),o,i+1)}catch{return r(s[u],o,i+1)}})();j(a)&&(a=a.trim());let l=typeof u=="symbol"?r(u):JSON.stringify(u);return $e(o,i+1)+l+":"+(o?" ":"")+a}).join(","+n)+n+$e(o,i)+"}":"undefined"}return r(Ge(e),t)}function qa(e){let t=e.split(`
`),n=t.filter(s=>s.trim().length>0).map(s=>s.split("").findIndex(o=>!o.match(/\s/g))),r=Math.min(...n);return t.map(s=>s.substring(r)).join(`
`)}function Ga(e,t){if(typeof e!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof t>"u"||t===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?t=process.stdout.columns>80?80:process.stdout.columns:t=80),isNaN(t)||typeof t!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return e.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let s=r.split(/[^\s]/g)[0],o=r.replace(s,"").split(" "),i=s;o.forEach(u=>{let a=i+(i.trim().length>0?" ":"")+u;a.length>t?(n.push(i),i=s+u):i=a}),i.length>0&&n.push(i)}),n.join(`
`)}typeof window<"u"&&(window.JSTextTools={camelify:es,convertObjectToTypedArray:qn,convertTypedArrayToObject:lt,indent:Ba,isANumberString:Ss,kebabify:ka,parse:un,pascalify:za,punctuation:Fs,replaceAll:Os,snakeify:La,stringify:tr,strip:er,unindent:qa,wrap:Ga});function nr(e,t){t=t||{};let n=b(t.maxUniqueValues)?t.maxUniqueValues:7,r=b(t.minNonMissingValues)?t.minNonMissingValues:15,s=b(t.maxCorrelationThreshold)?t.maxCorrelationThreshold:1-1e-5,o=t.progress||null;if(g(e))return f(w(e).length===2&&!G(e),"The `convertToNumerical` function only works on non-jagged 2-dimensional arrays and DataFrames!"),nr(new A(e));f(p(e),"You must pass a DataFrame into the `convertToNumerical` function!"),f(oe(n),"`maxUniqueValues` must be a whole number!"),f(oe(r),"`minNonMissingValues` must be a whole number!"),f(b(s),"`maxCorrelationThreshold` must be a number!"),v(o)||f(J(o),"If defined, `progress` must be a function!");let i={},u=!0;return e.apply((a,l)=>{o&&o(l/e.columns.length);let c=et(a.values);if(c.type==="boolean"&&(c.values=c.values.map(d=>d?1:0)),c.type==="date"&&(c.values=c.values.map(d=>{try{return d.getTime()}catch{return NaN}})),c.type==="null")return;c.type==="number"||c.type,c.type==="object"&&(c.values=c.values.map(d=>tr(d))),c.type;let h=c.values.filter(d=>!v(d));if(!(c.values.length-h.length>r.length)){if(c.type!=="boolean"){let d=re(Pe(h).toArray().filter(F=>!v(F.value)&&b(F.count)),(F,I)=>I.count-F.count);if(ee(d.slice(0,n).map(F=>F.count),u)/h.length>=.9){if(d.length<2)return;let F=Ot(a.name,c.values);for(;Object.keys(F).length>0;){let I=Object.keys(F)[0],De=F[I];delete F[I];let cr=Object.keys(i);for(let vn=0;vn<cr.length;vn++){let Rs=i[cr[vn]];if(ye(De,Rs,u)>s)return}i[I]=De}return}if(c.type==="object"||c.type==="string")return}if(c.type==="boolean"||c.type==="date"||c.type==="number"||c.type==="bigint"){let d=Object.keys(i);for(let E=0;E<d.length;E++){let F=i[d[E]];if(ye(c.values,F,u)>s)return}i[a.name]=c.values}}}),new A(i)}function rr(e){if(N(e)){let s=new A(rr(e.values));return s.index=e.index.slice(),s.columns=e.index.slice(),s}f(g(e),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let t=w(e);f(t.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=e.every(s=>typeof s=="bigint"),r=Ve([t[0],t[0]]);if(e.forEach((s,o)=>r[o][o]=s),n)for(let s=0;s<r.length;s++)for(let o=0;o<r[s].length;o++)try{r[s][o]=BigInt(r[s][o])}catch{}return r}function sr(e){let t="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(e,t,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(t)}),e}function hn(e,t,n){if(v(t)&&(t=e),p(e)){let s=new A(hn(e.values,t));return s.index=e.columns.slice(),s.columns=p(t)?t.columns.slice():new A(t).columns.slice(),sr(s)}if(p(t)){let s=new A(hn(e,t.values));return s.index=p(e)?e.columns.slice():new A(e).columns.slice(),s.columns=t.columns.slice(),sr(s)}f(g(e)&&g(t),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),f(!G(e)&&!G(t),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),f(e.length===t.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let r=Q([e[0].length,t[0].length]);for(let s=0;s<e[0].length;s++){let o=e.map(i=>i[s]);for(let i=0;i<t[0].length;i++){let u=t.map(a=>a[i]);n?r[s][i]=ye(...fe(o,u)):r[s][i]=ye(o,u)}}return sr(Le(r,-1,1))}function Ts(e,t,n){t=v(t)?1-1e-5:t,p(e)||(e=new A(e));let r=w(e);f((g(e)||p(e))&&r.length===2,"The first argument passed into the `getHighlyCorrelatedColumns` function must be a 2-dimensional array or DataFrame!"),f(b(t)&&t>=-1&&t<=1,"The second argument passed into the `getHighlyCorrelatedColumns` must be a number in the range [-1, 1] representing the threshold above which two columns will be considered to be highly correlated!");let s={};n&&(e=e.dropNaN());for(let o=0;o<r[1]-1;o++)for(let i=o+1;i<r[1];i++){let u=e.columns[o],a=e.columns[i],l=ye(e.get(u),e.get(a));l>t&&(s[u]||(s[u]=[]),s[u].push({column:a,correlation:l}),s[a]||(s[a]=[]),s[a].push({column:u,correlation:l}))}return Object.keys(s).forEach(o=>{s[o]=re(s[o],(i,u)=>i.column<u.column?-1:1)}),s}function Pt(e,t){return p(e)||N(e)?Pt(e.values):b(e)?se(e):g(e)?(t&&(e=ze(e)),Ye(ee(me(e,2)))):NaN}function _s(e,t){let n=M(e,{shouldDropNaNs:t}),r=t?n.nWithoutNaNs:n.n;return n.counts.values.filter(s=>b(s)||!t).map(s=>{let o=n.counts.get(s);return{value:s,count:o,percentage:o/r}})}var or=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5];function Wa(e){return se(e)>4.1?0:or[jn(Cn(se(e),0,4.1,0,or.length))]}function He(e,t,n){if(p(e)||N(e))return He(e.values,t);if(p(t)||N(t))return He(e,t.values);f(g(e)&&g(t)&&L(w(e),w(t)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[r,s]=n?fe(K(e),K(t)):[K(e),K(t)];if(r.length===0||s.length===0)return NaN;let o=M(r,{stdev:!0}),i=M(s,{stdev:!0}),u=o.mean,a=i.mean,l=o.stdev,c=i.stdev,h=r.length,d=s.length,E=(u-a)/Ye(l*l/h+c*c/d);return 2*Wa(E)}function ir(e){let t="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(e,t,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(t)}),e}function mn(e,t,n){if(v(t)&&(t=e),p(e)){let s=new A(mn(e.values,t));return s.index=e.columns.slice(),s.columns=p(t)?t.columns.slice():new A(t).columns.slice(),ir(s)}if(p(t)){let s=new A(mn(e,t.values));return s.index=p(e)?e.columns.slice():new A(e).columns.slice(),s.columns=t.columns.slice(),ir(s)}f(g(e)&&g(t),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),f(!G(e)&&!G(t),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),f(e.length===t.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let r=Q([e[0].length,t[0].length]);for(let s=0;s<e[0].length;s++){let o=e.map(i=>i[s]);for(let i=0;i<t[0].length;i++){let u=t.map(a=>a[i]);n?r[s][i]=He(...fe(o,u)):r[s][i]=He(o,u)}}return ir(Le(r,0,1))}function ur(e){if(g(e)){f(w(e).length===2&&!G(e),"The `hunterChainSort` function only works on non-jagged 2-dimensional arrays and DataFrames!");let i=new A(e);return i.index=i.columns.slice(),ur(i).values}f(p(e),"You must pass a 2-dimensional array or DataFrame into the `hunterChainSort` function!");let t=!0,n=e.index.slice(),r=[];for(;n.length>1;)if(r.length===0){let i=n[st(n.map(u=>ee(me(e.values[e.index.indexOf(u)],2),t)),t)];n.splice(n.indexOf(i),1),r.push(i)}else{let i=r.at(-1),u=e.values[e.index.indexOf(i)].filter((l,c)=>n.includes(e.index[c])),a=n[st(u,t)];n.splice(n.indexOf(a),1),r.push(a)}r.push(n[0]);let s=le(r);return e.get(s,null)}var dn=class e{static DROP_NAN_MODE="DROP_NAN_MODE";static DROP_MISSING_MODE="DROP_MISSING_MODE";constructor(t){let n=this;f(v(t)||t===e.DROP_NAN_MODE||t===e.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=v(t)?e.DROP_MISSING_MODE:t,n.index=null}fit(){let t=this,n=[];return Object.values(arguments).forEach(r=>{f(p(r)||N(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),t.mode===e.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),t.index=Gt(...n),t}transform(){let t=this;f(!!t.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(f(p(r)||N(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(t.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}};function ar(e,t){if(typeof e=="number")return e===0||e===1;if(typeof e=="bigint")return e===0n||e===1n;if(p(e)||N(e))return ar(e.values,t);if(g(e)){t&&(e=ze(e));let r=Pe(e).values.toSorted();return r.length===2&&Number(r[0])===0&&Number(r[1])===1||r.length===1&&(Number(r[0])===0||Number(r[0])===1)}return!1}function As(e){try{let t="@jrc03c/js-data-science-helpers/get-correlation-matrix";if(e[t]===Symbol.for(t))return!0;let n=M(e,{shouldDropNaNs:!0});return n.min>=-1&&n.max<=1}catch{return!1}}function Is(e,t){(p(e)||N(e))&&(e=e.values),(p(t)||N(t))&&(t=t.values),f(L(w(e),w(t)),"`yPred` and `yTrue` must have the same shape!");let n=K(e),r=K(t),s=0;return n.forEach((o,i)=>{o===r[i]&&s++}),s/n.length}function dt(e){return g(e)&&w(e).length===2}function Ms(e,t){return e.map(n=>t[Me(t.map(r=>we(n,r)))])}function gn(e,t){e=e.map(s=>s.map(o=>Number(o)));let n={},r=new Set;return t.forEach((s,o)=>{n[s]||(n[s]=[]),n[s].push(e[o]),r.add(s)}),Ft(e.map((s,o)=>{let i=t[o],u=1/0,a=1/0;return r.forEach(l=>{let c=n[l],h=c.length<2?0:ee(c.map(d=>we(s,d)));l===i?u=h:h<a&&(a=h)}),(a-u)/Je([u,a])}))}function we(e,t){return ee(me(de(e,t),2),!0)}var gt=class{constructor(t){f(typeof t=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),f(oe(t.k),"`k` must be a whole number!"),f(oe(t.maxIterations)||v(t.maxIterations),"`maxIterations` must be a whole number or undefined!"),f(oe(t.maxRestarts)||v(t.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),f(typeof t.tolerance=="number"||v(t.tolerance),"`tolerance` must be a number or undefined!"),this.k=t.k,this.maxRestarts=t.maxRestarts||25,this.maxIterations=t.maxIterations||100,this.tolerance=t.tolerance||1e-4,this.centroids=null}initializeCentroids(t){return Re(t).slice(0,this.k)}getFitStepFunction(t,n){f(dt(t),"`x` must be a matrix!"),p(t)&&(t=t.values),v(n)||f(J(n),"If defined, `progress` must be a function!");let r=this.initializeCentroids(t),s={currentRestart:0,currentIteration:0,currentCentroids:r,bestCentroids:r,bestScore:-1/0,isFinished:!1};return()=>{let o=this.predict(t,s.currentCentroids),i=[],u=Ve(this.k);t.forEach((l,c)=>{let h=o[c];i[h]||(i[h]=Ve(l.length)),i[h]=Ue(i[h],l),u[h]++});let a=C(0,this.k).map(l=>u[l]===0?Ue(s.currentCentroids[Math.floor(pe()*s.currentCentroids.length)],Fe(.001,In(s.currentCentroids[0].length))):je(i[l],u[l]));if(we(s.currentCentroids,a)<this.tolerance?s.currentIteration=this.maxIterations-1:s.currentCentroids=a,n&&n((s.currentRestart+s.currentIteration/this.maxIterations)/this.maxRestarts,this),s.currentIteration++,s.currentIteration>=this.maxIterations){let l=this.score(t,s.currentCentroids);if(l>s.bestScore&&(s.bestScore=l,s.bestCentroids=U(s.currentCentroids)),s.currentIteration=0,s.currentRestart++,s.currentRestart>=this.maxRestarts)s.isFinished=!0,this.centroids=s.bestCentroids,n&&n(1,this);else{let c=this.initializeCentroids(t);s.currentCentroids=c}}return s}}fit(t,n){let r=this.getFitStepFunction(t,n),s;for(;!s||!s.isFinished;)s=r();return this}predict(t,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return t.map(r=>Me(n.map(s=>we(r,s))))}score(t,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let s=this.predict(t,n).map(o=>n[o]);return-we(t,s)}};var pt=class extends gt{initializeCentroids(t){let r=[t[Math.floor(pe()*t.length)]];for(;r.length<this.k;){let s=t.map(i=>we(i,r[Me(r.map(u=>we(i,u)),!0)])),o=je(s,Je(s,!0));r.push(t[o.findIndex(i=>pe()<i)])}return r}};var pn=class{constructor(t){v(t)&&(t={}),f(typeof t=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),v(t.ks)&&(t.ks=C(2,16)),f(g(t.ks),"`ks` must be an array of whole numbers!"),t.ks.forEach(n=>{f(oe(n),"`ks` must be an array of whole numbers!")}),f(oe(t.maxIterations)||v(t.maxIterations),"`maxIterations` must be a whole number or undefined!"),f(oe(t.maxRestarts)||v(t.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),this.finalMaxIterations=t.finalMaxIterations||100,this.finalMaxRestarts=t.finalMaxRestarts||25,this.fittedModel=null,this.ks=t.ks,this.maxIterations=t.maxIterations||10,this.maxRestarts=t.maxRestarts||5,this.modelClass=t.modelClass||pt,this.tolerance=t.tolerance||1e-4}getFitStepFunction(t,n){p(t)&&(t=t.values),f(dt(t),"`x` must be a matrix!"),v(n)||f(J(n),"If defined, `progress` must be a function!");let r={currentIndex:0,isFinished:!1,scores:[]};return()=>{let s=this.ks[r.currentIndex],o=new this.modelClass({k:s,maxRestarts:10,maxIterations:20});o.fit(t,a=>n?n((r.currentIndex+a)/(this.ks.length+1)):null);let i=o.predict(t),u=gn(t,i);if(r.scores.length>=this.ks.length||u>1-this.tolerance?r.isFinished=!0:(r.scores.push({k:s,score:u}),r.currentIndex+1>=this.ks.length?r.isFinished=!0:r.currentIndex++),r.isFinished){let a=1,l=-1;r.scores.forEach(c=>{!isNaN(c.score)&&c.score>l&&(l=c.score,a=c.k)}),this.fittedModel=new this.modelClass({k:a,maxRestarts:this.finalMaxRestarts,maxIterations:this.finalMaxIterations}),this.fittedModel.fit(t,c=>n?n((this.ks.length+c)/(this.ks.length+1)):null),n&&n(1)}return r}}fit(t,n){let r=this.getFitStepFunction(t,n),s;for(;!s||!s.isFinished;)s=r();return this}predict(t,n){return this.fittedModel.predict(t,n)}score(t,n){return this.fittedModel.score(t,n)}get k(){return this.fittedModel.k}set k(t){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(t){f(L(w(t),w(this.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),this.fittedModel.centroids=t}};var Ha={accuracy:Is,isMatrix:dt,orderCentroids:Ms,silhouette:gn,sse:we},Cs={helpers:Ha,KMeansMeta:pn,KMeansNaive:gt,KMeansPlusPlus:pt};function Rt(e,t){if(p(e)||N(e)){let o=e.copy();return o.values=Rt(o.values),o}f(g(e),"The `normalize` function only works on arrays, Series, and DataFrames!");let n=M(e,{shouldDropNaNs:t,stdev:!0}),r=n.mean,s=n.stdev;return Ce(e,o=>(Number(o)-r)/s)}function Xe(e,t){if(N(e)){if(N(t))return new z(Xe(e.values,t.values));{let n=e.copy();return n.values=Xe(e.values,t),n}}if(N(t)){let n=t.copy();return n.values=Xe(e,t.values),n}return f(g(e),"`project` only works on vectors!"),f(g(t),"`project` only works on vectors!"),f(w(e).length===1,"`project` only works on vectors!"),f(w(t).length===1,"`project` only works on vectors!"),Fe(Number(ae(t,e))/Number(ae(t,t)),t)}function lr(e){if(p(e)){let o=new A(lr(e.values));return o.index=e.index.slice(),o.columns=e.columns.slice(),o}f(g(e)&&!G(e)&&w(e).length===2,"`orthonormalize` only works on matrices!");let t=x(e),n=[];t.forEach(o=>{let i=o;n.forEach(u=>{i=de(i,Xe(i,u))}),n.push(i)});let r=!0,s=n.map(o=>je(o,Pt(o,r)));return x(s)}function Xa(e){let t=e.counts.values;return t.length<3&&(t.length===2&&L(t.toSorted(),[0,1])||t.length===1&&(t[0]===0||t[0]===1))}function js(e){let t=[];return e.counts.values.forEach(n=>{if(b(n)){let r=e.counts.get(n);for(let s=0;s<r;s++)t.push(n)}}),t}var yn=class{constructor(t){t=t||{},this.isAllowedToClip=v(t.isAllowedToClip)?!0:t.isAllowedToClip,this.isAllowedToTakeTheLog=v(t.isAllowedToTakeTheLog)?!1:t.isAllowedToTakeTheLog,this.maxScore=t.maxScore||5,f(ce(this.isAllowedToClip),"The `isAllowedToClip` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"),f(ce(this.isAllowedToTakeTheLog),"The `isAllowedToTakeTheLog` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"),f(b(this.maxScore)&&this.maxScore>=0,"The `maxScore` property on the options object passed into the `OutlierMitigator` constructor must have a non-negative number value!"),this.mad=0,this.median=0}fit(t){if(p(t)||N(t))return this.fit(t.values);if(f(g(t),"The `OutlierMitigator.fit` method only works on arrays, Series, and DataFrames!"),t.length===0)return;let n=M(t,{shouldDropNaNs:!0,median:!0});if(Xa(n))return this;let r=js(n);return this.median=Number(n.median),this.mad=Number(M(se(de(r,this.median)),{median:!0}).median),this}fitAndTransform(){return this.fit(arguments[0]).transform(...arguments)}transform(){if(arguments.length>1)return Array.from(arguments).map(i=>this.transform(i));let t=arguments[0];if(p(t)||N(t))return this.transform(t.values);f(g(t),"The `OutlierMitigator.transform` method only works on arrays, Series, and DataFrames!");let n=M(t,{shouldDropNaNs:!0}),r=js(n),s=!1;if(this.mad===0){let i=[],u=[],a=-1/0,l=1/0;r.forEach(d=>{d<this.median?(i.push(d),d>a&&(a=d)):d>this.median&&(u.push(d),d<l&&(l=d))});let c=this.median,h=this.median;if(i.length>0&&(c=a),u.length>0&&(h=l),this.mad=(h-c)/2,this.mad===0)return t;s=(this.median-c)/this.mad>this.maxScore||(h-this.median)/this.mad>this.maxScore}if(M(je(se(de(r,this.median)),this.mad)).max>this.maxScore||s){let i=null,u=U(t);return this.isAllowedToClip&&(u=Ce(u,a=>(a=b(a)?Le(a,this.median-this.maxScore*this.mad,this.median+this.maxScore*this.mad):a,this.isAllowedToTakeTheLog&&b(a)&&(i===null||a<i)&&(i=a),a))),this.isAllowedToTakeTheLog&&(i===null&&(i=M(u).min),u=Ce(u,a=>b(a)?An(a-i+1):a)),u}else return t}};function yt(e,t,n){if(p(e)||N(e))return yt(e.values,t);if(p(t)||N(t))return yt(e,t.values);if(f(g(e),"You must pass two same-shaped numerical arrays into the `rSquared` function!"),f(g(t),"You must pass two same-shaped numerical arrays into the `rSquared` function!"),f(L(w(e),w(t)),"You must pass two same-shaped numerical arrays into the `rSquared` function!"),n){let o=fe(e,t);e=o[0],t=o[1]}let r=Number(ee(me(de(e,t),2))),s=Number(ee(me(de(e,Ft(e)),2)));return s===0?NaN:1-r/s}function Bs(e,t,n){let r=yt(e,t,n);return Bn(r)*Ye(se(r))}function ks(){return Rt(...arguments)}var bn=class{constructor(t){t=t||{},this.means=[],this.stdevs=[],this.wasFittedOnAVector=!1,this.hasBeenFitted=!1,this.shouldIgnoreNaNs=typeof t.shouldIgnoreNaNs>"u"?!1:t.shouldIgnoreNaNs}_getDataArrayAndShape(t){if(p(t))return[t.values,t.shape];if(N(t)){let r=x([t.values]);return[r,w(r)]}f(g(t),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=w(t);return f(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),t=x([t])),[t,n]}fit(t){let n=this._getDataArrayAndShape(t);t=n[0];let r=n[1];return this.wasFittedOnAVector=r.indexOf(1)>-1,this.means=[],this.stdevs=[],C(0,r[1]).forEach(s=>{let o=t.map(u=>u[s]),i=M(o,{shouldDropNaNs:this.shouldIgnoreNaNs,stdev:!0});this.means.push(i.mean),this.stdevs.push(i.stdev)}),this.hasBeenFitted=!0,this}fitAndTransform(){return this.fit(arguments[0]).transform(...arguments)}transform(){let t=Array.from(arguments);if(t.length>1)return t.map(i=>this.transform(i));let n=t[0];if(!this.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(p(n)){let i=new A(this.transform(n.values));return i.columns=n.columns,i.index=n.index,i}if(N(n)){let i=new z(this.transform(n.values));return i.name=n.name,i.index=n.index,i}let r=this._getDataArrayAndShape(n);n=r[0];let s=r[1];f(s[1]===this.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=n.map(i=>i.map((u,a)=>(Number(u)-Number(this.means[a]))/Number(this.stdevs[a])));return this.wasFittedOnAVector?K(o):o}untransform(t){if(!this.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(p(t)){let o=new A(this.untransform(t.values));return o.columns=t.columns,o.index=t.index,o}if(N(t)){let o=new z(this.untransform(t.values));return o.name=t.name,o.index=t.index,o}let n=this._getDataArrayAndShape(t);t=n[0];let r=n[1];f(r[1]===this.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let s=t.map(o=>o.map((i,u)=>i*this.stdevs[u]+this.means[u]));return this.wasFittedOnAVector?K(s):s}};function Ps(){let e=Array.from(arguments),t=e.filter(h=>g(h)||p(h)||N(h)),n=e.find(h=>!t.includes(h)&&typeof h=="object")||{},r=v(n.shouldShuffle)?!0:n.shouldShuffle,s=v(n.testSize)?.1:n.testSize;f(ce(r),"If passing an options object to the `trainTestSplit` function and including a `shouldShuffle` property on that object, then the value of that property must be a boolean!"),f(b(s)&&s>0&&s<1,"If passing an options object to the `trainTestSplit` function and including a `testSize` property on that object, then the value of that property must be a number between 0 and 1 (exclusive on both ends)!"),f(t.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let o=t.map(h=>w(h)[0]);f(X(o).length===1,`All datasets passed into the \`trainTestSplit\` function must have the same length at their shallowest dimension! The lengths of the datasets you provided, though, are: ${o.join(", ")}`);let i=[],u=r?Re(C(0,o[0])):C(0,o[0]),a=he((1-s)*u.length),l=u.slice(0,a),c=u.slice(a);return t.forEach(h=>{if(p(h))i.push(h.get(l,null)),i.push(h.get(c,null));else if(N(h))i.push(h.get(l)),i.push(h.get(c));else{let d=[],E=[];h.forEach((F,I)=>{l.includes(I)?d.push(F):E.push(F)}),i.push(d),i.push(E)}}),i}typeof window<"u"&&(window.JSDataScienceHelpers={cohensd:Wt,convertToNumerical:nr,diagonalize:rr,getCorrelationMatrix:hn,getHighlyCorrelatedColumns:Ts,getMagnitude:Pt,getOneHotEncodings:Ot,getPercentages:_s,getPValueMatrix:mn,hunterChainSort:ur,IndexMatcher:dn,isBinary:ar,isCorrelationMatrix:As,isWholeNumber:oe,KMeans:Cs,MathError:Ee,normalize:Rt,orthonormalize:lr,OutlierMitigator:yn,project:Xe,pValue:He,rScore:Bs,rSquared:yt,standardize:ks,StandardScaler:bn,trainTestSplit:Ps});})();
