var Js=Object.create;var zt=Object.defineProperty;var Ys=Object.getOwnPropertyDescriptor;var Vs=Object.getOwnPropertyNames;var $s=Object.getPrototypeOf,Ks=Object.prototype.hasOwnProperty;var Us=(e,t)=>{for(var n in t)zt(e,n,{get:t[n],enumerable:!0})},yr=(e,t,n,r)=>{if(t&&typeof t=="object"||typeof t=="function")for(let s of Vs(t))!Ks.call(e,s)&&s!==n&&zt(e,s,{get:()=>t[s],enumerable:!(r=Ys(t,s))||r.enumerable});return e};var Lt=(e,t,n)=>(n=e!=null?Js($s(e)):{},yr(t||!e||!e.__esModule?zt(n,"default",{value:e,enumerable:!0}):n,e)),zs=e=>yr(zt({},"__esModule",{value:!0}),e);var Qa={};Us(Qa,{IndexMatcher:()=>$t,KMeans:()=>hr,MathError:()=>pe,OutlierMitigator:()=>Kt,StandardScaler:()=>Ut,cohensd:()=>At,convertToNumerical:()=>yn,diagonalize:()=>bn,getCorrelationMatrix:()=>Yt,getHighlyCorrelatedColumns:()=>ur,getMagnitude:()=>pt,getOneHotEncodings:()=>ut,getPValueMatrix:()=>Vt,getPercentages:()=>ar,hunterChainSort:()=>vn,isBinary:()=>Nn,isCorrelationMatrix:()=>fr,isWholeNumber:()=>ne,normalize:()=>Nt,orthonormalize:()=>Dn,pValue:()=>Ue,project:()=>ze,rScore:()=>mr,rSquared:()=>Ze,standardize:()=>dr,trainTestSplit:()=>gr});module.exports=zs(Qa);var Ls=Object.defineProperty,qs=(e,t,n)=>t in e?Ls(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,Tr=(e,t,n)=>(qs(e,typeof t!="symbol"?t+"":t,n),n);function b(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Gs=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),pe=class extends Error{constructor(e){Gs()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function f(e,t){if(!e)throw new pe(t)}var _r=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function v(e){return e===null||typeof e>"u"}var Ws=_r.map(e=>e.name);function g(e){try{return e instanceof Array?!0:v(e.constructor)?!1:_r.indexOf(e.constructor)>-1||Ws.indexOf(e.constructor.name)>-1}catch{return!1}}function p(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function J(e){return typeof e=="function"}function Se(e){return typeof e=="object"&&!v(e)&&!g(e)}function N(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function nt(e,t){if(p(e)){let o=nt(e.values,t);return o.length>0&&b(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o.length>1&&b(o[1])&&o[1]>=0&&o[1]<e.columns.length&&(o[1]=e.columns[o[1]]),o}if(N(e)){let o=nt(e.values,t);return o.length>0&&b(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o}if(f(Se(e)||g(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!J(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Se(o)){u.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let l=0;l<a.length;l++){let c=a[l],h=o[c];if(i(h))return[c];let d=n(h,i,u);if(d&&d.length>0)return[c].concat(d)}}else if(g(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let c=n(l,i,u);if(c&&c.length>0)return[a].concat(c)}}else if(i(o))return[];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}function U(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(g(n))return n instanceof Array?n.map(s=>U(s)):n.slice();if(N(n)){let s=n.copy();return s.values=U(s.values),s}if(p(n)){let s=n.copy();return s.values=U(n.values),s}if(n instanceof Date)return new Date(n.getTime());n=rt(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(s=>{r[s]=U(n[s])}),r}else return n}return t(rt(e))}function rt(e){function t(s,o,i){if(o=o||[],i=i||"",o.indexOf(s)>-1){let u=i.split("/").slice(i.startsWith("/")?1:0);if(u.some((l,c)=>{let h=u.slice(0,u.length-c-1),d=n;return h.forEach(E=>{d=d[E]}),d===s}))return`<reference to "${n===s?"/":"/"+nt(n,s).join("/")}">`}return typeof s=="object"?s===null?null:(o.push(s),g(s)?typeof s.constructor<"u"&&s.constructor.name!=="Array"?s.slice():s.map((u,a)=>t(u,o,i+"/"+a)):(Object.keys(s).concat(Object.getOwnPropertySymbols(s)).forEach(u=>{s[u]=t(s[u],o,i+"/"+u.toString())}),s)):s}let n=e,r=t(n);if(p(e)){let s=e.copy();s._values=r.values,s._columns=r.columns,s._index=r.index,r=s}if(N(e)){let s=e.copy();s.name=r.name,s._values=r.values,s._index=r.index,r=s}return r}function Ie(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var br=["number","int","float","bigint"];function L(e,t){function n(r,s){let o=typeof r,i=typeof s;if(o!==i&&!br.includes(o)&&!br.includes(i))return!1;if(o==="undefined"&&i==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")try{let u=r.toString(),a=s.toString();return u===a}catch{return!1}if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{if(Ie(r))return Ie(s)?r.getTime()===s.getTime():!1;if(Ie(s))return!1;if(r instanceof RegExp&&s instanceof RegExp)return r.toString()===s.toString();if(g(r)!==g(s))return!1;let u=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(s).concat(Object.getOwnPropertySymbols(s));if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let c=u[l];if(!n(r[c],s[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(rt(e),rt(t))}}function Ft(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Hs=Ft(16),Xs=Ft(16),Zs=Ft(16),Qs=Ft(16),xs=Ft(16),eo=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)g(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Hs:v(e)?Xs:J(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+xs:e===1/0?Zs:e===-1/0?Qs:typeof e=="bigint"?e.toString():p(e)?e.toJSONString():N(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!v(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function K(e){if(p(e)||N(e))return K(e.values);f(g(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(s=>{g(s)?r=r.concat(t(s)):r.push(s)}),r}return t(e)}function M(e,t){t=t||{};let n=new eo,r={},s=K(e),o=[],i=-1/0,u=1/0,a=!1,l=0;for(let h of s){if(typeof h=="bigint"&&(a=!0),!t.shouldDropNaNs||b(h))try{h>i&&(i=h),h<u&&(u=h),l+=Number(h),o.push(h)}catch{i=NaN,u=NaN,l=NaN}n.increment(h)}let c=l/o.length;if(r.counts=n,r.max=i,r.mean=c,r.min=u,r.n=s.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=o.length),t.mode){let h=Array.from(n.values.map(F=>[F,n.get(F)])).toSorted((F,I)=>I[1]-F[1]),d=h[0][1],E=[];for(let F of h)if(F[1]==d)E.push(F[0]);else break;r.mode=E.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let h=o.toSorted((E,F)=>Number(E)-Number(F)),d=Math.floor(h.length/2);if(h.length%2===0){let E=h[d-1],F=h[d];if(r.median=(Number(E)+Number(F))/2,a&&typeof E=="bigint"&&typeof F=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=h[d]}if(t.stdev||t.variance){let h=0;for(let E of o)h+=Math.pow(Number(E)-c,2);h/=o.length;let d=Math.sqrt(h);r.stdev=d,r.variance=h}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(h=>{try{return BigInt(h)}catch{return h}}))}return r}function Pe(e,t){let{counts:n}=M(e);return v(t)||(J(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{L(r,t)||n.delete(r)})),n}function Sn(e){if(p(e)||N(e))return Sn(e.values);if(g(e)){let t=!1,n=!1,r=null;for(let s of e){if(Sn(s))return!0;if(g(s)){if(r===null)r=s.length;else if(s.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function G(e){return Sn(rt(e))}function Qt(e){if(p(e)||N(e))return Qt(e.values);f(g(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(g(e[t]))return!0;return!1}var Qe="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function Q(e){f(!v(e),Qe),g(e)||(e=[e]),f(!Qt(e),Qe),f(e.length>0,Qe);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),f(b(t),Qe),f(t>=0,Qe),f(Math.floor(t)===t,Qe),f(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(Q(e.slice(1)));return n}}function le(e){if(p(e)||N(e)){let n=e.copy();return n.values=le(n.values),n.index=le(n.index),n}f(g(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function C(e,t,n=1){f(!v(e)&&!v(t)&&!v(n),"You must pass two numbers and optionally a step value to the `range` function!"),f(b(e)&&b(t)&&b(n),"You must pass two numbers and optionally a step value to the `range` function!"),f(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,s=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let i=e;e=t+n,t=i+n}let o=[];for(let i=e;i<t;i+=n)if(s)try{o.push(BigInt(i))}catch{o.push(i)}else o.push(i);return r&&(o=le(o)),o}function Ot(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var to=Ot(256),no=Ot(256),ro=Ot(256),so=Ot(256),oo=Ot(256);function X(e){if(p(e)||N(e))return X(e.values);f(g(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return K(e).forEach(r=>{let s=typeof r=="object"&&r===null?to:v(r)?no:J(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+oo:r===1/0?ro:r===-1/0?so:typeof r=="bigint"?r.toString():p(r)?r.toJSONString():N(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||t.push(r),n[s]=!0}),t}function Ar(e){if(g(e)){let t=Ar(e[0]);return[e.length].concat(t||[])}else return}function w(e){return p(e)||N(e)?w(e.values):(f(g(e),"The `shape` function only works on arrays, Series, and DataFrames!"),Ar(e))}function Ir(e,t,n){if(v(n)&&(n=0),f(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),g(t)){f(!G(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=w(t);if(r.length===1)if(n===0){let s=e.copy();s._values.push(t);let o=Math.max(e.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(e.shape[0],r[0]),o=e.copy();for(C(0,s).forEach(i=>{i>=o._values.length&&o._values.push(Q(e.shape[1])),o._values[i].push(t[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...t.map(i=>i.length).concat([e.shape[1]])),o=e.copy();for(o._values=o._values.concat(t).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...t.map(u=>u.length))+e.shape[1],o=Math.max(e.shape[0],r[0]),i=e.copy();for(C(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(Q(e.shape[1])),i._values[u]=i._values[u].concat(t[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new pe("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(N(t)){let r=Ir(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(p(t))if(n===0){let r=e.copy(),s=X(r._columns.concat(t._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),t.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(t._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(e._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((s,o)=>{let i=t._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(t._values[i]):r._values[o]=r._values[o].concat(Q(t.shape[1]))}),t._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(Q(r._columns.length).concat(t._values[o])))}),r._columns=r._columns.concat(t._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new pe("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function io(e,t,n,r,s){if(s=s||0,f(J(r),"The first parameter to the `apply` method must be a function."),f(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new t(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let c=r(l,a,n);c instanceof t?o[u]=c.values:o[u]=c,v(i)&&(i=c instanceof t||g(c))}),i){let u=new e(o);return u.index=n.index,u}else{let u=new t(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new t(u);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return v(o)&&(o=c instanceof t||g(c)),c instanceof t?c.values:c});if(o){let u=new e(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new t(i);return u.index=n.index,u}}}function B(e){return typeof e=="string"}function uo(e,t,n,r,s){let o=u=>u instanceof e,i=u=>u instanceof t;if(v(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(Se(r)){let u=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new pe("You must pass a DataFrame, Series, or object into the `assign` method!")}else{f(B(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),f(g(s)&&!G(s)&&w(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}function ao(e,t){if(t.isEmpty)return new e;let n=new e(U(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function lo(e,t,n,r,s){v(r)&&(r=[]),v(s)&&(s=[]),(B(r)||b(r))&&(r=[r]),(B(s)||b(s))&&(s=[s]),f(g(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(g(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(w(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),f(w(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof t){let a=new e;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}function Mr(e){return b(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function st(e){return Mr(e)&&e>=0}function co(e,t,n,r,s,o){r=r||0,f(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,f(st(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",f(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let c=0;for(let h=0;h<l.length;h++){let d=l[h];if(v(d)&&c++,c>=o)return[]}}else if(s==="any")for(let c=0;c<l.length;c++){let h=l[c];if(v(h))return[]}else if(s==="all"){for(let c=0;c<l.length;c++){let h=l[c];if(!v(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(w(l).length<2)return new e;u.values=l;let c=u.get(null,a);if(v(c))return new e;B(c)&&(c=[c]),c instanceof t&&(c=c.values),u.index=c,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let E=u.values.map(I=>I[d]),F=i(E);F.length>0&&(l[h]=F)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=u.index,c}return u}function qe(e){if(p(e)||N(e))return e.dropNaN(...Object.values(arguments).slice(1));f(g(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(qe(n))}catch{if(b(n))return t.push(n)}}),t}function fo(e,t,n,r,s){n=n||0,f(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,f(st(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",f(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=qe(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=t.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new e}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new e}return i}function vr(e){let t={};return K(e).forEach((n,r)=>{t[n]=r}),t}function xe(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function ho(e,t,n,r,s){f(J(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),v(s)&&(s=0),f(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=vr(o.index),u=vr(o.columns);if(s===0){let a=0,l=o.values.filter((c,h)=>{let d=new t(c);d.name=n.index[h],d.index=n.columns;let E=r(d,h,n);return E?a++:delete i[o.index[h]],E});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=xe(i)[0],c.index=xe(u),c}o.values=l,o.index=xe(i)}else if(s===1){o=o.transpose();let a=0,l=o.values.filter((c,h)=>{let d=new t(c);d.name=n.columns[h],d.index=n.index;let E=r(d,h,n);return E?a++:delete u[o.index[h]],E});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=xe(u)[0],c.index=xe(i),c}o.values=l,o.index=xe(u),o=o.transpose()}return o}function mo(e,t,n){(B(t)||b(t))&&(t=[t]),(B(n)||b(n))&&(n=[n]);for(let s in t)typeof t[s]=="bigint"&&(t[s]=Number(t[s]));for(let s in n)typeof n[s]=="bigint"&&(n[s]=Number(n[s]));let r=X((t||[]).concat(n||[]).map(s=>typeof s));return f(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&f(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(f(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),f(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),v(t)||(t=t.map(s=>{if(B(s))return f(e.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(b(s))return f(s>=0,`Index ${s} is out of bounds!`),f(Math.floor(s)===s,"Row numbers must be integers!"),f(s<e.index.length,`Index ${s} is out of bounds!`),e.index[s]})),v(n)||(n=n.map(s=>{if(B(s))return f(e.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(b(s))return f(s>=0,`Column ${s} is out of bounds!`),f(Math.floor(s)===s,"Column numbers must be integers!"),f(s<e.columns.length,`Column ${s} is out of bounds!`),e.columns[s]})),e.getSubsetByNames(t,n)}function go(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function se(e,t){if(v(t)&&(t=go),p(e)||N(e))return e.sort(...Object.values(arguments).slice(1));f(g(e),"The `sort` function only works on arrays, Series, and DataFrames!"),f(J(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function po(e){let t=e.toLowerCase(),n="";for(let s=0;s<t.length;s++){let o=t[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Nr(e,t,n){v(n)?n=t.columns:B(n)&&(n=[n]);let r={};n.forEach(o=>{f(B(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=t.columns.indexOf(o);f(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=t.values.map(l=>l[i]),a=se(X(u));u.forEach(l=>{a.forEach(c=>{let h=o+"_"+po(c.toString());r[h]||(r[h]=[]),l===c?r[h].push(1):r[h].push(0)})})});let s=new e(r);return s.index=t.index,s}function yo(e,t,n){let r=e.shape;v(t)&&(t=C(0,r[0])),v(n)&&(n=C(0,r[1])),b(t)&&(t=[t]),b(n)&&(n=[n]),f(g(t)&&g(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(w(t).length===1&&w(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(t.length>0,"The `rowIndices` array must contain at least one index."),f(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(i=>{f(st(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(i<e.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{f(st(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),f(i<e.columns.length,`The column index ${i} is out of bounds.`)});let s=t.map(i=>e.index[i]),o=n.map(i=>e.columns[i]);return e.getSubsetByNames(s,o)}function bo(e,t,n,r,s){v(r)&&(r=n.index),v(s)&&(s=n.columns),B(r)&&(r=[r]),B(s)&&(s=[s]),f(g(r)&&g(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(w(r).length===1&&w(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(r.length>0,"The `rows` array must contain at least one row name."),f(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{f(B(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{f(B(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),f(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return o[0][0];if(r.length===1){let u=new t(o[0]);return u.name=r[0],u.index=s,u}if(s.length===1){let u=new t(o.map(a=>a[0]));return u.name=s[0],u.index=r,u}let i=new e(o);return i.columns=s,i.index=r,i}function vo(e,t,n){function r(d,E){return B(d)&&d.length>E?d.substring(0,E-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=Math.floor(s/2),i=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,u=Math.floor(i/2),a=s>n.index.length?null:C(0,o).concat(C(n.index.length-o,n.index.length)),l=i>n.columns.length?null:C(0,u).concat(C(n.columns.length-u,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),s<=n.index.length&&(c._index.splice(o,0,"..."),c._values.splice(o,0,C(0,c.columns.length).map(()=>"..."))),i<=n.columns.length&&(c._columns.splice(u,0,"..."),c._values=c._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return c instanceof t?(c.values=c.values.map(d=>r(d,h)),c.name=r(c.name,h),c.index=c.index.map(d=>r(d,h))):(c.values=c.values.map(d=>d.map(E=>r(E,h))),c.columns=c.columns.map(d=>r(d,h)),c.index=c.index.map(d=>r(d,h))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function et(e,t){f(b(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function No(e,t){let n=t?e:e.copy();return n.index=C(0,e.shape[0]).map(r=>"row"+et(r,(n.index.length-1).toString().length)),n}function Tt(e,t){if(p(e)||N(e))return Tt(e.values,t);f(g(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=K(e),r=!1,s=1;for(let o of n){if(!b(o))if(t)o=1;else return NaN;typeof o=="bigint"&&(r=!0,o=Number(o)),s*=o}if(r)try{return BigInt(s)}catch{}return s}catch{return NaN}}function wo(e){return Mr(e)&&e>0}function St(e,t){if(p(e)||N(e))return St(e.values,t);if(f(g(e),"The first argument passed into the `reshape` function must be an array!"),b(t)&&(t=[t]),f(g(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),f(w(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(o=>(typeof o=="bigint"&&(o=Number(o)),f(wo(o),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(o))),t.length===0)return K(e);let n=K(e);if(t.length===1&&t[0]===n.length)return n;f(Tt(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=Math.floor(n.length/t[0]);for(let o=0;o<t[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(St(i,t.slice(1)))}return r}var Cr=Math.pow(2,64),R=[];jr(Math.floor(Math.random()*Cr));function Do(e,t){e=H(e);function n(){e+=H("0x9e3779b97f4a7c15");let s=U(e);return s=(s^s>>BigInt(30))*H("0xbf58476d1ce4e5b9"),s=(s^s>>BigInt(27))*H("0x94d049bb133111eb"),s^s>>BigInt(31)}let r=[];for(let s=0;s<t;s++)r.push(n());return r}function H(e){return BigInt.asUintN(64,BigInt(e))}function wr(e,t){return e=H(e),t=BigInt(t),H(H(e<<t)|H(e>>H(BigInt(64)-t)))}function jr(e){if(typeof e=="bigint"&&(e=Number(e)),v(e))return U(R);{f(b(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=Do(Math.floor(e),4);R[0]=t[0],R[1]=t[1],R[2]=t[2],R[3]=t[3]}}function Dr(){let e=H(wr(R[0]+R[3],23)+R[0]),t=H(R[1]<<BigInt(17));return R[2]=H(R[2]^R[0]),R[3]=H(R[3]^R[1]),R[1]=H(R[1]^R[2]),R[0]=H(R[0]^R[3]),R[2]=H(R[2]^t),R[3]=wr(R[3],45),Math.floor(Number(e))/Cr}function ye(e){return v(e)?Dr():(g(e)||(e=[e]),St(Q(Tt(e)).map(Dr),e))}function Re(e){if(p(e)||N(e))return e.shuffle(...Object.values(arguments).slice(1));f(g(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let s=Math.floor(ye()*n.length);t.push(n.splice(s,1)[0])}return t}function Eo(e,t){return v(t)&&(t=0),f(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?Re(e.index):null,t===1?Re(e.columns):null)}function ce(e){return typeof e=="boolean"}function So(e,t,n){return J(t)?Fo(e,t,n):Oo(e,t,n)}function Fo(e,t,n){if(n=v(n)?0:n,f(J(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),f(b(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=se(e.index,(s,o)=>t(e.get(s,null),e.get(o,null)));return e.get(r,null)}else{let r=se(e.columns,(s,o)=>t(e.get(null,s),e.get(null,o)));return e.get(null,r)}}function Oo(e,t,n){let r=e.copy(),s=ye().toString();r=r.assign(s,r.index),v(t)&&(t=[s],n=[!0]),(b(t)||B(t))&&(t=[t],(ce(n)||B(n))&&(n=[n])),f(g(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),f(w(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),v(n)&&(n=C(0,t.length).map(()=>!0)),f(g(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),f(w(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),f(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(i=>{if(f(B(i)||b(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),B(i)){let u=r.columns.indexOf(i);return f(u>-1,`The column "${i}" does not exist!`),u}if(b(i))return f(st(i),"Column indices must be whole numbers!"),f(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(f(B(i)||ce(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),B(i)){let u=i.trim().toLowerCase();return f(u==="ascending"||u==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),u==="ascending"}if(ce(i))return i}),r.values=se(r.values,(i,u)=>{let a=0;for(;i[t[a]]===u[t[a]]&&a<t.length;)a++;let l=n[a];if(i[t[a]]===u[t[a]])return 0;if(i[t[a]]<u[t[a]])return l?-1:1;if(i[t[a]]>u[t[a]])return l?1:-1});let o=r.columns.indexOf(s);return r.index=r.values.map(i=>i[o]),r=r.dropColumns(s),r}function To(e,t){v(t)?t=0:f(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,s)=>{let o={};e.columns.forEach((i,u)=>{o[i]=e.values[s][u]}),n[r]=o}):e.columns.forEach((r,s)=>{let o={};e.index.forEach((i,u)=>{o[i]=e.values[u][s]}),n[r]=o}),n}function Br(e,t){return JSON.stringify(e.toObject(t))}async function _o(e,t,n){let r=Br(e,n),s=!1,o=!1,i,u;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new pe(i):typeof module<"u"?new pe(u):new pe("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function Ao(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function x(e){if(p(e)||N(e))return e.transpose();f(g(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=w(e);if(f(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return le(e);if(t.length===2){let n=Q(le(t));for(let r=0;r<t[0];r++)for(let s=0;s<t[1];s++)n[s][r]=e[r][s];return n}}function kr(e,t,n){if(N(n))return new e(t.values.concat(n.values));if(g(n)){let r=w(n);f(r.length===1&&!Qt(r),"Only vectors can be appended to Series!");let s=t.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(t.values.length+i))}),s}return kr(t,[n])}function Io(e,t){f(J(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,s)=>t(r,s)),n}function Mo(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,s)=>v(r)?!1:(n.push(t.index[s]),!0)),t._index=n,t}function Co(e,t){let n=[],r=[];t.values.forEach((o,i)=>{b(o)&&(r.push(o),n.push(t.index[i]))});let s=new e(r);return s.name=t.name,s.index=n,s}function jo(e,t,n){let r=t.copy(),s=U(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new e,r.name=t.name,r):(r.values=i,r.index=s,r)}function Bo(e,t){(B(t)||b(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=X((t||[]).map(r=>typeof r));return f(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&f(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(f(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),f(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),v(t)||(t=t.map(r=>{if(typeof r=="string")return f(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return f(r>=0,`Index ${r} is out of bounds!`),f(Math.floor(r)===r,"Indices must be integers!"),f(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function ko(e,t){let n=e.shape;v(t)&&(t=C(0,n[0])),f(g(t),"The `indices` array must be 1-dimensional array of whole numbers."),f(w(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),f(t.length>0,"The `indices` array must contain at least one index."),t.forEach(s=>{f(st(s),"The `indices` array must be a 1-dimensional array of whole numbers."),f(s<e.index.length,`The row index ${s} is out of bounds.`)});let r=t.map(s=>e.index[s]);return e.getSubsetByNames(r)}function Po(e,t,n){v(n)&&(n=t.index),f(g(n),"The `indices` array must be a 1-dimensional array of strings."),f(w(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),f(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{f(B(o),"The `indices` array must contain only strings."),f(t.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>t.values[t.index.indexOf(o)]);if(r.length===1)return r[0];let s=new e(r);return s.index=n,s.name=t.name,s}function Ro(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get(C(0,n/2).concat(C(t.index.length-n/2,t.index.length)));let s=U(t.index);s.splice(Math.floor(s.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(s)}let r={};return t.values.forEach((s,o)=>{let i={};i[t.name]=s,r[t.index[o]]=i}),console.table(r),console.log("Shape:",e.shape,`
`),e}function Jo(e){let t=e.copy();return t.get(Re(t.index))}function Yo(e,t,n){n=n||((a,l)=>a<l?-1:1),f(v(n)||J(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=x([t.values,t.index]),s=se(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new e;return u._values=o,u._index=i,u.name=t.name,u}function Vo(e,t){let n=x([t.values,t.index]);n=x(se(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function $o(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var Er=Symbol.for("@jrc03c/js-math-tools/series");function Ko(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Er}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Er}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(s){f(g(s),"The new values must be a 1-dimensional array!");let o=w(s);f(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<this._index.length?this._index=this._index.slice(0,o[0]):o[0]>this._index.length&&(this._index=this._index.concat(C(this._index.length,o[0]).map(i=>"item"+et(i,(s.length-1).toString().length)))),this._values=s}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(s){f(g(s),"The new index must be a 1-dimensional array of strings!"),f(s.length===this.shape[0],"The new index must be the same length as the old index!"),f(w(s).length===1,"The new index must be a 1-dimensional array of strings!"),s.forEach(o=>{f(B(o),"All of the row names must be strings!")}),this._index=s}}),r){if(r instanceof t)this.name=r.name,this.values=U(r.values),this.index=U(r.index);else if(g(r)){let s=w(r);f(s.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let s=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(u=>u.toString());f(s.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=s[0],i=r[o];f(w(i).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=o,this.values=i.slice()}}}get shape(){return w(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!v(r)).length===0}clear(){let r=this.copy();return r.values.forEach((s,o)=>{r.values[o]=void 0}),r}get(r){return Bo(this,r)}getSubsetByNames(r){return Po(t,this,r)}getSubsetByIndices(r){return ko(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(le(this.values));return r.index=le(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=C(0,this.shape[0]).map(s=>"item"+et(s,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=U(this.values),r._index=U(this.index),r.name=this.name,r}append(r){return kr(t,this,r)}apply(r){return Io(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return Mo(this,r,s)}dropNaN(){return Co(t,this)}toObject(){return $o(this)}print(){return Ro(this)}shuffle(){return Jo(this)}sort(r){return Yo(t,this,r)}sortByIndex(){return Vo(t,this)}filter(r){return jo(t,this,r)}toDataFrame(){let r=new e(x([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=le(r.values),r.index=le(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var Sr=Symbol.for("@jrc03c/js-math-tools/dataframe");function qt(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(ye()*t.length)];return n}var A=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Sr}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Sr}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!v(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){f(g(t),"The new values must be a 2-dimensional array!");let n=w(t);f(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat(C(this._index.length,n[0]).map(r=>"row"+et(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat(C(this._columns.length,n[1]).map(r=>"col"+et(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){f(g(t),"The new columns list must be a 1-dimensional array of strings!"),f(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),f(w(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+qt(8):r.trim()));let n=(()=>{let r=Pe(t),s={};return r.values.forEach(o=>{s[o]=r.get(o)}),s})();t=t.map(r=>n[r]>1?r+"_"+qt(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){f(g(t),"The new index must be a 1-dimensional array of strings!"),f(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),f(w(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+qt(8):r.trim()));let n=(()=>{let r=Pe(t),s={};return r.values.forEach(o=>{s[o]=r.get(o)}),s})();t=t.map(r=>n[r]>1?r+"_"+qt(8):r),this._index=t}}),f(v(e)||Se(e)||g(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof A)this.values=U(e.values),this.columns=U(e.columns),this.index=U(e.index);else if(g(e)){let t=w(e);f(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),f(!G(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(o=>o.toString());let t=[],n=null,r=null;this._columns.forEach(o=>{v(r)&&(n=o,r=e[o].length),f(e[o].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${o}" points to an array containing ${e[o].length} items.`),r=e[o].length;let i=e[o];t.push(i)}),this._values=x(t);let s=w(this.values);this._index=C(0,s[0]).map(o=>"row"+et(o,(s[0]-1).toString().length))}}get shape(){return w(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new A(Q(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return mo(this,e,t)}getSubsetByNames(e,t){return bo(A,z,this,e,t)}getSubsetByIndices(e,t){return yo(this,e,t)}getDummies(e){return Nr(A,this,e)}oneHotEncode(e){return Nr(A,this,e)}transpose(){let e=new A(x(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return No(this,e)}copy(){return ao(A,this)}assign(e,t){return uo(A,z,this,e,t)}apply(e,t){return io(A,z,this,e,t)}dropMissing(e,t,n){return co(A,z,this,e,t,n)}dropNaN(e,t,n){return fo(A,this,e,t,n)}drop(e,t){return lo(A,z,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return To(this,e)}toObject(){return Ao(this)}toJSONString(e){return Br(this,e)}saveAsJSON(e,t){return _o(this,e,t)}print(){return vo(A,z,this)}sort(e,t){return So(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return ho(A,z,this,e,t)}shuffle(e){return Eo(this,e)}append(e,t){return Ir(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},z=Ko(A);function Je(e,t){return M(e,{shouldDropNaNs:t}).max}function k(e){return f(J(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return g(a)?!0:N(a)?(n=!0,s.push(a),!0):p(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{f(L(g(u)?w(u):u.shape,g(i[a+1])?w(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=Je(i.map(l=>l.length?l.length:l.values.length)),a=C(0,u).map(l=>{let c=Object.keys(arguments).map(h=>g(arguments[h])?arguments[h][l]:N(arguments[h])||p(arguments[h])?arguments[h].values[l]:arguments[h]);return t(...c)});if(r)try{if(o.length===1&&L(w(o[0]),w(a))){let l=new A(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new A(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new z(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new z(a)}catch{return a}return a}else return e(...arguments)}}function Uo(e){try{return b(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var oe=k(Uo);function zo(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!b(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var Le=k(zo);function Lo(e,t){try{return t(e)}catch{return NaN}}var Ce=k(Lo);function qo(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var Go=k(qo);function Wo(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var Ho=k(Wo);function Xo(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var Zo=k(Xo);function ot(e,t){if(p(e)){let n=ot(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(N(e)){let n=ot(e.values,t);return e.index[n]}f(g(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=nt(e,Je(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function Pr(e,t){return M(e,{shouldDropNaNs:t}).min}function Me(e,t){if(p(e)){let n=Me(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(N(e)){let n=Me(e.values,t);return e.index[n]}f(g(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=nt(e,Pr(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function re(e,t){if(p(e)||N(e))return e.apply(n=>re(n,t));if(g(e))return e.map(n=>re(n,t));if(t==="null")return null;if(t==="number"){if(v(e))return NaN;let n=re(e,"boolean");if(ce(n))return n?1:0;try{JSON.parse(e)}catch{let o=re(e,"date");if(Ie(o))return o.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=re(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return re(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(re(e,"int"));if(t==="boolean"){if(ce(e))return e;if(b(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Ie(e))return e;if(v(e))return null;let n=parseFloat(e);if(!isNaN(n)){let s=new Date(e);return Ie(s)?s:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Se(e))return e;let n=re(e,"boolean");if(ce(n))return null;try{let s=re(e,"number");if(b(s))return JSON.parse(e),null}catch{}let r=re(e,"date");if(r)return r;try{let s=JSON.parse(e);return g(s)?s.map(o=>re(o,t)):s}catch{return null}}if(t==="string")return v(e)?L(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function Qo(e){try{return b(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var xo=k(Qo);function ei(e,t){try{if(!b(e))return NaN;if(typeof e=="bigint")return e;if(v(t))t=1e-10;else if(!b(t))return NaN;return oe(e)<t?0:e}catch{return NaN}}var ti=k(ei);function Fn(e){if(p(e)||N(e)){let t=e.copy();return t.values=Fn(t.values),t}if(g(e))return e.map(t=>Fn(t));try{let t=JSON.parse(e);return b(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var he=k(Fn);function Rr(e,t,n){try{return b(e)?b(t)?b(n)?typeof e=="bigint"?BigInt(Rr(he(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var Ge=k(Rr);function Xt(e,t){function*n(r,s){if(s>r.length)yield r;else if(s<=0)yield[];else if(r.length<2)yield r;else for(let o=0;o<r.length;o++){let i=r[o],u=r.slice(o+1);if(!(u.length<s-1)&&s-1>=0)for(let a of Xt(u,s-1))yield[i].concat(a)}}return p(e)||N(e)?Xt(e.values,t):(f(g(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),f(b(t)&&he(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(K(e),t))}function Jr(e,t){let n=[];for(let r of Xt(e,t))n.push(r.slice());return n}function xt(){let e=Object.values(arguments).map(n=>p(n)||N(n)?X(n.values):(f(g(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),X(n)));return X(e).filter(n=>e.every(r=>r.findIndex(s=>L(s,n))>-1))}var wt=class{constructor(e){f(v(e)||e===wt.DROP_NAN_MODE||e===wt.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=v(e)?wt.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(g(t)){let n=w(t);if(n.length===1)t=new z(t);else if(n.length===2)t=new A(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}f(p(t)||N(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===wt.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=xt(...e),this}transform(){f(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(g(t)){let n=w(t);if(n.length===1)return new z(t).get(this.index).values;if(n.length===2)return new A(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return f(p(t)||N(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},it=wt;Tr(it,"DROP_NAN_MODE","DROP_NAN_MODE");Tr(it,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Et(e,t,n,r){if(N(e))return Et(e.values,t,n,r);if(N(t))return Et(e,t.values,n,r);if(f(g(e)&&g(t)&&w(e).length===1&&w(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),f(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Et(...new it().fitAndTransform(e,t),!1,r);try{let s=M(e,{stdev:r}),o=M(t,{stdev:r}),i=Number(s.mean),u=Number(o.mean);if(!b(i)||!b(u))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let h=e[c],d=t[c];if(!b(h))return NaN;if(!b(d))return NaN;typeof h=="bigint"&&(h=Number(h)),typeof d=="bigint"&&(d=Number(d)),l+=(h-i)*(d-u)}return r?[l/e.length,s,o]:l/e.length}catch{return NaN}}function be(e,t,n){if(N(e))return be(e.values,t,n);if(N(t))return be(e,t.values,n);f(g(e)&&g(t)&&w(e).length===1&&w(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),f(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[s,o,i]=Et(e,t,n,!0),u=o.stdev*i.stdev;return s/u}catch{return NaN}}function ni(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var ri=k(ni),si=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function On(e,t){if(p(e)||N(e))return On(e.values,t);if(p(t)||N(t))return On(e,t.values);f(g(e)&&g(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=X(e),r=X(t),s=[];return n.forEach(o=>{r.findIndex(i=>L(i,o))<0&&s.push(o)}),s}function Yr(e,t){try{if(!b(e))return NaN;if(!b(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Yr(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var me=k(Yr);function Vr(e){try{if(!b(e))return NaN;if(typeof e=="bigint"){let t=Vr(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Ye=k(Vr);function oi(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!b(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var $r=k(oi);function Fe(){return $r(...arguments)}function de(e,t){return Le(e,Fe(t,-1))}function ee(e,t){return M(e,{shouldDropNaNs:t}).sum}function Tn(e,t){if(b(e)&&b(t))return oe(e-t);if(p(e)||N(e))return Tn(e.values,t);if(p(t)||N(t))return Tn(e,t.values);g(e)&&g(t)&&f(L(w(e),w(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Ye(ee(me(de(e,t),2)))}catch{return NaN}}function je(e,t){return Fe(e,me(t,-1))}function ae(e,t){if(p(e)){let s=ae(e.values,t);if(w(s).length===1){let o=new z(s);return o.name=N(t)?t.name:o.name,o.index=e.index.slice(),o}else{let o=new A(s);return o.index=e.index.slice(),p(t)&&(o.columns=t.columns.slice()),o}}if(p(t)){let s=ae(e,t.values);if(w(s).length===1){let o=new z(s);return o.name=N(e)?e.name:o.name,o.index=t.columns.slice(),o}else{let o=new A(s);return o.columns=t.columns.slice(),o}}if(N(e))return ae(e.values,t);if(N(t))return ae(e,t.values);f(g(e)&&g(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=w(e),r=w(t);if(f(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),f(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return ee(Fe(e,t));if(n.length===1&&r.length===2)return x(t).map(s=>ae(e,s));if(n.length===2&&r.length===1)return e.map(s=>ae(s,t));if(n.length===2&&r.length===2){let s=x(t),o=[];for(let i=0;i<e.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(ae(e[i],s[a]));o.push(u)}return o}}function Cn(e){if(p(e)||N(e))return e.dropMissing(...Object.values(arguments).slice(1));f(g(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Cn(n))}catch{v(n)||t.push(n)}}),t}function Wt(e,t){if(p(e)||N(e))return Wt(e.values,t);if(p(t)||N(t))return Wt(e,t.values);f(g(e)&&g(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),f(L(w(e),w(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=Wt(e[s],t[s]);n.push(o),r.push(i)}catch{!v(e[s])&&!v(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}function fe(e,t){if(p(e)||N(e))return fe(e.values,t);if(p(t)||N(t))return fe(e,t.values);f(g(e)&&g(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),f(L(w(e),w(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=fe(e[s],t[s]);n.push(o),r.push(i)}catch{b(e[s])&&b(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}function ii(e){return Cn(e)}function Zt(e,t){if(p(e)||N(e))return Zt(e.values,t);f(g(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),f(J(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(g(n)){if(!Zt(n,t))return!1}else if(!t(n))return!1;return!0}function ui(e){try{if(!b(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var ai=k(ui);function _n(e){try{return typeof e=="bigint"?BigInt(_n(he(e))):e!==he(e)?NaN:e<=1?1:e*_n(e-1)}catch{return NaN}}var li=k(_n);function An(e,t){if(p(e)||N(e))return An(e.values,t);if(f(Se(e)||g(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!J(t)){let s=t;t=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Se(s)){i.push(s);let u=Object.keys(s).concat(Object.getOwnPropertySymbols(s));for(let a=0;a<u.length;a++){let l=u[a],c=s[l];if(o(c))return c;let h=n(c,o,i);if(h)return h}}else if(g(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return t(s)}catch{return!1}}return n(e,r)}function In(e,t){if(p(e)||N(e))return In(e.values,t);if(f(Se(e)||g(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!J(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Se(o)){u.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o)),l=[];for(let c=0;c<a.length;c++){let h=a[c],d=o[h],E=!1;i(d)&&(l.push(d),E=!0);let F=n(d,i,u);F&&F.length>0&&F.slice(E?1:0).forEach(I=>l.push(I))}return l}else if(g(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let c=o[l],h=!1;i(c)&&(a.push(c),h=!0);let d=n(c,i,u);d&&d.length>0&&d.slice(h?1:0).forEach(E=>a.push(E))}return a}else if(i(o))return[o];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}function ci(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return b(t)?t:NaN}catch{return NaN}}var fi=k(ci);function hi(e){try{return b(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var mi=k(hi);function Ve(e){b(e)&&(e=[e]);let t=[],n=Tt(e);for(let r=0;r<n;r++)t.push(0);return St(t,e)}function di(e){typeof e=="bigint"&&(e=he(e)),f(!v(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),f(b(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),f(he(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),f(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=Ve([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var gi=["true","false","yes","no"],pi=["null","none","nan","na","n/a","","undefined"];function Gt(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=he(e.value)===e.value:e.isInteger=Zt(e.values,t=>b(t)?he(t)===t:!0)),e}function tt(e){if(p(e)){let o=e.copy(),i=tt(e.values);return o.values=i.values,Gt({type:i.type,values:o})}if(N(e)){let o=e.copy(),i=tt(e.values);return o.values=i.values,Gt({type:i.type,values:o})}if(!g(e)){let o=tt([e]);return o.value=o.values[0],delete o.values,Gt(o)}f(g(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=K(e).map(o=>{if(o===void 0)return"null";try{if(typeof o=="object"){let a=new Date(o.getTime());if(Ie(a))return"date"}}catch{}B(o)||(typeof o=="bigint"?o=o.toString()+"n":o=JSON.stringify(o));let u=o.toLowerCase().trim();if(pi.indexOf(u)>-1)return"null";if(gi.indexOf(u)>-1)return"boolean";try{if(o.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(o);return b(a)?"number":typeof a=="object"?g(a)?"string":"object":"string"}catch{let l=new Date(o);return Ie(l)?"date":"string"}}),n=Pe(t),s=n.values.toSorted((o,i)=>n.get(i)-n.get(o))[0];return Gt({type:s,values:Ce(e,o=>re(o,s))})}function Ht(e){if(p(e)){let n=e.copy();return n.values=Ht(n.values),n}f(g(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=w(e);if(f(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),f(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),f(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){f(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],s=e[1][0],o=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof s=="bigint"&&(s=Number(s)),typeof o=="bigint"&&(o=Number(o));let i=n*o-r*s;f(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return Fe(u,1/i)}else if(t[0]>1){let n=(r,s)=>b(r)||b(s)?Fe(r,s):ae(r,s);for(let r=1;r<t[0]-1;r++)try{let s=e.slice(0,r).map(I=>I.slice(0,r)),o=e.slice(0,r).map(I=>I.slice(r,t[0])),i=e.slice(r,t[0]).map(I=>I.slice(0,r)),u=e.slice(r,t[0]).map(I=>I.slice(r,t[0])),a=Ht(s),l=Ht(Le(u,n(-1,n(n(i,a),o)))),c=Le(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),E=l;return c.map((I,Ee)=>I.concat(h[Ee])).concat(d.map((I,Ee)=>I.concat(E[Ee])))}catch{}f(!1,"This matrix cannot be inverted!")}}var yi=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Kr(e,t,n){try{if(!b(e))return NaN;if(!b(t))return NaN;if(!b(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Kr(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var bi=k(Kr);function Ur(e,t){try{if(t=v(t)?Math.E:t,!b(e))return NaN;if(!b(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Ur(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var jn=k(Ur);function _t(e,t){return M(e,{shouldDropNaNs:t}).mean}function vi(e,t){return M(e,{shouldDropNaNs:t,median:!0}).median}function zr(e,t){try{if(!b(e))return NaN;if(!b(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=zr(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var Ni=k(zr);function wi(e,t){return M(e,{shouldDropNaNs:t,mode:!0}).mode}function Fr(){let e=ye(),t=ye();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function Bn(e){return v(e)?Fr():Ce(Q(e),Fr)}function Di(e){return Ce(Q(e),()=>1)}function kn(e,t){function*n(r,s){if(s=s||r.length,r.length===1){yield[r];return}for(let o of Jr(r,s)){if(!o.slice)continue;let i=Ve(o.length);yield o;let u=1;for(;u<o.length;)if(i[u]<u){if(u%2===0){let a=o[0];o[0]=o[u],o[u]=a}else{let a=o[i[u]];o[i[u]]=o[u],o[u]=a}yield o,i[u]+=1,u=1}else i[u]=0,u+=1}}return p(e)||N(e)?kn(e.values,t):(f(g(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),v(t)&&(t=e.length),f(b(t)&&he(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(K(e),t))}function Ei(e,t){let n=[];for(let r of kn(e,t))n.push(r.slice());return n}function Si(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(g(t))if(G(t))console.log(t);else{let n=w(t);n.length===1?new z(t).print():n.length==2?new A(t).print():console.log(t)}else p(t)||N(t)?t.print():console.log(t)})}var Fi=k((e,t,n,r,s)=>{try{let o=!1;for(let l of[e,t,n,r,s]){if(!b(l))return NaN;typeof l=="bigint"&&(o=!0)}o&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),s=Number(s));let i=(s-r)*(e-t),u=n-t;if(u===0)return NaN;let a=i/u+r;if(o)try{return BigInt(a)}catch{}return a}catch{return NaN}});function Pn(e,t,n,r,s){if(g(e)&&v(r)&&v(s)){r=t,s=n;let o=M(e);t=o.min,n=o.max}return Fi(e,t,n,r,s)}function Oi(e){try{return b(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var Rn=k(Oi);function Lr(e){try{return b(e)?typeof e=="bigint"?BigInt(Lr(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var Jn=k(Lr);function Ti(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var _i=k(Ti);function Mn(e,t){if(p(e)||N(e))return Mn(e.values,t);f(g(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),f(J(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(g(n)){if(Mn(n,t))return!0}else if(t(n))return!0;return!1}function qr(e,t){return M(e,{shouldDropNaNs:t,stdev:!0}).stdev}function Ai(e){return qr(e)}function Ii(e){try{return b(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var Mi=k(Ii);function Or(e,t){f(J(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function Ci(e,t){f(J(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function ji(){return X([...arguments].map(e=>g(e)?e:p(e)||N(e)?e.values:[e]))}function Bi(e,t){return M(e,{shouldDropNaNs:t,variance:!0}).variance}function ki(){let e=[],t=Object.values(arguments).map(n=>((p(n)||N(n))&&(n=n.values),f(g(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return C(0,Je(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(s=>{let o=s[n];r.push(v(o)?void 0:o)}),e.push(r)}),e}var Dt={abs:oe,add:Le,apply:Ce,arccos:Go,arcsin:Ho,arctan:Zo,argmax:ot,argmin:Me,assert:f,cast:re,ceil:xo,chop:ti,clamp:Ge,combinations:Jr,combinationsIterator:Xt,copy:U,correl:be,cos:ri,count:Pe,covariance:Et,DataFrame:A,dataTypes:si,decycle:rt,diff:On,distance:Tn,divide:je,dot:ae,dropMissing:Cn,dropMissingPairwise:Wt,dropNaN:qe,dropNaNPairwise:fe,dropUndefined:ii,every:Zt,exp:ai,factorial:li,find:An,findAll:In,flatten:K,float:fi,floor:mi,identity:di,IndexMatcher:it,indexOf:nt,inferType:tt,int:he,intersect:xt,inverse:Ht,isArray:g,isBoolean:ce,isBrowser:yi,isDataFrame:p,isDate:Ie,isEqual:L,isFunction:J,isJagged:G,isNested:Qt,isNumber:b,isObject:Se,isSeries:N,isString:B,isUndefined:v,lerp:bi,log:jn,MathError:pe,max:Je,mean:_t,median:vi,min:Pr,mod:Ni,mode:wi,multiply:$r,ndarray:Q,normal:Bn,ones:Di,permutations:Ei,permutationsIterator:kn,pow:me,print:Si,product:Tt,random:ye,range:C,remap:Pn,reshape:St,reverse:le,round:Rn,scale:Fe,seed:jr,Series:z,set:X,shape:w,shuffle:Re,sign:Jn,sin:_i,some:Mn,sort:se,sqrt:Ye,stats:M,std:qr,stdev:Ai,subtract:de,sum:ee,tan:Mi,timeAsync:Ci,timeSync:Or,time:Or,transpose:x,union:ji,variance:Bi,vectorize:k,zeros:Ve,zip:ki,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Dt.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Dt).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Dt[t]})}catch{e[t]=Dt[t]}})}};typeof window<"u"&&(window.JSMathTools=Dt);function At(e,t,n){if(N(e))return At(e.values,t);if(N(t))return At(e,t.values);if(f(g(e)&&g(t)&&w(e).length===1&&w(t).length===1,"The `cohensd` function only works on 1-dimensional arrays and Series!"),f(e.length===t.length,"Two arrays or Series passed into the `cohensd` function must have the same length!"),n){let r=new it().fitAndTransform(e,t);e=r[0],t=r[1]}try{let r=M(e,{variance:!0}),s=M(t,{variance:!0}),o=r.mean,i=s.mean;return(o-i)/Math.sqrt((r.variance+s.variance)/2)}catch{return NaN}}function Gr(e){return typeof e=="bigint"?e.toString()+"n":e}function ut(){if(arguments.length===1&&N(arguments[0])){let{name:s,values:o}=arguments[0],i=ut(s,o),u=new A(i);return u.index=arguments[0].index.slice(),u}let[e,t]=arguments;f(B(e),"When passing two arguments into the `getOneHotEncodings` function, the first argument must be a string representing the name of the variable being encoded!"),f(g(t)&&w(t).length===1,"When passing two arguments into the `getOneHotEncodings` function, the second argument must be a 1-dimensional array!");let n={};return se(X(t)).filter(s=>typeof s!="number"||s.toString()!=="NaN").filter(s=>!v(s)).map(s=>e+"_"+Gr(s)).slice(0,-1).forEach(s=>{n[s]=t.map(o=>s===e+"_"+Gr(o)?1:typeof o=="number"&&o.toString()==="NaN"?NaN:v(o)?NaN:0)}),n}function ne(e){return b(e)&&e>=0&&Math.floor(e)===e&&e<1/0}function is(e){if(typeof e!="string")throw new Error("`text` must be a string!");e=e.trim();let t="",n=!1;for(let r=0;r<e.length;r++){let s=e[r];s.match(/[A-Za-z0-9]/g)?(t.length===0?t+=s.toLowerCase():n?t+=s.toUpperCase():t+=s,n=!1):!s.includes("'")&&!s.includes("\u2019")&&!s.includes("\u275C")&&(n=!0)}return t}var Pi=Object.defineProperty,Ri=(e,t,n)=>t in e?Pi(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,us=(e,t,n)=>(Ri(e,typeof t!="symbol"?t+"":t,n),n);function D(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var Ji=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),Ke=class extends Error{constructor(e){Ji()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}};function m(e,t){if(!e)throw new Ke(t)}var as=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray];function S(e){return e===null||typeof e>"u"}var Yi=as.map(e=>e.name);function y(e){try{return e instanceof Array?!0:S(e.constructor)?!1:as.indexOf(e.constructor)>-1||Yi.indexOf(e.constructor.name)>-1}catch{return!1}}function _(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}function q(e){return typeof e=="function"}function Te(e){return typeof e=="object"&&!S(e)&&!y(e)}function O(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}function ht(e,t){if(_(e)){let o=ht(e.values,t);return o.length>0&&D(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o.length>1&&D(o[1])&&o[1]>=0&&o[1]<e.columns.length&&(o[1]=e.columns[o[1]]),o}if(O(e)){let o=ht(e.values,t);return o.length>0&&D(o[0])&&o[0]>=0&&o[0]<e.index.length&&(o[0]=e.index[o[0]]),o}if(m(Te(e)||y(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!q(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Te(o)){u.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o));for(let l=0;l<a.length;l++){let c=a[l],h=o[c];if(i(h))return[c];let d=n(h,i,u);if(d&&d.length>0)return[c].concat(d)}}else if(y(o)){u.push(o);for(let a=0;a<o.length;a++){let l=o[a];if(i(l))return[a];let c=n(l,i,u);if(c&&c.length>0)return[a].concat(c)}}else if(i(o))return[];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}function W(e){function t(n){if(typeof n=="object"){if(n===null)return null;if(y(n))return n instanceof Array?n.map(s=>W(s)):n.slice();if(O(n)){let s=n.copy();return s.values=W(s.values),s}if(_(n)){let s=n.copy();return s.values=W(n.values),s}if(n instanceof Date)return new Date(n.getTime());n=He(n);let r={};return Object.keys(n).concat(Object.getOwnPropertySymbols(n)).forEach(s=>{r[s]=W(n[s])}),r}else return n}return t(He(e))}function He(e){function t(s,o,i){if(o=o||[],i=i||"",o.indexOf(s)>-1){let u=i.split("/").slice(i.startsWith("/")?1:0);if(u.some((l,c)=>{let h=u.slice(0,u.length-c-1),d=n;return h.forEach(E=>{d=d[E]}),d===s}))return`<reference to "${n===s?"/":"/"+ht(n,s).join("/")}">`}return typeof s=="object"?s===null?null:(o.push(s),y(s)?typeof s.constructor<"u"&&s.constructor.name!=="Array"?s.slice():s.map((u,a)=>t(u,o,i+"/"+a)):(Object.keys(s).concat(Object.getOwnPropertySymbols(s)).forEach(u=>{s[u]=t(s[u],o,i+"/"+u.toString())}),s)):s}let n=e,r=t(n);if(_(e)){let s=e.copy();s._values=r.values,s._columns=r.columns,s._index=r.index,r=s}if(O(e)){let s=e.copy();s.name=r.name,s._values=r.values,s._index=r.index,r=s}return r}function Ne(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var Wr=["number","int","float","bigint"];function _e(e,t){function n(r,s){let o=typeof r,i=typeof s;if(o!==i&&!Wr.includes(o)&&!Wr.includes(i))return!1;if(o==="undefined"&&i==="undefined")return!0;if(o==="boolean"||o==="symbol")return r===s;if(o==="number"||o==="bigint")try{let u=r.toString(),a=s.toString();return u===a}catch{return!1}if(o==="string"||o==="function")return r===s;if(o==="object"){if(r===null||s===null)return r===null&&s===null;{if(Ne(r))return Ne(s)?r.getTime()===s.getTime():!1;if(Ne(s))return!1;if(r instanceof RegExp&&s instanceof RegExp)return r.toString()===s.toString();if(y(r)!==y(s))return!1;let u=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),a=Object.keys(s).concat(Object.getOwnPropertySymbols(s));if(u.length!==a.length)return!1;for(let l=0;l<u.length;l++){let c=u[l];if(!n(r[c],s[c]))return!1}return!0}}}try{return n(e,t)}catch{return n(He(e),He(t))}}function kt(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var Vi=kt(16),$i=kt(16),Ki=kt(16),Ui=kt(16),zi=kt(16),Li=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let t of e)y(t)?this.count(t):this.increment(t);return this}delete(e){let t=this.getStandardizedKey(e);return delete this.countsDict[t],delete this.valuesDict[t],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?Vi:S(e)?$i:q(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+zi:e===1/0?Ki:e===-1/0?Ui:typeof e=="bigint"?e.toString():_(e)?e.toJSONString():O(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!S(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,t){let n=this.getStandardizedKey(e);return this.countsDict[n]=t,this.valuesDict[n]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(t=>{e[t]=this.get(t)}),e}};function we(e){if(_(e)||O(e))return we(e.values);m(y(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function t(n){let r=[];return n.forEach(s=>{y(s)?r=r.concat(t(s)):r.push(s)}),r}return t(e)}function ue(e,t){t=t||{};let n=new Li,r={},s=we(e),o=[],i=-1/0,u=1/0,a=!1,l=0;for(let h of s){if(typeof h=="bigint"&&(a=!0),!t.shouldDropNaNs||D(h))try{h>i&&(i=h),h<u&&(u=h),l+=Number(h),o.push(h)}catch{i=NaN,u=NaN,l=NaN}n.increment(h)}let c=l/o.length;if(r.counts=n,r.max=i,r.mean=c,r.min=u,r.n=s.length,r.sum=l,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),t.shouldDropNaNs&&(r.nWithoutNaNs=o.length),t.mode){let h=Array.from(n.values.map(F=>[F,n.get(F)])).toSorted((F,I)=>I[1]-F[1]),d=h[0][1],E=[];for(let F of h)if(F[1]==d)E.push(F[0]);else break;r.mode=E.toSorted()}if(t.median)if(isNaN(c))r.median=NaN;else{let h=o.toSorted((E,F)=>Number(E)-Number(F)),d=Math.floor(h.length/2);if(h.length%2===0){let E=h[d-1],F=h[d];if(r.median=(Number(E)+Number(F))/2,a&&typeof E=="bigint"&&typeof F=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=h[d]}if(t.stdev||t.variance){let h=0;for(let E of o)h+=Math.pow(Number(E)-c,2);h/=o.length;let d=Math.sqrt(h);r.stdev=d,r.variance=h}if(a){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}t.mode&&(r.mode=r.mode.map(h=>{try{return BigInt(h)}catch{return h}}))}return r}function un(e,t){let{counts:n}=ue(e);return S(t)||(q(t)?n.values.forEach(r=>{t(r)||n.delete(r)}):n.values.forEach(r=>{_e(r,t)||n.delete(r)})),n}function Yn(e){if(_(e)||O(e))return Yn(e.values);if(y(e)){let t=!1,n=!1,r=null;for(let s of e){if(Yn(s))return!0;if(y(s)){if(r===null)r=s.length;else if(s.length!==r)return!0;t=!0}else n=!0;if(t&&n)return!0}}return!1}function Pt(e){return Yn(He(e))}function mn(e){if(_(e)||O(e))return mn(e.values);m(y(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let t=0;t<e.length;t++)if(y(e[t]))return!0;return!1}var at="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function ve(e){m(!S(e),at),y(e)||(e=[e]),m(!mn(e),at),m(e.length>0,at);let t=e[0];if(typeof t=="bigint"&&(t=Number(t)),m(D(t),at),m(t>=0,at),m(Math.floor(t)===t,at),m(t!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let n=[];for(let r=0;r<t;r++)n.push(void 0);return n}else{let n=[];for(let r=0;r<t;r++)n.push(ve(e.slice(1)));return n}}function Oe(e){if(_(e)||O(e)){let n=e.copy();return n.values=Oe(n.values),n.index=Oe(n.index),n}m(y(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let t=[];for(let n=e.length-1;n>=0;n--)t.push(e[n]);return t}function $(e,t,n=1){m(!S(e)&&!S(t)&&!S(n),"You must pass two numbers and optionally a step value to the `range` function!"),m(D(e)&&D(t)&&D(n),"You must pass two numbers and optionally a step value to the `range` function!"),m(n>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,s=typeof e=="bigint"||typeof t=="bigint"||typeof n=="bigint";if(e=Number(e),t=Number(t),n=Number(n),e>t){r=!0;let i=e;e=t+n,t=i+n}let o=[];for(let i=e;i<t;i+=n)if(s)try{o.push(BigInt(i))}catch{o.push(i)}else o.push(i);return r&&(o=Oe(o)),o}function Rt(e){let t="abcdefg1234567890",n="";for(;n.length<e;)n+=t[Math.floor(Math.random()*t.length)];return n}var qi=Rt(256),Gi=Rt(256),Wi=Rt(256),Hi=Rt(256),Xi=Rt(256);function ge(e){if(_(e)||O(e))return ge(e.values);m(y(e),"The `set` function only works on arrays, Series, and DataFrames!");let t=[],n={};return we(e).forEach(r=>{let s=typeof r=="object"&&r===null?qi:S(r)?Gi:q(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Xi:r===1/0?Wi:r===-1/0?Hi:typeof r=="bigint"?r.toString():_(r)?r.toJSONString():O(r)?JSON.stringify(r.toObject()):JSON.stringify(r);n[s]||t.push(r),n[s]=!0}),t}function ls(e){if(y(e)){let t=ls(e[0]);return[e.length].concat(t||[])}else return}function T(e){return _(e)||O(e)?T(e.values):(m(y(e),"The `shape` function only works on arrays, Series, and DataFrames!"),ls(e))}function cs(e,t,n){if(S(n)&&(n=0),m(n===0||n===1||n==="vertical"||n==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),y(t)){m(!Pt(t),"The array of data you're trying to append to this DataFrame is jagged!");let r=T(t);if(r.length===1)if(n===0){let s=e.copy();s._values.push(t);let o=Math.max(e.shape[1],r[0]);for(s._values.forEach(i=>{for(;i.length<o;)i.push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<o;)s._columns.push("col"+s._columns.length);return s}else{let s=Math.max(e.shape[0],r[0]),o=e.copy();for($(0,s).forEach(i=>{i>=o._values.length&&o._values.push(ve(e.shape[1])),o._values[i].push(t[i])});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<o._values[0].length;)o._columns.push("col"+o._columns.length);return o}else if(r.length===2)if(n===0){let s=Math.max(...t.map(i=>i.length).concat([e.shape[1]])),o=e.copy();for(o._values=o._values.concat(t).map(i=>{for(;i.length<s;)i.push(void 0);return i});o._index.length<o._values.length;)o._index.push("row"+o._index.length);for(;o._columns.length<s;)o._columns.push("col"+o._columns.length);return o}else{let s=Math.max(...t.map(u=>u.length))+e.shape[1],o=Math.max(e.shape[0],r[0]),i=e.copy();for($(0,o).forEach(u=>{for(u>=i._values.length&&i._values.push(ve(e.shape[1])),i._values[u]=i._values[u].concat(t[u]);i._values[u].length<s;)i._values[u].push(void 0)});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<s;)i._columns.push("col"+i._columns.length);return i}else throw new Ke("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(O(t)){let r=cs(e,t.values,n);return n===0?r.index[r.index.length-1]=r.index.indexOf(t.name)>-1?t.name+" (2)":t.name:r.columns[r.columns.length-1]=r.columns.indexOf(t.name)>-1?t.name+" (2)":t.name,r}else if(_(t))if(n===0){let r=e.copy(),s=ge(r._columns.concat(t._columns)).length;for(r._values.forEach(o=>{for(;o.length<s;)o.push(void 0)}),t.apply(o=>{let i=o.copy(),u=[];r._columns.forEach(a=>{let l=i._index.indexOf(a);l>-1?(u.push(i._values[l]),i._values.splice(l,1),i._index.splice(l,1)):u.push(void 0)}),r._values.push(u.concat(i._values))},1),r._columns=r._columns.concat(t._columns.filter(o=>r._columns.indexOf(o)<0));r._index.length<r._values.length;){let o="row"+r._index.length;r._index.push(o+(e._index.indexOf(o)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((s,o)=>{let i=t._index.indexOf(s);i>-1?r._values[o]=r._values[o].concat(t._values[i]):r._values[o]=r._values[o].concat(ve(t.shape[1]))}),t._index.forEach((s,o)=>{r._index.indexOf(s)<0&&(r._index.push(s),r._values.push(ve(r._columns.length).concat(t._values[o])))}),r._columns=r._columns.concat(t._columns.map(s=>s+(r._columns.indexOf(s)>-1?" (2)":""))),r}else throw new Ke("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}function Zi(e,t,n,r,s){if(s=s||0,m(q(r),"The first parameter to the `apply` method must be a function."),m(s===0||s===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),s===0){let o={},i;if(n.columns.forEach((u,a)=>{let l=new t(n.values.map(h=>h[a]));l.name=u,l.index=n.index;let c=r(l,a,n);c instanceof t?o[u]=c.values:o[u]=c,S(i)&&(i=c instanceof t||y(c))}),i){let u=new e(o);return u.index=n.index,u}else{let u=new t(n.columns.map(a=>o[a]));return u.index=n.columns,u}}else if(s===1){let o,i=n.values.map((u,a)=>{let l=new t(u);l.name=n.index[a],l.index=n.columns;let c=r(l,a,n);return S(o)&&(o=c instanceof t||y(c)),c instanceof t?c.values:c});if(o){let u=new e(i);return u.index=n.index,u.columns=n.columns,u}else{let u=new t(i);return u.index=n.index,u}}}function j(e){return typeof e=="string"}function Qi(e,t,n,r,s){let o=u=>u instanceof e,i=u=>u instanceof t;if(S(s)){if(o(r))return n.append(r,1);if(i(r))return n.append(r,1);if(Te(r)){let u=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(a=>r[a].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(a=>{for(;r[a].length<u;)r[a].push(void 0)}),n.append(new e(r),1)}else throw new Ke("You must pass a DataFrame, Series, or object into the `assign` method!")}else{m(j(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),m(y(s)&&!Pt(s)&&T(s).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let u=n.append(s,1);return u.columns[u.columns.length-1]=r,u}}function xi(e,t){if(t.isEmpty)return new e;let n=new e(W(t.values));return n.columns=t.columns.slice(),n.index=t.index.slice(),n}function eu(e,t,n,r,s){S(r)&&(r=[]),S(s)&&(s=[]),(j(r)||D(r))&&(r=[r]),(j(s)||D(s))&&(s=[s]),m(y(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),m(y(s),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),m(T(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),m(T(s).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let o,i;n.index.forEach((a,l)=>{r.indexOf(a)<0&&r.indexOf(l)<0&&(o||(o=[]),o.push(a))}),n.columns.forEach((a,l)=>{s.indexOf(a)<0&&s.indexOf(l)<0&&(i||(i=[]),i.push(a))});let u=n.get(o,i);if(u instanceof t){let a=new e;a=a.assign(u),n.index.indexOf(u.name)>-1&&(a=a.transpose()),u=a}return u}function fs(e){return D(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}function mt(e){return fs(e)&&e>=0}function tu(e,t,n,r,s,o){r=r||0,m(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),o=o||0,m(mt(o),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),s=o>0?"none":s||"any",m(s==="any"||s==="all"||s==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function i(l){if(o>0){let c=0;for(let h=0;h<l.length;h++){let d=l[h];if(S(d)&&c++,c>=o)return[]}}else if(s==="any")for(let c=0;c<l.length;c++){let h=l[c];if(S(h))return[]}else if(s==="all"){for(let c=0;c<l.length;c++){let h=l[c];if(!S(h))return l}return[]}return l}let u=n.copy(),a=Math.random().toString();if(r===0){u=u.assign(a,u.index);let l=u.values.map(i).filter(h=>h.length>0);if(T(l).length<2)return new e;u.values=l;let c=u.get(null,a);if(S(c))return new e;j(c)&&(c=[c]),c instanceof t&&(c=c.values),u.index=c,u=u.drop(null,a)}else if(r===1){let l={};if(u.columns.forEach((h,d)=>{let E=u.values.map(I=>I[d]),F=i(E);F.length>0&&(l[h]=F)}),Object.keys(l).length+Object.getOwnPropertySymbols(l).length===0)return new e;let c=new e(l);return c.index=u.index,c}return u}function Zn(e){if(_(e)||O(e))return e.dropNaN(...Object.values(arguments).slice(1));m(y(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(Zn(n))}catch{if(D(n))return t.push(n)}}),t}function nu(e,t,n,r,s){n=n||0,m(n===0||n===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),s=s||0,m(mt(s),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=s>0?"none":r||"any",m(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function o(u){let a=Zn(u);return s>0?u.length-a.length<s:r==="any"?a.length===u.length:r==="all"?a.length>0:!0}let i=t.copy();if(n===0){let u=i.index.filter(a=>{let l=i.get(a,null).values;return o(l)});return u.length>0?i.get(u,null):new e}else if(n===1){let u=i.columns.filter(a=>{let l=i.get(null,a).values;return o(l)});return u.length>0?i.get(null,u):new e}return i}function Hr(e){let t={};return we(e).forEach((n,r)=>{t[n]=r}),t}function lt(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((t,n)=>e[t]-e[n])}function ru(e,t,n,r,s){m(q(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),S(s)&&(s=0),m(s===0||s===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let o=n.copy();if(o.isEmpty)return o;let i=Hr(o.index),u=Hr(o.columns);if(s===0){let a=0,l=o.values.filter((c,h)=>{let d=new t(c);d.name=n.index[h],d.index=n.columns;let E=r(d,h,n);return E?a++:delete i[o.index[h]],E});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=lt(i)[0],c.index=lt(u),c}o.values=l,o.index=lt(i)}else if(s===1){o=o.transpose();let a=0,l=o.values.filter((c,h)=>{let d=new t(c);d.name=n.columns[h],d.index=n.index;let E=r(d,h,n);return E?a++:delete u[o.index[h]],E});if(a===0)return new e;if(a===1){let c=new t(l[0]);return c.name=lt(u)[0],c.index=lt(i),c}o.values=l,o.index=lt(u),o=o.transpose()}return o}function su(e,t,n){(j(t)||D(t))&&(t=[t]),(j(n)||D(n))&&(n=[n]);for(let s in t)typeof t[s]=="bigint"&&(t[s]=Number(t[s]));for(let s in n)typeof n[s]=="bigint"&&(n[s]=Number(n[s]));let r=ge((t||[]).concat(n||[]).map(s=>typeof s));return m(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&m(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(m(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),m(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),S(t)||(t=t.map(s=>{if(j(s))return m(e.index.indexOf(s)>-1,`Row "${s}" does not exist!`),s;if(D(s))return m(s>=0,`Index ${s} is out of bounds!`),m(Math.floor(s)===s,"Row numbers must be integers!"),m(s<e.index.length,`Index ${s} is out of bounds!`),e.index[s]})),S(n)||(n=n.map(s=>{if(j(s))return m(e.columns.indexOf(s)>-1,`Column "${s}" does not exist!`),s;if(D(s))return m(s>=0,`Column ${s} is out of bounds!`),m(Math.floor(s)===s,"Column numbers must be integers!"),m(s<e.columns.length,`Column ${s} is out of bounds!`),e.columns[s]})),e.getSubsetByNames(t,n)}function ou(e,t){try{return e<t?-1:e>t?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),t=typeof t=="object"&&t!==null?JSON.stringify(t):t.toString(),e<t?-1:e>t?1:0}}function Xe(e,t){if(S(t)&&(t=ou),_(e)||O(e))return e.sort(...Object.values(arguments).slice(1));m(y(e),"The `sort` function only works on arrays, Series, and DataFrames!"),m(q(t),"The second parameter of the `sort` function must be a comparison function!");let n=e.slice();return n.sort(t),n}function iu(e){let t=e.toLowerCase(),n="";for(let s=0;s<t.length;s++){let o=t[s];o.match(/[a-z0-9]/g)?n+=o:n+=" "}let r=n.split(" ").filter(s=>s.length>0);return r[0]+r.slice(1).map(s=>s[0].toUpperCase()+s.substring(1)).join("")}function Xr(e,t,n){S(n)?n=t.columns:j(n)&&(n=[n]);let r={};n.forEach(o=>{m(j(o),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let i=t.columns.indexOf(o);m(i>-1,`The given DataFrame does not have a column called "${o}"!`);let u=t.values.map(l=>l[i]),a=Xe(ge(u));u.forEach(l=>{a.forEach(c=>{let h=o+"_"+iu(c.toString());r[h]||(r[h]=[]),l===c?r[h].push(1):r[h].push(0)})})});let s=new e(r);return s.index=t.index,s}function uu(e,t,n){let r=e.shape;S(t)&&(t=$(0,r[0])),S(n)&&(n=$(0,r[1])),D(t)&&(t=[t]),D(n)&&(n=[n]),m(y(t)&&y(n),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),m(T(t).length===1&&T(n).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),m(t.length>0,"The `rowIndices` array must contain at least one index."),m(n.length>0,"The `colIndices` array must contain at least one index."),t.forEach(i=>{m(mt(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),m(i<e.index.length,`The row index ${i} is out of bounds.`)}),n.forEach(i=>{m(mt(i),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),m(i<e.columns.length,`The column index ${i} is out of bounds.`)});let s=t.map(i=>e.index[i]),o=n.map(i=>e.columns[i]);return e.getSubsetByNames(s,o)}function au(e,t,n,r,s){S(r)&&(r=n.index),S(s)&&(s=n.columns),j(r)&&(r=[r]),j(s)&&(s=[s]),m(y(r)&&y(s),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),m(T(r).length===1&&T(s).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),m(r.length>0,"The `rows` array must contain at least one row name."),m(s.length>0,"The `cols` array must contain at least one column name."),r.forEach(u=>{m(j(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),m(n.index.indexOf(u)>-1,`The row name "${u}" does not exist in the list of rows.`)}),s.forEach(u=>{m(j(u),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),m(n.columns.indexOf(u)>-1,`The column name "${u}" does not exist in the list of columns.`)});let o=r.map(u=>s.map(a=>n.values[n.index.indexOf(u)][n.columns.indexOf(a)]));if(r.length===1&&s.length===1)return o[0][0];if(r.length===1){let u=new t(o[0]);return u.name=r[0],u.index=s,u}if(s.length===1){let u=new t(o.map(a=>a[0]));return u.name=s[0],u.index=r,u}let i=new e(o);return i.columns=s,i.index=r,i}function lu(e,t,n){function r(d,E){return j(d)&&d.length>E?d.substring(0,E-3)+"...":d}if(n.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),n;let s=typeof window>"u"?20:10,o=Math.floor(s/2),i=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,u=Math.floor(i/2),a=s>n.index.length?null:$(0,o).concat($(n.index.length-o,n.index.length)),l=i>n.columns.length?null:$(0,u).concat($(n.columns.length-u,n.columns.length)),c=n.get(a,l);c instanceof t&&(n.shape[0]===1?(c=new e([c.values]),c.index=n.index,c.columns=new t(n.columns).get(l).values):n.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new t(n.index).get(a).values,c.columns=n.columns)),s<=n.index.length&&(c._index.splice(o,0,"..."),c._values.splice(o,0,$(0,c.columns.length).map(()=>"..."))),i<=n.columns.length&&(c._columns.splice(u,0,"..."),c._values=c._values.map(d=>(d.splice(u,0,"..."),d)));let h=28;return c instanceof t?(c.values=c.values.map(d=>r(d,h)),c.name=r(c.name,h),c.index=c.index.map(d=>r(d,h))):(c.values=c.values.map(d=>d.map(E=>r(E,h))),c.columns=c.columns.map(d=>r(d,h)),c.index=c.index.map(d=>r(d,h))),console.table(c.toDetailedObject()),console.log("Shape:",n.shape,`
`),n}function ct(e,t){m(D(e),"The `leftPad` function only works on numbers!");let n=e.toString();for(;n.length<t;)n="0"+n;return n}function cu(e,t){let n=t?e:e.copy();return n.index=$(0,e.shape[0]).map(r=>"row"+ct(r,(n.index.length-1).toString().length)),n}function Jt(e,t){if(_(e)||O(e))return Jt(e.values,t);m(y(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let n=we(e),r=!1,s=1;for(let o of n){if(!D(o))if(t)o=1;else return NaN;typeof o=="bigint"&&(r=!0,o=Number(o)),s*=o}if(r)try{return BigInt(s)}catch{}return s}catch{return NaN}}function fu(e){return fs(e)&&e>0}function jt(e,t){if(_(e)||O(e))return jt(e.values,t);if(m(y(e),"The first argument passed into the `reshape` function must be an array!"),D(t)&&(t=[t]),m(y(t),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),m(T(t).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),t=t.map(o=>(typeof o=="bigint"&&(o=Number(o)),m(fu(o),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(o))),t.length===0)return we(e);let n=we(e);if(t.length===1&&t[0]===n.length)return n;m(Jt(t)===n.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],s=Math.floor(n.length/t[0]);for(let o=0;o<t[0];o++){let i=n.slice(o*s,(o+1)*s);r.push(jt(i,t.slice(1)))}return r}var hs=Math.pow(2,64),Y=[];ms(Math.floor(Math.random()*hs));function hu(e,t){e=Z(e);function n(){e+=Z("0x9e3779b97f4a7c15");let s=W(e);return s=(s^s>>BigInt(30))*Z("0xbf58476d1ce4e5b9"),s=(s^s>>BigInt(27))*Z("0x94d049bb133111eb"),s^s>>BigInt(31)}let r=[];for(let s=0;s<t;s++)r.push(n());return r}function Z(e){return BigInt.asUintN(64,BigInt(e))}function Zr(e,t){return e=Z(e),t=BigInt(t),Z(Z(e<<t)|Z(e>>Z(BigInt(64)-t)))}function ms(e){if(typeof e=="bigint"&&(e=Number(e)),S(e))return W(Y);{m(D(e),"If passing a value into the `seed` function, then that value must be an integer!");let t=hu(Math.floor(e),4);Y[0]=t[0],Y[1]=t[1],Y[2]=t[2],Y[3]=t[3]}}function Qr(){let e=Z(Zr(Y[0]+Y[3],23)+Y[0]),t=Z(Y[1]<<BigInt(17));return Y[2]=Z(Y[2]^Y[0]),Y[3]=Z(Y[3]^Y[1]),Y[1]=Z(Y[1]^Y[2]),Y[0]=Z(Y[0]^Y[3]),Y[2]=Z(Y[2]^t),Y[3]=Zr(Y[3],45),Math.floor(Number(e))/hs}function dt(e){return S(e)?Qr():(y(e)||(e=[e]),jt(ve(Jt(e)).map(Qr),e))}function an(e){if(_(e)||O(e))return e.shuffle(...Object.values(arguments).slice(1));m(y(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let t=[],n=e.slice();for(let r=0;r<e.length;r++){let s=Math.floor(dt()*n.length);t.push(n.splice(s,1)[0])}return t}function mu(e,t){return S(t)&&(t=0),m(t===0||t===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(t===0?an(e.index):null,t===1?an(e.columns):null)}function We(e){return typeof e=="boolean"}function du(e,t,n){return q(t)?gu(e,t,n):pu(e,t,n)}function gu(e,t,n){if(n=S(n)?0:n,m(q(t),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),m(D(n),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),n===0){let r=Xe(e.index,(s,o)=>t(e.get(s,null),e.get(o,null)));return e.get(r,null)}else{let r=Xe(e.columns,(s,o)=>t(e.get(null,s),e.get(null,o)));return e.get(null,r)}}function pu(e,t,n){let r=e.copy(),s=dt().toString();r=r.assign(s,r.index),S(t)&&(t=[s],n=[!0]),(D(t)||j(t))&&(t=[t],(We(n)||j(n))&&(n=[n])),m(y(t),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),m(T(t).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),S(n)&&(n=$(0,t.length).map(()=>!0)),m(y(n),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),m(T(n).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),m(t.length===n.length,"The arrays passed into the `sort` method must be equal in length."),t=t.map(i=>{if(m(j(i)||D(i),"Column references can either be column names (as strings) or column indices (as whole numbers)."),j(i)){let u=r.columns.indexOf(i);return m(u>-1,`The column "${i}" does not exist!`),u}if(D(i))return m(mt(i),"Column indices must be whole numbers!"),m(i<r.columns.length,`The index ${i} is out of bounds!`),i}),n=n.map(i=>{if(m(j(i)||We(i),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),j(i)){let u=i.trim().toLowerCase();return m(u==="ascending"||u==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),u==="ascending"}if(We(i))return i}),r.values=Xe(r.values,(i,u)=>{let a=0;for(;i[t[a]]===u[t[a]]&&a<t.length;)a++;let l=n[a];if(i[t[a]]===u[t[a]])return 0;if(i[t[a]]<u[t[a]])return l?-1:1;if(i[t[a]]>u[t[a]])return l?1:-1});let o=r.columns.indexOf(s);return r.index=r.values.map(i=>i[o]),r=r.dropColumns(s),r}function yu(e,t){S(t)?t=0:m(t===0||t===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let n={};return t===0?e.index.forEach((r,s)=>{let o={};e.columns.forEach((i,u)=>{o[i]=e.values[s][u]}),n[r]=o}):e.columns.forEach((r,s)=>{let o={};e.index.forEach((i,u)=>{o[i]=e.values[u][s]}),n[r]=o}),n}function ds(e,t){return JSON.stringify(e.toObject(t))}async function bu(e,t,n){let r=ds(e,n),s=!1,o=!1,i,u;try{let a=t;if(t.includes("/")){let c=t.split("/");a=c[c.length-1]}let l=document.createElement("a");l.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,l.download=a,l.dispatchEvent(new MouseEvent("click")),s=!0}catch(a){i=a}try{let a=await import("node:fs"),l=await import("node:path");a.writeFileSync(l.resolve(t),r,"utf8"),o=!0}catch(a){u=a}if(!s&&!o)throw typeof window<"u"?new Ke(i):typeof module<"u"?new Ke(u):new Ke("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}function vu(e){let t={};return e.columns.forEach(n=>{t[n]=e.get(n).values}),t}function ke(e){if(_(e)||O(e))return e.transpose();m(y(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let t=T(e);if(m(t.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),t.length===1)return Oe(e);if(t.length===2){let n=ve(Oe(t));for(let r=0;r<t[0];r++)for(let s=0;s<t[1];s++)n[s][r]=e[r][s];return n}}function gs(e,t,n){if(O(n))return new e(t.values.concat(n.values));if(y(n)){let r=T(n);m(r.length===1&&!mn(r),"Only vectors can be appended to Series!");let s=t.copy();return n.forEach((o,i)=>{s._values.push(o),s._index.push("item"+(t.values.length+i))}),s}return gs(t,[n])}function Nu(e,t){m(q(t),"The parameter to the `apply` method must be a function.");let n=e.copy();return n._values=n._values.map((r,s)=>t(r,s)),n}function wu(e){let t=e.copy(),n=[];return t._values=t.values.filter((r,s)=>S(r)?!1:(n.push(t.index[s]),!0)),t._index=n,t}function Du(e,t){let n=[],r=[];t.values.forEach((o,i)=>{D(o)&&(r.push(o),n.push(t.index[i]))});let s=new e(r);return s.name=t.name,s.index=n,s}function Eu(e,t,n){let r=t.copy(),s=W(r.index),o=[],i=r.values.filter((u,a)=>{let l=n(u,a,r.values);return l||o.push(r.index[a]),l});return o.forEach(u=>{s.splice(s.indexOf(u),1)}),i.length===0?(r=new e,r.name=t.name,r):(r.values=i,r.index=s,r)}function Su(e,t){(j(t)||D(t))&&(t=[t]);for(let r in t)typeof t[r]=="bigint"&&(t[r]=Number(t[r]));let n=ge((t||[]).map(r=>typeof r));return m(n.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===1&&m(n[0]==="string"||n[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),n.length===2&&(m(n.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),m(n.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),S(t)||(t=t.map(r=>{if(typeof r=="string")return m(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return m(r>=0,`Index ${r} is out of bounds!`),m(Math.floor(r)===r,"Indices must be integers!"),m(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(t)}function Fu(e,t){let n=e.shape;S(t)&&(t=$(0,n[0])),m(y(t),"The `indices` array must be 1-dimensional array of whole numbers."),m(T(t).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),m(t.length>0,"The `indices` array must contain at least one index."),t.forEach(s=>{m(mt(s),"The `indices` array must be a 1-dimensional array of whole numbers."),m(s<e.index.length,`The row index ${s} is out of bounds.`)});let r=t.map(s=>e.index[s]);return e.getSubsetByNames(r)}function Ou(e,t,n){S(n)&&(n=t.index),m(y(n),"The `indices` array must be a 1-dimensional array of strings."),m(T(n).length===1,"The `indices` array must be a 1-dimensional array of strings."),m(n.length>0,"The `indices` array must contain at least one index name."),n.forEach(o=>{m(j(o),"The `indices` array must contain only strings."),m(t.index.indexOf(o)>-1,`The name "${o}" does not exist in the index.`)});let r=n.map(o=>t.values[t.index.indexOf(o)]);if(r.length===1)return r[0];let s=new e(r);return s.index=n,s.name=t.name,s}function Tu(e){let t=e.copy(),n=typeof window>"u"?20:10;if(t.index.length>n){t=t.get($(0,n/2).concat($(t.index.length-n/2,t.index.length)));let s=W(t.index);s.splice(Math.floor(s.length/2),0,"..."),t.values.push("..."),t.index.push("..."),t=t.get(s)}let r={};return t.values.forEach((s,o)=>{let i={};i[t.name]=s,r[t.index[o]]=i}),console.table(r),console.log("Shape:",e.shape,`
`),e}function _u(e){let t=e.copy();return t.get(an(t.index))}function Au(e,t,n){n=n||((a,l)=>a<l?-1:1),m(S(n)||q(n),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=ke([t.values,t.index]),s=Xe(r,(a,l)=>n(a[0],l[0])),o=[],i=[];s.forEach(a=>{o.push(a[0]),i.push(a[1])});let u=new e;return u._values=o,u._index=i,u.name=t.name,u}function Iu(e,t){let n=ke([t.values,t.index]);n=ke(Xe(n,(s,o)=>{if(s[1]===o[1])return 0;if(s[1]<o[1])return-1;if(s[1]>o[1])return 1}));let r=new e(n[0]);return r.index=n[1],r.name=t.name,r}function Mu(e){let t={};return t[e.name]={},e.index.forEach((n,r)=>{t[e.name][n]=e.values[r]}),t}var xr=Symbol.for("@jrc03c/js-math-tools/series");function Cu(e){class t{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===xr}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:xr}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(s){m(y(s),"The new values must be a 1-dimensional array!");let o=T(s);m(o.length===1,"The new array of values must be 1-dimensional!"),o[0]<this._index.length?this._index=this._index.slice(0,o[0]):o[0]>this._index.length&&(this._index=this._index.concat($(this._index.length,o[0]).map(i=>"item"+ct(i,(s.length-1).toString().length)))),this._values=s}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(s){m(y(s),"The new index must be a 1-dimensional array of strings!"),m(s.length===this.shape[0],"The new index must be the same length as the old index!"),m(T(s).length===1,"The new index must be a 1-dimensional array of strings!"),s.forEach(o=>{m(j(o),"All of the row names must be strings!")}),this._index=s}}),r){if(r instanceof t)this.name=r.name,this.values=W(r.values),this.index=W(r.index);else if(y(r)){let s=T(r);m(s.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let s=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(u=>u.toString());m(s.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let o=s[0],i=r[o];m(T(i).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=o,this.values=i.slice()}}}get shape(){return T(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!S(r)).length===0}clear(){let r=this.copy();return r.values.forEach((s,o)=>{r.values[o]=void 0}),r}get(r){return Su(this,r)}getSubsetByNames(r){return Ou(t,this,r)}getSubsetByIndices(r){return Fu(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new t(Oe(this.values));return r.index=Oe(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=$(0,this.shape[0]).map(s=>"item"+ct(s,(r.index.length-1).toString().length)),r}copy(){let r=new t;return r._values=W(this.values),r._index=W(this.index),r.name=this.name,r}append(r){return gs(t,this,r)}apply(r){return Nu(this,r)}concat(r){return this.append(r)}dropMissing(r,s){return wu(this,r,s)}dropNaN(){return Du(t,this)}toObject(){return Mu(this)}print(){return Tu(this)}shuffle(){return _u(this)}sort(r){return Au(t,this,r)}sortByIndex(){return Iu(t,this)}filter(r){return Eu(t,this,r)}toDataFrame(){let r=new e(ke([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=Oe(r.values),r.index=Oe(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return t}var es=Symbol.for("@jrc03c/js-math-tools/dataframe");function en(e){let t="abcdefghijklmnopqrstuvwxyz1234567890",n="";for(let r=0;r<e;r++)n+=t[Math.floor(dt()*t.length)];return n}var V=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===es}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:es}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!S(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(t){m(y(t),"The new values must be a 2-dimensional array!");let n=T(t);m(n.length===2,"The new array of values must be 2-dimensional!"),n[0]<this._index.length?this._index=this._index.slice(0,n[0]):n[0]>this._index.length&&(this._index=this._index.concat($(this._index.length,n[0]).map(r=>"row"+ct(r,(n[0]-1).toString().length)))),n[1]<this._columns.length?this._columns=this._columns.slice(0,n[1]):n[1]>this._columns.length&&(this._columns=this._columns.concat($(this._columns.length,n[1]).map(r=>"col"+ct(r,(n[1]-1).toString().length)))),this._values=t}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(t){m(y(t),"The new columns list must be a 1-dimensional array of strings!"),m(this.isEmpty||t.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),m(T(t).length===1,"The new columns list must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+en(8):r.trim()));let n=(()=>{let r=un(t),s={};return r.values.forEach(o=>{s[o]=r.get(o)}),s})();t=t.map(r=>n[r]>1?r+"_"+en(8):r),this._columns=t}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(t){m(y(t),"The new index must be a 1-dimensional array of strings!"),m(this.isEmpty||t.length===this.shape[0],"The new index must be the same length as the old index!"),m(T(t).length===1,"The new index must be a 1-dimensional array of strings!"),t=t.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+en(8):r.trim()));let n=(()=>{let r=un(t),s={};return r.values.forEach(o=>{s[o]=r.get(o)}),s})();t=t.map(r=>n[r]>1?r+"_"+en(8):r),this._index=t}}),m(S(e)||Te(e)||y(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof V)this.values=W(e.values),this.columns=W(e.columns),this.index=W(e.index);else if(y(e)){let t=T(e);m(t.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),m(!Pt(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(o=>o.toString());let t=[],n=null,r=null;this._columns.forEach(o=>{S(r)&&(n=o,r=e[o].length),m(e[o].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${n}" points to an array containing ${r} items, and the key "${o}" points to an array containing ${e[o].length} items.`),r=e[o].length;let i=e[o];t.push(i)}),this._values=ke(t);let s=T(this.values);this._index=$(0,s[0]).map(o=>"row"+ct(o,(s[0]-1).toString().length))}}get shape(){return T(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new V(ve(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,t){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return su(this,e,t)}getSubsetByNames(e,t){return au(V,te,this,e,t)}getSubsetByIndices(e,t){return uu(this,e,t)}getDummies(e){return Xr(V,this,e)}oneHotEncode(e){return Xr(V,this,e)}transpose(){let e=new V(ke(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return cu(this,e)}copy(){return xi(V,this)}assign(e,t){return Qi(V,te,this,e,t)}apply(e,t){return Zi(V,te,this,e,t)}dropMissing(e,t,n){return tu(V,te,this,e,t,n)}dropNaN(e,t,n){return nu(V,this,e,t,n)}drop(e,t){return eu(V,te,this,e,t)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return yu(this,e)}toObject(){return vu(this)}toJSONString(e){return ds(this,e)}saveAsJSON(e,t){return bu(this,e,t)}print(){return lu(V,te,this)}sort(e,t){return du(this,e,t)}sortByIndex(){return this.sort()}filter(e,t){return ru(V,te,this,e,t)}shuffle(e){return mu(this,e)}append(e,t){return cs(this,e,t)}concat(e,t){return this.append(e,t)}join(e,t){return this.append(e,t)}toString(){return JSON.stringify(this)}},te=Cu(V);function dn(e,t){return ue(e,{shouldDropNaNs:t}).max}function P(e){return m(q(e),"You must pass a function into the `vectorize` function!"),function t(){let n,r,s=[],o=[],i=Object.keys(arguments).filter(u=>{let a=arguments[u];return y(a)?!0:O(a)?(n=!0,s.push(a),!0):_(a)?(r=!0,o.push(a),!0):!1}).map(u=>arguments[u]);if(i.slice(0,-1).forEach((u,a)=>{m(_e(y(u)?T(u):u.shape,y(i[a+1])?T(i[a+1]):i[a+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),i.length>0){let u=dn(i.map(l=>l.length?l.length:l.values.length)),a=$(0,u).map(l=>{let c=Object.keys(arguments).map(h=>y(arguments[h])?arguments[h][l]:O(arguments[h])||_(arguments[h])?arguments[h].values[l]:arguments[h]);return t(...c)});if(r)try{if(o.length===1&&_e(T(o[0]),T(a))){let l=new V(a);return l.index=o[0].index.slice(),l.columns=o[0].columns.slice(),l}else return new V(a)}catch{return a}if(n)try{if(s.length===1&&s[0].length===a.length){let l=new te(a);return l.name=s[0].name,l.index=s[0].index.slice(),l}else return new te(a)}catch{return a}return a}else return e(...arguments)}}function ju(e){try{return D(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var Qn=P(ju);function Bu(){try{let e=0,t=!1,n=Object.values(arguments);for(let r of n){if(!D(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),e+=r}if(t)try{return BigInt(e)}catch{}return e}catch{return NaN}}var ln=P(Bu);function ku(e,t){try{return t(e)}catch{return NaN}}var gn=P(ku);function Pu(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var Ru=P(Pu);function Ju(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var Yu=P(Ju);function Vu(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var $u=P(Vu);function Vn(e,t){if(_(e)){let n=Vn(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(O(e)){let n=Vn(e.values,t);return e.index[n]}m(y(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let n=ht(e,dn(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function ps(e,t){return ue(e,{shouldDropNaNs:t}).min}function $n(e,t){if(_(e)){let n=$n(e.values,t);return[e.index[n[0]],e.columns[n[1]]]}if(O(e)){let n=$n(e.values,t);return e.index[n]}m(y(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let n=ht(e,ps(e,t));return n?n.length===0?void 0:n.length===1?n[0]:n:void 0}catch{return}}function ie(e,t){if(_(e)||O(e))return e.apply(n=>ie(n,t));if(y(e))return e.map(n=>ie(n,t));if(t==="null")return null;if(t==="number"){if(S(e))return NaN;let n=ie(e,"boolean");if(We(n))return n?1:0;try{JSON.parse(e)}catch{let o=ie(e,"date");if(Ne(o))return o.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(t==="int"){let n=ie(e,"number");return n>=0?Math.floor(n):Math.ceil(n)}if(t==="float")return ie(e,"number");if(t==="bigint")return typeof e=="bigint"?e:BigInt(ie(e,"int"));if(t==="boolean"){if(We(e))return e;if(D(e))return e===0?!1:e===1?!0:null;try{let n=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return n==="true"||n==="yes"||n==="y"?!0:n==="false"||n==="no"||n==="n"?!1:null}catch{return null}}if(t==="date"){if(Ne(e))return e;if(S(e))return null;let n=parseFloat(e);if(!isNaN(n)){let s=new Date(e);return Ne(s)?s:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(t==="object"){if(Te(e))return e;let n=ie(e,"boolean");if(We(n))return null;try{let s=ie(e,"number");if(D(s))return JSON.parse(e),null}catch{}let r=ie(e,"date");if(r)return r;try{let s=JSON.parse(e);return y(s)?s.map(o=>ie(o,t)):s}catch{return null}}if(t==="string")return S(e)?_e(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString()}function Ku(e){try{return D(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var Uu=P(Ku);function zu(e,t){try{if(!D(e))return NaN;if(typeof e=="bigint")return e;if(S(t))t=1e-10;else if(!D(t))return NaN;return Qn(e)<t?0:e}catch{return NaN}}var Lu=P(zu);function Kn(e){if(_(e)||O(e)){let t=e.copy();return t.values=Kn(t.values),t}if(y(e))return e.map(t=>Kn(t));try{let t=JSON.parse(e);return D(t)?typeof t=="bigint"?Number(t):t>=0?Math.floor(t):Math.ceil(t):NaN}catch{return NaN}}var Ae=P(Kn);function ys(e,t,n){try{return D(e)?D(t)?D(n)?typeof e=="bigint"?BigInt(ys(Ae(e),t,n)):e<t?t:e>n?n:e:NaN:NaN:NaN}catch{return NaN}}var qu=P(ys);function cn(e,t){function*n(r,s){if(s>r.length)yield r;else if(s<=0)yield[];else if(r.length<2)yield r;else for(let o=0;o<r.length;o++){let i=r[o],u=r.slice(o+1);if(!(u.length<s-1)&&s-1>=0)for(let a of cn(u,s-1))yield[i].concat(a)}}return _(e)||O(e)?cn(e.values,t):(m(y(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),m(D(t)&&Ae(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(we(e),t))}function bs(e,t){let n=[];for(let r of cn(e,t))n.push(r.slice());return n}function vs(){let e=Object.values(arguments).map(n=>_(n)||O(n)?ge(n.values):(m(y(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),ge(n)));return ge(e).filter(n=>e.every(r=>r.findIndex(s=>_e(s,n))>-1))}var It=class{constructor(e){m(S(e)||e===It.DROP_NAN_MODE||e===It.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=S(e)?It.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(t=>{if(y(t)){let n=T(t);if(n.length===1)t=new te(t);else if(n.length===2)t=new V(t);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}m(_(t)||O(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===It.DROP_MISSING_MODE?e.push(t.dropMissing().index):e.push(t.dropNaN().index)}),this.index=vs(...e),this}transform(){m(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(t=>{if(y(t)){let n=T(t);if(n.length===1)return new te(t).get(this.index).values;if(n.length===2)return new V(t).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return m(_(t)||O(t),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),t.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},pn=It;us(pn,"DROP_NAN_MODE","DROP_NAN_MODE");us(pn,"DROP_MISSING_MODE","DROP_MISSING_MODE");function Ct(e,t,n,r){if(O(e))return Ct(e.values,t,n,r);if(O(t))return Ct(e,t.values,n,r);if(m(y(e)&&y(t)&&T(e).length===1&&T(t).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),m(e.length===t.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),n)return Ct(...new pn().fitAndTransform(e,t),!1,r);try{let s=ue(e,{stdev:r}),o=ue(t,{stdev:r}),i=Number(s.mean),u=Number(o.mean);if(!D(i)||!D(u))return NaN;let a=Math.max(e.length,t.length),l=0;for(let c=0;c<a;c++){let h=e[c],d=t[c];if(!D(h))return NaN;if(!D(d))return NaN;typeof h=="bigint"&&(h=Number(h)),typeof d=="bigint"&&(d=Number(d)),l+=(h-i)*(d-u)}return r?[l/e.length,s,o]:l/e.length}catch{return NaN}}function Un(e,t,n){if(O(e))return Un(e.values,t,n);if(O(t))return Un(e,t.values,n);m(y(e)&&y(t)&&T(e).length===1&&T(t).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),m(e.length===t.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[s,o,i]=Ct(e,t,n,!0),u=o.stdev*i.stdev;return s/u}catch{return NaN}}function Gu(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var Wu=P(Gu),Hu=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function zn(e,t){if(_(e)||O(e))return zn(e.values,t);if(_(t)||O(t))return zn(e,t.values);m(y(e)&&y(t),"The `diff` function only works on arrays, Series, and DataFrames!");let n=ge(e),r=ge(t),s=[];return n.forEach(o=>{r.findIndex(i=>_e(i,o))<0&&s.push(o)}),s}function Ns(e,t){try{if(!D(e))return NaN;if(!D(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Ns(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.pow(e,t)}catch{return NaN}}var xn=P(Ns);function ws(e){try{if(!D(e))return NaN;if(typeof e=="bigint"){let t=ws(Number(e));try{return BigInt(t)}catch{return t}}return Math.sqrt(e)}catch{return NaN}}var Ds=P(ws);function Xu(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let t=!1,n=1;for(let r of e){if(!D(r))return NaN;typeof r=="bigint"&&(t=!0,r=Number(r)),n*=r}if(t)try{return BigInt(n)}catch{}return n}catch{return NaN}}var Es=P(Xu);function gt(){return Es(...arguments)}function Ss(e,t){return ln(e,gt(t,-1))}function er(e,t){return ue(e,{shouldDropNaNs:t}).sum}function Ln(e,t){if(D(e)&&D(t))return Qn(e-t);if(_(e)||O(e))return Ln(e.values,t);if(_(t)||O(t))return Ln(e,t.values);y(e)&&y(t)&&m(_e(T(e),T(t)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Ds(er(xn(Ss(e,t),2)))}catch{return NaN}}function Zu(e,t){return gt(e,xn(t,-1))}function Be(e,t){if(_(e)){let s=Be(e.values,t);if(T(s).length===1){let o=new te(s);return o.name=O(t)?t.name:o.name,o.index=e.index.slice(),o}else{let o=new V(s);return o.index=e.index.slice(),_(t)&&(o.columns=t.columns.slice()),o}}if(_(t)){let s=Be(e,t.values);if(T(s).length===1){let o=new te(s);return o.name=O(e)?e.name:o.name,o.index=t.columns.slice(),o}else{let o=new V(s);return o.columns=t.columns.slice(),o}}if(O(e))return Be(e.values,t);if(O(t))return Be(e,t.values);m(y(e)&&y(t),"The `dot` function only works on arrays, Series, and DataFrames!");let n=T(e),r=T(t);if(m(n.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),m(n[n.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${n[n.length-1]} !== ${r[0]})`),n.length===1&&r.length===1)return er(gt(e,t));if(n.length===1&&r.length===2)return ke(t).map(s=>Be(e,s));if(n.length===2&&r.length===1)return e.map(s=>Be(s,t));if(n.length===2&&r.length===2){let s=ke(t),o=[];for(let i=0;i<e.length;i++){let u=[];for(let a=0;a<s.length;a++)u.push(Be(e[i],s[a]));o.push(u)}return o}}function tr(e){if(_(e)||O(e))return e.dropMissing(...Object.values(arguments).slice(1));m(y(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let t=[];return e.forEach(n=>{try{return t.push(tr(n))}catch{S(n)||t.push(n)}}),t}function nn(e,t){if(_(e)||O(e))return nn(e.values,t);if(_(t)||O(t))return nn(e,t.values);m(y(e)&&y(t),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),m(_e(T(e),T(t)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=nn(e[s],t[s]);n.push(o),r.push(i)}catch{!S(e[s])&&!S(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}function rn(e,t){if(_(e)||O(e))return rn(e.values,t);if(_(t)||O(t))return rn(e,t.values);m(y(e)&&y(t),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),m(_e(T(e),T(t)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let n=[],r=[];for(let s=0;s<e.length;s++)try{let[o,i]=rn(e[s],t[s]);n.push(o),r.push(i)}catch{D(e[s])&&D(t[s])&&(n.push(e[s]),r.push(t[s]))}return[n,r]}function Qu(e){return tr(e)}function fn(e,t){if(_(e)||O(e))return fn(e.values,t);m(y(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),m(q(t),"The second argument passed into the `every` function must be a function!");for(let n of e)if(y(n)){if(!fn(n,t))return!1}else if(!t(n))return!1;return!0}function xu(e){try{if(!D(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var ea=P(xu);function qn(e){try{return typeof e=="bigint"?BigInt(qn(Ae(e))):e!==Ae(e)?NaN:e<=1?1:e*qn(e-1)}catch{return NaN}}var ta=P(qn);function Gn(e,t){if(_(e)||O(e))return Gn(e.values,t);if(m(Te(e)||y(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!q(t)){let s=t;t=o=>o===s}function n(s,o,i){if(i=i||[],i.indexOf(s)>-1)return null;if(Te(s)){i.push(s);let u=Object.keys(s).concat(Object.getOwnPropertySymbols(s));for(let a=0;a<u.length;a++){let l=u[a],c=s[l];if(o(c))return c;let h=n(c,o,i);if(h)return h}}else if(y(s)){i.push(s);for(let u=0;u<s.length;u++){let a=s[u];if(o(a))return a;let l=n(a,o,i);if(l)return l}}else if(o(s))return s;return null}function r(s){try{return t(s)}catch{return!1}}return n(e,r)}function Wn(e,t){if(_(e)||O(e))return Wn(e.values,t);if(m(Te(e)||y(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!q(t)){let o=t;t=i=>i===o}function n(o,i,u){if(u=u||[],u.indexOf(o)>-1)return null;if(Te(o)){u.push(o);let a=Object.keys(o).concat(Object.getOwnPropertySymbols(o)),l=[];for(let c=0;c<a.length;c++){let h=a[c],d=o[h],E=!1;i(d)&&(l.push(d),E=!0);let F=n(d,i,u);F&&F.length>0&&F.slice(E?1:0).forEach(I=>l.push(I))}return l}else if(y(o)){u.push(o);let a=[];for(let l=0;l<o.length;l++){let c=o[l],h=!1;i(c)&&(a.push(c),h=!0);let d=n(c,i,u);d&&d.length>0&&d.slice(h?1:0).forEach(E=>a.push(E))}return a}else if(i(o))return[o];return null}function r(o){try{return t(o)}catch{return!1}}let s=n(e,r);return s&&s.length>0?s:null}function na(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let t=JSON.parse(e);return D(t)?t:NaN}catch{return NaN}}var ra=P(na);function sa(e){try{return D(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var oa=P(sa);function nr(e){D(e)&&(e=[e]);let t=[],n=Jt(e);for(let r=0;r<n;r++)t.push(0);return jt(t,e)}function ia(e){typeof e=="bigint"&&(e=Ae(e)),m(!S(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),m(D(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),m(Ae(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),m(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let t=nr([e,e]);for(let n=0;n<e;n++)t[n][n]=1;return t}var ua=["true","false","yes","no"],aa=["null","none","nan","na","n/a","","undefined"];function tn(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=Ae(e.value)===e.value:e.isInteger=fn(e.values,t=>D(t)?Ae(t)===t:!0)),e}function sn(e){if(_(e)){let o=e.copy(),i=sn(e.values);return o.values=i.values,tn({type:i.type,values:o})}if(O(e)){let o=e.copy(),i=sn(e.values);return o.values=i.values,tn({type:i.type,values:o})}if(!y(e)){let o=sn([e]);return o.value=o.values[0],delete o.values,tn(o)}m(y(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let t=we(e).map(o=>{if(o===void 0)return"null";try{if(typeof o=="object"){let a=new Date(o.getTime());if(Ne(a))return"date"}}catch{}j(o)||(typeof o=="bigint"?o=o.toString()+"n":o=JSON.stringify(o));let u=o.toLowerCase().trim();if(aa.indexOf(u)>-1)return"null";if(ua.indexOf(u)>-1)return"boolean";try{if(o.match(/^-?\d+n$/g))return"bigint";let a=JSON.parse(o);return D(a)?"number":typeof a=="object"?y(a)?"string":"object":"string"}catch{let l=new Date(o);return Ne(l)?"date":"string"}}),n=un(t),s=n.values.toSorted((o,i)=>n.get(i)-n.get(o))[0];return tn({type:s,values:gn(e,o=>ie(o,s))})}function on(e){if(_(e)){let n=e.copy();return n.values=on(n.values),n}m(y(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let t=T(e);if(m(t.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),m(t[0]===t[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),m(t[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),t[0]===0)return e;if(t[0]===1){m(e[0][0]!==0,"This matrix cannot be inverted!");let n=e[0][0];return typeof n=="bigint"&&(n=Number(n)),1/n}else if(t[0]===2){let n=e[0][0],r=e[0][1],s=e[1][0],o=e[1][1];typeof n=="bigint"&&(n=Number(n)),typeof r=="bigint"&&(r=Number(r)),typeof s=="bigint"&&(s=Number(s)),typeof o=="bigint"&&(o=Number(o));let i=n*o-r*s;m(i!==0,"This matrix cannot be inverted!");let u=[[o,-r],[-s,n]];return gt(u,1/i)}else if(t[0]>1){let n=(r,s)=>D(r)||D(s)?gt(r,s):Be(r,s);for(let r=1;r<t[0]-1;r++)try{let s=e.slice(0,r).map(I=>I.slice(0,r)),o=e.slice(0,r).map(I=>I.slice(r,t[0])),i=e.slice(r,t[0]).map(I=>I.slice(0,r)),u=e.slice(r,t[0]).map(I=>I.slice(r,t[0])),a=on(s),l=on(ln(u,n(-1,n(n(i,a),o)))),c=ln(a,n(n(n(n(a,o),l),i),a)),h=n(-1,n(n(a,o),l)),d=n(-1,n(n(l,i),a)),E=l;return c.map((I,Ee)=>I.concat(h[Ee])).concat(d.map((I,Ee)=>I.concat(E[Ee])))}catch{}m(!1,"This matrix cannot be inverted!")}}var la=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `);function Fs(e,t,n){try{if(!D(e))return NaN;if(!D(t))return NaN;if(!D(n))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let r=Fs(Number(e),Number(t),n);try{return BigInt(r)}catch{return r}}return n*(t-e)+e}catch{return NaN}}var ca=P(Fs);function Os(e,t){try{if(t=S(t)?Math.E:t,!D(e))return NaN;if(!D(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Os(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return Math.log(e)/Math.log(t)}catch{return NaN}}var fa=P(Os);function ha(e,t){return ue(e,{shouldDropNaNs:t}).mean}function ma(e,t){return ue(e,{shouldDropNaNs:t,median:!0}).median}function Ts(e,t){try{if(!D(e))return NaN;if(!D(t))return NaN;if(typeof e=="bigint"||typeof t=="bigint"){let n=Ts(Number(e),Number(t));try{return BigInt(n)}catch{return n}}return e%t}catch{return NaN}}var da=P(Ts);function ga(e,t){return ue(e,{shouldDropNaNs:t,mode:!0}).mode}function ts(){let e=dt(),t=dt();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*t)}function pa(e){return S(e)?ts():gn(ve(e),ts)}function ya(e){return gn(ve(e),()=>1)}function rr(e,t){function*n(r,s){if(s=s||r.length,r.length===1){yield[r];return}for(let o of bs(r,s)){if(!o.slice)continue;let i=nr(o.length);yield o;let u=1;for(;u<o.length;)if(i[u]<u){if(u%2===0){let a=o[0];o[0]=o[u],o[u]=a}else{let a=o[i[u]];o[i[u]]=o[u],o[u]=a}yield o,i[u]+=1,u=1}else i[u]=0,u+=1}}return _(e)||O(e)?rr(e.values,t):(m(y(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),S(t)&&(t=e.length),m(D(t)&&Ae(t)===t&&t>=0,"`r` must be a non-negative integer!"),n(we(e),t))}function ba(e,t){let n=[];for(let r of rr(e,t))n.push(r.slice());return n}function va(){Object.keys(arguments).forEach(e=>{let t=arguments[e];if(y(t))if(Pt(t))console.log(t);else{let n=T(t);n.length===1?new te(t).print():n.length==2?new V(t).print():console.log(t)}else _(t)||O(t)?t.print():console.log(t)})}var Na=P((e,t,n,r,s)=>{try{let o=!1;for(let l of[e,t,n,r,s]){if(!D(l))return NaN;typeof l=="bigint"&&(o=!0)}o&&(e=Number(e),t=Number(t),n=Number(n),r=Number(r),s=Number(s));let i=(s-r)*(e-t),u=n-t;if(u===0)return NaN;let a=i/u+r;if(o)try{return BigInt(a)}catch{}return a}catch{return NaN}});function wa(e,t,n,r,s){if(y(e)&&S(r)&&S(s)){r=t,s=n;let o=ue(e);t=o.min,n=o.max}return Na(e,t,n,r,s)}function Da(e){try{return D(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var Ea=P(Da);function _s(e){try{return D(e)?typeof e=="bigint"?BigInt(_s(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var Sa=P(_s);function Fa(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Oa=P(Fa);function Hn(e,t){if(_(e)||O(e))return Hn(e.values,t);m(y(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),m(q(t),"The second argument passed into the `some` function must be a function!");for(let n of e)if(y(n)){if(Hn(n,t))return!0}else if(t(n))return!0;return!1}function As(e,t){return ue(e,{shouldDropNaNs:t,stdev:!0}).stdev}function Ta(e){return As(e)}function _a(e){try{return D(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var Aa=P(_a);function ns(e,t){m(q(e),"`fn` must be a function!");let n=new Date;return t?e(...t):e(),new Date-n}async function Ia(e,t){m(q(e),"`fn` must be a function!");let n=new Date;return t?await e(...t):await e(),new Date-n}function Ma(){return ge([...arguments].map(e=>y(e)?e:_(e)||O(e)?e.values:[e]))}function Ca(e,t){return ue(e,{shouldDropNaNs:t,variance:!0}).variance}function ja(){let e=[],t=Object.values(arguments).map(n=>((_(n)||O(n))&&(n=n.values),m(y(n),"The `zip` function only works on arrays, Series, and DataFrames!"),n));return $(0,dn(t.map(n=>n.length))).forEach(n=>{let r=[];t.forEach(s=>{let o=s[n];r.push(S(o)?void 0:o)}),e.push(r)}),e}var Mt={abs:Qn,add:ln,apply:gn,arccos:Ru,arcsin:Yu,arctan:$u,argmax:Vn,argmin:$n,assert:m,cast:ie,ceil:Uu,chop:Lu,clamp:qu,combinations:bs,combinationsIterator:cn,copy:W,correl:Un,cos:Wu,count:un,covariance:Ct,DataFrame:V,dataTypes:Hu,decycle:He,diff:zn,distance:Ln,divide:Zu,dot:Be,dropMissing:tr,dropMissingPairwise:nn,dropNaN:Zn,dropNaNPairwise:rn,dropUndefined:Qu,every:fn,exp:ea,factorial:ta,find:Gn,findAll:Wn,flatten:we,float:ra,floor:oa,identity:ia,IndexMatcher:pn,indexOf:ht,inferType:sn,int:Ae,intersect:vs,inverse:on,isArray:y,isBoolean:We,isBrowser:la,isDataFrame:_,isDate:Ne,isEqual:_e,isFunction:q,isJagged:Pt,isNested:mn,isNumber:D,isObject:Te,isSeries:O,isString:j,isUndefined:S,lerp:ca,log:fa,MathError:Ke,max:dn,mean:ha,median:ma,min:ps,mod:da,mode:ga,multiply:Es,ndarray:ve,normal:pa,ones:ya,permutations:ba,permutationsIterator:rr,pow:xn,print:va,product:Jt,random:dt,range:$,remap:wa,reshape:jt,reverse:Oe,round:Ea,scale:gt,seed:ms,Series:te,set:ge,shape:T,shuffle:an,sign:Sa,sin:Oa,some:Hn,sort:Xe,sqrt:Ds,stats:ue,std:As,stdev:Ta,subtract:Ss,sum:er,tan:Aa,timeAsync:Ia,timeSync:ns,time:ns,transpose:ke,union:Ma,variance:Ca,vectorize:P,zeros:nr,zip:ja,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new Mt.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(Mt).forEach(t=>{try{Object.defineProperty(e,t,{configurable:!1,enumerable:!0,writable:!1,value:Mt[t]})}catch{e[t]=Mt[t]}})}};typeof window<"u"&&(window.JSMathTools=Mt);var Ba=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:void 0;function Xn(e){let t=Symbol.for("@TypedArrayConstructor"),n="Symbol(@TypedArrayConstructor)",r=t in e?t:n in e?n:void 0;if(r){if(!("values"in e))throw new Error("The value passed into the `convertObjectToTypedArray` must have a 'values' property!");return e[r]==="ArrayBuffer"?new Uint8Array(e.values).buffer:new Ba[e[r]](e.values)}if(y(e)&&e.constructor.name==="Array")return e;throw new Error("The value passed into the `convertObjectToTypedArray` must be an object that can be converted into a typed array!")}function ft(e){if(e instanceof ArrayBuffer||e instanceof BigInt64Array||e instanceof BigUint64Array||e instanceof Float32Array||e instanceof Float64Array||e instanceof Int16Array||e instanceof Int32Array||e instanceof Int8Array||e instanceof Uint16Array||e instanceof Uint32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray)return{[Symbol.for("@TypedArrayConstructor")]:e.constructor.name,values:e instanceof ArrayBuffer?Array.from(new Uint8Array(e)):Array.from(e)};if(y(e))return e.map(t=>{try{return ft(t)}catch{return t}});if(typeof e=="object"&e!==null){if(Ne(e))return new Date(e.getTime());let t={};return Object.keys(e).forEach(n=>{try{t[n]=ft(e[n])}catch{t[n]=e[n]}}),t}throw new Error("The value passed into the `convertTypedArrayToObject` function must be a typed array! Valid types include: ArrayBuffer, Float32Array, Float64Array, Int16Array, Int32Array, Int8Array, Uint16Array, Uint32Array, Uint8Array, and Uint8ClampedArray.")}function Is(e){return e=e.trim(),!!(e.match(/^-?\d+(\.\d+)?$/g)||e.match(/^-?\d+(\.\d+)?e-?\d+(\.\d+)?$/g)||e.match(/^-?\.\d+$/g)||e==="NaN")}var Ms="!\"#%&'()*+,-./:;<=>?@[]^_`{|}~\xA0\xA1\xA4\xA7\xA9\xAA\xAB\xAE\xB0\xB1\xB6\xB7\xBA\xBB\xBF\xD7\xF7\u0254\u0300\u0301\u0302\u0303\u037E\u0387\u055A\u055B\u055C\u055D\u055E\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A\u066B\u066C\u066D\u06D4\u0700\u0701\u0702\u0703\u0704\u0705\u0706\u0707\u0708\u0709\u070A\u070B\u070C\u070D\u07F7\u07F8\u07F9\u0830\u0831\u0832\u0833\u0834\u0835\u0836\u0837\u0838\u0839\u083A\u083B\u083C\u083D\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04\u0F05\u0F06\u0F07\u0F08\u0F09\u0F0A\u0F0B\u0F0C\u0F0D\u0F0E\u0F0F\u0F10\u0F11\u0F12\u0F14\u0F3A\u0F3B\u0F3C\u0F3D\u0F85\u0FD0\u0FD1\u0FD2\u0FD3\u0FD4\u0FD9\u0FDA\u104A\u104B\u104C\u104D\u104E\u104F\u10FB\u1360\u1361\u1362\u1363\u1364\u1365\u1366\u1367\u1368\u1400\u166E\u169B\u169C\u16EB\u16EC\u16ED\u1735\u1736\u17D4\u17D5\u17D6\u17D8\u17D9\u17DA\u1800\u1801\u1802\u1803\u1804\u1805\u1806\u1807\u1808\u1809\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0\u1AA1\u1AA2\u1AA3\u1AA4\u1AA5\u1AA6\u1AA8\u1AA9\u1AAA\u1AAB\u1AAC\u1AAD\u1B5A\u1B5B\u1B5C\u1B5D\u1B5E\u1B5F\u1B60\u1BFC\u1BFD\u1BFE\u1BFF\u1C3B\u1C3C\u1C3D\u1C3E\u1C3F\u1C7E\u1C7F\u1CC0\u1CC1\u1CC2\u1CC3\u1CC4\u1CC5\u1CC6\u1CC7\u1CD3\u2010\u2011\u2012\u2013\u2014\u2015\u2016\u2017\u2018\u2019\u201A\u201B\u201C\u201D\u201E\u201F\u2020\u2021\u2022\u2023\u2024\u2025\u2026\u2027\u2030\u2031\u2032\u2033\u2034\u2035\u2036\u2037\u2038\u2039\u203A\u203B\u203C\u203D\u203E\u203F\u2040\u2041\u2042\u2043\u2045\u2046\u2047\u2048\u2049\u204A\u204B\u204C\u204D\u204E\u204F\u2050\u2051\u2052\u2053\u2054\u2055\u2056\u2057\u2058\u2059\u205A\u205B\u205C\u205D\u205E\u207D\u207E\u208D\u208E\u2116\u2117\u2120\u2122\u212E\u2212\u2234\u2235\u2248\u2300\u2308\u2309\u230A\u230B\u2311\u2329\u232A\u2380\u25CA\u25CC\u261E\u2640\u2642\u26A5\u2766\u2767\u2768\u2769\u276A\u276B\u276C\u276D\u276E\u276F\u2770\u2771\u2772\u2773\u2774\u2775\u27C5\u27C6\u27E6\u27E7\u27E8\u27E9\u27EA\u27EB\u27EC\u27ED\u27EE\u27EF\u2983\u2984\u2985\u2986\u2987\u2988\u2989\u298A\u298B\u298C\u298D\u298E\u298F\u2990\u2991\u2992\u2993\u2994\u2995\u2996\u2997\u2998\u29D8\u29D9\u29DA\u29DB\u29FC\u29FD\u2CF9\u2CFA\u2CFB\u2CFC\u2CFE\u2CFF\u2D70\u2E00\u2E01\u2E02\u2E03\u2E04\u2E05\u2E06\u2E07\u2E08\u2E09\u2E0A\u2E0B\u2E0C\u2E0D\u2E0E\u2E0F\u2E10\u2E11\u2E12\u2E13\u2E14\u2E15\u2E16\u2E17\u2E18\u2E19\u2E1A\u2E1B\u2E1C\u2E1D\u2E1E\u2E1F\u2E20\u2E21\u2E22\u2E23\u2E24\u2E25\u2E26\u2E27\u2E28\u2E29\u2E2A\u2E2B\u2E2C\u2E2D\u2E2E\u2E30\u2E31\u2E32\u2E33\u2E34\u2E35\u2E36\u2E37\u2E38\u2E39\u2E3A\u2E3B\u2E3C\u2E3D\u2E3E\u2E3F\u2E40\u2E41\u2E42\u2E43\u2E44\u2E45\u2E46\u2E47\u2E48\u2E49\u2E4A\u2E4B\u2E4C\u2E4D\u2E4E\u2E4F\u2E52\u3001\u3002\u3003\u3008\u3009\u300A\u300B\u300C\u300D\u300E\u300F\u3010\u3011\u3014\u3015\u3016\u3017\u3018\u3019\u301A\u301B\u301C\u301D\u301E\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D\uA60E\uA60F\uA673\uA67E\uA6F2\uA6F3\uA6F4\uA6F5\uA6F6\uA6F7\uA874\uA875\uA876\uA877\uA8CE\uA8CF\uA8F8\uA8F9\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1\uA9C2\uA9C3\uA9C4\uA9C5\uA9C6\uA9C7\uA9C8\uA9C9\uA9CA\uA9CB\uA9CC\uA9CD\uA9DE\uA9DF\uAA5C\uAA5D\uAA5E\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uD800\uD801\uD802\uD803\uD804\uD805\uD806\uD807\uD809\uD81A\uD81B\uD82F\uD836\uD83A\u{1F03B}\uDC41\uDC42\uDC43\uDC44\uDC45\uDC47\uDC48\uDC49\uDC4A\uDC4B\uDC4C\uDC4D\uDC4E\uDC4F\uDC57\uDC5A\uDC5B\uDC5D\uDC70\uDC71\uDC72\uDC73\uDC74\uDC9F\uDCBB\uDCBC\uDCBE\uDCBF\uDCC0\uDCC1\uDCC6\uDD00\uDD01\uDD02\uDD1F\uDD2F\uDD3F\uDD40\uDD41\uDD42\uDD43\uDD44\uDD45\uDD46\uDD5E\uDD5F\uDD6F\uDD74\uDD75\uDDC1\uDDC2\uDDC3\uDDC4\uDDC5\uDDC6\uDDC7\uDDC8\uDDC9\uDDCA\uDDCB\uDDCC\uDDCD\uDDCE\uDDCF\uDDD0\uDDD1\uDDD2\uDDD3\uDDD4\uDDD5\uDDD6\uDDD7\uDDDB\uDDDD\uDDDE\uDDDF\uDDE2\uDE38\uDE39\uDE3A\uDE3B\uDE3C\uDE3D\uDE3F\uDE40\uDE41\uDE42\uDE43\uDE44\uDE45\uDE46\uDE50\uDE51\uDE52\uDE53\uDE54\uDE55\uDE56\uDE57\uDE58\uDE60\uDE61\uDE62\uDE63\uDE64\uDE65\uDE66\uDE67\uDE68\uDE69\uDE6A\uDE6B\uDE6C\uDE6E\uDE6F\uDE7F\uDE87\uDE88\uDE89\uDE8A\uDE8B\uDE97\uDE98\uDE99\uDE9A\uDE9B\uDE9C\uDE9E\uDE9F\uDEA0\uDEA1\uDEA2\uDEA9\uDEAD\uDEF0\uDEF1\uDEF2\uDEF3\uDEF4\uDEF5\uDEF6\uDEF7\uDEF8\uDF37\uDF38\uDF39\uDF3A\uDF3B\uDF3C\uDF3D\uDF3E\uDF3F\uDF44\uDF55\uDF56\uDF57\uDF58\uDF59\uDF99\uDF9A\uDF9B\uDF9C\uDF9F\uDFD0\uDFE2\uDFFF\uFD3F\uFE10\uFE11\uFE12\uFE13\uFE14\uFE15\uFE16\uFE17\uFE18\uFE19\uFE30\uFE31\uFE32\uFE33\uFE34\uFE35\uFE36\uFE37\uFE38\uFE39\uFE3A\uFE3B\uFE3C\uFE3D\uFE3E\uFE3F\uFE40\uFE41\uFE42\uFE43\uFE44\uFE45\uFE46\uFE47\uFE48\uFE49\uFE4A\uFE4B\uFE4C\uFE4D\uFE4E\uFE4F\uFE50\uFE51\uFE52\uFE54\uFE55\uFE56\uFE57\uFE58\uFE59\uFE5A\uFE5B\uFE5C\uFE5D\uFE5E\uFE5F\uFE60\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01\uFF02\uFF03\uFF05\uFF06\uFF07\uFF08\uFF09\uFF0A\uFF0C\uFF0D\uFF0E\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B\uFF3C\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F\uFF60\uFF61\uFF62\uFF63\uFF64\uFF65";function Cs(e,t,n){if(typeof e!="string")throw new Error("`text` must be a string!");if(typeof t!="string")throw new Error("`a` must be a string!");if(typeof n!="string")throw new Error("`b` must be a string!");return e.split(t).join(n)}var rs="  ",ss=" ";function sr(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t="";for(let n=0;n<e.length;n++){let r=e[n].toLowerCase();Ms.includes(r)?t+=ss:t+=r}for(;t.includes(rs);)t=Cs(t,rs,ss);return t.trim()}function ka(e,t){return t=t||"",e.split(`
`).map(n=>n.trim().length>0?t+n:n).join(`
`)}function Pa(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=sr(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("-")}var os={"@Infinity":1/0,"@NegativeInfinity":-1/0,"@NaN":NaN,"@undefined":void 0};function Bt(e){if(typeof e=="object"){if(e===null)return e;if(y(e))for(let t=0;t<e.length;t++)e[t]=Bt(e[t]);else Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{e[t]=Bt(e[t])});return e}else return typeof e>"u"||e==="Symbol(@undefined)"?void 0:e}function Ra(e){if(typeof e=="bigint")return e;if(typeof e=="string")if(e.match(/^\s*?-?\d+n\s*?$/g))try{return BigInt(e.split("n")[0])}catch{return NaN}else return NaN;else return NaN}function Ja(e){if(typeof e!="string")return typeof e=="number"?e:void 0;if(Is(e))return parseFloat(e)}function Ya(e){if(typeof e!="string")return;let t="@jrc03c/js-text-tools/newline-replacer";if(e=e.replaceAll(`
`,t),e.trim().match(/^("|')?Symbol\(@String\):.*?("|')?$/g)){let n=e.replace("Symbol(@String):","");if(n.match(/^".*?"$/g))try{return JSON.parse(n)}catch{n=n.substring(1,n.length-1)}return n=n.replaceAll(t,`
`),n}}function Va(e){if(typeof e!="string")return typeof e=="symbol"?{out:e,isASymbol:!0}:void 0;if(e.trim().match(/^'?"?Symbol\(.*?\)"?'?$/g)){let t=e.replace(/^.*?Symbol\(/g,"").replace(/\).*?$/g,"");return t in os?{out:os[t],isASymbol:!0}:{out:Symbol.for(t),isASymbol:!0}}}function $a(e){if(typeof e!="string")return e instanceof RegExp?e:void 0;let t=e.trim();if(t.match(/^\/.*?\/(d|g|i|m|s|u|v|y)*?$/g))try{let n=t.replace(/^\//g,"").replace(/\/(d|g|i|m|s|u|v|y)*?$/g,""),r=t.match(/\/(d|g|i|m|s|u|v|y)*?$/g).at(-1).split("/").at(-1);return new RegExp(n,r)}catch{}}function Ka(e){if(typeof e!="string")return typeof e=="object"?e:"Symbol(@undefined)";try{let t=JSON.parse(e,(n,r)=>{try{let s=hn(r);return typeof s>"u"?"Symbol(@undefined)":s}catch{return typeof r>"u"?"Symbol(@undefined)":r}});return y(t)&&(t=Bt(t)),t}catch{return e}}function Ua(e){if(typeof e!="string")return e instanceof Date&&e.toString()!=="Invalid Date"?e:void 0;try{let t=new Date(Date.parse(e));if(t.toString()!=="Invalid Date")return t}catch{}}function za(e){return typeof e=="object"?e!==null?Bt(e):void 0:(Object.keys(e).concat(Object.getOwnPropertySymbols(e)).forEach(t=>{try{let n=t;try{t=hn(t)}catch{}e[t]=hn(e[n]),t!==n&&delete e[n]}catch{}}),Bt(e))}function hn(e){function t(n){if(typeof n=="string"){let r=Ya(n);if(typeof r=="string")return r;let s=Va(n);return r=s?s.out:void 0,s&&s.isASymbol||(r=$a(n),r instanceof RegExp)||(r=Ra(n),typeof r=="bigint")||(r=Ja(n),typeof r=="number")||(r=Ua(n),r instanceof Date)?r:(r=Ka(n),typeof r<"u"?r==="Symbol(@undefined)"?void 0:r:n)}if(typeof n=="object"){if(n===null)return null;let r;try{if(r=Xn(n),y(r))return r}catch{}if(r=za(n),r)try{return Xn(r)}catch{return r}return n}return n}return t(e)}function La(e){let t=is(e);return t[0].toUpperCase()+t.slice(1)}function qa(e){if(typeof e!="string")throw new Error("`text` must be a string!");let t=sr(e).split(" ");return t.length===0?"":t.length===1?t[0]:t.join("_")}function $e(e,t){return!e||t<=0?"":$(0,t).map(()=>e).join("")}function or(e,t){m(j(t)||S(t),"The second parameter to the `stringify` function must be undefined or a string!");let n=t?`
`:"";function r(s,o,i){return i=i||0,typeof s=="bigint"?JSON.stringify(s.toString()+"n"):typeof s=="number"?s===1/0?'"Symbol(@Infinity)"':s===-1/0?'"Symbol(@NegativeInfinity)"':isNaN(s)?'"Symbol(@NaN)"':s.toString():typeof s=="string"?JSON.stringify("Symbol(@String):"+s):typeof s=="boolean"?s.toString():typeof s>"u"?'"Symbol(@undefined)"':typeof s=="symbol"||typeof s=="function"?JSON.stringify(s.toString()):s instanceof RegExp?s.toString():typeof s=="object"?s===null?"null":Ne(s)?JSON.stringify(s.toJSON()):y(s)?s.length===0?$e(o,i-1)+"[]":s instanceof Array?$e(o,i-1)+"["+n+s.map(u=>{let a=(()=>{try{return r(ft(u),o,i+1)}catch{return r(u,o,i+1)}})();return j(a)&&(a=a.trim()),$e(o,i+1)+a}).join(","+n)+n+$e(o,i)+"]":r(ft(s),null,o):Object.keys(s).length+Object.getOwnPropertySymbols(s).length===0?$e(o,i-1)+"{}":$e(o,i-1)+"{"+n+Object.keys(s).concat(Object.getOwnPropertySymbols(s)).map(u=>{let a=(()=>{try{return r(ft(s[u]),o,i+1)}catch{return r(s[u],o,i+1)}})();j(a)&&(a=a.trim());let l=typeof u=="symbol"?r(u):JSON.stringify(u);return $e(o,i+1)+l+":"+(o?" ":"")+a}).join(","+n)+n+$e(o,i)+"}":"undefined"}return r(He(e),t)}function Ga(e){let t=e.split(`
`),n=t.filter(s=>s.trim().length>0).map(s=>s.split("").findIndex(o=>!o.match(/\s/g))),r=Math.min(...n);return t.map(s=>s.substring(r)).join(`
`)}function Wa(e,t){if(typeof e!="string")throw new Error("The first argument to the `wrap` function must be a string!");if((typeof t>"u"||t===null)&&(typeof process<"u"&&typeof process.stdout<"u"&&typeof process.stdout.columns=="number"?t=process.stdout.columns>80?80:process.stdout.columns:t=80),isNaN(t)||typeof t!="number")throw new Error("The second argument to the `wrap` function must be undefined, null, or an integer!");let n=[];return e.split(`
`).forEach(r=>{if(r.trim().length===0)return n.push("");let s=r.split(/[^\s]/g)[0],o=r.replace(s,"").split(" "),i=s;o.forEach(u=>{let a=i+(i.trim().length>0?" ":"")+u;a.length>t?(n.push(i),i=s+u):i=a}),i.length>0&&n.push(i)}),n.join(`
`)}typeof window<"u"&&(window.JSTextTools={camelify:is,convertObjectToTypedArray:Xn,convertTypedArrayToObject:ft,indent:ka,isANumberString:Is,kebabify:Pa,parse:hn,pascalify:La,punctuation:Ms,replaceAll:Cs,snakeify:qa,stringify:or,strip:sr,unindent:Ga,wrap:Wa});function yn(e,t){t=t||{};let n=b(t.maxUniqueValues)?t.maxUniqueValues:7,r=b(t.minNonMissingValues)?t.minNonMissingValues:15,s=b(t.maxCorrelationThreshold)?t.maxCorrelationThreshold:1-1e-5,o=t.progress||null;if(g(e))return f(w(e).length===2&&!G(e),"The `convertToNumerical` function only works on non-jagged 2-dimensional arrays and DataFrames!"),yn(new A(e));f(p(e),"You must pass a DataFrame into the `convertToNumerical` function!"),f(ne(n),"`maxUniqueValues` must be a whole number!"),f(ne(r),"`minNonMissingValues` must be a whole number!"),f(b(s),"`maxCorrelationThreshold` must be a number!"),v(o)||f(J(o),"If defined, `progress` must be a function!");let i={},u=!0;return e.apply((a,l)=>{o&&o(l/e.columns.length);let c=tt(a.values);if(c.type==="boolean"&&(c.values=c.values.map(d=>d?1:0)),c.type==="date"&&(c.values=c.values.map(d=>{try{return d.getTime()}catch{return NaN}})),c.type==="null")return;c.type==="number"||c.type,c.type==="object"&&(c.values=c.values.map(d=>or(d))),c.type;let h=c.values.filter(d=>!v(d));if(!(c.values.length-h.length>r.length)){if(c.type!=="boolean"){let d=se(Pe(h).toArray().filter(F=>!v(F.value)&&b(F.count)),(F,I)=>I.count-F.count);if(ee(d.slice(0,n).map(F=>F.count),u)/h.length>=.9){if(d.length<2)return;let F=ut(a.name,c.values);for(;Object.keys(F).length>0;){let I=Object.keys(F)[0],Ee=F[I];delete F[I];let pr=Object.keys(i);for(let En=0;En<pr.length;En++){let Rs=i[pr[En]];if(be(Ee,Rs,u)>s)return}i[I]=Ee}return}if(c.type==="object"||c.type==="string")return}if(c.type==="boolean"||c.type==="date"||c.type==="number"||c.type==="bigint"){let d=Object.keys(i);for(let E=0;E<d.length;E++){let F=i[d[E]];if(be(c.values,F,u)>s)return}i[a.name]=c.values}}}),new A(i)}function bn(e){if(N(e)){let s=new A(bn(e.values));return s.index=e.index.slice(),s.columns=e.index.slice(),s}f(g(e),"The `diagonalize` function only works on 1-dimensional arrays and Series!");let t=w(e);f(t.length===1,"The `diagonalize` function only works on 1-dimensional arrays and Series!");let n=e.every(s=>typeof s=="bigint"),r=Ve([t[0],t[0]]);if(e.forEach((s,o)=>r[o][o]=s),n)for(let s=0;s<r.length;s++)for(let o=0;o<r[s].length;o++)try{r[s][o]=BigInt(r[s][o])}catch{}return r}function ir(e){let t="@jrc03c/js-data-science-helpers/get-correlation-matrix";return Object.defineProperty(e,t,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(t)}),e}function Yt(e,t,n){if(v(t)&&(t=e),p(e)){let s=new A(Yt(e.values,t));return s.index=e.columns.slice(),s.columns=p(t)?t.columns.slice():new A(t).columns.slice(),ir(s)}if(p(t)){let s=new A(Yt(e,t.values));return s.index=p(e)?e.columns.slice():new A(e).columns.slice(),s.columns=t.columns.slice(),ir(s)}f(g(e)&&g(t),"The `getCorrelationMatrix` function only works on 2-dimensional arrays and DataFrames!"),f(!G(e)&&!G(t),"The `getCorrelationMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),f(e.length===t.length,'The dimensions of the matrices you passed into the `getCorrelationMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let r=Q([e[0].length,t[0].length]);for(let s=0;s<e[0].length;s++){let o=e.map(i=>i[s]);for(let i=0;i<t[0].length;i++){let u=t.map(a=>a[i]);n?r[s][i]=be(...fe(o,u)):r[s][i]=be(o,u)}}return ir(Ge(r,-1,1))}function ur(e,t,n){t=v(t)?1-1e-5:t,p(e)||(e=new A(e));let r=w(e);f((g(e)||p(e))&&r.length===2,"The first argument passed into the `getHighlyCorrelatedColumns` function must be a 2-dimensional array or DataFrame!"),f(b(t)&&t>=-1&&t<=1,"The second argument passed into the `getHighlyCorrelatedColumns` must be a number in the range [-1, 1] representing the threshold above which two columns will be considered to be highly correlated!");let s={};n&&(e=e.dropNaN());for(let o=0;o<r[1]-1;o++)for(let i=o+1;i<r[1];i++){let u=e.columns[o],a=e.columns[i],l=be(e.get(u),e.get(a));l>t&&(s[u]||(s[u]=[]),s[u].push({column:a,correlation:l}),s[a]||(s[a]=[]),s[a].push({column:u,correlation:l}))}return Object.keys(s).forEach(o=>{s[o]=se(s[o],(i,u)=>i.column<u.column?-1:1)}),s}function pt(e,t){return p(e)||N(e)?pt(e.values):b(e)?oe(e):g(e)?(t&&(e=qe(e)),Ye(ee(me(e,2)))):NaN}function ar(e,t){let n=M(e,{shouldDropNaNs:t}),r=t?n.nWithoutNaNs:n.n;return n.counts.values.filter(s=>b(s)||!t).map(s=>{let o=n.counts.get(s);return{value:s,count:o,percentage:o/r}})}var lr=[.5,.49601,.49202,.48803,.48405,.48006,.47608,.4721,.46812,.46414,.46017,.4562,.45224,.44828,.44433,.44038,.4364,.43251,.42858,.42465,.42074,.41683,.41294,.40905,.40517,.40129,.39743,.39358,.38974,.38591,.38209,.37828,.37448,.3707,.36693,.36317,.35942,.35569,.35197,.34827,.34458,.3409,.33724,.3336,.32997,.32636,.32276,.31918,.31561,.31207,.30854,.30503,.30153,.29806,.2946,.29116,.28774,.28434,.28096,.2776,.27425,.27093,.26763,.26435,.26109,.25785,.25463,.25143,.24825,.2451,.24196,.23885,.23576,.2327,.22965,.22663,.22363,.22065,.2177,.21476,.21186,.20897,.20611,.20327,.20045,.19766,.19489,.19215,.18943,.18673,.18406,.18141,.17879,.17619,.17361,.17106,.16853,.16602,.16354,.16109,.15866,.15625,.15386,.15151,.14917,.14686,.14457,.14231,.14007,.13786,.13567,.1335,.13136,.12924,.12714,.12507,.12302,.121,.119,.11702,.11507,.11314,.11123,.10935,.10749,.10565,.10383,.10204,.10027,.09853,.0968,.0951,.09342,.09176,.09012,.08851,.08692,.08534,.08379,.08226,.08076,.07927,.0778,.07636,.07493,.07353,.07215,.07078,.06944,.06811,.06681,.06552,.06426,.06301,.06178,.06057,.05938,.05821,.05705,.05592,.0548,.0537,.05262,.05155,.0505,.04947,.04846,.04746,.04648,.04551,.04457,.04363,.04272,.04182,.04093,.04006,.0392,.03836,.03754,.03673,.03593,.03515,.03438,.03362,.03288,.03216,.03144,.03074,.03005,.02938,.02872,.02807,.02743,.0268,.02619,.02559,.025,.02442,.02385,.0233,.02275,.02222,.02169,.02118,.02068,.02018,.0197,.01923,.01876,.01831,.01786,.01743,.017,.01659,.01618,.01578,.01539,.015,.01463,.01426,.0139,.01355,.01321,.01287,.01255,.01222,.01191,.0116,.0113,.01101,.01072,.01044,.01017,.0099,.00964,.00939,.00914,.00889,.00866,.00842,.0082,.00798,.00776,.00755,.00734,.00714,.00695,.00676,.00657,.00639,.00621,.00604,.00587,.0057,.00554,.00539,.00523,.00508,.00494,.0048,.00466,.00453,.0044,.00427,.00415,.00402,.00391,.00379,.00368,.00357,.00347,.00336,.00326,.00317,.00307,.00298,.00289,.0028,.00272,.00264,.00256,.00248,.0024,.00233,.00226,.00219,.00212,.00205,.00199,.00193,.00187,.00181,.00175,.00169,.00164,.00159,.00154,.00149,.00144,.00139,.00135,.00131,.00126,.00122,.00118,.00114,.00111,.00107,.00104,.001,97e-5,94e-5,9e-4,87e-5,84e-5,82e-5,79e-5,76e-5,74e-5,71e-5,69e-5,66e-5,64e-5,62e-5,6e-4,58e-5,56e-5,54e-5,52e-5,5e-4,48e-5,47e-5,45e-5,43e-5,42e-5,4e-4,39e-5,38e-5,36e-5,35e-5,34e-5,32e-5,31e-5,3e-4,29e-5,28e-5,27e-5,26e-5,25e-5,24e-5,23e-5,22e-5,22e-5,21e-5,2e-4,19e-5,19e-5,18e-5,17e-5,17e-5,16e-5,15e-5,15e-5,14e-5,14e-5,13e-5,13e-5,12e-5,12e-5,11e-5,11e-5,1e-4,1e-4,1e-4,9e-5,9e-5,8e-5,8e-5,8e-5,8e-5,7e-5,7e-5,7e-5,6e-5,6e-5,6e-5,6e-5,5e-5,5e-5,5e-5,5e-5,5e-5,4e-5,4e-5,4e-5,4e-5,4e-5,4e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,3e-5,2e-5,2e-5,2e-5,2e-5];function Ha(e){return oe(e)>4.1?0:lr[Rn(Pn(oe(e),0,4.1,0,lr.length))]}function Ue(e,t,n){if(p(e)||N(e))return Ue(e.values,t);if(p(t)||N(t))return Ue(e,t.values);f(g(e)&&g(t)&&L(w(e),w(t)),"You must pass two identically-shaped arrays, Series, or DataFrames into the `pValue` function!");let[r,s]=n?fe(K(e),K(t)):[K(e),K(t)];if(r.length===0||s.length===0)return NaN;let o=M(r,{stdev:!0}),i=M(s,{stdev:!0}),u=o.mean,a=i.mean,l=o.stdev,c=i.stdev,h=r.length,d=s.length,E=(u-a)/Ye(l*l/h+c*c/d);return 2*Ha(E)}function cr(e){let t="@jrc03c/js-data-science-helpers/get-p-value-matrix";return Object.defineProperty(e,t,{configurable:!1,enumerable:!1,writable:!1,value:Symbol.for(t)}),e}function Vt(e,t,n){if(v(t)&&(t=e),p(e)){let s=new A(Vt(e.values,t));return s.index=e.columns.slice(),s.columns=p(t)?t.columns.slice():new A(t).columns.slice(),cr(s)}if(p(t)){let s=new A(Vt(e,t.values));return s.index=p(e)?e.columns.slice():new A(e).columns.slice(),s.columns=t.columns.slice(),cr(s)}f(g(e)&&g(t),"The `getPValueMatrix` function only works on 2-dimensional arrays and DataFrames!"),f(!G(e)&&!G(t),"The `getPValueMatrix` function only works on non-jagged 2-dimensional arrays and DataFrames!"),f(e.length===t.length,'The dimensions of the matrices you passed into the `getPValueMatrix` function aren\'t compatible! ([shape(a).join(", ")] vs. [shape(b).join(", ")]) The function expects that you\'ll be comparing the columns of two matrices where the columns are all of the same length, so please make sure that the matrices are oriented accordingly.');let r=Q([e[0].length,t[0].length]);for(let s=0;s<e[0].length;s++){let o=e.map(i=>i[s]);for(let i=0;i<t[0].length;i++){let u=t.map(a=>a[i]);n?r[s][i]=Ue(...fe(o,u)):r[s][i]=Ue(o,u)}}return cr(Ge(r,0,1))}function vn(e){if(g(e)){f(w(e).length===2&&!G(e),"The `hunterChainSort` function only works on non-jagged 2-dimensional arrays and DataFrames!");let i=new A(e);return i.index=i.columns.slice(),vn(i).values}f(p(e),"You must pass a 2-dimensional array or DataFrame into the `hunterChainSort` function!");let t=!0,n=e.index.slice(),r=[];for(;n.length>1;)if(r.length===0){let i=n[ot(n.map(u=>ee(me(e.values[e.index.indexOf(u)],2),t)),t)];n.splice(n.indexOf(i),1),r.push(i)}else{let i=r.at(-1),u=e.values[e.index.indexOf(i)].filter((l,c)=>n.includes(e.index[c])),a=n[ot(u,t)];n.splice(n.indexOf(a),1),r.push(a)}r.push(n[0]);let s=le(r);return e.get(s,null)}var $t=class e{static DROP_NAN_MODE="DROP_NAN_MODE";static DROP_MISSING_MODE="DROP_MISSING_MODE";constructor(t){let n=this;f(v(t)||t===e.DROP_NAN_MODE||t===e.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),n.mode=v(t)?e.DROP_MISSING_MODE:t,n.index=null}fit(){let t=this,n=[];return Object.values(arguments).forEach(r=>{f(p(r)||N(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),t.mode===e.DROP_MISSING_MODE?n.push(r.dropMissing().index):n.push(r.dropNaN().index)}),t.index=xt(...n),t}transform(){let t=this;f(!!t.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let n=Object.values(arguments).map(r=>(f(p(r)||N(r),"The `IndexMatcher` only works on Series and DataFrames! To drop NaN values in a pair-wise fashion from regular arrays, use the `dropNaNPairwise` function from the @jrc03c/js-math-tools library."),r.get(t.index,null)));return n.length===1?n[0]:n}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}};function Nn(e,t){if(typeof e=="number")return e===0||e===1;if(typeof e=="bigint")return e===0n||e===1n;if(p(e)||N(e))return Nn(e.values,t);if(g(e)){t&&(e=qe(e));let r=Pe(e).values.toSorted();return r.length===2&&Number(r[0])===0&&Number(r[1])===1||r.length===1&&(Number(r[0])===0||Number(r[0])===1)}return!1}function fr(e){try{let t="@jrc03c/js-data-science-helpers/get-correlation-matrix";if(e[t]===Symbol.for(t))return!0;let n=M(e,{shouldDropNaNs:!0});return n.min>=-1&&n.max<=1}catch{return!1}}function js(e,t){(p(e)||N(e))&&(e=e.values),(p(t)||N(t))&&(t=t.values),f(L(w(e),w(t)),"`yPred` and `yTrue` must have the same shape!");let n=K(e),r=K(t),s=0;return n.forEach((o,i)=>{o===r[i]&&s++}),s/n.length}function yt(e){return g(e)&&w(e).length===2}function Bs(e,t){return e.map(n=>t[Me(t.map(r=>De(n,r)))])}function ks(e,t){e=e.map(s=>s.map(o=>Number(o)));let n={},r=new Set;return t.forEach((s,o)=>{n[s]||(n[s]=[]),n[s].push(e[o]),r.add(s)}),_t(e.map((s,o)=>{let i=t[o],u=1/0,a=1/0;return r.forEach(l=>{let c=n[l],h=c.length<2?0:ee(c.map(d=>De(s,d)));l===i?u=h:h<a&&(a=h)}),(a-u)/Je([u,a])}))}function De(e,t){return ee(me(de(e,t),2),!0)}var bt=class{constructor(t){f(typeof t=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),f(ne(t.k),"`k` must be a whole number!"),f(ne(t.maxIterations)||v(t.maxIterations),"`maxIterations` must be a whole number or undefined!"),f(ne(t.maxRestarts)||v(t.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),f(typeof t.tolerance=="number"||v(t.tolerance),"`tolerance` must be a number or undefined!"),this.k=t.k,this.maxRestarts=t.maxRestarts||25,this.maxIterations=t.maxIterations||100,this.tolerance=t.tolerance||1e-4,this.centroids=null}initializeCentroids(t){return Re(t).slice(0,this.k)}getFitStepFunction(t,n){f(yt(t),"`x` must be a matrix!"),p(t)&&(t=t.values),v(n)||f(J(n),"If defined, `progress` must be a function!");let r=this.initializeCentroids(t),s={currentRestart:0,currentIteration:0,currentCentroids:r,bestCentroids:r,bestScore:-1/0,isFinished:!1};return()=>{let o=this.predict(t,s.currentCentroids),i=[],u=Ve(this.k);t.forEach((l,c)=>{let h=o[c];i[h]||(i[h]=Ve(l.length)),i[h]=Le(i[h],l),u[h]++});let a=C(0,this.k).map(l=>u[l]===0?Le(s.currentCentroids[Math.floor(ye()*s.currentCentroids.length)],Fe(.001,Bn(s.currentCentroids[0].length))):je(i[l],u[l]));if(De(s.currentCentroids,a)<this.tolerance?s.currentIteration=this.maxIterations-1:s.currentCentroids=a,n&&n((s.currentRestart+s.currentIteration/this.maxIterations)/this.maxRestarts,this),s.currentIteration++,s.currentIteration>=this.maxIterations){let l=this.score(t,s.currentCentroids);if(l>s.bestScore&&(s.bestScore=l,s.bestCentroids=U(s.currentCentroids)),s.currentIteration=0,s.currentRestart++,s.currentRestart>=this.maxRestarts)s.isFinished=!0,this.centroids=s.bestCentroids,n&&n(1,this);else{let c=this.initializeCentroids(t);s.currentCentroids=c}}return s}}fit(t,n){let r=this.getFitStepFunction(t,n),s;for(;!s||!s.isFinished;)s=r();return this}predict(t,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `predict` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `predict` method or run the `fit` method first!");return t.map(r=>Me(n.map(s=>De(r,s))))}score(t,n){if(n=n||this.centroids,!n)throw new Error("No centroids were provided to the `score` method, and the K-Means model hasn't been fitted yet. Please either pass centroids as a second parameter to the `score` method or run the `fit` method first!");let s=this.predict(t,n).map(o=>n[o]);return-De(t,s)}};var vt=class extends bt{initializeCentroids(t){let r=[t[Math.floor(ye()*t.length)]];for(;r.length<this.k;){let s=t.map(i=>De(i,r[Me(r.map(u=>De(i,u)),!0)])),o=je(s,Je(s,!0));r.push(t[o.findIndex(i=>ye()<i)])}return r}};var wn=class{constructor(t){v(t)&&(t={}),f(typeof t=="object","`config` must be an object! See the documentation for more information about the properties that the `config` object can contain."),v(t.ks)&&(t.ks=C(2,16)),f(g(t.ks),"`ks` must be an array of whole numbers!"),t.ks.forEach(n=>{f(ne(n),"`ks` must be an array of whole numbers!")}),f(ne(t.maxIterations)||v(t.maxIterations),"`maxIterations` must be a whole number or undefined!"),f(ne(t.maxRestarts)||v(t.maxRestarts),"`maxRestarts` must be a whole number or undefined!"),this.finalMaxIterations=t.finalMaxIterations||100,this.finalMaxRestarts=t.finalMaxRestarts||25,this.fittedModel=null,this.ks=t.ks,this.maxIterations=t.maxIterations||10,this.maxRestarts=t.maxRestarts||5,this.modelClass=t.modelClass||vt,this.tolerance=t.tolerance||1e-4}getFitStepFunction(t,n){p(t)&&(t=t.values),f(yt(t),"`x` must be a matrix!"),v(n)||f(J(n),"If defined, `progress` must be a function!");let r={currentIndex:0,isFinished:!1,scores:[]};return()=>{let s=this.ks[r.currentIndex],o=new this.modelClass({k:s,maxRestarts:10,maxIterations:20});o.fit(t,a=>n?n((r.currentIndex+a)/(this.ks.length+1)):null);let i=o.predict(t),u=ks(t,i);if(r.scores.length>=this.ks.length||u>1-this.tolerance?r.isFinished=!0:(r.scores.push({k:s,score:u}),r.currentIndex+1>=this.ks.length?r.isFinished=!0:r.currentIndex++),r.isFinished){let a=1,l=-1;r.scores.forEach(c=>{!isNaN(c.score)&&c.score>l&&(l=c.score,a=c.k)}),this.fittedModel=new this.modelClass({k:a,maxRestarts:this.finalMaxRestarts,maxIterations:this.finalMaxIterations}),this.fittedModel.fit(t,c=>n?n((this.ks.length+c)/(this.ks.length+1)):null),n&&n(1)}return r}}fit(t,n){let r=this.getFitStepFunction(t,n),s;for(;!s||!s.isFinished;)s=r();return this}predict(t,n){return this.fittedModel.predict(t,n)}score(t,n){return this.fittedModel.score(t,n)}get k(){return this.fittedModel.k}set k(t){throw new Error("You can't set the k-value manually! It has to be set automatically via the `fit` method.")}get centroids(){return this.fittedModel.centroids}set centroids(t){f(L(w(t),w(this.fittedModel.centroids)),"When assigning a new value to the `centroids` property, the new centroids must have the same shape as the old centroids!"),this.fittedModel.centroids=t}};var Xa={accuracy:js,isMatrix:yt,orderCentroids:Bs,sse:De},hr={helpers:Xa,KMeansMeta:wn,KMeansNaive:bt,KMeansPlusPlus:vt};function Nt(e,t){if(p(e)||N(e)){let o=e.copy();return o.values=Nt(o.values),o}f(g(e),"The `normalize` function only works on arrays, Series, and DataFrames!");let n=M(e,{shouldDropNaNs:t,stdev:!0}),r=n.mean,s=n.stdev;return Ce(e,o=>(Number(o)-r)/s)}function ze(e,t){if(N(e)){if(N(t))return new z(ze(e.values,t.values));{let n=e.copy();return n.values=ze(e.values,t),n}}if(N(t)){let n=t.copy();return n.values=ze(e,t.values),n}return f(g(e),"`project` only works on vectors!"),f(g(t),"`project` only works on vectors!"),f(w(e).length===1,"`project` only works on vectors!"),f(w(t).length===1,"`project` only works on vectors!"),Fe(Number(ae(t,e))/Number(ae(t,t)),t)}function Dn(e){if(p(e)){let o=new A(Dn(e.values));return o.index=e.index.slice(),o.columns=e.columns.slice(),o}f(g(e)&&!G(e)&&w(e).length===2,"`orthonormalize` only works on matrices!");let t=x(e),n=[];t.forEach(o=>{let i=o;n.forEach(u=>{i=de(i,ze(i,u))}),n.push(i)});let r=!0,s=n.map(o=>je(o,pt(o,r)));return x(s)}function Za(e){let t=e.counts.values;return t.length<3&&(t.length===2&&L(t.toSorted(),[0,1])||t.length===1&&(t[0]===0||t[0]===1))}function Ps(e){let t=[];return e.counts.values.forEach(n=>{if(b(n)){let r=e.counts.get(n);for(let s=0;s<r;s++)t.push(n)}}),t}var Kt=class{constructor(t){t=t||{},this.isAllowedToClip=v(t.isAllowedToClip)?!0:t.isAllowedToClip,this.isAllowedToTakeTheLog=v(t.isAllowedToTakeTheLog)?!1:t.isAllowedToTakeTheLog,this.maxScore=t.maxScore||5,f(ce(this.isAllowedToClip),"The `isAllowedToClip` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"),f(ce(this.isAllowedToTakeTheLog),"The `isAllowedToTakeTheLog` property on the options object passed into the `OutlierMitigator` constructor must have a boolean value!"),f(b(this.maxScore)&&this.maxScore>=0,"The `maxScore` property on the options object passed into the `OutlierMitigator` constructor must have a non-negative number value!"),this.mad=0,this.median=0}fit(t){if(p(t)||N(t))return this.fit(t.values);if(f(g(t),"The `OutlierMitigator.fit` method only works on arrays, Series, and DataFrames!"),t.length===0)return;let n=M(t,{shouldDropNaNs:!0,median:!0});if(Za(n))return this;let r=Ps(n);return this.median=Number(n.median),this.mad=Number(M(oe(de(r,this.median)),{median:!0}).median),this}fitAndTransform(){return this.fit(arguments[0]).transform(...arguments)}transform(){if(arguments.length>1)return Array.from(arguments).map(i=>this.transform(i));let t=arguments[0];if(p(t)||N(t))return this.transform(t.values);f(g(t),"The `OutlierMitigator.transform` method only works on arrays, Series, and DataFrames!");let n=M(t,{shouldDropNaNs:!0}),r=Ps(n),s=!1;if(this.mad===0){let i=[],u=[],a=-1/0,l=1/0;r.forEach(d=>{d<this.median?(i.push(d),d>a&&(a=d)):d>this.median&&(u.push(d),d<l&&(l=d))});let c=this.median,h=this.median;if(i.length>0&&(c=a),u.length>0&&(h=l),this.mad=(h-c)/2,this.mad===0)return t;s=(this.median-c)/this.mad>this.maxScore||(h-this.median)/this.mad>this.maxScore}if(M(je(oe(de(r,this.median)),this.mad)).max>this.maxScore||s){let i=null,u=U(t);return this.isAllowedToClip&&(u=Ce(u,a=>(a=b(a)?Ge(a,this.median-this.maxScore*this.mad,this.median+this.maxScore*this.mad):a,this.isAllowedToTakeTheLog&&b(a)&&(i===null||a<i)&&(i=a),a))),this.isAllowedToTakeTheLog&&(i===null&&(i=M(u).min),u=Ce(u,a=>b(a)?jn(a-i+1):a)),u}else return t}};function Ze(e,t,n){if(p(e)||N(e))return Ze(e.values,t);if(p(t)||N(t))return Ze(e,t.values);if(f(g(e),"You must pass two same-shaped numerical arrays into the `rSquared` function!"),f(g(t),"You must pass two same-shaped numerical arrays into the `rSquared` function!"),f(L(w(e),w(t)),"You must pass two same-shaped numerical arrays into the `rSquared` function!"),n){let o=fe(e,t);e=o[0],t=o[1]}let r=Number(ee(me(de(e,t),2))),s=Number(ee(me(de(e,_t(e)),2)));return s===0?NaN:1-r/s}function mr(e,t,n){let r=Ze(e,t,n);return Jn(r)*Ye(oe(r))}function dr(){return Nt(...arguments)}var Ut=class{constructor(t){t=t||{},this.means=[],this.stdevs=[],this.wasFittedOnAVector=!1,this.hasBeenFitted=!1,this.shouldIgnoreNaNs=typeof t.shouldIgnoreNaNs>"u"?!1:t.shouldIgnoreNaNs}_getDataArrayAndShape(t){if(p(t))return[t.values,t.shape];if(N(t)){let r=x([t.values]);return[r,w(r)]}f(g(t),"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!");let n=w(t);return f(n.length<3,"`x` must be a 1- or 2-dimensional array, DataFrame, or Series!"),n.length===1&&(n.push(1),t=x([t])),[t,n]}fit(t){let n=this._getDataArrayAndShape(t);t=n[0];let r=n[1];return this.wasFittedOnAVector=r.indexOf(1)>-1,this.means=[],this.stdevs=[],C(0,r[1]).forEach(s=>{let o=t.map(u=>u[s]),i=M(o,{shouldDropNaNs:this.shouldIgnoreNaNs,stdev:!0});this.means.push(i.mean),this.stdevs.push(i.stdev)}),this.hasBeenFitted=!0,this}fitAndTransform(){return this.fit(arguments[0]).transform(...arguments)}transform(){let t=Array.from(arguments);if(t.length>1)return t.map(i=>this.transform(i));let n=t[0];if(!this.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(p(n)){let i=new A(this.transform(n.values));return i.columns=n.columns,i.index=n.index,i}if(N(n)){let i=new z(this.transform(n.values));return i.name=n.name,i.index=n.index,i}let r=this._getDataArrayAndShape(n);n=r[0];let s=r[1];f(s[1]===this.means.length,"The data you passed into the `transform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let o=n.map(i=>i.map((u,a)=>(Number(u)-Number(this.means[a]))/Number(this.stdevs[a])));return this.wasFittedOnAVector?K(o):o}untransform(t){if(!this.hasBeenFitted)throw new Error("This `StandardScaler` instance hasn't been trained on any data yet! Please use the `fit` method to train it before calling the `transform` method.");if(p(t)){let o=new A(this.untransform(t.values));return o.columns=t.columns,o.index=t.index,o}if(N(t)){let o=new z(this.untransform(t.values));return o.name=t.name,o.index=t.index,o}let n=this._getDataArrayAndShape(t);t=n[0];let r=n[1];f(r[1]===this.means.length,"The data you passed into the `untransform` function doesn't have the same number of columns as the data set on which this StandardScaler was fitted!");let s=t.map(o=>o.map((i,u)=>i*this.stdevs[u]+this.means[u]));return this.wasFittedOnAVector?K(s):s}};function gr(){let e=Array.from(arguments),t=e.filter(h=>g(h)||p(h)||N(h)),n=e.find(h=>!t.includes(h)&&typeof h=="object")||{},r=v(n.shouldShuffle)?!0:n.shouldShuffle,s=v(n.testSize)?.1:n.testSize;f(ce(r),"If passing an options object to the `trainTestSplit` function and including a `shouldShuffle` property on that object, then the value of that property must be a boolean!"),f(b(s)&&s>0&&s<1,"If passing an options object to the `trainTestSplit` function and including a `testSize` property on that object, then the value of that property must be a number between 0 and 1 (exclusive on both ends)!"),f(t.length>0,"You must pass at least one dataset into the `trainTestSplit` function!");let o=t.map(h=>w(h)[0]);f(X(o).length===1,`All datasets passed into the \`trainTestSplit\` function must have the same length at their shallowest dimension! The lengths of the datasets you provided, though, are: ${o.join(", ")}`);let i=[],u=r?Re(C(0,o[0])):C(0,o[0]),a=he((1-s)*u.length),l=u.slice(0,a),c=u.slice(a);return t.forEach(h=>{if(p(h))i.push(h.get(l,null)),i.push(h.get(c,null));else if(N(h))i.push(h.get(l)),i.push(h.get(c));else{let d=[],E=[];h.forEach((F,I)=>{l.includes(I)?d.push(F):E.push(F)}),i.push(d),i.push(E)}}),i}typeof window<"u"&&(window.JSDataScienceHelpers={cohensd:At,convertToNumerical:yn,diagonalize:bn,getCorrelationMatrix:Yt,getHighlyCorrelatedColumns:ur,getMagnitude:pt,getOneHotEncodings:ut,getPercentages:ar,getPValueMatrix:Vt,hunterChainSort:vn,IndexMatcher:$t,isBinary:Nn,isCorrelationMatrix:fr,isWholeNumber:ne,KMeans:hr,MathError:pe,normalize:Nt,orthonormalize:Dn,OutlierMitigator:Kt,project:ze,pValue:Ue,rScore:mr,rSquared:Ze,standardize:dr,StandardScaler:Ut,trainTestSplit:gr});0&&(module.exports={IndexMatcher,KMeans,MathError,OutlierMitigator,StandardScaler,cohensd,convertToNumerical,diagonalize,getCorrelationMatrix,getHighlyCorrelatedColumns,getMagnitude,getOneHotEncodings,getPValueMatrix,getPercentages,hunterChainSort,isBinary,isCorrelationMatrix,isWholeNumber,normalize,orthonormalize,pValue,project,rScore,rSquared,standardize,trainTestSplit});
