(()=>{var o=class{subscriptions={};copy(){let s=new this.constructor(this.toObject());return Object.keys(this.subscriptions).forEach(t=>{s.subscriptions[t]=this.subscriptions[t].slice()}),s}emit(s,t){return this.subscriptions[s]&&this.subscriptions[s].forEach(i=>{i(t)}),this}off(s,t){if(typeof s!="string")throw new Error(`The first argument passed into a \`${this.constructor.name}\` instance's \`off\` method must be a string representing an event name!`);if(typeof t!="function")throw new Error(`The second argument passed into a \`${this.constructor.name}\` instance's \`off\` method must be a callback function!`);if(this.subscriptions[s]){let i=this.subscriptions[s].indexOf(t);i>-1&&this.subscriptions[s].splice(i,1)}}on(s,t){if(typeof s!="string")throw new Error(`The first argument passed into a \`${this.constructor.name}\` instance's \`on\` method must be a string representing an event name!`);if(typeof t!="function")throw new Error(`The second argument passed into a \`${this.constructor.name}\` instance's \`on\` method must be a callback function!`);return this.subscriptions[s]||(this.subscriptions[s]=[]),this.subscriptions[s].push(t),()=>this.off(s,t)}toObject(){return{}}};typeof globalThis<"u"&&(globalThis.BaseClass=o);})();
