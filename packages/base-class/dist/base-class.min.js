(()=>{var o=class{subscriptions={};copy(){let s=new this.constructor(this.toObject());return Object.keys(this.subscriptions).forEach(t=>{s.subscriptions[t]=this.subscriptions[t].slice()}),s}emit(){let s=Array.from(arguments),t=s[0],i=s.slice(1);return this.subscriptions[t]&&this.subscriptions[t].forEach(r=>{r(...i)}),this}off(s,t){if(typeof s!="string")throw new Error(`The first argument passed into a \`${this.constructor.name}\` instance's \`off\` method must be a string representing an event name!`);if(typeof t!="function")throw new Error(`The second argument passed into a \`${this.constructor.name}\` instance's \`off\` method must be a callback function!`);if(this.subscriptions[s]){let i=this.subscriptions[s].indexOf(t);i>-1&&this.subscriptions[s].splice(i,1)}return this}on(s,t){if(typeof s!="string")throw new Error(`The first argument passed into a \`${this.constructor.name}\` instance's \`on\` method must be a string representing an event name!`);if(typeof t!="function")throw new Error(`The second argument passed into a \`${this.constructor.name}\` instance's \`on\` method must be a callback function!`);return this.subscriptions[s]||(this.subscriptions[s]=[]),this.subscriptions[s].push(t),()=>this.off(s,t)}toObject(){return{}}};typeof globalThis<"u"&&(globalThis.BaseClass=o);})();
