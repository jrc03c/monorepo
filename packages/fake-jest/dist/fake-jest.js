(()=>{var p=Object.create;var u=Object.defineProperty;var d=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,x=Object.prototype.hasOwnProperty;var E=e=>u(e,"__esModule",{value:!0});var $=(e,t)=>()=>(t||e((t={exports:{}}).exports,t),t.exports);var g=(e,t,s,a)=>{if(t&&typeof t=="object"||typeof t=="function")for(let r of T(t))!x.call(e,r)&&(s||r!=="default")&&u(e,r,{get:()=>t[r],enumerable:!(a=d(t,r))||a.enumerable});return e},I=(e,t)=>g(E(u(e!=null?p(m(e)):{},"default",!t&&e&&e.__esModule?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var f=$((q,h)=>{var o="\x1B[0m",y={fx:{reset:e=>o+e+o,bright:e=>"\x1B[1m"+e+o,dim:e=>"\x1B[2m"+e+o,underscore:e=>"\x1B[4m"+e+o,blink:e=>"\x1B[5m"+e+o,reverse:e=>"\x1B[7m"+e+o,hidden:e=>"\x1B[8m"+e+o},fg:{black:e=>"\x1B[30m"+e+o,red:e=>"\x1B[31m"+e+o,green:e=>"\x1B[32m"+e+o,yellow:e=>"\x1B[33m"+e+o,blue:e=>"\x1B[34m"+e+o,magenta:e=>"\x1B[35m"+e+o,cyan:e=>"\x1B[36m"+e+o,white:e=>"\x1B[37m"+e+o},bg:{black:e=>"\x1B[40m"+e+o,red:e=>"\x1B[41m"+e+o,green:e=>"\x1B[42m"+e+o,yellow:e=>"\x1B[43m"+e+o,blue:e=>"\x1B[44m"+e+o,magenta:e=>"\x1B[45m"+e+o,cyan:e=>"\x1B[46m"+e+o,white:e=>"\x1B[47m"+e+o}};h.exports=y});var i=I(f(),1),c=class{constructor(t){this.valenceIsPositive=!0,this.value=t}get not(){return this.valenceIsPositive=!this.valenceIsPositive,this}toBe(t){let s=this.value===t||typeof this.value=="number"&&isNaN(this.value)&&typeof t=="number"&&isNaN(t);if(this.valenceIsPositive){if(!s)throw new Error(`The value ${this.value} is supposed to be ${t}, but it's not!`)}else if(s)throw new Error(`The value ${this.value} is not supposed to be equal to ${t}, but it is!`)}toBeCloseTo(t){let s=Math.abs(this.value-t)<=1e-5;if(this.valenceIsPositive){if(!s)throw new Error(`The value ${this.value} is supposed to be close to ${t}, but it's not!`)}else if(s)throw new Error(`The value ${this.value} is not supposed to be close to ${t}, but it is!`)}toBeGreaterThan(t){let s=this.value>t;if(this.valenceIsPositive){if(!s)throw new Error(`The value ${this.value} is supposed to be greater than ${t}, but it's not!`)}else if(s)throw new Error(`The value ${this.value} is not supposed to be greater than ${t}, but it is!`)}toBeGreaterThanOrEqualTo(t){let s=this.value>=t;if(this.valenceIsPositive){if(!s)throw new Error(`The value ${this.value} is supposed to be greater than or equal to ${t}, but it's not!`)}else if(s)throw new Error(`The value ${this.value} is not supposed to be greater than or equal to ${t}, but it is!`)}toBeLessThan(t){let s=this.value<t;if(this.valenceIsPositive){if(!s)throw new Error(`The value ${this.value} is supposed to be less than ${t}, but it's not!`)}else if(s)throw new Error(`The value ${this.value} is not supposed to be less than ${t}, but it is!`)}toBeLessThanOrEqualTo(t){let s=this.value<=t;if(this.valenceIsPositive){if(!s)throw new Error(`The value ${this.value} is supposed to be less than or equal to ${t}, but it's not!`)}else if(s)throw new Error(`The value ${this.value} is not supposed to be less than or equal to ${t}, but it is!`)}toBeNaN(){let t=isNaN(this.value);if(this.valenceIsPositive){if(!t)throw new Error(`The value ${this.value} is supposed to be NaN, but it's not!`)}else if(t)throw new Error(`The value ${this.value} is not supposed to be NaN, but it is!`)}toStrictEqual(t){function s(r,n){if(r instanceof Array)if(n instanceof Array){if(r.length!==n.length)return!1;for(let l=0;l<r.length;l++)if(!s(r[l],n[l]))return!1}else return!1;else{if(n instanceof Array)return!1;if(r!==n)return!1}return!0}let a=s(this.value,t);if(this.valenceIsPositive){if(!a)throw new Error("The two values are supposed to be strictly equivalent, but they're not!")}else if(a)throw new Error("The two values are not supposed to be strictly equivalent, but they are!")}toThrow(){let t=!1;try{let s=this.value();if(s instanceof Promise)return s.then(()=>{if(this.valenceIsPositive)throw new Error("The function was supposed to throw an error, but it didn't!")}).catch(()=>{if(!this.valenceIsPositive)throw new Error("The function was not supposed to throw an error, but it did!")})}catch{t=!0}if(this.valenceIsPositive){if(!t)throw new Error("The function was supposed to throw an error, but it didn't!")}else if(t)throw new Error("The function was not supposed to throw an error, but it did!")}},b=[],v=[],w=[];function N(e){b.push(e)}function A(e){v.push(e)}function O(e){return new c(e)}async function B(e,t){w.push({description:e,fn:t})}(async()=>{for(let e of v)await e();for(let e of w){let t=!0;try{await e.fn()}catch(s){console.error(i.default.fx.dim(i.default.fg.red(s.stack))),t=!1}console.log(t?i.default.fx.bright(i.default.fg.green("PASS")):i.default.fx.bright(i.default.fg.red("FAIL")),":",e.description)}for(let e of b)await e()})();})();
