var Jn=Object.defineProperty,zn=(e,n,t)=>n in e?Jn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,Ye=(e,n,t)=>(zn(e,typeof n!="symbol"?n+"":n,t),t),Rn=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),Cn=class extends Error{constructor(e){Rn()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}},U=Cn;function l(e,n){if(!e)throw new U(n)}function Yn(e){return e===null||typeof e>"u"}var g=Yn,Xe=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray],qn=Xe.map(e=>e.name);function Un(e){try{return e instanceof Array?!0:g(e.constructor)?!1:Xe.indexOf(e.constructor)>-1||qn.indexOf(e.constructor.name)>-1}catch{return!1}}var f=Un;function Wn(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}var b=Wn;function Kn(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}var y=Kn;function Ze(e){if(b(e)||y(e))return Ze(e.values);l(f(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function n(t){let r=[];return t.forEach(a=>{f(a)?r=r.concat(n(a)):r.push(a)}),r}return n(e)}var A=Ze;function Gn(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var d=Gn;function Hn(e){return typeof e=="function"}var D=Hn;function Ln(e){return typeof e=="object"&&!g(e)&&!f(e)}var $=Ln;function xe(e,n){if(b(e)){let i=xe(e.values,n);return i.length>0&&d(i[0])&&i[0]>=0&&i[0]<e.index.length&&(i[0]=e.index[i[0]]),i.length>1&&d(i[1])&&i[1]>=0&&i[1]<e.columns.length&&(i[1]=e.columns[i[1]]),i}if(y(e)){let i=xe(e.values,n);return i.length>0&&d(i[0])&&i[0]>=0&&i[0]<e.index.length&&(i[0]=e.index[i[0]]),i}if(l($(e)||f(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!D(n)){let i=n;n=s=>s===i}function t(i,s,o){if(o=o||[],o.indexOf(i)>-1)return null;if($(i)){o.push(i);let u=Object.keys(i).concat(Object.getOwnPropertySymbols(i));for(let h=0;h<u.length;h++){let c=u[h],m=i[c];if(s(m))return[c];let p=t(m,s,o);if(p&&p.length>0)return[c].concat(p)}}else if(f(i)){o.push(i);for(let u=0;u<i.length;u++){let h=i[u];if(s(h))return[u];let c=t(h,s,o);if(c&&c.length>0)return[u].concat(c)}}else if(s(i))return[];return null}function r(i){try{return n(i)}catch{return!1}}let a=t(e,r);return a&&a.length>0?a:null}var pe=xe;function j(e){function n(t){if(typeof t=="object"){if(t===null)return null;if(f(t))return t instanceof Array?t.map(a=>j(a)):t.slice();if(y(t)){let a=t.copy();return a.values=j(a.values),a}if(b(t)){let a=t.copy();return a.values=j(t.values),a}if(t instanceof Date)return new Date(t.getTime());t=V(t);let r={};return Object.keys(t).concat(Object.getOwnPropertySymbols(t)).forEach(a=>{r[a]=j(t[a])}),r}else return t}return n(V(e))}function V(e){function n(a,i,s){if(i=i||[],s=s||"",i.indexOf(a)>-1){let o=s.split("/").slice(s.startsWith("/")?1:0);if(o.some((u,h)=>{let c=o.slice(0,o.length-h-1),m=t;return c.forEach(p=>{m=m[p]}),m===a}))return`<reference to "${t===a?"/":"/"+pe(t,a).join("/")}">`}return typeof a=="object"?a===null?null:(i.push(a),f(a)?typeof a.constructor<"u"&&a.constructor.name!=="Array"?a.slice():a.map((o,u)=>n(o,i,s+"/"+u)):(Object.keys(a).concat(Object.getOwnPropertySymbols(a)).forEach(o=>{a[o]=n(a[o],i,s+"/"+o.toString())}),a)):a}let t=e,r=n(t);if(b(e)){let a=e.copy();a._values=r.values,a._columns=r.columns,a._index=r.index,r=a}if(y(e)){let a=e.copy();a.name=r.name,a._values=r.values,a._index=r.index,r=a}return r}function en(e){if(b(e)||y(e))return en(e.values);l(f(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let n=0;n<e.length;n++)if(f(e[n]))return!0;return!1}var Be=en,H="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function nn(e){l(!g(e),H),f(e)||(e=[e]),l(!Be(e),H),l(e.length>0,H);let n=e[0];if(typeof n=="bigint"&&(n=Number(n)),l(d(n),H),l(n>=0,H),l(Math.floor(n)===n,H),l(n!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let t=[];for(let r=0;r<n;r++)t.push(void 0);return t}else{let t=[];for(let r=0;r<n;r++)t.push(nn(e.slice(1)));return t}}var B=nn;function tn(e,n){if(b(e)||y(e))return tn(e.values,n);l(f(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let t=A(e),r=!1,a=1;for(let i of t){if(!d(i))if(n)i=1;else return NaN;typeof i=="bigint"&&(r=!0,i=Number(i)),a*=i}if(r)try{return BigInt(a)}catch{}return a}catch{return NaN}}var ye=tn;function Qn(e){return d(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}var rn=Qn;function Vn(e){return rn(e)&&e>0}var Xn=Vn;function an(e){if(f(e)){let n=an(e[0]);return[e.length].concat(n||[])}else return}function sn(e){return b(e)||y(e)?sn(e.values):(l(f(e),"The `shape` function only works on arrays, Series, and DataFrames!"),an(e))}var v=sn;function we(e,n){if(b(e)||y(e))return we(e.values,n);if(l(f(e),"The first argument passed into the `reshape` function must be an array!"),d(n)&&(n=[n]),l(f(n),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),l(v(n).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),n=n.map(i=>(typeof i=="bigint"&&(i=Number(i)),l(Xn(i),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(i))),n.length===0)return A(e);let t=A(e);if(n.length===1&&n[0]===t.length)return t;l(ye(n)===t.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],a=Math.floor(t.length/n[0]);for(let i=0;i<n[0];i++){let s=t.slice(i*a,(i+1)*a);r.push(we(s,n.slice(1)))}return r}var Ae=we,on=Math.pow(2,64),_=[];be(Math.floor(Math.random()*on));function Zn(e,n){e=M(e);function t(){e+=M("0x9e3779b97f4a7c15");let a=j(e);return a=(a^a>>BigInt(30))*M("0xbf58476d1ce4e5b9"),a=(a^a>>BigInt(27))*M("0x94d049bb133111eb"),a^a>>BigInt(31)}let r=[];for(let a=0;a<n;a++)r.push(t());return r}function M(e){return BigInt.asUintN(64,BigInt(e))}function qe(e,n){return e=M(e),n=BigInt(n),M(M(e<<n)|M(e>>M(BigInt(64)-n)))}function be(e){if(typeof e=="bigint"&&(e=Number(e)),g(e))return j(_);{l(d(e),"If passing a value into the `seed` function, then that value must be an integer!");let n=Zn(Math.floor(e),4);_[0]=n[0],_[1]=n[1],_[2]=n[2],_[3]=n[3]}}function Ue(){let e=M(qe(_[0]+_[3],23)+_[0]),n=M(_[1]<<BigInt(17));return _[2]=M(_[2]^_[0]),_[3]=M(_[3]^_[1]),_[1]=M(_[1]^_[2]),_[0]=M(_[0]^_[3]),_[2]=M(_[2]^n),_[3]=qe(_[3],45),Math.floor(Number(e))/on}function W(e){return g(e)?Ue():(f(e)||(e=[e]),Ae(B(ye(e)).map(Ue),e))}function et(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var R=et,We=["number","int","float","bigint"];function nt(e,n){function t(r,a){let i=typeof r,s=typeof a;if(i!==s&&!We.includes(i)&&!We.includes(s))return!1;if(i==="undefined"&&s==="undefined")return!0;if(i==="boolean"||i==="symbol")return r===a;if(i==="number"||i==="bigint")try{let o=r.toString(),u=a.toString();return o===u}catch{return!1}if(i==="string"||i==="function")return r===a;if(i==="object"){if(r===null||a===null)return r===null&&a===null;{if(R(r))return R(a)?r.getTime()===a.getTime():!1;if(R(a))return!1;if(r instanceof RegExp&&a instanceof RegExp)return r.toString()===a.toString();if(f(r)!==f(a))return!1;let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),u=Object.keys(a).concat(Object.getOwnPropertySymbols(a));if(o.length!==u.length)return!1;for(let h=0;h<o.length;h++){let c=o[h];if(!t(r[c],a[c]))return!1}return!0}}}try{return t(e,n)}catch{return t(V(e),V(n))}}var J=nt;function te(e){let n="abcdefg1234567890",t="";for(;t.length<e;)t+=n[Math.floor(Math.random()*n.length)];return t}var tt=te(16),rt=te(16),at=te(16),it=te(16),st=te(16),ot=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let n of e)f(n)?this.count(n):this.increment(n);return this}delete(e){let n=this.getStandardizedKey(e);return delete this.countsDict[n],delete this.valuesDict[n],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?tt:g(e)?rt:D(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+st:e===1/0?at:e===-1/0?it:typeof e=="bigint"?e.toString():b(e)?e.toJSONString():y(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!g(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,n){let t=this.getStandardizedKey(e);return this.countsDict[t]=n,this.valuesDict[t]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(n=>{e[n]=this.get(n)}),e}},lt=ot;function ut(e,n){n=n||{};let t=new lt,r={},a=A(e),i=[],s=-1/0,o=1/0,u=!1,h=0;for(let m of a){if(typeof m=="bigint"&&(u=!0),!n.shouldDropNaNs||d(m))try{m>s&&(s=m),m<o&&(o=m),h+=Number(m),i.push(m)}catch{s=NaN,o=NaN,h=NaN}t.increment(m)}let c=h/i.length;if(r.counts=t,r.max=s,r.mean=c,r.min=o,r.n=a.length,r.sum=h,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),n.shouldDropNaNs&&(r.nWithoutNaNs=i.length),n.mode){let m=Array.from(t.values.map(N=>[N,t.get(N)])).toSorted((N,z)=>z[1]-N[1]),p=m[0][1],x=[];for(let N of m)if(N[1]==p)x.push(N[0]);else break;r.mode=x.toSorted()}if(n.median)if(isNaN(c))r.median=NaN;else{let m=i.toSorted((x,N)=>Number(x)-Number(N)),p=Math.floor(m.length/2);if(m.length%2===0){let x=m[p-1],N=m[p];if(r.median=(Number(x)+Number(N))/2,u&&typeof x=="bigint"&&typeof N=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=m[p]}if(n.stdev||n.variance){let m=0;for(let x of i)m+=Math.pow(Number(x)-c,2);m/=i.length;let p=Math.sqrt(m);r.stdev=p,r.variance=m}if(u){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}n.mode&&(r.mode=r.mode.map(m=>{try{return BigInt(m)}catch{return m}}))}return r}var F=ut;function ht(e,n){let{counts:t}=F(e);return g(n)||(D(n)?t.values.forEach(r=>{n(r)||t.delete(r)}):t.values.forEach(r=>{J(r,n)||t.delete(r)})),t}var fe=ht;function Oe(e){if(b(e)||y(e))return Oe(e.values);if(f(e)){let n=!1,t=!1,r=null;for(let a of e){if(Oe(a))return!0;if(f(a)){if(r===null)r=a.length;else if(a.length!==r)return!0;n=!0}else t=!0;if(n&&t)return!0}}return!1}function ct(e){return Oe(V(e))}var re=ct;function _e(e){if(b(e)||y(e)){let t=e.copy();return t.values=_e(t.values),t.index=_e(t.index),t}l(f(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let n=[];for(let t=e.length-1;t>=0;t--)n.push(e[t]);return n}var q=_e;function ft(e,n,t=1){l(!g(e)&&!g(n)&&!g(t),"You must pass two numbers and optionally a step value to the `range` function!"),l(d(e)&&d(n)&&d(t),"You must pass two numbers and optionally a step value to the `range` function!"),l(t>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,a=typeof e=="bigint"||typeof n=="bigint"||typeof t=="bigint";if(e=Number(e),n=Number(n),t=Number(t),e>n){r=!0;let s=e;e=n+t,n=s+t}let i=[];for(let s=e;s<n;s+=t)if(a)try{i.push(BigInt(s))}catch{i.push(s)}else i.push(s);return r&&(i=q(i)),i}var T=ft;function ae(e){let n="abcdefg1234567890",t="";for(;t.length<e;)t+=n[Math.floor(Math.random()*n.length)];return t}var mt=ae(256),dt=ae(256),gt=ae(256),pt=ae(256),yt=ae(256);function ln(e){if(b(e)||y(e))return ln(e.values);l(f(e),"The `set` function only works on arrays, Series, and DataFrames!");let n=[],t={};return A(e).forEach(r=>{let a=typeof r=="object"&&r===null?mt:g(r)?dt:D(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+yt:r===1/0?gt:r===-1/0?pt:typeof r=="bigint"?r.toString():b(r)?r.toJSONString():y(r)?JSON.stringify(r.toObject()):JSON.stringify(r);t[a]||n.push(r),t[a]=!0}),n}var P=ln;function un(e,n,t){if(g(t)&&(t=0),l(t===0||t===1||t==="vertical"||t==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),f(n)){l(!re(n),"The array of data you're trying to append to this DataFrame is jagged!");let r=v(n);if(r.length===1)if(t===0){let a=e.copy();a._values.push(n);let i=Math.max(e.shape[1],r[0]);for(a._values.forEach(s=>{for(;s.length<i;)s.push(void 0)});a._index.length<a._values.length;)a._index.push("row"+a._index.length);for(;a._columns.length<i;)a._columns.push("col"+a._columns.length);return a}else{let a=Math.max(e.shape[0],r[0]),i=e.copy();for(T(0,a).forEach(s=>{s>=i._values.length&&i._values.push(B(e.shape[1])),i._values[s].push(n[s])});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<i._values[0].length;)i._columns.push("col"+i._columns.length);return i}else if(r.length===2)if(t===0){let a=Math.max(...n.map(s=>s.length).concat([e.shape[1]])),i=e.copy();for(i._values=i._values.concat(n).map(s=>{for(;s.length<a;)s.push(void 0);return s});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<a;)i._columns.push("col"+i._columns.length);return i}else{let a=Math.max(...n.map(o=>o.length))+e.shape[1],i=Math.max(e.shape[0],r[0]),s=e.copy();for(T(0,i).forEach(o=>{for(o>=s._values.length&&s._values.push(B(e.shape[1])),s._values[o]=s._values[o].concat(n[o]);s._values[o].length<a;)s._values[o].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<a;)s._columns.push("col"+s._columns.length);return s}else throw new U("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(y(n)){let r=un(e,n.values,t);return t===0?r.index[r.index.length-1]=r.index.indexOf(n.name)>-1?n.name+" (2)":n.name:r.columns[r.columns.length-1]=r.columns.indexOf(n.name)>-1?n.name+" (2)":n.name,r}else if(b(n))if(t===0){let r=e.copy(),a=P(r._columns.concat(n._columns)).length;for(r._values.forEach(i=>{for(;i.length<a;)i.push(void 0)}),n.apply(i=>{let s=i.copy(),o=[];r._columns.forEach(u=>{let h=s._index.indexOf(u);h>-1?(o.push(s._values[h]),s._values.splice(h,1),s._index.splice(h,1)):o.push(void 0)}),r._values.push(o.concat(s._values))},1),r._columns=r._columns.concat(n._columns.filter(i=>r._columns.indexOf(i)<0));r._index.length<r._values.length;){let i="row"+r._index.length;r._index.push(i+(e._index.indexOf(i)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((a,i)=>{let s=n._index.indexOf(a);s>-1?r._values[i]=r._values[i].concat(n._values[s]):r._values[i]=r._values[i].concat(B(n.shape[1]))}),n._index.forEach((a,i)=>{r._index.indexOf(a)<0&&(r._index.push(a),r._values.push(B(r._columns.length).concat(n._values[i])))}),r._columns=r._columns.concat(n._columns.map(a=>a+(r._columns.indexOf(a)>-1?" (2)":""))),r}else throw new U("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}var bt=un;function vt(e,n,t,r,a){if(a=a||0,l(D(r),"The first parameter to the `apply` method must be a function."),l(a===0||a===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),a===0){let i={},s;if(t.columns.forEach((o,u)=>{let h=new n(t.values.map(m=>m[u]));h.name=o,h.index=t.index;let c=r(h,u,t);c instanceof n?i[o]=c.values:i[o]=c,g(s)&&(s=c instanceof n||f(c))}),s){let o=new e(i);return o.index=t.index,o}else{let o=new n(t.columns.map(u=>i[u]));return o.index=t.columns,o}}else if(a===1){let i,s=t.values.map((o,u)=>{let h=new n(o);h.name=t.index[u],h.index=t.columns;let c=r(h,u,t);return g(i)&&(i=c instanceof n||f(c)),c instanceof n?c.values:c});if(i){let o=new e(s);return o.index=t.index,o.columns=t.columns,o}else{let o=new n(s);return o.index=t.index,o}}}var Nt=vt;function xt(e){return typeof e=="string"}var w=xt;function wt(e,n,t,r,a){let i=o=>o instanceof e,s=o=>o instanceof n;if(g(a)){if(i(r)||s(r))return t.append(r,1);if($(r)){let o=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(u=>r[u].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(u=>{for(;r[u].length<o;)r[u].push(void 0)}),t.append(new e(r),1)}else throw new U("You must pass a DataFrame, Series, or object into the `assign` method!")}else{l(w(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),l(f(a)&&!re(a)&&v(a).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let o=t.append(a,1);return o.columns[o.columns.length-1]=r,o}}var Ot=wt;function _t(e,n){if(n.isEmpty)return new e;let t=new e(j(n.values));return t.columns=n.columns.slice(),t.index=n.index.slice(),t}var St=_t;function Tt(e,n,t,r,a){g(r)&&(r=[]),g(a)&&(a=[]),(w(r)||d(r))&&(r=[r]),(w(a)||d(a))&&(a=[a]),l(f(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),l(f(a),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),l(v(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),l(v(a).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let i,s;t.index.forEach((u,h)=>{r.indexOf(u)<0&&r.indexOf(h)<0&&(i||(i=[]),i.push(u))}),t.columns.forEach((u,h)=>{a.indexOf(u)<0&&a.indexOf(h)<0&&(s||(s=[]),s.push(u))});let o=t.get(i,s);if(o instanceof n){let u=new e;u=u.assign(o),t.index.indexOf(o.name)>-1&&(u=u.transpose()),o=u}return o}var Dt=Tt;function jt(e){return rn(e)&&e>=0}var X=jt;function Mt(e,n,t,r,a,i){r=r||0,l(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),i=i||0,l(X(i),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),a=i>0?"none":a||"any",l(a==="any"||a==="all"||a==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(h){if(i>0){let c=0;for(let m=0;m<h.length;m++){let p=h[m];if(g(p)&&c++,c>=i)return[]}}else if(a==="any")for(let c=0;c<h.length;c++){let m=h[c];if(g(m))return[]}else if(a==="all"){for(let c=0;c<h.length;c++){let m=h[c];if(!g(m))return h}return[]}return h}let o=t.copy(),u=Math.random().toString();if(r===0){o=o.assign(u,o.index);let h=o.values.map(s).filter(m=>m.length>0);if(v(h).length<2)return new e;o.values=h;let c=o.get(null,u);if(g(c))return new e;w(c)&&(c=[c]),c instanceof n&&(c=c.values),o.index=c,o=o.drop(null,u)}else if(r===1){let h={};if(o.columns.forEach((m,p)=>{let x=o.values.map(z=>z[p]),N=s(x);N.length>0&&(h[m]=N)}),Object.keys(h).length+Object.getOwnPropertySymbols(h).length===0)return new e;let c=new e(h);return c.index=o.index,c}return o}var It=Mt;function hn(e){if(b(e)||y(e))return e.dropNaN(...Object.values(arguments).slice(1));l(f(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let n=[];return e.forEach(t=>{try{return n.push(hn(t))}catch{if(d(t))return n.push(t)}}),n}var cn=hn;function Et(e,n,t,r,a){t=t||0,l(t===0||t===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),a=a||0,l(X(a),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=a>0?"none":r||"any",l(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function i(o){let u=cn(o);return a>0?o.length-u.length<a:r==="any"?u.length===o.length:r==="all"?u.length>0:!0}let s=n.copy();if(t===0){let o=s.index.filter(u=>{let h=s.get(u,null).values;return i(h)});return o.length>0?s.get(o,null):new e}else if(t===1){let o=s.columns.filter(u=>{let h=s.get(null,u).values;return i(h)});return o.length>0?s.get(null,o):new e}return s}var Ft=Et;function Ke(e){let n={};return A(e).forEach((t,r)=>{n[t]=r}),n}function L(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((n,t)=>e[n]-e[t])}function kt(e,n,t,r,a){l(D(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),g(a)&&(a=0),l(a===0||a===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let i=t.copy();if(i.isEmpty)return i;let s=Ke(i.index),o=Ke(i.columns);if(a===0){let u=0,h=i.values.filter((c,m)=>{let p=new n(c);p.name=t.index[m],p.index=t.columns;let x=r(p,m,t);return x?u++:delete s[i.index[m]],x});if(u===0)return new e;if(u===1){let c=new n(h[0]);return c.name=L(s)[0],c.index=L(o),c}i.values=h,i.index=L(s)}else if(a===1){i=i.transpose();let u=0,h=i.values.filter((c,m)=>{let p=new n(c);p.name=t.columns[m],p.index=t.index;let x=r(p,m,t);return x?u++:delete o[i.index[m]],x});if(u===0)return new e;if(u===1){let c=new n(h[0]);return c.name=L(o)[0],c.index=L(s),c}i.values=h,i.index=L(o),i=i.transpose()}return i}var Pt=kt;function Bt(e,n,t){(w(n)||d(n))&&(n=[n]),(w(t)||d(t))&&(t=[t]);for(let a in n)typeof n[a]=="bigint"&&(n[a]=Number(n[a]));for(let a in t)typeof t[a]=="bigint"&&(t[a]=Number(t[a]));let r=P((n||[]).concat(t||[]).map(a=>typeof a));return l(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&l(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(l(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),l(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),g(n)||(n=n.map(a=>{if(w(a))return l(e.index.indexOf(a)>-1,`Row "${a}" does not exist!`),a;if(d(a))return l(a>=0,`Index ${a} is out of bounds!`),l(Math.floor(a)===a,"Row numbers must be integers!"),l(a<e.index.length,`Index ${a} is out of bounds!`),e.index[a]})),g(t)||(t=t.map(a=>{if(w(a))return l(e.columns.indexOf(a)>-1,`Column "${a}" does not exist!`),a;if(d(a))return l(a>=0,`Column ${a} is out of bounds!`),l(Math.floor(a)===a,"Column numbers must be integers!"),l(a<e.columns.length,`Column ${a} is out of bounds!`),e.columns[a]})),e.getSubsetByNames(n,t)}var At=Bt;function $t(e,n){try{return e<n?-1:e>n?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),n=typeof n=="object"&&n!==null?JSON.stringify(n):n.toString(),e<n?-1:e>n?1:0}}function Jt(e,n){if(g(n)&&(n=$t),b(e)||y(e))return e.sort(...Object.values(arguments).slice(1));l(f(e),"The `sort` function only works on arrays, Series, and DataFrames!"),l(D(n),"The second parameter of the `sort` function must be a comparison function!");let t=e.slice();return t.sort(n),t}var G=Jt;function zt(e){let n=e.toLowerCase(),t="";for(let a=0;a<n.length;a++){let i=n[a];i.match(/[a-z0-9]/g)?t+=i:t+=" "}let r=t.split(" ").filter(a=>a.length>0);return r[0]+r.slice(1).map(a=>a[0].toUpperCase()+a.substring(1)).join("")}function Rt(e,n,t){g(t)?t=n.columns:w(t)&&(t=[t]);let r={};t.forEach(i=>{l(w(i),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=n.columns.indexOf(i);l(s>-1,`The given DataFrame does not have a column called "${i}"!`);let o=n.values.map(h=>h[s]),u=G(P(o));o.forEach(h=>{u.forEach(c=>{let m=i+"_"+zt(c.toString());r[m]||(r[m]=[]),h===c?r[m].push(1):r[m].push(0)})})});let a=new e(r);return a.index=n.index,a}var Ge=Rt;function Ct(e,n,t){let r=e.shape;g(n)&&(n=T(0,r[0])),g(t)&&(t=T(0,r[1])),d(n)&&(n=[n]),d(t)&&(t=[t]),l(f(n)&&f(t),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),l(v(n).length===1&&v(t).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),l(n.length>0,"The `rowIndices` array must contain at least one index."),l(t.length>0,"The `colIndices` array must contain at least one index."),n.forEach(s=>{l(X(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),l(s<e.index.length,`The row index ${s} is out of bounds.`)}),t.forEach(s=>{l(X(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),l(s<e.columns.length,`The column index ${s} is out of bounds.`)});let a=n.map(s=>e.index[s]),i=t.map(s=>e.columns[s]);return e.getSubsetByNames(a,i)}var Yt=Ct;function qt(e,n,t,r,a){g(r)&&(r=t.index),g(a)&&(a=t.columns),w(r)&&(r=[r]),w(a)&&(a=[a]),l(f(r)&&f(a),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),l(v(r).length===1&&v(a).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),l(r.length>0,"The `rows` array must contain at least one row name."),l(a.length>0,"The `cols` array must contain at least one column name."),r.forEach(o=>{l(w(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),l(t.index.indexOf(o)>-1,`The row name "${o}" does not exist in the list of rows.`)}),a.forEach(o=>{l(w(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),l(t.columns.indexOf(o)>-1,`The column name "${o}" does not exist in the list of columns.`)});let i=r.map(o=>a.map(u=>t.values[t.index.indexOf(o)][t.columns.indexOf(u)]));if(r.length===1&&a.length===1)return i[0][0];if(r.length===1){let o=new n(i[0]);return o.name=r[0],o.index=a,o}if(a.length===1){let o=new n(i.map(u=>u[0]));return o.name=a[0],o.index=r,o}let s=new e(i);return s.columns=a,s.index=r,s}var Ut=qt;function Wt(e,n,t){function r(p,x){return w(p)&&p.length>x?p.substring(0,x-3)+"...":p}if(t.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),t;let a=typeof window>"u"?20:10,i=Math.floor(a/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,o=Math.floor(s/2),u=a>t.index.length?null:T(0,i).concat(T(t.index.length-i,t.index.length)),h=s>t.columns.length?null:T(0,o).concat(T(t.columns.length-o,t.columns.length)),c=t.get(u,h);c instanceof n&&(t.shape[0]===1?(c=new e([c.values]),c.index=t.index,c.columns=new n(t.columns).get(h).values):t.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new n(t.index).get(u).values,c.columns=t.columns)),a<=t.index.length&&(c._index.splice(i,0,"..."),c._values.splice(i,0,T(0,c.columns.length).map(()=>"..."))),s<=t.columns.length&&(c._columns.splice(o,0,"..."),c._values=c._values.map(p=>(p.splice(o,0,"..."),p)));let m=28;return c instanceof n?(c.values=c.values.map(p=>r(p,m)),c.name=r(c.name,m),c.index=c.index.map(p=>r(p,m))):(c.values=c.values.map(p=>p.map(x=>r(x,m))),c.columns=c.columns.map(p=>r(p,m)),c.index=c.index.map(p=>r(p,m))),console.table(c.toDetailedObject()),console.log("Shape:",t.shape,`
`),t}var Kt=Wt;function Gt(e,n){l(d(e),"The `leftPad` function only works on numbers!");let t=e.toString();for(;t.length<n;)t="0"+t;return t}var Q=Gt;function Ht(e,n){let t=n?e:e.copy();return t.index=T(0,e.shape[0]).map(r=>"row"+Q(r,(t.index.length-1).toString().length)),t}var Lt=Ht;function Qt(e){if(b(e)||y(e))return e.shuffle(...Object.values(arguments).slice(1));l(f(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let n=[],t=e.slice();for(let r=0;r<e.length;r++){let a=Math.floor(W()*t.length);n.push(t.splice(a,1)[0])}return n}var me=Qt;function Vt(e,n){return g(n)&&(n=0),l(n===0||n===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(n===0?me(e.index):null,n===1?me(e.columns):null)}var Xt=Vt;function Zt(e){return typeof e=="boolean"}var K=Zt;function er(e,n,t){return D(n)?nr(e,n,t):tr(e,n,t)}function nr(e,n,t){if(t=g(t)?0:t,l(D(n),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),l(d(t),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),t===0){let r=G(e.index,(a,i)=>n(e.get(a,null),e.get(i,null)));return e.get(r,null)}else{let r=G(e.columns,(a,i)=>n(e.get(null,a),e.get(null,i)));return e.get(null,r)}}function tr(e,n,t){let r=e.copy(),a=W().toString();r=r.assign(a,r.index),g(n)&&(n=[a],t=[!0]),(d(n)||w(n))&&(n=[n],(K(t)||w(t))&&(t=[t])),l(f(n),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),l(v(n).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),g(t)&&(t=T(0,n.length).map(()=>!0)),l(f(t),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),l(v(t).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),l(n.length===t.length,"The arrays passed into the `sort` method must be equal in length."),n=n.map(s=>{if(l(w(s)||d(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),w(s)){let o=r.columns.indexOf(s);return l(o>-1,`The column "${s}" does not exist!`),o}if(d(s))return l(X(s),"Column indices must be whole numbers!"),l(s<r.columns.length,`The index ${s} is out of bounds!`),s}),t=t.map(s=>{if(l(w(s)||K(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),w(s)){let o=s.trim().toLowerCase();return l(o==="ascending"||o==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),o==="ascending"}if(K(s))return s}),r.values=G(r.values,(s,o)=>{let u=0;for(;s[n[u]]===o[n[u]]&&u<n.length;)u++;let h=t[u];if(s[n[u]]===o[n[u]])return 0;if(s[n[u]]<o[n[u]])return h?-1:1;if(s[n[u]]>o[n[u]])return h?1:-1});let i=r.columns.indexOf(a);return r.index=r.values.map(s=>s[i]),r=r.dropColumns(a),r}var rr=er;function ar(e,n){g(n)?n=0:l(n===0||n===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let t={};return n===0?e.index.forEach((r,a)=>{let i={};e.columns.forEach((s,o)=>{i[s]=e.values[a][o]}),t[r]=i}):e.columns.forEach((r,a)=>{let i={};e.index.forEach((s,o)=>{i[s]=e.values[o][a]}),t[r]=i}),t}var ir=ar;function sr(e,n){return JSON.stringify(e.toObject(n))}var fn=sr;async function or(e,n,t){let r=fn(e,t),a=!1,i=!1,s,o;try{let u=n;if(n.includes("/")){let c=n.split("/");u=c[c.length-1]}let h=document.createElement("a");h.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,h.download=u,h.dispatchEvent(new MouseEvent("click")),a=!0}catch(u){s=u}try{let u=await import("node:fs"),h=await import("node:path");u.writeFileSync(h.resolve(n),r,"utf8"),i=!0}catch(u){o=u}if(!a&&!i)throw typeof window<"u"?new U(s):typeof module<"u"?new U(o):new U("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}var lr=or;function ur(e){let n={};return e.columns.forEach(t=>{n[t]=e.get(t).values}),n}var hr=ur;function cr(e){if(b(e)||y(e))return e.transpose();l(f(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let n=v(e);if(l(n.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),n.length===1)return q(e);if(n.length===2){let t=B(q(n));for(let r=0;r<n[0];r++)for(let a=0;a<n[1];a++)t[a][r]=e[r][a];return t}}var C=cr;function mn(e,n,t){if(y(t))return new e(n.values.concat(t.values));if(f(t)){let r=v(t);l(r.length===1&&!Be(r),"Only vectors can be appended to Series!");let a=n.copy();return t.forEach((i,s)=>{a._values.push(i),a._index.push("item"+(n.values.length+s))}),a}return mn(n,[t])}var fr=mn;function mr(e,n){l(D(n),"The parameter to the `apply` method must be a function.");let t=e.copy();return t._values=t._values.map((r,a)=>n(r,a)),t}var dr=mr;function gr(e){let n=e.copy(),t=[];return n._values=n.values.filter((r,a)=>g(r)?!1:(t.push(n.index[a]),!0)),n._index=t,n}var pr=gr;function yr(e,n){let t=[],r=[];n.values.forEach((i,s)=>{d(i)&&(r.push(i),t.push(n.index[s]))});let a=new e(r);return a.name=n.name,a.index=t,a}var br=yr;function vr(e,n,t){let r=n.copy(),a=j(r.index),i=[],s=r.values.filter((o,u)=>{let h=t(o,u,r.values);return h||i.push(r.index[u]),h});return i.forEach(o=>{a.splice(a.indexOf(o),1)}),s.length===0?(r=new e,r.name=n.name,r):(r.values=s,r.index=a,r)}var Nr=vr;function xr(e,n){(w(n)||d(n))&&(n=[n]);for(let r in n)typeof n[r]=="bigint"&&(n[r]=Number(n[r]));let t=P((n||[]).map(r=>typeof r));return l(t.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),t.length===1&&l(t[0]==="string"||t[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),t.length===2&&(l(t.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),l(t.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),g(n)||(n=n.map(r=>{if(typeof r=="string")return l(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return l(r>=0,`Index ${r} is out of bounds!`),l(Math.floor(r)===r,"Indices must be integers!"),l(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(n)}var wr=xr;function Or(e,n){let t=e.shape;g(n)&&(n=T(0,t[0])),l(f(n),"The `indices` array must be 1-dimensional array of whole numbers."),l(v(n).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),l(n.length>0,"The `indices` array must contain at least one index."),n.forEach(a=>{l(X(a),"The `indices` array must be a 1-dimensional array of whole numbers."),l(a<e.index.length,`The row index ${a} is out of bounds.`)});let r=n.map(a=>e.index[a]);return e.getSubsetByNames(r)}var _r=Or;function Sr(e,n,t){g(t)&&(t=n.index),l(f(t),"The `indices` array must be a 1-dimensional array of strings."),l(v(t).length===1,"The `indices` array must be a 1-dimensional array of strings."),l(t.length>0,"The `indices` array must contain at least one index name."),t.forEach(i=>{l(w(i),"The `indices` array must contain only strings."),l(n.index.indexOf(i)>-1,`The name "${i}" does not exist in the index.`)});let r=t.map(i=>n.values[n.index.indexOf(i)]);if(r.length===1)return r[0];let a=new e(r);return a.index=t,a.name=n.name,a}var Tr=Sr;function Dr(e){let n=e.copy(),t=typeof window>"u"?20:10;if(n.index.length>t){n=n.get(T(0,t/2).concat(T(n.index.length-t/2,n.index.length)));let a=j(n.index);a.splice(Math.floor(a.length/2),0,"..."),n.values.push("..."),n.index.push("..."),n=n.get(a)}let r={};return n.values.forEach((a,i)=>{let s={};s[n.name]=a,r[n.index[i]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}var jr=Dr;function Mr(e){let n=e.copy();return n.get(me(n.index))}var Ir=Mr;function Er(e,n,t){t=t||((u,h)=>u<h?-1:1),l(g(t)||D(t),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=C([n.values,n.index]),a=G(r,(u,h)=>t(u[0],h[0])),i=[],s=[];a.forEach(u=>{i.push(u[0]),s.push(u[1])});let o=new e;return o._values=i,o._index=s,o.name=n.name,o}var Fr=Er;function kr(e,n){let t=C([n.values,n.index]);t=C(G(t,(a,i)=>{if(a[1]===i[1])return 0;if(a[1]<i[1])return-1;if(a[1]>i[1])return 1}));let r=new e(t[0]);return r.index=t[1],r.name=n.name,r}var Pr=kr;function Br(e){let n={};return n[e.name]={},e.index.forEach((t,r)=>{n[e.name][t]=e.values[r]}),n}var Ar=Br,He=Symbol.for("@jrc03c/js-math-tools/series");function $r(e){class n{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===He}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:He}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(a){l(f(a),"The new values must be a 1-dimensional array!");let i=v(a);l(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<this._index.length?this._index=this._index.slice(0,i[0]):i[0]>this._index.length&&(this._index=this._index.concat(T(this._index.length,i[0]).map(s=>"item"+Q(s,(a.length-1).toString().length)))),this._values=a}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(a){l(f(a),"The new index must be a 1-dimensional array of strings!"),l(a.length===this.shape[0],"The new index must be the same length as the old index!"),l(v(a).length===1,"The new index must be a 1-dimensional array of strings!"),a.forEach(i=>{l(w(i),"All of the row names must be strings!")}),this._index=a}}),r){if(r instanceof n)this.name=r.name,this.values=j(r.values),this.index=j(r.index);else if(f(r)){let a=v(r);l(a.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let a=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(o=>o.toString());l(a.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=a[0],s=r[i];l(v(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=i,this.values=s.slice()}}}get shape(){return v(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!g(r)).length===0}clear(){let r=this.copy();return r.values.forEach((a,i)=>{r.values[i]=void 0}),r}get(r){return wr(this,r)}getSubsetByNames(r){return Tr(n,this,r)}getSubsetByIndices(r){return _r(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new n(q(this.values));return r.index=q(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=T(0,this.shape[0]).map(a=>"item"+Q(a,(r.index.length-1).toString().length)),r}copy(){let r=new n;return r._values=j(this.values),r._index=j(this.index),r.name=this.name,r}append(r){return fr(n,this,r)}apply(r){return dr(this,r)}concat(r){return this.append(r)}dropMissing(r,a){return pr(this,r,a)}dropNaN(){return br(n,this)}toObject(){return Ar(this)}print(){return jr(this)}shuffle(){return Ir(this)}sort(r){return Fr(n,this,r)}sortByIndex(){return Pr(n,this)}filter(r){return Nr(n,this,r)}toDataFrame(){let r=new e(C([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=q(r.values),r.index=q(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return n}var Le=Symbol.for("@jrc03c/js-math-tools/dataframe");function ie(e){let n="abcdefghijklmnopqrstuvwxyz1234567890",t="";for(let r=0;r<e;r++)t+=n[Math.floor(W()*n.length)];return t}var S=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Le}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Le}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!g(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(n){l(f(n),"The new values must be a 2-dimensional array!");let t=v(n);l(t.length===2,"The new array of values must be 2-dimensional!"),t[0]<this._index.length?this._index=this._index.slice(0,t[0]):t[0]>this._index.length&&(this._index=this._index.concat(T(this._index.length,t[0]).map(r=>"row"+Q(r,(t[0]-1).toString().length)))),t[1]<this._columns.length?this._columns=this._columns.slice(0,t[1]):t[1]>this._columns.length&&(this._columns=this._columns.concat(T(this._columns.length,t[1]).map(r=>"col"+Q(r,(t[1]-1).toString().length)))),this._values=n}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(n){l(f(n),"The new columns list must be a 1-dimensional array of strings!"),l(this.isEmpty||n.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),l(v(n).length===1,"The new columns list must be a 1-dimensional array of strings!"),n=n.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ie(8):r.trim()));let t=(()=>{let r=fe(n),a={};return r.values.forEach(i=>{a[i]=r.get(i)}),a})();n=n.map(r=>t[r]>1?r+"_"+ie(8):r),this._columns=n}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(n){l(f(n),"The new index must be a 1-dimensional array of strings!"),l(this.isEmpty||n.length===this.shape[0],"The new index must be the same length as the old index!"),l(v(n).length===1,"The new index must be a 1-dimensional array of strings!"),n=n.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ie(8):r.trim()));let t=(()=>{let r=fe(n),a={};return r.values.forEach(i=>{a[i]=r.get(i)}),a})();n=n.map(r=>t[r]>1?r+"_"+ie(8):r),this._index=n}}),l(g(e)||$(e)||f(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof S)this.values=j(e.values),this.columns=j(e.columns),this.index=j(e.index);else if(f(e)){let n=v(e);l(n.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),l(!re(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(i=>i.toString());let n=[],t=null,r=null;this._columns.forEach(i=>{g(r)&&(t=i,r=e[i].length),l(e[i].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${t}" points to an array containing ${r} items, and the key "${i}" points to an array containing ${e[i].length} items.`),r=e[i].length;let s=e[i];n.push(s)}),this._values=C(n);let a=v(this.values);this._index=T(0,a[0]).map(i=>"row"+Q(i,(a[0]-1).toString().length))}}get shape(){return v(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new S(B(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,n){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return At(this,e,n)}getSubsetByNames(e,n){return Ut(S,I,this,e,n)}getSubsetByIndices(e,n){return Yt(this,e,n)}getDummies(e){return Ge(S,this,e)}oneHotEncode(e){return Ge(S,this,e)}transpose(){let e=new S(C(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return Lt(this,e)}copy(){return St(S,this)}assign(e,n){return Ot(S,I,this,e,n)}apply(e,n){return Nt(S,I,this,e,n)}dropMissing(e,n,t){return It(S,I,this,e,n,t)}dropNaN(e,n,t){return Ft(S,this,e,n,t)}drop(e,n){return Dt(S,I,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return ir(this,e)}toObject(){return hr(this)}toJSONString(e){return fn(this,e)}saveAsJSON(e,n){return lr(this,e,n)}print(){return Kt(S,I,this)}sort(e,n){return rr(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Pt(S,I,this,e,n)}shuffle(e){return Xt(this,e)}append(e,n){return bt(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){return JSON.stringify(this)}},I=$r(S);function Jr(e,n){return F(e,{shouldDropNaNs:n}).max}var ve=Jr;function zr(e){return l(D(e),"You must pass a function into the `vectorize` function!"),function n(){let t,r,a=[],i=[],s=Object.keys(arguments).filter(o=>{let u=arguments[o];return f(u)?!0:y(u)?(t=!0,a.push(u),!0):b(u)?(r=!0,i.push(u),!0):!1}).map(o=>arguments[o]);if(s.slice(0,-1).forEach((o,u)=>{l(J(f(o)?v(o):o.shape,f(s[u+1])?v(s[u+1]):s[u+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let o=ve(s.map(h=>h.length?h.length:h.values.length)),u=T(0,o).map(h=>{let c=Object.keys(arguments).map(m=>f(arguments[m])?arguments[m][h]:y(arguments[m])||b(arguments[m])?arguments[m].values[h]:arguments[m]);return n(...c)});if(r)try{if(i.length===1&&J(v(i[0]),v(u))){let h=new S(u);return h.index=i[0].index.slice(),h.columns=i[0].columns.slice(),h}else return new S(u)}catch{return u}if(t)try{if(a.length===1&&a[0].length===u.length){let h=new I(u);return h.name=a[0].name,h.index=a[0].index.slice(),h}else return new I(u)}catch{return u}return u}else return e(...arguments)}}var O=zr;function Se(e){if(b(e)||y(e)){let n=e.copy();return n.values=Se(n.values),n}if(f(e))return e.map(n=>Se(n));try{let n=JSON.parse(e);return d(n)?typeof n=="bigint"?Number(n):n>=0?Math.floor(n):Math.ceil(n):NaN}catch{return NaN}}var E=O(Se);function de(e,n){function*t(r,a){if(a>r.length)yield r;else if(a<=0)yield[];else if(r.length<2)yield r;else for(let i=0;i<r.length;i++){let s=r[i],o=r.slice(i+1);if(!(o.length<a-1)&&a-1>=0)for(let u of de(o,a-1))yield[s].concat(u)}}return b(e)||y(e)?de(e.values,n):(l(f(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),l(d(n)&&E(n)===n&&n>=0,"`r` must be a non-negative integer!"),t(A(e),n))}function dn(e,n){let t=[];for(let r of de(e,n))t.push(r.slice());return t}function Rr(e){d(e)&&(e=[e]);let n=[],t=ye(e);for(let r=0;r<t;r++)n.push(0);return Ae(n,e)}var $e=Rr;function Je(e,n){function*t(r,a){if(a=a||r.length,r.length===1){yield[r];return}for(let i of dn(r,a)){if(!i.slice)continue;let s=$e(i.length);yield i;let o=1;for(;o<i.length;)if(s[o]<o){if(o%2===0){let u=i[0];i[0]=i[o],i[o]=u}else{let u=i[s[o]];i[s[o]]=i[o],i[o]=u}yield i,s[o]+=1,o=1}else s[o]=0,o+=1}}return b(e)||y(e)?Je(e.values,n):(l(f(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),g(n)&&(n=e.length),l(d(n)&&E(n)===n&&n>=0,"`r` must be a non-negative integer!"),t(A(e),n))}function Cr(e,n){let t=[];for(let r of Je(e,n))t.push(r.slice());return t}function Qe(e,n){l(D(e),"`fn` must be a function!");let t=new Date;return n?e(...n):e(),new Date-t}async function Yr(e,n){l(D(e),"`fn` must be a function!");let t=new Date;return n?await e(...n):await e(),new Date-t}function qr(e){try{return d(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var ze=O(qr);function Ur(){try{let e=0,n=!1,t=Object.values(arguments);for(let r of t){if(!d(r))return NaN;typeof r=="bigint"&&(n=!0,r=Number(r)),e+=r}if(n)try{return BigInt(e)}catch{}return e}catch{return NaN}}var ge=O(Ur);function Wr(e,n){try{return n(e)}catch{return NaN}}var Ne=O(Wr);function Kr(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var Gr=O(Kr);function Hr(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var Lr=O(Hr);function Qr(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var Vr=O(Qr);function Te(e,n){if(b(e)){let t=Te(e.values,n);return[e.index[t[0]],e.columns[t[1]]]}if(y(e)){let t=Te(e.values,n);return e.index[t]}l(f(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let t=pe(e,ve(e,n));return t?t.length===0?void 0:t.length===1?t[0]:t:void 0}catch{return}}var Xr=Te;function Zr(e,n){return F(e,{shouldDropNaNs:n}).min}var gn=Zr;function De(e,n){if(b(e)){let t=De(e.values,n);return[e.index[t[0]],e.columns[t[1]]]}if(y(e)){let t=De(e.values,n);return e.index[t]}l(f(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let t=pe(e,gn(e,n));return t?t.length===0?void 0:t.length===1?t[0]:t:void 0}catch{return}}var ea=De;function k(e,n){if(b(e)||y(e))return e.apply(t=>k(t,n));if(f(e))return e.map(t=>k(t,n));if(n==="null")return null;if(n==="number"){if(g(e))return NaN;let t=k(e,"boolean");if(K(t))return t?1:0;try{JSON.parse(e)}catch{let a=k(e,"date");if(R(a))return a.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(n==="int"){let t=k(e,"number");return t>=0?Math.floor(t):Math.ceil(t)}if(n==="float")return k(e,"number");if(n==="bigint")return typeof e=="bigint"?e:BigInt(k(e,"int"));if(n==="boolean"){if(K(e))return e;if(d(e))return e===0?!1:e===1?!0:null;try{let t=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return t==="true"||t==="yes"||t==="y"?!0:t==="false"||t==="no"||t==="n"?!1:null}catch{return null}}if(n==="date"){if(R(e))return e;if(g(e))return null;let t=parseFloat(e);if(!isNaN(t)){let a=new Date(e);return R(a)?a:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(n==="object"){if($(e))return e;let t=k(e,"boolean");if(K(t))return null;try{let a=k(e,"number");if(d(a))return JSON.parse(e),null}catch{}let r=k(e,"date");if(r)return r;try{let a=JSON.parse(e);return f(a)?a.map(i=>k(i,n)):a}catch{return null}}if(n==="string")return g(e)?J(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():(()=>typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString())()}var pn=k;function na(e){try{return d(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var ta=O(na);function ra(e,n){try{if(!d(e))return NaN;if(typeof e=="bigint")return e;if(g(n))n=1e-10;else if(!d(n))return NaN;return ze(e)<n?0:e}catch{return NaN}}var aa=O(ra);function yn(e,n,t){try{return d(e)?d(n)?d(t)?typeof e=="bigint"?BigInt(yn(E(e),n,t)):e<n?n:e>t?t:e:NaN:NaN:NaN}catch{return NaN}}var ia=O(yn);function sa(){let e=Object.values(arguments).map(n=>b(n)||y(n)?P(n.values):(l(f(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),P(n)));return P(e).filter(n=>e.every(t=>t.findIndex(r=>J(r,n))>-1))}var bn=sa,ee=class{constructor(e){l(g(e)||e===ee.DROP_NAN_MODE||e===ee.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=g(e)?ee.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(n=>{if(f(n)){let t=v(n);if(t.length===1)n=new I(n);else if(t.length===2)n=new S(n);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}l(b(n)||y(n),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===ee.DROP_MISSING_MODE?e.push(n.dropMissing().index):e.push(n.dropNaN().index)}),this.index=bn(...e),this}transform(){l(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(n=>{if(f(n)){let t=v(n);if(t.length===1)return new I(n).get(this.index).values;if(t.length===2)return new S(n).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return l(b(n)||y(n),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),n.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},je=ee;Ye(je,"DROP_NAN_MODE","DROP_NAN_MODE"),Ye(je,"DROP_MISSING_MODE","DROP_MISSING_MODE");var vn=je;function oe(e,n,t,r){if(y(e))return oe(e.values,n,t,r);if(y(n))return oe(e,n.values,t,r);if(l(f(e)&&f(n)&&v(e).length===1&&v(n).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),l(e.length===n.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),t)return oe(...new vn().fitAndTransform(e,n),!1,r);try{let a=F(e,{stdev:r}),i=F(n,{stdev:r}),s=Number(a.mean),o=Number(i.mean);if(!d(s)||!d(o))return NaN;let u=Math.max(e.length,n.length),h=0;for(let c=0;c<u;c++){let m=e[c],p=n[c];if(!d(m))return NaN;if(!d(p))return NaN;typeof m=="bigint"&&(m=Number(m)),typeof p=="bigint"&&(p=Number(p)),h+=(m-s)*(p-o)}return r?[h/e.length,a,i]:h/e.length}catch{return NaN}}var Nn=oe;function Me(e,n,t){if(y(e))return Me(e.values,n,t);if(y(n))return Me(e,n.values,t);l(f(e)&&f(n)&&v(e).length===1&&v(n).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),l(e.length===n.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[r,a,i]=Nn(e,n,t,!0),s=a.stdev*i.stdev;return r/s}catch{return NaN}}var oa=Me;function la(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var ua=O(la),ha=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Ie(e,n){if(b(e)||y(e))return Ie(e.values,n);if(b(n)||y(n))return Ie(e,n.values);l(f(e)&&f(n),"The `diff` function only works on arrays, Series, and DataFrames!");let t=P(e),r=P(n),a=[];return t.forEach(i=>{r.findIndex(s=>J(s,i))<0&&a.push(i)}),a}var ca=Ie;function xn(e,n){try{if(!d(e))return NaN;if(!d(n))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let t=xn(Number(e),Number(n));try{return BigInt(t)}catch{return t}}return Math.pow(e,n)}catch{return NaN}}var Re=O(xn);function wn(e){try{if(!d(e))return NaN;if(typeof e=="bigint"){let n=wn(Number(e));try{return BigInt(n)}catch{return n}}return Math.sqrt(e)}catch{return NaN}}var On=O(wn);function fa(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let n=!1,t=1;for(let r of e){if(!d(r))return NaN;typeof r=="bigint"&&(n=!0,r=Number(r)),t*=r}if(n)try{return BigInt(t)}catch{}return t}catch{return NaN}}var _n=O(fa);function ma(){return _n(...arguments)}var Z=ma;function da(e,n){return ge(e,Z(n,-1))}var Sn=da;function ga(e,n){return F(e,{shouldDropNaNs:n}).sum}var Ce=ga;function Ee(e,n){if(d(e)&&d(n))return ze(e-n);if(b(e)||y(e))return Ee(e.values,n);if(b(n)||y(n))return Ee(e,n.values);f(e)&&f(n)&&l(J(v(e),v(n)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return On(Ce(Re(Sn(e,n),2)))}catch{return NaN}}var pa=Ee;function ya(e,n){return Z(e,Re(n,-1))}var ba=ya;function Y(e,n){if(b(e)){let a=Y(e.values,n);if(v(a).length===1){let i=new I(a);return i.name=y(n)?n.name:i.name,i.index=e.index.slice(),i}else{let i=new S(a);return i.index=e.index.slice(),b(n)&&(i.columns=n.columns.slice()),i}}if(b(n)){let a=Y(e,n.values);if(v(a).length===1){let i=new I(a);return i.name=y(e)?e.name:i.name,i.index=n.columns.slice(),i}else{let i=new S(a);return i.columns=n.columns.slice(),i}}if(y(e))return Y(e.values,n);if(y(n))return Y(e,n.values);l(f(e)&&f(n),"The `dot` function only works on arrays, Series, and DataFrames!");let t=v(e),r=v(n);if(l(t.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),l(t[t.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${t[t.length-1]} !== ${r[0]})`),t.length===1&&r.length===1)return Ce(Z(e,n));if(t.length===1&&r.length===2)return C(n).map(a=>Y(e,a));if(t.length===2&&r.length===1)return e.map(a=>Y(a,n));if(t.length===2&&r.length===2){let a=C(n),i=[];for(let s=0;s<e.length;s++){let o=[];for(let u=0;u<a.length;u++)o.push(Y(e[s],a[u]));i.push(o)}return i}}var Tn=Y;function Dn(e){if(b(e)||y(e))return e.dropMissing(...Object.values(arguments).slice(1));l(f(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let n=[];return e.forEach(t=>{try{return n.push(Dn(t))}catch{g(t)||n.push(t)}}),n}var jn=Dn;function le(e,n){if(b(e)||y(e))return le(e.values,n);if(b(n)||y(n))return le(e,n.values);l(f(e)&&f(n),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),l(J(v(e),v(n)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let t=[],r=[];for(let a=0;a<e.length;a++)try{let[i,s]=le(e[a],n[a]);t.push(i),r.push(s)}catch{!g(e[a])&&!g(n[a])&&(t.push(e[a]),r.push(n[a]))}return[t,r]}var va=le;function ue(e,n){if(b(e)||y(e))return ue(e.values,n);if(b(n)||y(n))return ue(e,n.values);l(f(e)&&f(n),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),l(J(v(e),v(n)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let t=[],r=[];for(let a=0;a<e.length;a++)try{let[i,s]=ue(e[a],n[a]);t.push(i),r.push(s)}catch{d(e[a])&&d(n[a])&&(t.push(e[a]),r.push(n[a]))}return[t,r]}var Na=ue;function xa(e){return jn(e)}var wa=xa;function Fe(e,n){if(b(e)||y(e))return Fe(e.values,n);l(f(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),l(D(n),"The second argument passed into the `every` function must be a function!");for(let t of e)if(f(t)){if(!Fe(t,n))return!1}else if(!n(t))return!1;return!0}var Mn=Fe;function Oa(e){try{if(!d(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var _a=O(Oa);function ke(e){try{return typeof e=="bigint"?BigInt(ke(E(e))):e!==E(e)?NaN:e<=1?1:e*ke(e-1)}catch{return NaN}}var Sa=O(ke);function In(e,n){if(b(e)||y(e))return In(e.values,n);if(l($(e)||f(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!D(n)){let a=n;n=i=>i===a}function t(a,i,s){if(s=s||[],s.indexOf(a)>-1)return null;if($(a)){s.push(a);let o=Object.keys(a).concat(Object.getOwnPropertySymbols(a));for(let u=0;u<o.length;u++){let h=o[u],c=a[h];if(i(c))return c;let m=t(c,i,s);if(m)return m}}else if(f(a)){s.push(a);for(let o=0;o<a.length;o++){let u=a[o];if(i(u))return u;let h=t(u,i,s);if(h)return h}}else if(i(a))return a;return null}function r(a){try{return n(a)}catch{return!1}}return t(e,r)}var Ta=In;function En(e,n){if(b(e)||y(e))return En(e.values,n);if(l($(e)||f(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!D(n)){let i=n;n=s=>s===i}function t(i,s,o){if(o=o||[],o.indexOf(i)>-1)return null;if($(i)){o.push(i);let u=Object.keys(i).concat(Object.getOwnPropertySymbols(i)),h=[];for(let c=0;c<u.length;c++){let m=u[c],p=i[m],x=!1;s(p)&&(h.push(p),x=!0);let N=t(p,s,o);N&&N.length>0&&N.slice(x?1:0).forEach(z=>h.push(z))}return h}else if(f(i)){o.push(i);let u=[];for(let h=0;h<i.length;h++){let c=i[h],m=!1;s(c)&&(u.push(c),m=!0);let p=t(c,s,o);p&&p.length>0&&p.slice(m?1:0).forEach(x=>u.push(x))}return u}else if(s(i))return[i];return null}function r(i){try{return n(i)}catch{return!1}}let a=t(e,r);return a&&a.length>0?a:null}var Da=En;function ja(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let n=JSON.parse(e);return d(n)?n:NaN}catch{return NaN}}var Ma=O(ja);function Ia(e){try{return d(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var Ea=O(Ia);function Fa(e){typeof e=="bigint"&&(e=E(e)),l(!g(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),l(d(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),l(E(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),l(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let n=$e([e,e]);for(let t=0;t<e;t++)n[t][t]=1;return n}var ka=Fa,Pa=["true","false","yes","no"],Ba=["null","none","nan","na","n/a","","undefined"];function se(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=E(e.value)===e.value:e.isInteger=Mn(e.values,n=>d(n)?E(n)===n:!0)),e}function he(e){if(b(e)){let a=e.copy(),i=he(e.values);return a.values=i.values,se({type:i.type,values:a})}if(y(e)){let a=e.copy(),i=he(e.values);return a.values=i.values,se({type:i.type,values:a})}if(!f(e)){let a=he([e]);return a.value=a.values[0],delete a.values,se(a)}l(f(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let n=A(e).map(a=>{if(a===void 0)return"null";try{if(typeof a=="object"){let s=new Date(a.getTime());if(R(s))return"date"}}catch{}w(a)||(typeof a=="bigint"?a=a.toString()+"n":a=JSON.stringify(a));let i=a.toLowerCase().trim();if(Ba.indexOf(i)>-1)return"null";if(Pa.indexOf(i)>-1)return"boolean";try{if(a.match(/^-?\d+n$/g))return"bigint";let s=JSON.parse(a);return d(s)?"number":typeof s=="object"?f(s)?"string":"object":"string"}catch{let s=new Date(a);return R(s)?"date":"string"}}),t=fe(n),r=t.values.toSorted((a,i)=>t.get(i)-t.get(a))[0];return se({type:r,values:Ne(e,a=>pn(a,r))})}var Aa=he;function ce(e){if(b(e)){let t=e.copy();return t.values=ce(t.values),t}l(f(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let n=v(e);if(l(n.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),l(n[0]===n[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),l(n[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),n[0]===0)return e;if(n[0]===1){l(e[0][0]!==0,"This matrix cannot be inverted!");let t=e[0][0];return typeof t=="bigint"&&(t=Number(t)),1/t}else if(n[0]===2){let t=e[0][0],r=e[0][1],a=e[1][0],i=e[1][1];typeof t=="bigint"&&(t=Number(t)),typeof r=="bigint"&&(r=Number(r)),typeof a=="bigint"&&(a=Number(a)),typeof i=="bigint"&&(i=Number(i));let s=t*i-r*a;l(s!==0,"This matrix cannot be inverted!");let o=[[i,-r],[-a,t]];return Z(o,1/s)}else if(n[0]>1){let t=(r,a)=>d(r)||d(a)?Z(r,a):Tn(r,a);for(let r=1;r<n[0]-1;r++)try{let a=e.slice(0,r).map(N=>N.slice(0,r)),i=e.slice(0,r).map(N=>N.slice(r,n[0])),s=e.slice(r,n[0]).map(N=>N.slice(0,r)),o=e.slice(r,n[0]).map(N=>N.slice(r,n[0])),u=ce(a),h=ce(ge(o,t(-1,t(t(s,u),i)))),c=ge(u,t(t(t(t(u,i),h),s),u)),m=t(-1,t(t(u,i),h)),p=t(-1,t(t(h,s),u)),x=h;return c.map((N,z)=>N.concat(m[z])).concat(p.map((N,z)=>N.concat(x[z])))}catch{}l(!1,"This matrix cannot be inverted!")}}var $a=ce,Ja=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `),za=Ja;function Fn(e,n,t){try{if(!d(e))return NaN;if(!d(n))return NaN;if(!d(t))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let r=Fn(Number(e),Number(n),t);try{return BigInt(r)}catch{return r}}return t*(n-e)+e}catch{return NaN}}var Ra=O(Fn);function kn(e,n){try{if(n=g(n)?Math.E:n,!d(e))return NaN;if(!d(n))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let t=kn(Number(e),Number(n));try{return BigInt(t)}catch{return t}}return Math.log(e)/Math.log(n)}catch{return NaN}}var Ca=O(kn);function Ya(e,n){return F(e,{shouldDropNaNs:n}).mean}var qa=Ya;function Ua(e,n){return F(e,{shouldDropNaNs:n,median:!0}).median}var Wa=Ua;function Pn(e,n){try{if(!d(e))return NaN;if(!d(n))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let t=Pn(Number(e),Number(n));try{return BigInt(t)}catch{return t}}return e%n}catch{return NaN}}var Ka=O(Pn);function Ga(e,n){return F(e,{shouldDropNaNs:n,mode:!0}).mode}var Ha=Ga;function Ve(){let e=W(),n=W();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*n)}function La(e){return g(e)?Ve():Ne(B(e),Ve)}var Qa=La;function Va(e){return Ne(B(e),()=>1)}var Xa=Va;function Za(){Object.keys(arguments).forEach(e=>{let n=arguments[e];if(f(n))if(re(n))console.log(n);else{let t=v(n);t.length===1?new I(n).print():t.length==2?new S(n).print():console.log(n)}else b(n)||y(n)?n.print():console.log(n)})}var ei=Za,ni=O((e,n,t,r,a)=>{try{let i=!1;for(let h of[e,n,t,r,a]){if(!d(h))return NaN;typeof h=="bigint"&&(i=!0)}i&&(e=Number(e),n=Number(n),t=Number(t),r=Number(r),a=Number(a));let s=(a-r)*(e-n),o=t-n;if(o===0)return NaN;let u=s/o+r;if(i)try{return BigInt(u)}catch{}return u}catch{return NaN}});function ti(e,n,t,r,a){if(f(e)&&g(r)&&g(a)){r=n,a=t;let i=F(e);n=i.min,t=i.max}return ni(e,n,t,r,a)}var ri=ti;function ai(e){try{return d(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var ii=O(ai);function Bn(e){try{return d(e)?typeof e=="bigint"?BigInt(Bn(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var si=O(Bn);function oi(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var li=O(oi);function Pe(e,n){if(b(e)||y(e))return Pe(e.values,n);l(f(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),l(D(n),"The second argument passed into the `some` function must be a function!");for(let t of e)if(f(t)){if(Pe(t,n))return!0}else if(n(t))return!0;return!1}var ui=Pe;function hi(e,n){return F(e,{shouldDropNaNs:n,stdev:!0}).stdev}var An=hi;function ci(e){return An(e)}var fi=ci;function mi(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var di=O(mi);function gi(){return P([...arguments].map(e=>f(e)?e:b(e)||y(e)?e.values:[e]))}var pi=gi;function yi(e,n){return F(e,{shouldDropNaNs:n,variance:!0}).variance}var bi=yi;function vi(){let e=[],n=Object.values(arguments).map(t=>((b(t)||y(t))&&(t=t.values),l(f(t),"The `zip` function only works on arrays, Series, and DataFrames!"),t));return T(0,ve(n.map(t=>t.length))).forEach(t=>{let r=[];n.forEach(a=>{let i=a[t];r.push(g(i)?void 0:i)}),e.push(r)}),e}var Ni=vi,ne={abs:ze,add:ge,apply:Ne,arccos:Gr,arcsin:Lr,arctan:Vr,argmax:Xr,argmin:ea,assert:l,cast:pn,ceil:ta,chop:aa,clamp:ia,combinations:dn,combinationsIterator:de,copy:j,correl:oa,cos:ua,count:fe,covariance:Nn,DataFrame:S,dataTypes:ha,decycle:V,diff:ca,distance:pa,divide:ba,dot:Tn,dropMissing:jn,dropMissingPairwise:va,dropNaN:cn,dropNaNPairwise:Na,dropUndefined:wa,every:Mn,exp:_a,factorial:Sa,find:Ta,findAll:Da,flatten:A,float:Ma,floor:Ea,identity:ka,IndexMatcher:vn,indexOf:pe,inferType:Aa,int:E,intersect:bn,inverse:$a,isArray:f,isBoolean:K,isBrowser:za,isDataFrame:b,isDate:R,isEqual:J,isFunction:D,isJagged:re,isNested:Be,isNumber:d,isObject:$,isSeries:y,isString:w,isUndefined:g,lerp:Ra,log:Ca,MathError:U,max:ve,mean:qa,median:Wa,min:gn,mod:Ka,mode:Ha,multiply:_n,ndarray:B,normal:Qa,ones:Xa,permutations:Cr,permutationsIterator:Je,pow:Re,print:ei,product:ye,random:W,range:T,remap:ri,reshape:Ae,reverse:q,round:ii,scale:Z,seed:be,Series:I,set:P,shape:v,shuffle:me,sign:si,sin:li,some:ui,sort:G,sqrt:On,stats:F,std:An,stdev:fi,subtract:Sn,sum:Ce,tan:di,timeAsync:Yr,timeSync:Qe,time:Qe,transpose:C,union:pi,variance:bi,vectorize:O,zeros:$e,zip:Ni,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new ne.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(ne).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:ne[n]})}catch{e[n]=ne[n]}})}};typeof window<"u"&&(window.JSMathTools=ne);function $n(e,n,t){arguments.length===2&&(d(arguments[1])?t=null:(t=n,n=null)),l(d(e)&&E(e)===e,"`keyLength` must be an integer!"),n&&(l(d(n)&&E(n)===n,"`keySeed` must be an integer!"),be(n)),t&&l(w(t),"`charset` must be a string!");let r="";t=t||"abcdefg1234567890";for(let a=0;a<e;a++)r+=t[E(W()*t.length)];return r}typeof window<"u"&&(window.makeKey=$n);var Di=$n;export{Di as default};
