var Kn=Object.create;var Ue=Object.defineProperty;var Wn=Object.getOwnPropertyDescriptor;var Gn=Object.getOwnPropertyNames;var Hn=Object.getPrototypeOf,Ln=Object.prototype.hasOwnProperty;var Qn=(e,n)=>()=>(n||e((n={exports:{}}).exports,n),n.exports);var Vn=(e,n,t,r)=>{if(n&&typeof n=="object"||typeof n=="function")for(let a of Gn(n))!Ln.call(e,a)&&a!==t&&Ue(e,a,{get:()=>n[a],enumerable:!(r=Wn(n,a))||r.enumerable});return e};var Xn=(e,n,t)=>(t=e!=null?Kn(Hn(e)):{},Vn(n||!e||!e.__esModule?Ue(t,"default",{value:e,enumerable:!0}):t,e));var qn=Qn((Ui,qe)=>{function Yn(e){return new Promise((n,t)=>{try{return setTimeout(()=>n(),e)}catch(r){return t(r)}})}typeof qe<"u"&&(qe.exports=Yn);typeof window<"u"&&(window.pause=Yn)});var Zn=Object.defineProperty,et=(e,n,t)=>n in e?Zn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,Ke=(e,n,t)=>(et(e,typeof n!="symbol"?n+"":n,t),t),nt=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),tt=class extends Error{constructor(e){nt()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}},U=tt;function u(e,n){if(!e)throw new U(n)}function rt(e){return e===null||typeof e>"u"}var g=rt,nn=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray],at=nn.map(e=>e.name);function it(e){try{return e instanceof Array?!0:g(e.constructor)?!1:nn.indexOf(e.constructor)>-1||at.indexOf(e.constructor.name)>-1}catch{return!1}}var f=it;function st(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}var b=st;function ot(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}var y=ot;function tn(e){if(b(e)||y(e))return tn(e.values);u(f(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function n(t){let r=[];return t.forEach(a=>{f(a)?r=r.concat(n(a)):r.push(a)}),r}return n(e)}var A=tn;function ut(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var d=ut;function lt(e){return typeof e=="function"}var D=lt;function ht(e){return typeof e=="object"&&!g(e)&&!f(e)}var J=ht;function we(e,n){if(b(e)){let i=we(e.values,n);return i.length>0&&d(i[0])&&i[0]>=0&&i[0]<e.index.length&&(i[0]=e.index[i[0]]),i.length>1&&d(i[1])&&i[1]>=0&&i[1]<e.columns.length&&(i[1]=e.columns[i[1]]),i}if(y(e)){let i=we(e.values,n);return i.length>0&&d(i[0])&&i[0]>=0&&i[0]<e.index.length&&(i[0]=e.index[i[0]]),i}if(u(J(e)||f(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!D(n)){let i=n;n=s=>s===i}function t(i,s,o){if(o=o||[],o.indexOf(i)>-1)return null;if(J(i)){o.push(i);let l=Object.keys(i).concat(Object.getOwnPropertySymbols(i));for(let h=0;h<l.length;h++){let c=l[h],m=i[c];if(s(m))return[c];let p=t(m,s,o);if(p&&p.length>0)return[c].concat(p)}}else if(f(i)){o.push(i);for(let l=0;l<i.length;l++){let h=i[l];if(s(h))return[l];let c=t(h,s,o);if(c&&c.length>0)return[l].concat(c)}}else if(s(i))return[];return null}function r(i){try{return n(i)}catch{return!1}}let a=t(e,r);return a&&a.length>0?a:null}var pe=we;function j(e){function n(t){if(typeof t=="object"){if(t===null)return null;if(f(t))return t instanceof Array?t.map(a=>j(a)):t.slice();if(y(t)){let a=t.copy();return a.values=j(a.values),a}if(b(t)){let a=t.copy();return a.values=j(t.values),a}if(t instanceof Date)return new Date(t.getTime());t=V(t);let r={};return Object.keys(t).concat(Object.getOwnPropertySymbols(t)).forEach(a=>{r[a]=j(t[a])}),r}else return t}return n(V(e))}function V(e){function n(a,i,s){if(i=i||[],s=s||"",i.indexOf(a)>-1){let o=s.split("/").slice(s.startsWith("/")?1:0);if(o.some((l,h)=>{let c=o.slice(0,o.length-h-1),m=t;return c.forEach(p=>{m=m[p]}),m===a}))return`<reference to "${t===a?"/":"/"+pe(t,a).join("/")}">`}return typeof a=="object"?a===null?null:(i.push(a),f(a)?typeof a.constructor<"u"&&a.constructor.name!=="Array"?a.slice():a.map((o,l)=>n(o,i,s+"/"+l)):(Object.keys(a).concat(Object.getOwnPropertySymbols(a)).forEach(o=>{a[o]=n(a[o],i,s+"/"+o.toString())}),a)):a}let t=e,r=n(t);if(b(e)){let a=e.copy();a._values=r.values,a._columns=r.columns,a._index=r.index,r=a}if(y(e)){let a=e.copy();a.name=r.name,a._values=r.values,a._index=r.index,r=a}return r}function rn(e){if(b(e)||y(e))return rn(e.values);u(f(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let n=0;n<e.length;n++)if(f(e[n]))return!0;return!1}var Ae=rn,H="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function an(e){u(!g(e),H),f(e)||(e=[e]),u(!Ae(e),H),u(e.length>0,H);let n=e[0];if(typeof n=="bigint"&&(n=Number(n)),u(d(n),H),u(n>=0,H),u(Math.floor(n)===n,H),u(n!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let t=[];for(let r=0;r<n;r++)t.push(void 0);return t}else{let t=[];for(let r=0;r<n;r++)t.push(an(e.slice(1)));return t}}var B=an;function sn(e,n){if(b(e)||y(e))return sn(e.values,n);u(f(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let t=A(e),r=!1,a=1;for(let i of t){if(!d(i))if(n)i=1;else return NaN;typeof i=="bigint"&&(r=!0,i=Number(i)),a*=i}if(r)try{return BigInt(a)}catch{}return a}catch{return NaN}}var ye=sn;function ct(e){return d(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}var on=ct;function ft(e){return on(e)&&e>0}var mt=ft;function un(e){if(f(e)){let n=un(e[0]);return[e.length].concat(n||[])}else return}function ln(e){return b(e)||y(e)?ln(e.values):(u(f(e),"The `shape` function only works on arrays, Series, and DataFrames!"),un(e))}var v=ln;function Oe(e,n){if(b(e)||y(e))return Oe(e.values,n);if(u(f(e),"The first argument passed into the `reshape` function must be an array!"),d(n)&&(n=[n]),u(f(n),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),u(v(n).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),n=n.map(i=>(typeof i=="bigint"&&(i=Number(i)),u(mt(i),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(i))),n.length===0)return A(e);let t=A(e);if(n.length===1&&n[0]===t.length)return t;u(ye(n)===t.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],a=Math.floor(t.length/n[0]);for(let i=0;i<n[0];i++){let s=t.slice(i*a,(i+1)*a);r.push(Oe(s,n.slice(1)))}return r}var Je=Oe,hn=Math.pow(2,64),_=[];be(Math.floor(Math.random()*hn));function dt(e,n){e=M(e);function t(){e+=M("0x9e3779b97f4a7c15");let a=j(e);return a=(a^a>>BigInt(30))*M("0xbf58476d1ce4e5b9"),a=(a^a>>BigInt(27))*M("0x94d049bb133111eb"),a^a>>BigInt(31)}let r=[];for(let a=0;a<n;a++)r.push(t());return r}function M(e){return BigInt.asUintN(64,BigInt(e))}function We(e,n){return e=M(e),n=BigInt(n),M(M(e<<n)|M(e>>M(BigInt(64)-n)))}function be(e){if(typeof e=="bigint"&&(e=Number(e)),g(e))return j(_);{u(d(e),"If passing a value into the `seed` function, then that value must be an integer!");let n=dt(Math.floor(e),4);_[0]=n[0],_[1]=n[1],_[2]=n[2],_[3]=n[3]}}function Ge(){let e=M(We(_[0]+_[3],23)+_[0]),n=M(_[1]<<BigInt(17));return _[2]=M(_[2]^_[0]),_[3]=M(_[3]^_[1]),_[1]=M(_[1]^_[2]),_[0]=M(_[0]^_[3]),_[2]=M(_[2]^n),_[3]=We(_[3],45),Math.floor(Number(e))/hn}function K(e){return g(e)?Ge():(f(e)||(e=[e]),Je(B(ye(e)).map(Ge),e))}function gt(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var R=gt,He=["number","int","float","bigint"];function pt(e,n){function t(r,a){let i=typeof r,s=typeof a;if(i!==s&&!He.includes(i)&&!He.includes(s))return!1;if(i==="undefined"&&s==="undefined")return!0;if(i==="boolean"||i==="symbol")return r===a;if(i==="number"||i==="bigint")try{let o=r.toString(),l=a.toString();return o===l}catch{return!1}if(i==="string"||i==="function")return r===a;if(i==="object"){if(r===null||a===null)return r===null&&a===null;{if(R(r))return R(a)?r.getTime()===a.getTime():!1;if(R(a))return!1;if(r instanceof RegExp&&a instanceof RegExp)return r.toString()===a.toString();if(f(r)!==f(a))return!1;let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),l=Object.keys(a).concat(Object.getOwnPropertySymbols(a));if(o.length!==l.length)return!1;for(let h=0;h<o.length;h++){let c=o[h];if(!t(r[c],a[c]))return!1}return!0}}}try{return t(e,n)}catch{return t(V(e),V(n))}}var $=pt;function te(e){let n="abcdefg1234567890",t="";for(;t.length<e;)t+=n[Math.floor(Math.random()*n.length)];return t}var yt=te(16),bt=te(16),vt=te(16),Nt=te(16),xt=te(16),wt=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let n of e)f(n)?this.count(n):this.increment(n);return this}delete(e){let n=this.getStandardizedKey(e);return delete this.countsDict[n],delete this.valuesDict[n],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?yt:g(e)?bt:D(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+xt:e===1/0?vt:e===-1/0?Nt:typeof e=="bigint"?e.toString():b(e)?e.toJSONString():y(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!g(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,n){let t=this.getStandardizedKey(e);return this.countsDict[t]=n,this.valuesDict[t]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(n=>{e[n]=this.get(n)}),e}},Ot=wt;function _t(e,n){n=n||{};let t=new Ot,r={},a=A(e),i=[],s=-1/0,o=1/0,l=!1,h=0;for(let m of a){if(typeof m=="bigint"&&(l=!0),!n.shouldDropNaNs||d(m))try{m>s&&(s=m),m<o&&(o=m),h+=Number(m),i.push(m)}catch{s=NaN,o=NaN,h=NaN}t.increment(m)}let c=h/i.length;if(r.counts=t,r.max=s,r.mean=c,r.min=o,r.n=a.length,r.sum=h,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),n.shouldDropNaNs&&(r.nWithoutNaNs=i.length),n.mode){let m=Array.from(t.values.map(N=>[N,t.get(N)])).toSorted((N,z)=>z[1]-N[1]),p=m[0][1],x=[];for(let N of m)if(N[1]==p)x.push(N[0]);else break;r.mode=x.toSorted()}if(n.median)if(isNaN(c))r.median=NaN;else{let m=i.toSorted((x,N)=>Number(x)-Number(N)),p=Math.floor(m.length/2);if(m.length%2===0){let x=m[p-1],N=m[p];if(r.median=(Number(x)+Number(N))/2,l&&typeof x=="bigint"&&typeof N=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=m[p]}if(n.stdev||n.variance){let m=0;for(let x of i)m+=Math.pow(Number(x)-c,2);m/=i.length;let p=Math.sqrt(m);r.stdev=p,r.variance=m}if(l){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}n.mode&&(r.mode=r.mode.map(m=>{try{return BigInt(m)}catch{return m}}))}return r}var k=_t;function St(e,n){let{counts:t}=k(e);return g(n)||(D(n)?t.values.forEach(r=>{n(r)||t.delete(r)}):t.values.forEach(r=>{$(r,n)||t.delete(r)})),t}var fe=St;function _e(e){if(b(e)||y(e))return _e(e.values);if(f(e)){let n=!1,t=!1,r=null;for(let a of e){if(_e(a))return!0;if(f(a)){if(r===null)r=a.length;else if(a.length!==r)return!0;n=!0}else t=!0;if(n&&t)return!0}}return!1}function Tt(e){return _e(V(e))}var re=Tt;function Se(e){if(b(e)||y(e)){let t=e.copy();return t.values=Se(t.values),t.index=Se(t.index),t}u(f(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let n=[];for(let t=e.length-1;t>=0;t--)n.push(e[t]);return n}var q=Se;function Dt(e,n,t=1){u(!g(e)&&!g(n)&&!g(t),"You must pass two numbers and optionally a step value to the `range` function!"),u(d(e)&&d(n)&&d(t),"You must pass two numbers and optionally a step value to the `range` function!"),u(t>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,a=typeof e=="bigint"||typeof n=="bigint"||typeof t=="bigint";if(e=Number(e),n=Number(n),t=Number(t),e>n){r=!0;let s=e;e=n+t,n=s+t}let i=[];for(let s=e;s<n;s+=t)if(a)try{i.push(BigInt(s))}catch{i.push(s)}else i.push(s);return r&&(i=q(i)),i}var T=Dt;function ae(e){let n="abcdefg1234567890",t="";for(;t.length<e;)t+=n[Math.floor(Math.random()*n.length)];return t}var jt=ae(256),Mt=ae(256),It=ae(256),Et=ae(256),kt=ae(256);function cn(e){if(b(e)||y(e))return cn(e.values);u(f(e),"The `set` function only works on arrays, Series, and DataFrames!");let n=[],t={};return A(e).forEach(r=>{let a=typeof r=="object"&&r===null?jt:g(r)?Mt:D(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+kt:r===1/0?It:r===-1/0?Et:typeof r=="bigint"?r.toString():b(r)?r.toJSONString():y(r)?JSON.stringify(r.toObject()):JSON.stringify(r);t[a]||n.push(r),t[a]=!0}),n}var P=cn;function fn(e,n,t){if(g(t)&&(t=0),u(t===0||t===1||t==="vertical"||t==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),f(n)){u(!re(n),"The array of data you're trying to append to this DataFrame is jagged!");let r=v(n);if(r.length===1)if(t===0){let a=e.copy();a._values.push(n);let i=Math.max(e.shape[1],r[0]);for(a._values.forEach(s=>{for(;s.length<i;)s.push(void 0)});a._index.length<a._values.length;)a._index.push("row"+a._index.length);for(;a._columns.length<i;)a._columns.push("col"+a._columns.length);return a}else{let a=Math.max(e.shape[0],r[0]),i=e.copy();for(T(0,a).forEach(s=>{s>=i._values.length&&i._values.push(B(e.shape[1])),i._values[s].push(n[s])});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<i._values[0].length;)i._columns.push("col"+i._columns.length);return i}else if(r.length===2)if(t===0){let a=Math.max(...n.map(s=>s.length).concat([e.shape[1]])),i=e.copy();for(i._values=i._values.concat(n).map(s=>{for(;s.length<a;)s.push(void 0);return s});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<a;)i._columns.push("col"+i._columns.length);return i}else{let a=Math.max(...n.map(o=>o.length))+e.shape[1],i=Math.max(e.shape[0],r[0]),s=e.copy();for(T(0,i).forEach(o=>{for(o>=s._values.length&&s._values.push(B(e.shape[1])),s._values[o]=s._values[o].concat(n[o]);s._values[o].length<a;)s._values[o].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<a;)s._columns.push("col"+s._columns.length);return s}else throw new U("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(y(n)){let r=fn(e,n.values,t);return t===0?r.index[r.index.length-1]=r.index.indexOf(n.name)>-1?n.name+" (2)":n.name:r.columns[r.columns.length-1]=r.columns.indexOf(n.name)>-1?n.name+" (2)":n.name,r}else if(b(n))if(t===0){let r=e.copy(),a=P(r._columns.concat(n._columns)).length;for(r._values.forEach(i=>{for(;i.length<a;)i.push(void 0)}),n.apply(i=>{let s=i.copy(),o=[];r._columns.forEach(l=>{let h=s._index.indexOf(l);h>-1?(o.push(s._values[h]),s._values.splice(h,1),s._index.splice(h,1)):o.push(void 0)}),r._values.push(o.concat(s._values))},1),r._columns=r._columns.concat(n._columns.filter(i=>r._columns.indexOf(i)<0));r._index.length<r._values.length;){let i="row"+r._index.length;r._index.push(i+(e._index.indexOf(i)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((a,i)=>{let s=n._index.indexOf(a);s>-1?r._values[i]=r._values[i].concat(n._values[s]):r._values[i]=r._values[i].concat(B(n.shape[1]))}),n._index.forEach((a,i)=>{r._index.indexOf(a)<0&&(r._index.push(a),r._values.push(B(r._columns.length).concat(n._values[i])))}),r._columns=r._columns.concat(n._columns.map(a=>a+(r._columns.indexOf(a)>-1?" (2)":""))),r}else throw new U("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}var Ft=fn;function Pt(e,n,t,r,a){if(a=a||0,u(D(r),"The first parameter to the `apply` method must be a function."),u(a===0||a===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),a===0){let i={},s;if(t.columns.forEach((o,l)=>{let h=new n(t.values.map(m=>m[l]));h.name=o,h.index=t.index;let c=r(h,l,t);c instanceof n?i[o]=c.values:i[o]=c,g(s)&&(s=c instanceof n||f(c))}),s){let o=new e(i);return o.index=t.index,o}else{let o=new n(t.columns.map(l=>i[l]));return o.index=t.columns,o}}else if(a===1){let i,s=t.values.map((o,l)=>{let h=new n(o);h.name=t.index[l],h.index=t.columns;let c=r(h,l,t);return g(i)&&(i=c instanceof n||f(c)),c instanceof n?c.values:c});if(i){let o=new e(s);return o.index=t.index,o.columns=t.columns,o}else{let o=new n(s);return o.index=t.index,o}}}var Bt=Pt;function At(e){return typeof e=="string"}var w=At;function Jt(e,n,t,r,a){let i=o=>o instanceof e,s=o=>o instanceof n;if(g(a)){if(i(r)||s(r))return t.append(r,1);if(J(r)){let o=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(l=>r[l].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(l=>{for(;r[l].length<o;)r[l].push(void 0)}),t.append(new e(r),1)}else throw new U("You must pass a DataFrame, Series, or object into the `assign` method!")}else{u(w(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),u(f(a)&&!re(a)&&v(a).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let o=t.append(a,1);return o.columns[o.columns.length-1]=r,o}}var $t=Jt;function zt(e,n){if(n.isEmpty)return new e;let t=new e(j(n.values));return t.columns=n.columns.slice(),t.index=n.index.slice(),t}var Rt=zt;function Ct(e,n,t,r,a){g(r)&&(r=[]),g(a)&&(a=[]),(w(r)||d(r))&&(r=[r]),(w(a)||d(a))&&(a=[a]),u(f(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),u(f(a),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),u(v(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),u(v(a).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let i,s;t.index.forEach((l,h)=>{r.indexOf(l)<0&&r.indexOf(h)<0&&(i||(i=[]),i.push(l))}),t.columns.forEach((l,h)=>{a.indexOf(l)<0&&a.indexOf(h)<0&&(s||(s=[]),s.push(l))});let o=t.get(i,s);if(o instanceof n){let l=new e;l=l.assign(o),t.index.indexOf(o.name)>-1&&(l=l.transpose()),o=l}return o}var Yt=Ct;function qt(e){return on(e)&&e>=0}var X=qt;function Ut(e,n,t,r,a,i){r=r||0,u(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),i=i||0,u(X(i),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),a=i>0?"none":a||"any",u(a==="any"||a==="all"||a==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(h){if(i>0){let c=0;for(let m=0;m<h.length;m++){let p=h[m];if(g(p)&&c++,c>=i)return[]}}else if(a==="any")for(let c=0;c<h.length;c++){let m=h[c];if(g(m))return[]}else if(a==="all"){for(let c=0;c<h.length;c++){let m=h[c];if(!g(m))return h}return[]}return h}let o=t.copy(),l=Math.random().toString();if(r===0){o=o.assign(l,o.index);let h=o.values.map(s).filter(m=>m.length>0);if(v(h).length<2)return new e;o.values=h;let c=o.get(null,l);if(g(c))return new e;w(c)&&(c=[c]),c instanceof n&&(c=c.values),o.index=c,o=o.drop(null,l)}else if(r===1){let h={};if(o.columns.forEach((m,p)=>{let x=o.values.map(z=>z[p]),N=s(x);N.length>0&&(h[m]=N)}),Object.keys(h).length+Object.getOwnPropertySymbols(h).length===0)return new e;let c=new e(h);return c.index=o.index,c}return o}var Kt=Ut;function mn(e){if(b(e)||y(e))return e.dropNaN(...Object.values(arguments).slice(1));u(f(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let n=[];return e.forEach(t=>{try{return n.push(mn(t))}catch{if(d(t))return n.push(t)}}),n}var dn=mn;function Wt(e,n,t,r,a){t=t||0,u(t===0||t===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),a=a||0,u(X(a),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=a>0?"none":r||"any",u(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function i(o){let l=dn(o);return a>0?o.length-l.length<a:r==="any"?l.length===o.length:r==="all"?l.length>0:!0}let s=n.copy();if(t===0){let o=s.index.filter(l=>{let h=s.get(l,null).values;return i(h)});return o.length>0?s.get(o,null):new e}else if(t===1){let o=s.columns.filter(l=>{let h=s.get(null,l).values;return i(h)});return o.length>0?s.get(null,o):new e}return s}var Gt=Wt;function Le(e){let n={};return A(e).forEach((t,r)=>{n[t]=r}),n}function L(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((n,t)=>e[n]-e[t])}function Ht(e,n,t,r,a){u(D(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),g(a)&&(a=0),u(a===0||a===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let i=t.copy();if(i.isEmpty)return i;let s=Le(i.index),o=Le(i.columns);if(a===0){let l=0,h=i.values.filter((c,m)=>{let p=new n(c);p.name=t.index[m],p.index=t.columns;let x=r(p,m,t);return x?l++:delete s[i.index[m]],x});if(l===0)return new e;if(l===1){let c=new n(h[0]);return c.name=L(s)[0],c.index=L(o),c}i.values=h,i.index=L(s)}else if(a===1){i=i.transpose();let l=0,h=i.values.filter((c,m)=>{let p=new n(c);p.name=t.columns[m],p.index=t.index;let x=r(p,m,t);return x?l++:delete o[i.index[m]],x});if(l===0)return new e;if(l===1){let c=new n(h[0]);return c.name=L(o)[0],c.index=L(s),c}i.values=h,i.index=L(o),i=i.transpose()}return i}var Lt=Ht;function Qt(e,n,t){(w(n)||d(n))&&(n=[n]),(w(t)||d(t))&&(t=[t]);for(let a in n)typeof n[a]=="bigint"&&(n[a]=Number(n[a]));for(let a in t)typeof t[a]=="bigint"&&(t[a]=Number(t[a]));let r=P((n||[]).concat(t||[]).map(a=>typeof a));return u(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&u(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(u(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),u(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),g(n)||(n=n.map(a=>{if(w(a))return u(e.index.indexOf(a)>-1,`Row "${a}" does not exist!`),a;if(d(a))return u(a>=0,`Index ${a} is out of bounds!`),u(Math.floor(a)===a,"Row numbers must be integers!"),u(a<e.index.length,`Index ${a} is out of bounds!`),e.index[a]})),g(t)||(t=t.map(a=>{if(w(a))return u(e.columns.indexOf(a)>-1,`Column "${a}" does not exist!`),a;if(d(a))return u(a>=0,`Column ${a} is out of bounds!`),u(Math.floor(a)===a,"Column numbers must be integers!"),u(a<e.columns.length,`Column ${a} is out of bounds!`),e.columns[a]})),e.getSubsetByNames(n,t)}var Vt=Qt;function Xt(e,n){try{return e<n?-1:e>n?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),n=typeof n=="object"&&n!==null?JSON.stringify(n):n.toString(),e<n?-1:e>n?1:0}}function Zt(e,n){if(g(n)&&(n=Xt),b(e)||y(e))return e.sort(...Object.values(arguments).slice(1));u(f(e),"The `sort` function only works on arrays, Series, and DataFrames!"),u(D(n),"The second parameter of the `sort` function must be a comparison function!");let t=e.slice();return t.sort(n),t}var G=Zt;function er(e){let n=e.toLowerCase(),t="";for(let a=0;a<n.length;a++){let i=n[a];i.match(/[a-z0-9]/g)?t+=i:t+=" "}let r=t.split(" ").filter(a=>a.length>0);return r[0]+r.slice(1).map(a=>a[0].toUpperCase()+a.substring(1)).join("")}function nr(e,n,t){g(t)?t=n.columns:w(t)&&(t=[t]);let r={};t.forEach(i=>{u(w(i),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=n.columns.indexOf(i);u(s>-1,`The given DataFrame does not have a column called "${i}"!`);let o=n.values.map(h=>h[s]),l=G(P(o));o.forEach(h=>{l.forEach(c=>{let m=i+"_"+er(c.toString());r[m]||(r[m]=[]),h===c?r[m].push(1):r[m].push(0)})})});let a=new e(r);return a.index=n.index,a}var Qe=nr;function tr(e,n,t){let r=e.shape;g(n)&&(n=T(0,r[0])),g(t)&&(t=T(0,r[1])),d(n)&&(n=[n]),d(t)&&(t=[t]),u(f(n)&&f(t),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),u(v(n).length===1&&v(t).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),u(n.length>0,"The `rowIndices` array must contain at least one index."),u(t.length>0,"The `colIndices` array must contain at least one index."),n.forEach(s=>{u(X(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),u(s<e.index.length,`The row index ${s} is out of bounds.`)}),t.forEach(s=>{u(X(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),u(s<e.columns.length,`The column index ${s} is out of bounds.`)});let a=n.map(s=>e.index[s]),i=t.map(s=>e.columns[s]);return e.getSubsetByNames(a,i)}var rr=tr;function ar(e,n,t,r,a){g(r)&&(r=t.index),g(a)&&(a=t.columns),w(r)&&(r=[r]),w(a)&&(a=[a]),u(f(r)&&f(a),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),u(v(r).length===1&&v(a).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),u(r.length>0,"The `rows` array must contain at least one row name."),u(a.length>0,"The `cols` array must contain at least one column name."),r.forEach(o=>{u(w(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),u(t.index.indexOf(o)>-1,`The row name "${o}" does not exist in the list of rows.`)}),a.forEach(o=>{u(w(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),u(t.columns.indexOf(o)>-1,`The column name "${o}" does not exist in the list of columns.`)});let i=r.map(o=>a.map(l=>t.values[t.index.indexOf(o)][t.columns.indexOf(l)]));if(r.length===1&&a.length===1)return i[0][0];if(r.length===1){let o=new n(i[0]);return o.name=r[0],o.index=a,o}if(a.length===1){let o=new n(i.map(l=>l[0]));return o.name=a[0],o.index=r,o}let s=new e(i);return s.columns=a,s.index=r,s}var ir=ar;function sr(e,n,t){function r(p,x){return w(p)&&p.length>x?p.substring(0,x-3)+"...":p}if(t.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),t;let a=typeof window>"u"?20:10,i=Math.floor(a/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,o=Math.floor(s/2),l=a>t.index.length?null:T(0,i).concat(T(t.index.length-i,t.index.length)),h=s>t.columns.length?null:T(0,o).concat(T(t.columns.length-o,t.columns.length)),c=t.get(l,h);c instanceof n&&(t.shape[0]===1?(c=new e([c.values]),c.index=t.index,c.columns=new n(t.columns).get(h).values):t.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new n(t.index).get(l).values,c.columns=t.columns)),a<=t.index.length&&(c._index.splice(i,0,"..."),c._values.splice(i,0,T(0,c.columns.length).map(()=>"..."))),s<=t.columns.length&&(c._columns.splice(o,0,"..."),c._values=c._values.map(p=>(p.splice(o,0,"..."),p)));let m=28;return c instanceof n?(c.values=c.values.map(p=>r(p,m)),c.name=r(c.name,m),c.index=c.index.map(p=>r(p,m))):(c.values=c.values.map(p=>p.map(x=>r(x,m))),c.columns=c.columns.map(p=>r(p,m)),c.index=c.index.map(p=>r(p,m))),console.table(c.toDetailedObject()),console.log("Shape:",t.shape,`
`),t}var or=sr;function ur(e,n){u(d(e),"The `leftPad` function only works on numbers!");let t=e.toString();for(;t.length<n;)t="0"+t;return t}var Q=ur;function lr(e,n){let t=n?e:e.copy();return t.index=T(0,e.shape[0]).map(r=>"row"+Q(r,(t.index.length-1).toString().length)),t}var hr=lr;function cr(e){if(b(e)||y(e))return e.shuffle(...Object.values(arguments).slice(1));u(f(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let n=[],t=e.slice();for(let r=0;r<e.length;r++){let a=Math.floor(K()*t.length);n.push(t.splice(a,1)[0])}return n}var me=cr;function fr(e,n){return g(n)&&(n=0),u(n===0||n===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(n===0?me(e.index):null,n===1?me(e.columns):null)}var mr=fr;function dr(e){return typeof e=="boolean"}var W=dr;function gr(e,n,t){return D(n)?pr(e,n,t):yr(e,n,t)}function pr(e,n,t){if(t=g(t)?0:t,u(D(n),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),u(d(t),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),t===0){let r=G(e.index,(a,i)=>n(e.get(a,null),e.get(i,null)));return e.get(r,null)}else{let r=G(e.columns,(a,i)=>n(e.get(null,a),e.get(null,i)));return e.get(null,r)}}function yr(e,n,t){let r=e.copy(),a=K().toString();r=r.assign(a,r.index),g(n)&&(n=[a],t=[!0]),(d(n)||w(n))&&(n=[n],(W(t)||w(t))&&(t=[t])),u(f(n),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),u(v(n).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),g(t)&&(t=T(0,n.length).map(()=>!0)),u(f(t),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),u(v(t).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),u(n.length===t.length,"The arrays passed into the `sort` method must be equal in length."),n=n.map(s=>{if(u(w(s)||d(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),w(s)){let o=r.columns.indexOf(s);return u(o>-1,`The column "${s}" does not exist!`),o}if(d(s))return u(X(s),"Column indices must be whole numbers!"),u(s<r.columns.length,`The index ${s} is out of bounds!`),s}),t=t.map(s=>{if(u(w(s)||W(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),w(s)){let o=s.trim().toLowerCase();return u(o==="ascending"||o==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),o==="ascending"}if(W(s))return s}),r.values=G(r.values,(s,o)=>{let l=0;for(;s[n[l]]===o[n[l]]&&l<n.length;)l++;let h=t[l];if(s[n[l]]===o[n[l]])return 0;if(s[n[l]]<o[n[l]])return h?-1:1;if(s[n[l]]>o[n[l]])return h?1:-1});let i=r.columns.indexOf(a);return r.index=r.values.map(s=>s[i]),r=r.dropColumns(a),r}var br=gr;function vr(e,n){g(n)?n=0:u(n===0||n===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let t={};return n===0?e.index.forEach((r,a)=>{let i={};e.columns.forEach((s,o)=>{i[s]=e.values[a][o]}),t[r]=i}):e.columns.forEach((r,a)=>{let i={};e.index.forEach((s,o)=>{i[s]=e.values[o][a]}),t[r]=i}),t}var Nr=vr;function xr(e,n){return JSON.stringify(e.toObject(n))}var gn=xr;async function wr(e,n,t){let r=gn(e,t),a=!1,i=!1,s,o;try{let l=n;if(n.includes("/")){let c=n.split("/");l=c[c.length-1]}let h=document.createElement("a");h.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,h.download=l,h.dispatchEvent(new MouseEvent("click")),a=!0}catch(l){s=l}try{let l=await import("node:fs"),h=await import("node:path");l.writeFileSync(h.resolve(n),r,"utf8"),i=!0}catch(l){o=l}if(!a&&!i)throw typeof window<"u"?new U(s):typeof module<"u"?new U(o):new U("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}var Or=wr;function _r(e){let n={};return e.columns.forEach(t=>{n[t]=e.get(t).values}),n}var Sr=_r;function Tr(e){if(b(e)||y(e))return e.transpose();u(f(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let n=v(e);if(u(n.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),n.length===1)return q(e);if(n.length===2){let t=B(q(n));for(let r=0;r<n[0];r++)for(let a=0;a<n[1];a++)t[a][r]=e[r][a];return t}}var C=Tr;function pn(e,n,t){if(y(t))return new e(n.values.concat(t.values));if(f(t)){let r=v(t);u(r.length===1&&!Ae(r),"Only vectors can be appended to Series!");let a=n.copy();return t.forEach((i,s)=>{a._values.push(i),a._index.push("item"+(n.values.length+s))}),a}return pn(n,[t])}var Dr=pn;function jr(e,n){u(D(n),"The parameter to the `apply` method must be a function.");let t=e.copy();return t._values=t._values.map((r,a)=>n(r,a)),t}var Mr=jr;function Ir(e){let n=e.copy(),t=[];return n._values=n.values.filter((r,a)=>g(r)?!1:(t.push(n.index[a]),!0)),n._index=t,n}var Er=Ir;function kr(e,n){let t=[],r=[];n.values.forEach((i,s)=>{d(i)&&(r.push(i),t.push(n.index[s]))});let a=new e(r);return a.name=n.name,a.index=t,a}var Fr=kr;function Pr(e,n,t){let r=n.copy(),a=j(r.index),i=[],s=r.values.filter((o,l)=>{let h=t(o,l,r.values);return h||i.push(r.index[l]),h});return i.forEach(o=>{a.splice(a.indexOf(o),1)}),s.length===0?(r=new e,r.name=n.name,r):(r.values=s,r.index=a,r)}var Br=Pr;function Ar(e,n){(w(n)||d(n))&&(n=[n]);for(let r in n)typeof n[r]=="bigint"&&(n[r]=Number(n[r]));let t=P((n||[]).map(r=>typeof r));return u(t.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),t.length===1&&u(t[0]==="string"||t[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),t.length===2&&(u(t.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),u(t.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),g(n)||(n=n.map(r=>{if(typeof r=="string")return u(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return u(r>=0,`Index ${r} is out of bounds!`),u(Math.floor(r)===r,"Indices must be integers!"),u(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(n)}var Jr=Ar;function $r(e,n){let t=e.shape;g(n)&&(n=T(0,t[0])),u(f(n),"The `indices` array must be 1-dimensional array of whole numbers."),u(v(n).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),u(n.length>0,"The `indices` array must contain at least one index."),n.forEach(a=>{u(X(a),"The `indices` array must be a 1-dimensional array of whole numbers."),u(a<e.index.length,`The row index ${a} is out of bounds.`)});let r=n.map(a=>e.index[a]);return e.getSubsetByNames(r)}var zr=$r;function Rr(e,n,t){g(t)&&(t=n.index),u(f(t),"The `indices` array must be a 1-dimensional array of strings."),u(v(t).length===1,"The `indices` array must be a 1-dimensional array of strings."),u(t.length>0,"The `indices` array must contain at least one index name."),t.forEach(i=>{u(w(i),"The `indices` array must contain only strings."),u(n.index.indexOf(i)>-1,`The name "${i}" does not exist in the index.`)});let r=t.map(i=>n.values[n.index.indexOf(i)]);if(r.length===1)return r[0];let a=new e(r);return a.index=t,a.name=n.name,a}var Cr=Rr;function Yr(e){let n=e.copy(),t=typeof window>"u"?20:10;if(n.index.length>t){n=n.get(T(0,t/2).concat(T(n.index.length-t/2,n.index.length)));let a=j(n.index);a.splice(Math.floor(a.length/2),0,"..."),n.values.push("..."),n.index.push("..."),n=n.get(a)}let r={};return n.values.forEach((a,i)=>{let s={};s[n.name]=a,r[n.index[i]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}var qr=Yr;function Ur(e){let n=e.copy();return n.get(me(n.index))}var Kr=Ur;function Wr(e,n,t){t=t||((l,h)=>l<h?-1:1),u(g(t)||D(t),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=C([n.values,n.index]),a=G(r,(l,h)=>t(l[0],h[0])),i=[],s=[];a.forEach(l=>{i.push(l[0]),s.push(l[1])});let o=new e;return o._values=i,o._index=s,o.name=n.name,o}var Gr=Wr;function Hr(e,n){let t=C([n.values,n.index]);t=C(G(t,(a,i)=>{if(a[1]===i[1])return 0;if(a[1]<i[1])return-1;if(a[1]>i[1])return 1}));let r=new e(t[0]);return r.index=t[1],r.name=n.name,r}var Lr=Hr;function Qr(e){let n={};return n[e.name]={},e.index.forEach((t,r)=>{n[e.name][t]=e.values[r]}),n}var Vr=Qr,Ve=Symbol.for("@jrc03c/js-math-tools/series");function Xr(e){class n{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===Ve}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Ve}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(a){u(f(a),"The new values must be a 1-dimensional array!");let i=v(a);u(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<this._index.length?this._index=this._index.slice(0,i[0]):i[0]>this._index.length&&(this._index=this._index.concat(T(this._index.length,i[0]).map(s=>"item"+Q(s,(a.length-1).toString().length)))),this._values=a}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(a){u(f(a),"The new index must be a 1-dimensional array of strings!"),u(a.length===this.shape[0],"The new index must be the same length as the old index!"),u(v(a).length===1,"The new index must be a 1-dimensional array of strings!"),a.forEach(i=>{u(w(i),"All of the row names must be strings!")}),this._index=a}}),r){if(r instanceof n)this.name=r.name,this.values=j(r.values),this.index=j(r.index);else if(f(r)){let a=v(r);u(a.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let a=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(o=>o.toString());u(a.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=a[0],s=r[i];u(v(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=i,this.values=s.slice()}}}get shape(){return v(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!g(r)).length===0}clear(){let r=this.copy();return r.values.forEach((a,i)=>{r.values[i]=void 0}),r}get(r){return Jr(this,r)}getSubsetByNames(r){return Cr(n,this,r)}getSubsetByIndices(r){return zr(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new n(q(this.values));return r.index=q(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=T(0,this.shape[0]).map(a=>"item"+Q(a,(r.index.length-1).toString().length)),r}copy(){let r=new n;return r._values=j(this.values),r._index=j(this.index),r.name=this.name,r}append(r){return Dr(n,this,r)}apply(r){return Mr(this,r)}concat(r){return this.append(r)}dropMissing(r,a){return Er(this,r,a)}dropNaN(){return Fr(n,this)}toObject(){return Vr(this)}print(){return qr(this)}shuffle(){return Kr(this)}sort(r){return Gr(n,this,r)}sortByIndex(){return Lr(n,this)}filter(r){return Br(n,this,r)}toDataFrame(){let r=new e(C([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=q(r.values),r.index=q(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return n}var Xe=Symbol.for("@jrc03c/js-math-tools/dataframe");function ie(e){let n="abcdefghijklmnopqrstuvwxyz1234567890",t="";for(let r=0;r<e;r++)t+=n[Math.floor(K()*n.length)];return t}var S=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Xe}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Xe}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!g(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(n){u(f(n),"The new values must be a 2-dimensional array!");let t=v(n);u(t.length===2,"The new array of values must be 2-dimensional!"),t[0]<this._index.length?this._index=this._index.slice(0,t[0]):t[0]>this._index.length&&(this._index=this._index.concat(T(this._index.length,t[0]).map(r=>"row"+Q(r,(t[0]-1).toString().length)))),t[1]<this._columns.length?this._columns=this._columns.slice(0,t[1]):t[1]>this._columns.length&&(this._columns=this._columns.concat(T(this._columns.length,t[1]).map(r=>"col"+Q(r,(t[1]-1).toString().length)))),this._values=n}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(n){u(f(n),"The new columns list must be a 1-dimensional array of strings!"),u(this.isEmpty||n.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),u(v(n).length===1,"The new columns list must be a 1-dimensional array of strings!"),n=n.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ie(8):r.trim()));let t=(()=>{let r=fe(n),a={};return r.values.forEach(i=>{a[i]=r.get(i)}),a})();n=n.map(r=>t[r]>1?r+"_"+ie(8):r),this._columns=n}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(n){u(f(n),"The new index must be a 1-dimensional array of strings!"),u(this.isEmpty||n.length===this.shape[0],"The new index must be the same length as the old index!"),u(v(n).length===1,"The new index must be a 1-dimensional array of strings!"),n=n.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+ie(8):r.trim()));let t=(()=>{let r=fe(n),a={};return r.values.forEach(i=>{a[i]=r.get(i)}),a})();n=n.map(r=>t[r]>1?r+"_"+ie(8):r),this._index=n}}),u(g(e)||J(e)||f(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof S)this.values=j(e.values),this.columns=j(e.columns),this.index=j(e.index);else if(f(e)){let n=v(e);u(n.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),u(!re(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(i=>i.toString());let n=[],t=null,r=null;this._columns.forEach(i=>{g(r)&&(t=i,r=e[i].length),u(e[i].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${t}" points to an array containing ${r} items, and the key "${i}" points to an array containing ${e[i].length} items.`),r=e[i].length;let s=e[i];n.push(s)}),this._values=C(n);let a=v(this.values);this._index=T(0,a[0]).map(i=>"row"+Q(i,(a[0]-1).toString().length))}}get shape(){return v(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new S(B(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,n){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return Vt(this,e,n)}getSubsetByNames(e,n){return ir(S,I,this,e,n)}getSubsetByIndices(e,n){return rr(this,e,n)}getDummies(e){return Qe(S,this,e)}oneHotEncode(e){return Qe(S,this,e)}transpose(){let e=new S(C(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return hr(this,e)}copy(){return Rt(S,this)}assign(e,n){return $t(S,I,this,e,n)}apply(e,n){return Bt(S,I,this,e,n)}dropMissing(e,n,t){return Kt(S,I,this,e,n,t)}dropNaN(e,n,t){return Gt(S,this,e,n,t)}drop(e,n){return Yt(S,I,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return Nr(this,e)}toObject(){return Sr(this)}toJSONString(e){return gn(this,e)}saveAsJSON(e,n){return Or(this,e,n)}print(){return or(S,I,this)}sort(e,n){return br(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Lt(S,I,this,e,n)}shuffle(e){return mr(this,e)}append(e,n){return Ft(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){return JSON.stringify(this)}},I=Xr(S);function Zr(e,n){return k(e,{shouldDropNaNs:n}).max}var ve=Zr;function ea(e){return u(D(e),"You must pass a function into the `vectorize` function!"),function n(){let t,r,a=[],i=[],s=Object.keys(arguments).filter(o=>{let l=arguments[o];return f(l)?!0:y(l)?(t=!0,a.push(l),!0):b(l)?(r=!0,i.push(l),!0):!1}).map(o=>arguments[o]);if(s.slice(0,-1).forEach((o,l)=>{u($(f(o)?v(o):o.shape,f(s[l+1])?v(s[l+1]):s[l+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let o=ve(s.map(h=>h.length?h.length:h.values.length)),l=T(0,o).map(h=>{let c=Object.keys(arguments).map(m=>f(arguments[m])?arguments[m][h]:y(arguments[m])||b(arguments[m])?arguments[m].values[h]:arguments[m]);return n(...c)});if(r)try{if(i.length===1&&$(v(i[0]),v(l))){let h=new S(l);return h.index=i[0].index.slice(),h.columns=i[0].columns.slice(),h}else return new S(l)}catch{return l}if(t)try{if(a.length===1&&a[0].length===l.length){let h=new I(l);return h.name=a[0].name,h.index=a[0].index.slice(),h}else return new I(l)}catch{return l}return l}else return e(...arguments)}}var O=ea;function Te(e){if(b(e)||y(e)){let n=e.copy();return n.values=Te(n.values),n}if(f(e))return e.map(n=>Te(n));try{let n=JSON.parse(e);return d(n)?typeof n=="bigint"?Number(n):n>=0?Math.floor(n):Math.ceil(n):NaN}catch{return NaN}}var E=O(Te);function de(e,n){function*t(r,a){if(a>r.length)yield r;else if(a<=0)yield[];else if(r.length<2)yield r;else for(let i=0;i<r.length;i++){let s=r[i],o=r.slice(i+1);if(!(o.length<a-1)&&a-1>=0)for(let l of de(o,a-1))yield[s].concat(l)}}return b(e)||y(e)?de(e.values,n):(u(f(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),u(d(n)&&E(n)===n&&n>=0,"`r` must be a non-negative integer!"),t(A(e),n))}function yn(e,n){let t=[];for(let r of de(e,n))t.push(r.slice());return t}function na(e){d(e)&&(e=[e]);let n=[],t=ye(e);for(let r=0;r<t;r++)n.push(0);return Je(n,e)}var $e=na;function ze(e,n){function*t(r,a){if(a=a||r.length,r.length===1){yield[r];return}for(let i of yn(r,a)){if(!i.slice)continue;let s=$e(i.length);yield i;let o=1;for(;o<i.length;)if(s[o]<o){if(o%2===0){let l=i[0];i[0]=i[o],i[o]=l}else{let l=i[s[o]];i[s[o]]=i[o],i[o]=l}yield i,s[o]+=1,o=1}else s[o]=0,o+=1}}return b(e)||y(e)?ze(e.values,n):(u(f(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),g(n)&&(n=e.length),u(d(n)&&E(n)===n&&n>=0,"`r` must be a non-negative integer!"),t(A(e),n))}function ta(e,n){let t=[];for(let r of ze(e,n))t.push(r.slice());return t}function Ze(e,n){u(D(e),"`fn` must be a function!");let t=new Date;return n?e(...n):e(),new Date-t}async function ra(e,n){u(D(e),"`fn` must be a function!");let t=new Date;return n?await e(...n):await e(),new Date-t}function aa(e){try{return d(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var Re=O(aa);function ia(){try{let e=0,n=!1,t=Object.values(arguments);for(let r of t){if(!d(r))return NaN;typeof r=="bigint"&&(n=!0,r=Number(r)),e+=r}if(n)try{return BigInt(e)}catch{}return e}catch{return NaN}}var ge=O(ia);function sa(e,n){try{return n(e)}catch{return NaN}}var Ne=O(sa);function oa(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var ua=O(oa);function la(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var ha=O(la);function ca(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var fa=O(ca);function De(e,n){if(b(e)){let t=De(e.values,n);return[e.index[t[0]],e.columns[t[1]]]}if(y(e)){let t=De(e.values,n);return e.index[t]}u(f(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let t=pe(e,ve(e,n));return t?t.length===0?void 0:t.length===1?t[0]:t:void 0}catch{return}}var ma=De;function da(e,n){return k(e,{shouldDropNaNs:n}).min}var bn=da;function je(e,n){if(b(e)){let t=je(e.values,n);return[e.index[t[0]],e.columns[t[1]]]}if(y(e)){let t=je(e.values,n);return e.index[t]}u(f(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let t=pe(e,bn(e,n));return t?t.length===0?void 0:t.length===1?t[0]:t:void 0}catch{return}}var ga=je;function F(e,n){if(b(e)||y(e))return e.apply(t=>F(t,n));if(f(e))return e.map(t=>F(t,n));if(n==="null")return null;if(n==="number"){if(g(e))return NaN;let t=F(e,"boolean");if(W(t))return t?1:0;try{JSON.parse(e)}catch{let a=F(e,"date");if(R(a))return a.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(n==="int"){let t=F(e,"number");return t>=0?Math.floor(t):Math.ceil(t)}if(n==="float")return F(e,"number");if(n==="bigint")return typeof e=="bigint"?e:BigInt(F(e,"int"));if(n==="boolean"){if(W(e))return e;if(d(e))return e===0?!1:e===1?!0:null;try{let t=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return t==="true"||t==="yes"||t==="y"?!0:t==="false"||t==="no"||t==="n"?!1:null}catch{return null}}if(n==="date"){if(R(e))return e;if(g(e))return null;let t=parseFloat(e);if(!isNaN(t)){let a=new Date(e);return R(a)?a:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(n==="object"){if(J(e))return e;let t=F(e,"boolean");if(W(t))return null;try{let a=F(e,"number");if(d(a))return JSON.parse(e),null}catch{}let r=F(e,"date");if(r)return r;try{let a=JSON.parse(e);return f(a)?a.map(i=>F(i,n)):a}catch{return null}}if(n==="string")return g(e)?$(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():(()=>typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString())()}var vn=F;function pa(e){try{return d(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var ya=O(pa);function ba(e,n){try{if(!d(e))return NaN;if(typeof e=="bigint")return e;if(g(n))n=1e-10;else if(!d(n))return NaN;return Re(e)<n?0:e}catch{return NaN}}var va=O(ba);function Nn(e,n,t){try{return d(e)?d(n)?d(t)?typeof e=="bigint"?BigInt(Nn(E(e),n,t)):e<n?n:e>t?t:e:NaN:NaN:NaN}catch{return NaN}}var Na=O(Nn);function xa(){let e=Object.values(arguments).map(n=>b(n)||y(n)?P(n.values):(u(f(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),P(n)));return P(e).filter(n=>e.every(t=>t.findIndex(r=>$(r,n))>-1))}var xn=xa,ee=class{constructor(e){u(g(e)||e===ee.DROP_NAN_MODE||e===ee.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=g(e)?ee.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(n=>{if(f(n)){let t=v(n);if(t.length===1)n=new I(n);else if(t.length===2)n=new S(n);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}u(b(n)||y(n),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===ee.DROP_MISSING_MODE?e.push(n.dropMissing().index):e.push(n.dropNaN().index)}),this.index=xn(...e),this}transform(){u(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(n=>{if(f(n)){let t=v(n);if(t.length===1)return new I(n).get(this.index).values;if(t.length===2)return new S(n).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return u(b(n)||y(n),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),n.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},Me=ee;Ke(Me,"DROP_NAN_MODE","DROP_NAN_MODE"),Ke(Me,"DROP_MISSING_MODE","DROP_MISSING_MODE");var wn=Me;function oe(e,n,t,r){if(y(e))return oe(e.values,n,t,r);if(y(n))return oe(e,n.values,t,r);if(u(f(e)&&f(n)&&v(e).length===1&&v(n).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),u(e.length===n.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),t)return oe(...new wn().fitAndTransform(e,n),!1,r);try{let a=k(e,{stdev:r}),i=k(n,{stdev:r}),s=Number(a.mean),o=Number(i.mean);if(!d(s)||!d(o))return NaN;let l=Math.max(e.length,n.length),h=0;for(let c=0;c<l;c++){let m=e[c],p=n[c];if(!d(m))return NaN;if(!d(p))return NaN;typeof m=="bigint"&&(m=Number(m)),typeof p=="bigint"&&(p=Number(p)),h+=(m-s)*(p-o)}return r?[h/e.length,a,i]:h/e.length}catch{return NaN}}var On=oe;function Ie(e,n,t){if(y(e))return Ie(e.values,n,t);if(y(n))return Ie(e,n.values,t);u(f(e)&&f(n)&&v(e).length===1&&v(n).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),u(e.length===n.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[r,a,i]=On(e,n,t,!0),s=a.stdev*i.stdev;return r/s}catch{return NaN}}var wa=Ie;function Oa(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var _a=O(Oa),Sa=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Ee(e,n){if(b(e)||y(e))return Ee(e.values,n);if(b(n)||y(n))return Ee(e,n.values);u(f(e)&&f(n),"The `diff` function only works on arrays, Series, and DataFrames!");let t=P(e),r=P(n),a=[];return t.forEach(i=>{r.findIndex(s=>$(s,i))<0&&a.push(i)}),a}var Ta=Ee;function _n(e,n){try{if(!d(e))return NaN;if(!d(n))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let t=_n(Number(e),Number(n));try{return BigInt(t)}catch{return t}}return Math.pow(e,n)}catch{return NaN}}var Ce=O(_n);function Sn(e){try{if(!d(e))return NaN;if(typeof e=="bigint"){let n=Sn(Number(e));try{return BigInt(n)}catch{return n}}return Math.sqrt(e)}catch{return NaN}}var Tn=O(Sn);function Da(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let n=!1,t=1;for(let r of e){if(!d(r))return NaN;typeof r=="bigint"&&(n=!0,r=Number(r)),t*=r}if(n)try{return BigInt(t)}catch{}return t}catch{return NaN}}var Dn=O(Da);function ja(){return Dn(...arguments)}var Z=ja;function Ma(e,n){return ge(e,Z(n,-1))}var jn=Ma;function Ia(e,n){return k(e,{shouldDropNaNs:n}).sum}var Ye=Ia;function ke(e,n){if(d(e)&&d(n))return Re(e-n);if(b(e)||y(e))return ke(e.values,n);if(b(n)||y(n))return ke(e,n.values);f(e)&&f(n)&&u($(v(e),v(n)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return Tn(Ye(Ce(jn(e,n),2)))}catch{return NaN}}var Ea=ke;function ka(e,n){return Z(e,Ce(n,-1))}var Fa=ka;function Y(e,n){if(b(e)){let a=Y(e.values,n);if(v(a).length===1){let i=new I(a);return i.name=y(n)?n.name:i.name,i.index=e.index.slice(),i}else{let i=new S(a);return i.index=e.index.slice(),b(n)&&(i.columns=n.columns.slice()),i}}if(b(n)){let a=Y(e,n.values);if(v(a).length===1){let i=new I(a);return i.name=y(e)?e.name:i.name,i.index=n.columns.slice(),i}else{let i=new S(a);return i.columns=n.columns.slice(),i}}if(y(e))return Y(e.values,n);if(y(n))return Y(e,n.values);u(f(e)&&f(n),"The `dot` function only works on arrays, Series, and DataFrames!");let t=v(e),r=v(n);if(u(t.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),u(t[t.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${t[t.length-1]} !== ${r[0]})`),t.length===1&&r.length===1)return Ye(Z(e,n));if(t.length===1&&r.length===2)return C(n).map(a=>Y(e,a));if(t.length===2&&r.length===1)return e.map(a=>Y(a,n));if(t.length===2&&r.length===2){let a=C(n),i=[];for(let s=0;s<e.length;s++){let o=[];for(let l=0;l<a.length;l++)o.push(Y(e[s],a[l]));i.push(o)}return i}}var Mn=Y;function In(e){if(b(e)||y(e))return e.dropMissing(...Object.values(arguments).slice(1));u(f(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let n=[];return e.forEach(t=>{try{return n.push(In(t))}catch{g(t)||n.push(t)}}),n}var En=In;function ue(e,n){if(b(e)||y(e))return ue(e.values,n);if(b(n)||y(n))return ue(e,n.values);u(f(e)&&f(n),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),u($(v(e),v(n)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let t=[],r=[];for(let a=0;a<e.length;a++)try{let[i,s]=ue(e[a],n[a]);t.push(i),r.push(s)}catch{!g(e[a])&&!g(n[a])&&(t.push(e[a]),r.push(n[a]))}return[t,r]}var Pa=ue;function le(e,n){if(b(e)||y(e))return le(e.values,n);if(b(n)||y(n))return le(e,n.values);u(f(e)&&f(n),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),u($(v(e),v(n)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let t=[],r=[];for(let a=0;a<e.length;a++)try{let[i,s]=le(e[a],n[a]);t.push(i),r.push(s)}catch{d(e[a])&&d(n[a])&&(t.push(e[a]),r.push(n[a]))}return[t,r]}var Ba=le;function Aa(e){return En(e)}var Ja=Aa;function Fe(e,n){if(b(e)||y(e))return Fe(e.values,n);u(f(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),u(D(n),"The second argument passed into the `every` function must be a function!");for(let t of e)if(f(t)){if(!Fe(t,n))return!1}else if(!n(t))return!1;return!0}var kn=Fe;function $a(e){try{if(!d(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var za=O($a);function Pe(e){try{return typeof e=="bigint"?BigInt(Pe(E(e))):e!==E(e)?NaN:e<=1?1:e*Pe(e-1)}catch{return NaN}}var Ra=O(Pe);function Fn(e,n){if(b(e)||y(e))return Fn(e.values,n);if(u(J(e)||f(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!D(n)){let a=n;n=i=>i===a}function t(a,i,s){if(s=s||[],s.indexOf(a)>-1)return null;if(J(a)){s.push(a);let o=Object.keys(a).concat(Object.getOwnPropertySymbols(a));for(let l=0;l<o.length;l++){let h=o[l],c=a[h];if(i(c))return c;let m=t(c,i,s);if(m)return m}}else if(f(a)){s.push(a);for(let o=0;o<a.length;o++){let l=a[o];if(i(l))return l;let h=t(l,i,s);if(h)return h}}else if(i(a))return a;return null}function r(a){try{return n(a)}catch{return!1}}return t(e,r)}var Ca=Fn;function Pn(e,n){if(b(e)||y(e))return Pn(e.values,n);if(u(J(e)||f(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!D(n)){let i=n;n=s=>s===i}function t(i,s,o){if(o=o||[],o.indexOf(i)>-1)return null;if(J(i)){o.push(i);let l=Object.keys(i).concat(Object.getOwnPropertySymbols(i)),h=[];for(let c=0;c<l.length;c++){let m=l[c],p=i[m],x=!1;s(p)&&(h.push(p),x=!0);let N=t(p,s,o);N&&N.length>0&&N.slice(x?1:0).forEach(z=>h.push(z))}return h}else if(f(i)){o.push(i);let l=[];for(let h=0;h<i.length;h++){let c=i[h],m=!1;s(c)&&(l.push(c),m=!0);let p=t(c,s,o);p&&p.length>0&&p.slice(m?1:0).forEach(x=>l.push(x))}return l}else if(s(i))return[i];return null}function r(i){try{return n(i)}catch{return!1}}let a=t(e,r);return a&&a.length>0?a:null}var Ya=Pn;function qa(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let n=JSON.parse(e);return d(n)?n:NaN}catch{return NaN}}var Ua=O(qa);function Ka(e){try{return d(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var Wa=O(Ka);function Ga(e){typeof e=="bigint"&&(e=E(e)),u(!g(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),u(d(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),u(E(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),u(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let n=$e([e,e]);for(let t=0;t<e;t++)n[t][t]=1;return n}var Ha=Ga,La=["true","false","yes","no"],Qa=["null","none","nan","na","n/a","","undefined"];function se(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=E(e.value)===e.value:e.isInteger=kn(e.values,n=>d(n)?E(n)===n:!0)),e}function he(e){if(b(e)){let a=e.copy(),i=he(e.values);return a.values=i.values,se({type:i.type,values:a})}if(y(e)){let a=e.copy(),i=he(e.values);return a.values=i.values,se({type:i.type,values:a})}if(!f(e)){let a=he([e]);return a.value=a.values[0],delete a.values,se(a)}u(f(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let n=A(e).map(a=>{if(a===void 0)return"null";try{if(typeof a=="object"){let s=new Date(a.getTime());if(R(s))return"date"}}catch{}w(a)||(typeof a=="bigint"?a=a.toString()+"n":a=JSON.stringify(a));let i=a.toLowerCase().trim();if(Qa.indexOf(i)>-1)return"null";if(La.indexOf(i)>-1)return"boolean";try{if(a.match(/^-?\d+n$/g))return"bigint";let s=JSON.parse(a);return d(s)?"number":typeof s=="object"?f(s)?"string":"object":"string"}catch{let s=new Date(a);return R(s)?"date":"string"}}),t=fe(n),r=t.values.toSorted((a,i)=>t.get(i)-t.get(a))[0];return se({type:r,values:Ne(e,a=>vn(a,r))})}var Va=he;function ce(e){if(b(e)){let t=e.copy();return t.values=ce(t.values),t}u(f(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let n=v(e);if(u(n.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),u(n[0]===n[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),u(n[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),n[0]===0)return e;if(n[0]===1){u(e[0][0]!==0,"This matrix cannot be inverted!");let t=e[0][0];return typeof t=="bigint"&&(t=Number(t)),1/t}else if(n[0]===2){let t=e[0][0],r=e[0][1],a=e[1][0],i=e[1][1];typeof t=="bigint"&&(t=Number(t)),typeof r=="bigint"&&(r=Number(r)),typeof a=="bigint"&&(a=Number(a)),typeof i=="bigint"&&(i=Number(i));let s=t*i-r*a;u(s!==0,"This matrix cannot be inverted!");let o=[[i,-r],[-a,t]];return Z(o,1/s)}else if(n[0]>1){let t=(r,a)=>d(r)||d(a)?Z(r,a):Mn(r,a);for(let r=1;r<n[0]-1;r++)try{let a=e.slice(0,r).map(N=>N.slice(0,r)),i=e.slice(0,r).map(N=>N.slice(r,n[0])),s=e.slice(r,n[0]).map(N=>N.slice(0,r)),o=e.slice(r,n[0]).map(N=>N.slice(r,n[0])),l=ce(a),h=ce(ge(o,t(-1,t(t(s,l),i)))),c=ge(l,t(t(t(t(l,i),h),s),l)),m=t(-1,t(t(l,i),h)),p=t(-1,t(t(h,s),l)),x=h;return c.map((N,z)=>N.concat(m[z])).concat(p.map((N,z)=>N.concat(x[z])))}catch{}u(!1,"This matrix cannot be inverted!")}}var Xa=ce,Za=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `),ei=Za;function Bn(e,n,t){try{if(!d(e))return NaN;if(!d(n))return NaN;if(!d(t))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let r=Bn(Number(e),Number(n),t);try{return BigInt(r)}catch{return r}}return t*(n-e)+e}catch{return NaN}}var ni=O(Bn);function An(e,n){try{if(n=g(n)?Math.E:n,!d(e))return NaN;if(!d(n))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let t=An(Number(e),Number(n));try{return BigInt(t)}catch{return t}}return Math.log(e)/Math.log(n)}catch{return NaN}}var ti=O(An);function ri(e,n){return k(e,{shouldDropNaNs:n}).mean}var ai=ri;function ii(e,n){return k(e,{shouldDropNaNs:n,median:!0}).median}var si=ii;function Jn(e,n){try{if(!d(e))return NaN;if(!d(n))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let t=Jn(Number(e),Number(n));try{return BigInt(t)}catch{return t}}return e%n}catch{return NaN}}var oi=O(Jn);function ui(e,n){return k(e,{shouldDropNaNs:n,mode:!0}).mode}var li=ui;function en(){let e=K(),n=K();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*n)}function hi(e){return g(e)?en():Ne(B(e),en)}var ci=hi;function fi(e){return Ne(B(e),()=>1)}var mi=fi;function di(){Object.keys(arguments).forEach(e=>{let n=arguments[e];if(f(n))if(re(n))console.log(n);else{let t=v(n);t.length===1?new I(n).print():t.length==2?new S(n).print():console.log(n)}else b(n)||y(n)?n.print():console.log(n)})}var gi=di,pi=O((e,n,t,r,a)=>{try{let i=!1;for(let h of[e,n,t,r,a]){if(!d(h))return NaN;typeof h=="bigint"&&(i=!0)}i&&(e=Number(e),n=Number(n),t=Number(t),r=Number(r),a=Number(a));let s=(a-r)*(e-n),o=t-n;if(o===0)return NaN;let l=s/o+r;if(i)try{return BigInt(l)}catch{}return l}catch{return NaN}});function yi(e,n,t,r,a){if(f(e)&&g(r)&&g(a)){r=n,a=t;let i=k(e);n=i.min,t=i.max}return pi(e,n,t,r,a)}var bi=yi;function vi(e){try{return d(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var Ni=O(vi);function $n(e){try{return d(e)?typeof e=="bigint"?BigInt($n(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var xi=O($n);function wi(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var Oi=O(wi);function Be(e,n){if(b(e)||y(e))return Be(e.values,n);u(f(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),u(D(n),"The second argument passed into the `some` function must be a function!");for(let t of e)if(f(t)){if(Be(t,n))return!0}else if(n(t))return!0;return!1}var _i=Be;function Si(e,n){return k(e,{shouldDropNaNs:n,stdev:!0}).stdev}var zn=Si;function Ti(e){return zn(e)}var Di=Ti;function ji(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var Mi=O(ji);function Ii(){return P([...arguments].map(e=>f(e)?e:b(e)||y(e)?e.values:[e]))}var Ei=Ii;function ki(e,n){return k(e,{shouldDropNaNs:n,variance:!0}).variance}var Fi=ki;function Pi(){let e=[],n=Object.values(arguments).map(t=>((b(t)||y(t))&&(t=t.values),u(f(t),"The `zip` function only works on arrays, Series, and DataFrames!"),t));return T(0,ve(n.map(t=>t.length))).forEach(t=>{let r=[];n.forEach(a=>{let i=a[t];r.push(g(i)?void 0:i)}),e.push(r)}),e}var Bi=Pi,ne={abs:Re,add:ge,apply:Ne,arccos:ua,arcsin:ha,arctan:fa,argmax:ma,argmin:ga,assert:u,cast:vn,ceil:ya,chop:va,clamp:Na,combinations:yn,combinationsIterator:de,copy:j,correl:wa,cos:_a,count:fe,covariance:On,DataFrame:S,dataTypes:Sa,decycle:V,diff:Ta,distance:Ea,divide:Fa,dot:Mn,dropMissing:En,dropMissingPairwise:Pa,dropNaN:dn,dropNaNPairwise:Ba,dropUndefined:Ja,every:kn,exp:za,factorial:Ra,find:Ca,findAll:Ya,flatten:A,float:Ua,floor:Wa,identity:Ha,IndexMatcher:wn,indexOf:pe,inferType:Va,int:E,intersect:xn,inverse:Xa,isArray:f,isBoolean:W,isBrowser:ei,isDataFrame:b,isDate:R,isEqual:$,isFunction:D,isJagged:re,isNested:Ae,isNumber:d,isObject:J,isSeries:y,isString:w,isUndefined:g,lerp:ni,log:ti,MathError:U,max:ve,mean:ai,median:si,min:bn,mod:oi,mode:li,multiply:Dn,ndarray:B,normal:ci,ones:mi,permutations:ta,permutationsIterator:ze,pow:Ce,print:gi,product:ye,random:K,range:T,remap:bi,reshape:Je,reverse:q,round:Ni,scale:Z,seed:be,Series:I,set:P,shape:v,shuffle:me,sign:xi,sin:Oi,some:_i,sort:G,sqrt:Tn,stats:k,std:zn,stdev:Di,subtract:jn,sum:Ye,tan:Mi,timeAsync:ra,timeSync:Ze,time:Ze,transpose:C,union:Ei,variance:Fi,vectorize:O,zeros:$e,zip:Bi,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new ne.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(ne).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:ne[n]})}catch{e[n]=ne[n]}})}};typeof window<"u"&&(window.JSMathTools=ne);function Rn(e,n,t){arguments.length===2&&(d(arguments[1])?t=null:(t=n,n=null)),u(d(e)&&E(e)===e,"`keyLength` must be an integer!"),n&&(u(d(n)&&E(n)===n,"`keySeed` must be an integer!"),be(n)),t&&u(w(t),"`charset` must be a string!");let r="";t=t||"abcdefg1234567890";for(let a=0;a<e;a++)r+=t[E(K()*t.length)];return r}typeof window<"u"&&(window.makeKey=Rn);var Cn=Rn;var Un=Xn(qn(),1),xe=class{interval=null;isRunning=!1;jobs=[];results={};timeBetweenJobs=100;constructor(n){this.timeBetweenJobs=typeof n>"u"?this.timeBetweenJobs:n}append(n){let t=Cn(8);return this.jobs.push({fn:n,id:t}),this.start(),t}async retrieve(n){for(;!this.results[n];)await(0,Un.default)(10);return this.results[n]}async process(n){let t=this.append(n);return await this.retrieve(t)}start(){if(this.isRunning)return;this.isRunning=!0;let n=!1,t=async()=>{if(n)return;if(n=!0,!this.jobs||this.jobs.length===0)return this.stop();let r=this.jobs.shift(),a=await r.fn();this.results&&(this.results[r.id]=a),n=!1};return t(),this.interval=setInterval(t,this.timeBetweenJobs),this}stop(){return this.interval&&(clearInterval(this.interval),this.interval=null),this.isRunning=!1,this}destroy(){this.stop(),this.jobs=null,this.results=null,this.interval=null,this.isRunning=null,this.timeBetweenJobs=null}};typeof window<"u"&&(window.Queue=xe);var Wi=xe;export{Wi as default};
