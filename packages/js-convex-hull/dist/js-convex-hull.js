var Un=Object.defineProperty,Wn=(e,n,t)=>n in e?Un(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,qe=(e,n,t)=>(Wn(e,typeof n!="symbol"?n+"":n,t),t),Gn=new Function(`
  try {
    return this === window
  } catch(e) {}

  try {
    return typeof importScripts !== "undefined"
  } catch(e) {}

  return false
`),Kn=class extends Error{constructor(e){Gn()?super(e):super(`

\x1B[31m`+e+`
\x1B[0m`)}},U=Kn;function l(e,n){if(!e)throw new U(n)}function Ln(e){return e===null||typeof e>"u"}var g=Ln,Qe=[Array,ArrayBuffer,BigInt64Array,BigUint64Array,Float32Array,Float64Array,Int16Array,Int32Array,Int8Array,Uint16Array,Uint32Array,Uint8Array,Uint8ClampedArray],Hn=Qe.map(e=>e.name);function Vn(e){try{return e instanceof Array?!0:g(e.constructor)?!1:Qe.indexOf(e.constructor)>-1||Hn.indexOf(e.constructor.name)>-1}catch{return!1}}var f=Vn;function Xn(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/dataframe")}catch{return!1}}var v=Xn;function Zn(e){try{return!!e._symbol&&e._symbol===Symbol.for("@jrc03c/js-math-tools/series")}catch{return!1}}var y=Zn;function en(e){if(v(e)||y(e))return en(e.values);l(f(e),"The `flatten` function only works on arrays, Series, and DataFrames!");function n(t){let r=[];return t.forEach(a=>{f(a)?r=r.concat(n(a)):r.push(a)}),r}return n(e)}var B=en;function Qn(e){return typeof e=="number"&&!isNaN(e)||typeof e=="bigint"}var d=Qn;function et(e){return typeof e=="function"}var D=et;function nt(e){return typeof e=="object"&&!g(e)&&!f(e)}var A=nt;function we(e,n){if(v(e)){let i=we(e.values,n);return i.length>0&&d(i[0])&&i[0]>=0&&i[0]<e.index.length&&(i[0]=e.index[i[0]]),i.length>1&&d(i[1])&&i[1]>=0&&i[1]<e.columns.length&&(i[1]=e.columns[i[1]]),i}if(y(e)){let i=we(e.values,n);return i.length>0&&d(i[0])&&i[0]>=0&&i[0]<e.index.length&&(i[0]=e.index[i[0]]),i}if(l(A(e)||f(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `indexOf` function!"),!D(n)){let i=n;n=s=>s===i}function t(i,s,o){if(o=o||[],o.indexOf(i)>-1)return null;if(A(i)){o.push(i);let u=Object.keys(i).concat(Object.getOwnPropertySymbols(i));for(let h=0;h<u.length;h++){let c=u[h],m=i[c];if(s(m))return[c];let p=t(m,s,o);if(p&&p.length>0)return[c].concat(p)}}else if(f(i)){o.push(i);for(let u=0;u<i.length;u++){let h=i[u];if(s(h))return[u];let c=t(h,s,o);if(c&&c.length>0)return[u].concat(c)}}else if(s(i))return[];return null}function r(i){try{return n(i)}catch{return!1}}let a=t(e,r);return a&&a.length>0?a:null}var ve=we;function M(e){function n(t){if(typeof t=="object"){if(t===null)return null;if(f(t))return t instanceof Array?t.map(a=>M(a)):t.slice();if(y(t)){let a=t.copy();return a.values=M(a.values),a}if(v(t)){let a=t.copy();return a.values=M(t.values),a}if(t instanceof Date)return new Date(t.getTime());t=V(t);let r={};return Object.keys(t).concat(Object.getOwnPropertySymbols(t)).forEach(a=>{r[a]=M(t[a])}),r}else return t}return n(V(e))}function V(e){function n(a,i,s){if(i=i||[],s=s||"",i.indexOf(a)>-1){let o=s.split("/").slice(s.startsWith("/")?1:0);if(o.some((u,h)=>{let c=o.slice(0,o.length-h-1),m=t;return c.forEach(p=>{m=m[p]}),m===a}))return`<reference to "${t===a?"/":"/"+ve(t,a).join("/")}">`}return typeof a=="object"?a===null?null:(i.push(a),f(a)?typeof a.constructor<"u"&&a.constructor.name!=="Array"?a.slice():a.map((o,u)=>n(o,i,s+"/"+u)):(Object.keys(a).concat(Object.getOwnPropertySymbols(a)).forEach(o=>{a[o]=n(a[o],i,s+"/"+o.toString())}),a)):a}let t=e,r=n(t);if(v(e)){let a=e.copy();a._values=r.values,a._columns=r.columns,a._index=r.index,r=a}if(y(e)){let a=e.copy();a.name=r.name,a._values=r.values,a._index=r.index,r=a}return r}function nn(e){if(v(e)||y(e))return nn(e.values);l(f(e),"The `isNested` function only works on arrays, Series, and DataFrames!");for(let n=0;n<e.length;n++)if(f(e[n]))return!0;return!1}var Ae=nn,K="You must pass a natural number or a one-dimensional array of natural numbers into the `ndarray` function!";function tn(e){l(!g(e),K),f(e)||(e=[e]),l(!Ae(e),K),l(e.length>0,K);let n=e[0];if(typeof n=="bigint"&&(n=Number(n)),l(d(n),K),l(n>=0,K),l(Math.floor(n)===n,K),l(n!==1/0,"We can't create an array containing an infinite number of values!"),e.length===1){let t=[];for(let r=0;r<n;r++)t.push(void 0);return t}else{let t=[];for(let r=0;r<n;r++)t.push(tn(e.slice(1)));return t}}var P=tn;function rn(e,n){if(v(e)||y(e))return rn(e.values,n);l(f(e),"The `product` function only works on arrays, Series, and DataFrames!");try{if(e.length===0)return NaN;let t=B(e),r=!1,a=1;for(let i of t){if(!d(i))if(n)i=1;else return NaN;typeof i=="bigint"&&(r=!0,i=Number(i)),a*=i}if(r)try{return BigInt(a)}catch{}return a}catch{return NaN}}var be=rn;function tt(e){return d(e)&&(e>=0?Math.floor(e)===e:Math.ceil(e)===e)}var an=tt;function rt(e){return an(e)&&e>0}var at=rt;function sn(e){if(f(e)){let n=sn(e[0]);return[e.length].concat(n||[])}else return}function on(e){return v(e)||y(e)?on(e.values):(l(f(e),"The `shape` function only works on arrays, Series, and DataFrames!"),sn(e))}var b=on;function Oe(e,n){if(v(e)||y(e))return Oe(e.values,n);if(l(f(e),"The first argument passed into the `reshape` function must be an array!"),d(n)&&(n=[n]),l(f(n),"The second argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),l(b(n).length===1,"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),n=n.map(i=>(typeof i=="bigint"&&(i=Number(i)),l(at(i),"The first argument passed into the `reshape` function must be a whole number or a one-dimensional array of whole numbers!"),Number(i))),n.length===0)return B(e);let t=B(e);if(n.length===1&&n[0]===t.length)return t;l(be(n)===t.length,"The new shape doesn't match the number of values available in `x` (the first argument passed into the `reshape` function)!");let r=[],a=Math.floor(t.length/n[0]);for(let i=0;i<n[0];i++){let s=t.slice(i*a,(i+1)*a);r.push(Oe(s,n.slice(1)))}return r}var Je=Oe,ln=Math.pow(2,64),S=[];un(Math.floor(Math.random()*ln));function it(e,n){e=j(e);function t(){e+=j("0x9e3779b97f4a7c15");let a=M(e);return a=(a^a>>BigInt(30))*j("0xbf58476d1ce4e5b9"),a=(a^a>>BigInt(27))*j("0x94d049bb133111eb"),a^a>>BigInt(31)}let r=[];for(let a=0;a<n;a++)r.push(t());return r}function j(e){return BigInt.asUintN(64,BigInt(e))}function Ue(e,n){return e=j(e),n=BigInt(n),j(j(e<<n)|j(e>>j(BigInt(64)-n)))}function un(e){if(typeof e=="bigint"&&(e=Number(e)),g(e))return M(S);{l(d(e),"If passing a value into the `seed` function, then that value must be an integer!");let n=it(Math.floor(e),4);S[0]=n[0],S[1]=n[1],S[2]=n[2],S[3]=n[3]}}function We(){let e=j(Ue(S[0]+S[3],23)+S[0]),n=j(S[1]<<BigInt(17));return S[2]=j(S[2]^S[0]),S[3]=j(S[3]^S[1]),S[1]=j(S[1]^S[2]),S[0]=j(S[0]^S[3]),S[2]=j(S[2]^n),S[3]=Ue(S[3],45),Math.floor(Number(e))/ln}function X(e){return g(e)?We():(f(e)||(e=[e]),Je(P(be(e)).map(We),e))}function st(e){return e instanceof Date&&e.toString()!=="Invalid Date"}var C=st,Ge=["number","int","float","bigint"];function ot(e,n){function t(r,a){let i=typeof r,s=typeof a;if(i!==s&&!Ge.includes(i)&&!Ge.includes(s))return!1;if(i==="undefined"&&s==="undefined")return!0;if(i==="boolean"||i==="symbol")return r===a;if(i==="number"||i==="bigint")try{let o=r.toString(),u=a.toString();return o===u}catch{return!1}if(i==="string"||i==="function")return r===a;if(i==="object"){if(r===null||a===null)return r===null&&a===null;{if(C(r))return C(a)?r.getTime()===a.getTime():!1;if(C(a))return!1;if(r instanceof RegExp&&a instanceof RegExp)return r.toString()===a.toString();if(f(r)!==f(a))return!1;let o=Object.keys(r).concat(Object.getOwnPropertySymbols(r)),u=Object.keys(a).concat(Object.getOwnPropertySymbols(a));if(o.length!==u.length)return!1;for(let h=0;h<o.length;h++){let c=o[h];if(!t(r[c],a[c]))return!1}return!0}}}try{return t(e,n)}catch{return t(V(e),V(n))}}var J=ot;function re(e){let n="abcdefg1234567890",t="";for(;t.length<e;)t+=n[Math.floor(Math.random()*n.length)];return t}var lt=re(16),ut=re(16),ht=re(16),ct=re(16),ft=re(16),mt=class{constructor(){this.clear()}get counts(){return this.values.map(e=>this.get(e))}get values(){return Object.values(this.valuesDict)}clear(){return this.countsDict={},this.valuesDict={},this}count(e){for(let n of e)f(n)?this.count(n):this.increment(n);return this}delete(e){let n=this.getStandardizedKey(e);return delete this.countsDict[n],delete this.valuesDict[n],this}get(e){return this.countsDict[this.getStandardizedKey(e)]||0}getStandardizedKey(e){return typeof e=="object"&&e===null?lt:g(e)?ut:D(e)?e.toString():typeof e=="symbol"?e.toString()+" - "+ft:e===1/0?ht:e===-1/0?ct:typeof e=="bigint"?e.toString():v(e)?e.toJSONString():y(e)?JSON.stringify(e.toObject()):JSON.stringify(e)}has(e){return!g(this.countsDict[this.getStandardizedKey(e)])}increment(e){return this.set(e,this.get(e)+1)}set(e,n){let t=this.getStandardizedKey(e);return this.countsDict[t]=n,this.valuesDict[t]=e,this}toArray(){return this.values.map(e=>({value:e,count:this.get(e)}))}toObject(){let e={};return this.values.forEach(n=>{e[n]=this.get(n)}),e}},dt=mt;function gt(e,n){n=n||{};let t=new dt,r={},a=B(e),i=[],s=-1/0,o=1/0,u=!1,h=0;for(let m of a){if(typeof m=="bigint"&&(u=!0),!n.shouldDropNaNs||d(m))try{m>s&&(s=m),m<o&&(o=m),h+=Number(m),i.push(m)}catch{s=NaN,o=NaN,h=NaN}t.increment(m)}let c=h/i.length;if(r.counts=t,r.max=s,r.mean=c,r.min=o,r.n=a.length,r.sum=h,isNaN(r.mean)&&(r.max=NaN,r.min=NaN),n.shouldDropNaNs&&(r.nWithoutNaNs=i.length),n.mode){let m=Array.from(t.values.map(N=>[N,t.get(N)])).toSorted((N,z)=>z[1]-N[1]),p=m[0][1],x=[];for(let N of m)if(N[1]==p)x.push(N[0]);else break;r.mode=x.toSorted()}if(n.median)if(isNaN(c))r.median=NaN;else{let m=i.toSorted((x,N)=>Number(x)-Number(N)),p=Math.floor(m.length/2);if(m.length%2===0){let x=m[p-1],N=m[p];if(r.median=(Number(x)+Number(N))/2,u&&typeof x=="bigint"&&typeof N=="bigint")try{r.median=BigInt(r.median)}catch{}}else r.median=m[p]}if(n.stdev||n.variance){let m=0;for(let x of i)m+=Math.pow(Number(x)-c,2);m/=i.length;let p=Math.sqrt(m);r.stdev=p,r.variance=m}if(u){try{r.sum=BigInt(r.sum)}catch{}try{r.mean=BigInt(r.mean)}catch{}n.mode&&(r.mode=r.mode.map(m=>{try{return BigInt(m)}catch{return m}}))}return r}var k=gt;function pt(e,n){let{counts:t}=k(e);return g(n)||(D(n)?t.values.forEach(r=>{n(r)||t.delete(r)}):t.values.forEach(r=>{J(r,n)||t.delete(r)})),t}var de=pt;function Se(e){if(v(e)||y(e))return Se(e.values);if(f(e)){let n=!1,t=!1,r=null;for(let a of e){if(Se(a))return!0;if(f(a)){if(r===null)r=a.length;else if(a.length!==r)return!0;n=!0}else t=!0;if(n&&t)return!0}}return!1}function yt(e){return Se(V(e))}var ae=yt;function _e(e){if(v(e)||y(e)){let t=e.copy();return t.values=_e(t.values),t.index=_e(t.index),t}l(f(e),"The `reverse` function only works on arrays, Series, and DataFrames!");let n=[];for(let t=e.length-1;t>=0;t--)n.push(e[t]);return n}var q=_e;function vt(e,n,t=1){l(!g(e)&&!g(n)&&!g(t),"You must pass two numbers and optionally a step value to the `range` function!"),l(d(e)&&d(n)&&d(t),"You must pass two numbers and optionally a step value to the `range` function!"),l(t>0,"The step value must be greater than 0! (NOTE: The step value is a magnitude; it does not indicate direction.)");let r=!1,a=typeof e=="bigint"||typeof n=="bigint"||typeof t=="bigint";if(e=Number(e),n=Number(n),t=Number(t),e>n){r=!0;let s=e;e=n+t,n=s+t}let i=[];for(let s=e;s<n;s+=t)if(a)try{i.push(BigInt(s))}catch{i.push(s)}else i.push(s);return r&&(i=q(i)),i}var T=vt;function ie(e){let n="abcdefg1234567890",t="";for(;t.length<e;)t+=n[Math.floor(Math.random()*n.length)];return t}var bt=ie(256),Nt=ie(256),xt=ie(256),wt=ie(256),Ot=ie(256);function hn(e){if(v(e)||y(e))return hn(e.values);l(f(e),"The `set` function only works on arrays, Series, and DataFrames!");let n=[],t={};return B(e).forEach(r=>{let a=typeof r=="object"&&r===null?bt:g(r)?Nt:D(r)?r.toString():typeof r=="symbol"?r.toString()+" - "+Ot:r===1/0?xt:r===-1/0?wt:typeof r=="bigint"?r.toString():v(r)?r.toJSONString():y(r)?JSON.stringify(r.toObject()):JSON.stringify(r);t[a]||n.push(r),t[a]=!0}),n}var E=hn;function cn(e,n,t){if(g(t)&&(t=0),l(t===0||t===1||t==="vertical"||t==="horizontal",'The only valid axis values for use when appending data to a DataFrame are 0, 1, "vertical", and "horizontal". Note that 0 == "horizontal" and 1 == "vertical".'),f(n)){l(!ae(n),"The array of data you're trying to append to this DataFrame is jagged!");let r=b(n);if(r.length===1)if(t===0){let a=e.copy();a._values.push(n);let i=Math.max(e.shape[1],r[0]);for(a._values.forEach(s=>{for(;s.length<i;)s.push(void 0)});a._index.length<a._values.length;)a._index.push("row"+a._index.length);for(;a._columns.length<i;)a._columns.push("col"+a._columns.length);return a}else{let a=Math.max(e.shape[0],r[0]),i=e.copy();for(T(0,a).forEach(s=>{s>=i._values.length&&i._values.push(P(e.shape[1])),i._values[s].push(n[s])});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<i._values[0].length;)i._columns.push("col"+i._columns.length);return i}else if(r.length===2)if(t===0){let a=Math.max(...n.map(s=>s.length).concat([e.shape[1]])),i=e.copy();for(i._values=i._values.concat(n).map(s=>{for(;s.length<a;)s.push(void 0);return s});i._index.length<i._values.length;)i._index.push("row"+i._index.length);for(;i._columns.length<a;)i._columns.push("col"+i._columns.length);return i}else{let a=Math.max(...n.map(o=>o.length))+e.shape[1],i=Math.max(e.shape[0],r[0]),s=e.copy();for(T(0,i).forEach(o=>{for(o>=s._values.length&&s._values.push(P(e.shape[1])),s._values[o]=s._values[o].concat(n[o]);s._values[o].length<a;)s._values[o].push(void 0)});s._index.length<s._values.length;)s._index.push("row"+s._index.length);for(;s._columns.length<a;)s._columns.push("col"+s._columns.length);return s}else throw new U("Only 1- and 2-dimensional arrays can be appended to a DataFrame!")}else if(y(n)){let r=cn(e,n.values,t);return t===0?r.index[r.index.length-1]=r.index.indexOf(n.name)>-1?n.name+" (2)":n.name:r.columns[r.columns.length-1]=r.columns.indexOf(n.name)>-1?n.name+" (2)":n.name,r}else if(v(n))if(t===0){let r=e.copy(),a=E(r._columns.concat(n._columns)).length;for(r._values.forEach(i=>{for(;i.length<a;)i.push(void 0)}),n.apply(i=>{let s=i.copy(),o=[];r._columns.forEach(u=>{let h=s._index.indexOf(u);h>-1?(o.push(s._values[h]),s._values.splice(h,1),s._index.splice(h,1)):o.push(void 0)}),r._values.push(o.concat(s._values))},1),r._columns=r._columns.concat(n._columns.filter(i=>r._columns.indexOf(i)<0));r._index.length<r._values.length;){let i="row"+r._index.length;r._index.push(i+(e._index.indexOf(i)>-1?" (2)":""))}return r}else{let r=e.copy();return r._index.forEach((a,i)=>{let s=n._index.indexOf(a);s>-1?r._values[i]=r._values[i].concat(n._values[s]):r._values[i]=r._values[i].concat(P(n.shape[1]))}),n._index.forEach((a,i)=>{r._index.indexOf(a)<0&&(r._index.push(a),r._values.push(P(r._columns.length).concat(n._values[i])))}),r._columns=r._columns.concat(n._columns.map(a=>a+(r._columns.indexOf(a)>-1?" (2)":""))),r}else throw new U("Only 1- or 2-dimensional arrays, Series, and DataFrames can be appended to a DataFrame!")}var St=cn;function _t(e,n,t,r,a){if(a=a||0,l(D(r),"The first parameter to the `apply` method must be a function."),l(a===0||a===1,"The second parameter to the `apply` method (the `axis`) must be 0 or 1."),a===0){let i={},s;if(t.columns.forEach((o,u)=>{let h=new n(t.values.map(m=>m[u]));h.name=o,h.index=t.index;let c=r(h,u,t);c instanceof n?i[o]=c.values:i[o]=c,g(s)&&(s=c instanceof n||f(c))}),s){let o=new e(i);return o.index=t.index,o}else{let o=new n(t.columns.map(u=>i[u]));return o.index=t.columns,o}}else if(a===1){let i,s=t.values.map((o,u)=>{let h=new n(o);h.name=t.index[u],h.index=t.columns;let c=r(h,u,t);return g(i)&&(i=c instanceof n||f(c)),c instanceof n?c.values:c});if(i){let o=new e(s);return o.index=t.index,o.columns=t.columns,o}else{let o=new n(s);return o.index=t.index,o}}}var Tt=_t;function Dt(e){return typeof e=="string"}var O=Dt;function Mt(e,n,t,r,a){let i=o=>o instanceof e,s=o=>o instanceof n;if(g(a)){if(i(r)||s(r))return t.append(r,1);if(A(r)){let o=Math.max(...Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(u=>r[u].length));return Object.keys(r).concat(Object.getOwnPropertySymbols(r)).forEach(u=>{for(;r[u].length<o;)r[u].push(void 0)}),t.append(new e(r),1)}else throw new U("You must pass a DataFrame, Series, or object into the `assign` method!")}else{l(O(r),"If passing two arguments into the `assign` method, then the first argument must be a string name!"),l(f(a)&&!ae(a)&&b(a).length===1,"If passing two arguments into the `assign` method, then the second argument must be a 1-dimensional array!");let o=t.append(a,1);return o.columns[o.columns.length-1]=r,o}}var jt=Mt;function It(e,n){if(n.isEmpty)return new e;let t=new e(M(n.values));return t.columns=n.columns.slice(),t.index=n.index.slice(),t}var Et=It;function kt(e,n,t,r,a){g(r)&&(r=[]),g(a)&&(a=[]),(O(r)||d(r))&&(r=[r]),(O(a)||d(a))&&(a=[a]),l(f(r),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),l(f(a),"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),l(b(r).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings."),l(b(a).length===1,"The `drop` method only works on 1-dimensional arrays of numerical indices and/or strings.");let i,s;t.index.forEach((u,h)=>{r.indexOf(u)<0&&r.indexOf(h)<0&&(i||(i=[]),i.push(u))}),t.columns.forEach((u,h)=>{a.indexOf(u)<0&&a.indexOf(h)<0&&(s||(s=[]),s.push(u))});let o=t.get(i,s);if(o instanceof n){let u=new e;u=u.assign(o),t.index.indexOf(o.name)>-1&&(u=u.transpose()),o=u}return o}var Ft=kt;function Pt(e){return an(e)&&e>=0}var Z=Pt;function Bt(e,n,t,r,a,i){r=r||0,l(r===0||r===1,"The first parameter of the `dropMissing` method (the `axis`) must be 0 or 1."),i=i||0,l(Z(i),"The third parameter of the `dropMissing` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` null values)."),a=i>0?"none":a||"any",l(a==="any"||a==="all"||a==="none","The second parameter of the `dropMissing` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains null values, then it should be dropped; or that if 'all' of the data contains null values, then it should be dropped).");function s(h){if(i>0){let c=0;for(let m=0;m<h.length;m++){let p=h[m];if(g(p)&&c++,c>=i)return[]}}else if(a==="any")for(let c=0;c<h.length;c++){let m=h[c];if(g(m))return[]}else if(a==="all"){for(let c=0;c<h.length;c++){let m=h[c];if(!g(m))return h}return[]}return h}let o=t.copy(),u=Math.random().toString();if(r===0){o=o.assign(u,o.index);let h=o.values.map(s).filter(m=>m.length>0);if(b(h).length<2)return new e;o.values=h;let c=o.get(null,u);if(g(c))return new e;O(c)&&(c=[c]),c instanceof n&&(c=c.values),o.index=c,o=o.drop(null,u)}else if(r===1){let h={};if(o.columns.forEach((m,p)=>{let x=o.values.map(z=>z[p]),N=s(x);N.length>0&&(h[m]=N)}),Object.keys(h).length+Object.getOwnPropertySymbols(h).length===0)return new e;let c=new e(h);return c.index=o.index,c}return o}var At=Bt;function fn(e){if(v(e)||y(e))return e.dropNaN(...Object.values(arguments).slice(1));l(f(e),"The `dropNaN` function only works on arrays, Series, and DataFrames!");let n=[];return e.forEach(t=>{try{return n.push(fn(t))}catch{if(d(t))return n.push(t)}}),n}var mn=fn;function Jt(e,n,t,r,a){t=t||0,l(t===0||t===1,"The first parameter of the `dropNaN` method (the `axis`) must be 0 or 1."),a=a||0,l(Z(a),"The third parameter of the `dropNaN` method (the `threshold`) should be a whole number (meaning that data should be dropped if it contains more than `threshold` NaN values)."),r=a>0?"none":r||"any",l(r==="any"||r==="all"||r==="none","The second parameter of the `dropNaN` method (the `condition` parameter, which indicates the condition under which data should be dropped) should be 'any' or 'all' (meaning that if 'any' of the data contains NaN values, then it should be dropped; or that if 'all' of the data contains NaN values, then it should be dropped).");function i(o){let u=mn(o);return a>0?o.length-u.length<a:r==="any"?u.length===o.length:r==="all"?u.length>0:!0}let s=n.copy();if(t===0){let o=s.index.filter(u=>{let h=s.get(u,null).values;return i(h)});return o.length>0?s.get(o,null):new e}else if(t===1){let o=s.columns.filter(u=>{let h=s.get(null,u).values;return i(h)});return o.length>0?s.get(null,o):new e}return s}var $t=Jt;function Ke(e){let n={};return B(e).forEach((t,r)=>{n[t]=r}),n}function L(e){return Object.keys(e).concat(Object.getOwnPropertySymbols(e)).sort((n,t)=>e[n]-e[t])}function zt(e,n,t,r,a){l(D(r),"The `filter` method takes a single parameter: a function that is used to filter the values."),g(a)&&(a=0),l(a===0||a===1,"The `axis` parameter to the `filter` method must be 0 or 1.");let i=t.copy();if(i.isEmpty)return i;let s=Ke(i.index),o=Ke(i.columns);if(a===0){let u=0,h=i.values.filter((c,m)=>{let p=new n(c);p.name=t.index[m],p.index=t.columns;let x=r(p,m,t);return x?u++:delete s[i.index[m]],x});if(u===0)return new e;if(u===1){let c=new n(h[0]);return c.name=L(s)[0],c.index=L(o),c}i.values=h,i.index=L(s)}else if(a===1){i=i.transpose();let u=0,h=i.values.filter((c,m)=>{let p=new n(c);p.name=t.columns[m],p.index=t.index;let x=r(p,m,t);return x?u++:delete o[i.index[m]],x});if(u===0)return new e;if(u===1){let c=new n(h[0]);return c.name=L(o)[0],c.index=L(s),c}i.values=h,i.index=L(o),i=i.transpose()}return i}var Ct=zt;function Rt(e,n,t){(O(n)||d(n))&&(n=[n]),(O(t)||d(t))&&(t=[t]);for(let a in n)typeof n[a]=="bigint"&&(n[a]=Number(n[a]));for(let a in t)typeof t[a]=="bigint"&&(t[a]=Number(t[a]));let r=E((n||[]).concat(t||[]).map(a=>typeof a));return l(r.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===1&&l(r[0]==="string"||r[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),r.length===2&&(l(r.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),l(r.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),g(n)||(n=n.map(a=>{if(O(a))return l(e.index.indexOf(a)>-1,`Row "${a}" does not exist!`),a;if(d(a))return l(a>=0,`Index ${a} is out of bounds!`),l(Math.floor(a)===a,"Row numbers must be integers!"),l(a<e.index.length,`Index ${a} is out of bounds!`),e.index[a]})),g(t)||(t=t.map(a=>{if(O(a))return l(e.columns.indexOf(a)>-1,`Column "${a}" does not exist!`),a;if(d(a))return l(a>=0,`Column ${a} is out of bounds!`),l(Math.floor(a)===a,"Column numbers must be integers!"),l(a<e.columns.length,`Column ${a} is out of bounds!`),e.columns[a]})),e.getSubsetByNames(n,t)}var Yt=Rt;function qt(e,n){try{return e<n?-1:e>n?1:0}catch{return e=typeof e=="object"&&e!==null?JSON.stringify(e):e.toString(),n=typeof n=="object"&&n!==null?JSON.stringify(n):n.toString(),e<n?-1:e>n?1:0}}function Ut(e,n){if(g(n)&&(n=qt),v(e)||y(e))return e.sort(...Object.values(arguments).slice(1));l(f(e),"The `sort` function only works on arrays, Series, and DataFrames!"),l(D(n),"The second parameter of the `sort` function must be a comparison function!");let t=e.slice();return t.sort(n),t}var G=Ut;function Wt(e){let n=e.toLowerCase(),t="";for(let a=0;a<n.length;a++){let i=n[a];i.match(/[a-z0-9]/g)?t+=i:t+=" "}let r=t.split(" ").filter(a=>a.length>0);return r[0]+r.slice(1).map(a=>a[0].toUpperCase()+a.substring(1)).join("")}function Gt(e,n,t){g(t)?t=n.columns:O(t)&&(t=[t]);let r={};t.forEach(i=>{l(O(i),"You must pass either a string or a one-dimensional array of strings into the `getDummies` (AKA `oneHotEncode`) method!");let s=n.columns.indexOf(i);l(s>-1,`The given DataFrame does not have a column called "${i}"!`);let o=n.values.map(h=>h[s]),u=G(E(o));o.forEach(h=>{u.forEach(c=>{let m=i+"_"+Wt(c.toString());r[m]||(r[m]=[]),h===c?r[m].push(1):r[m].push(0)})})});let a=new e(r);return a.index=n.index,a}var Le=Gt;function Kt(e,n,t){let r=e.shape;g(n)&&(n=T(0,r[0])),g(t)&&(t=T(0,r[1])),d(n)&&(n=[n]),d(t)&&(t=[t]),l(f(n)&&f(t),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),l(b(n).length===1&&b(t).length===1,"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),l(n.length>0,"The `rowIndices` array must contain at least one index."),l(t.length>0,"The `colIndices` array must contain at least one index."),n.forEach(s=>{l(Z(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),l(s<e.index.length,`The row index ${s} is out of bounds.`)}),t.forEach(s=>{l(Z(s),"The `rowIndices` and `colIndices` parameters must be 1-dimensional arrays of whole numbers."),l(s<e.columns.length,`The column index ${s} is out of bounds.`)});let a=n.map(s=>e.index[s]),i=t.map(s=>e.columns[s]);return e.getSubsetByNames(a,i)}var Lt=Kt;function Ht(e,n,t,r,a){g(r)&&(r=t.index),g(a)&&(a=t.columns),O(r)&&(r=[r]),O(a)&&(a=[a]),l(f(r)&&f(a),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),l(b(r).length===1&&b(a).length===1,"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),l(r.length>0,"The `rows` array must contain at least one row name."),l(a.length>0,"The `cols` array must contain at least one column name."),r.forEach(o=>{l(O(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),l(t.index.indexOf(o)>-1,`The row name "${o}" does not exist in the list of rows.`)}),a.forEach(o=>{l(O(o),"The `rows` and `cols` parameters must be 1-dimensional arrays of strings."),l(t.columns.indexOf(o)>-1,`The column name "${o}" does not exist in the list of columns.`)});let i=r.map(o=>a.map(u=>t.values[t.index.indexOf(o)][t.columns.indexOf(u)]));if(r.length===1&&a.length===1)return i[0][0];if(r.length===1){let o=new n(i[0]);return o.name=r[0],o.index=a,o}if(a.length===1){let o=new n(i.map(u=>u[0]));return o.name=a[0],o.index=r,o}let s=new e(i);return s.columns=a,s.index=r,s}var Vt=Ht;function Xt(e,n,t){function r(p,x){return O(p)&&p.length>x?p.substring(0,x-3)+"...":p}if(t.isEmpty)return console.table({}),console.log("Shape:",[0,0],`
`),t;let a=typeof window>"u"?20:10,i=Math.floor(a/2),s=typeof process>"u"?10:Math.floor(process.stdout.columns/24)-1,o=Math.floor(s/2),u=a>t.index.length?null:T(0,i).concat(T(t.index.length-i,t.index.length)),h=s>t.columns.length?null:T(0,o).concat(T(t.columns.length-o,t.columns.length)),c=t.get(u,h);c instanceof n&&(t.shape[0]===1?(c=new e([c.values]),c.index=t.index,c.columns=new n(t.columns).get(h).values):t.shape[1]===1&&(c=new e([c.values]).transpose(),c.index=new n(t.index).get(u).values,c.columns=t.columns)),a<=t.index.length&&(c._index.splice(i,0,"..."),c._values.splice(i,0,T(0,c.columns.length).map(()=>"..."))),s<=t.columns.length&&(c._columns.splice(o,0,"..."),c._values=c._values.map(p=>(p.splice(o,0,"..."),p)));let m=28;return c instanceof n?(c.values=c.values.map(p=>r(p,m)),c.name=r(c.name,m),c.index=c.index.map(p=>r(p,m))):(c.values=c.values.map(p=>p.map(x=>r(x,m))),c.columns=c.columns.map(p=>r(p,m)),c.index=c.index.map(p=>r(p,m))),console.table(c.toDetailedObject()),console.log("Shape:",t.shape,`
`),t}var Zt=Xt;function Qt(e,n){l(d(e),"The `leftPad` function only works on numbers!");let t=e.toString();for(;t.length<n;)t="0"+t;return t}var H=Qt;function er(e,n){let t=n?e:e.copy();return t.index=T(0,e.shape[0]).map(r=>"row"+H(r,(t.index.length-1).toString().length)),t}var nr=er;function tr(e){if(v(e)||y(e))return e.shuffle(...Object.values(arguments).slice(1));l(f(e),"The `shuffle` function only works on arrays, Series, and DataFrames!");let n=[],t=e.slice();for(let r=0;r<e.length;r++){let a=Math.floor(X()*t.length);n.push(t.splice(a,1)[0])}return n}var ge=tr;function rr(e,n){return g(n)&&(n=0),l(n===0||n===1,"The `axis` parameter to the `shuffle` must be 0, 1, or undefined."),e.get(n===0?ge(e.index):null,n===1?ge(e.columns):null)}var ar=rr;function ir(e){return typeof e=="boolean"}var W=ir;function sr(e,n,t){return D(n)?or(e,n,t):lr(e,n,t)}function or(e,n,t){if(t=g(t)?0:t,l(D(n),"When sorting a DataFrame using a function, the first argument to the `sort` method must be a function!"),l(d(t),"When sorting a DataFrame using a function, the second argument to the `sort` method must be null, undefined, 0, or 1 to indicate the axis along which the data should be sorted! An axis of 0 means that the rows will be sorted relative to each other, whereas an axis of 1 means that the columns will be sorted relative to each other."),t===0){let r=G(e.index,(a,i)=>n(e.get(a,null),e.get(i,null)));return e.get(r,null)}else{let r=G(e.columns,(a,i)=>n(e.get(null,a),e.get(null,i)));return e.get(null,r)}}function lr(e,n,t){let r=e.copy(),a=X().toString();r=r.assign(a,r.index),g(n)&&(n=[a],t=[!0]),(d(n)||O(n))&&(n=[n],(W(t)||O(t))&&(t=[t])),l(f(n),"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),l(b(n).length===1,"The first parameter of the `sort` method must be (1) a string or index representing a column name or index, respectively; (2) a 1-dimensional array of strings and/or indices; or (3) null."),g(t)&&(t=T(0,n.length).map(()=>!0)),l(f(t),"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),l(b(t).length===1,"The second parameter of the `sort` method must be (1) a string or boolean representing the sort direction ('ascending' / 'descending', or true / false); (2) a 1-dimensional array of strings and/or booleans; or (3) null."),l(n.length===t.length,"The arrays passed into the `sort` method must be equal in length."),n=n.map(s=>{if(l(O(s)||d(s),"Column references can either be column names (as strings) or column indices (as whole numbers)."),O(s)){let o=r.columns.indexOf(s);return l(o>-1,`The column "${s}" does not exist!`),o}if(d(s))return l(Z(s),"Column indices must be whole numbers!"),l(s<r.columns.length,`The index ${s} is out of bounds!`),s}),t=t.map(s=>{if(l(O(s)||W(s),"Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),O(s)){let o=s.trim().toLowerCase();return l(o==="ascending"||o==="descending","Direction references can either be strings ('ascending' or 'descending') or booleans (true or false)."),o==="ascending"}if(W(s))return s}),r.values=G(r.values,(s,o)=>{let u=0;for(;s[n[u]]===o[n[u]]&&u<n.length;)u++;let h=t[u];if(s[n[u]]===o[n[u]])return 0;if(s[n[u]]<o[n[u]])return h?-1:1;if(s[n[u]]>o[n[u]])return h?1:-1});let i=r.columns.indexOf(a);return r.index=r.values.map(s=>s[i]),r=r.dropColumns(a),r}var ur=sr;function hr(e,n){g(n)?n=0:l(n===0||n===1,"The axis parameter of the `toDetailedObject` method must be undefined, 0, or 1. An axis of 0 indicates that the returned object should be organized first by rows and then by columns. An axis of 1 indicates that the returned object should be organized first by columns and then by rows.");let t={};return n===0?e.index.forEach((r,a)=>{let i={};e.columns.forEach((s,o)=>{i[s]=e.values[a][o]}),t[r]=i}):e.columns.forEach((r,a)=>{let i={};e.index.forEach((s,o)=>{i[s]=e.values[o][a]}),t[r]=i}),t}var cr=hr;function fr(e,n){return JSON.stringify(e.toObject(n))}var dn=fr;async function mr(e,n,t){let r=dn(e,t),a=!1,i=!1,s,o;try{let u=n;if(n.includes("/")){let c=n.split("/");u=c[c.length-1]}let h=document.createElement("a");h.href=`data:application/json;charset=utf-8,${encodeURIComponent(r)}`,h.download=u,h.dispatchEvent(new MouseEvent("click")),a=!0}catch(u){s=u}try{let u=await import("node:fs"),h=await import("node:path");u.writeFileSync(h.resolve(n),r,"utf8"),i=!0}catch(u){o=u}if(!a&&!i)throw typeof window<"u"?new U(s):typeof module<"u"?new U(o):new U("I don't know what's going wrong, but it doesn't seem like you're in Node or the browser, and we couldn't download and/or write the file to disk!");return e}var dr=mr;function gr(e){let n={};return e.columns.forEach(t=>{n[t]=e.get(t).values}),n}var pr=gr;function yr(e){if(v(e)||y(e))return e.transpose();l(f(e),"The `transpose` function only works on arrays, Series, and DataFrames!");let n=b(e);if(l(n.length<=2,"I'm not smart enough to know how to transpose arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `transpose` function!"),n.length===1)return q(e);if(n.length===2){let t=P(q(n));for(let r=0;r<n[0];r++)for(let a=0;a<n[1];a++)t[a][r]=e[r][a];return t}}var R=yr;function gn(e,n,t){if(y(t))return new e(n.values.concat(t.values));if(f(t)){let r=b(t);l(r.length===1&&!Ae(r),"Only vectors can be appended to Series!");let a=n.copy();return t.forEach((i,s)=>{a._values.push(i),a._index.push("item"+(n.values.length+s))}),a}return gn(n,[t])}var vr=gn;function br(e,n){l(D(n),"The parameter to the `apply` method must be a function.");let t=e.copy();return t._values=t._values.map((r,a)=>n(r,a)),t}var Nr=br;function xr(e){let n=e.copy(),t=[];return n._values=n.values.filter((r,a)=>g(r)?!1:(t.push(n.index[a]),!0)),n._index=t,n}var wr=xr;function Or(e,n){let t=[],r=[];n.values.forEach((i,s)=>{d(i)&&(r.push(i),t.push(n.index[s]))});let a=new e(r);return a.name=n.name,a.index=t,a}var Sr=Or;function _r(e,n,t){let r=n.copy(),a=M(r.index),i=[],s=r.values.filter((o,u)=>{let h=t(o,u,r.values);return h||i.push(r.index[u]),h});return i.forEach(o=>{a.splice(a.indexOf(o),1)}),s.length===0?(r=new e,r.name=n.name,r):(r.values=s,r.index=a,r)}var Tr=_r;function Dr(e,n){(O(n)||d(n))&&(n=[n]);for(let r in n)typeof n[r]=="bigint"&&(n[r]=Number(n[r]));let t=E((n||[]).map(r=>typeof r));return l(t.length<=2,"Only whole numbers and/or strings are allowed in `get` arrays!"),t.length===1&&l(t[0]==="string"||t[0]==="number","Only whole numbers and/or strings are allowed in `get` arrays!"),t.length===2&&(l(t.indexOf("string")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!"),l(t.indexOf("number")>-1,"Only whole numbers and/or strings are allowed in `get` arrays!")),g(n)||(n=n.map(r=>{if(typeof r=="string")return l(e.index.indexOf(r)>-1,`Index "${r}" does not exist!`),r;if(typeof r=="number")return l(r>=0,`Index ${r} is out of bounds!`),l(Math.floor(r)===r,"Indices must be integers!"),l(r<e.index.length,`Index ${r} is out of bounds!`),e.index[r]})),e.getSubsetByNames(n)}var Mr=Dr;function jr(e,n){let t=e.shape;g(n)&&(n=T(0,t[0])),l(f(n),"The `indices` array must be 1-dimensional array of whole numbers."),l(b(n).length===1,"The `indices` array must be a 1-dimensional array of whole numbers."),l(n.length>0,"The `indices` array must contain at least one index."),n.forEach(a=>{l(Z(a),"The `indices` array must be a 1-dimensional array of whole numbers."),l(a<e.index.length,`The row index ${a} is out of bounds.`)});let r=n.map(a=>e.index[a]);return e.getSubsetByNames(r)}var Ir=jr;function Er(e,n,t){g(t)&&(t=n.index),l(f(t),"The `indices` array must be a 1-dimensional array of strings."),l(b(t).length===1,"The `indices` array must be a 1-dimensional array of strings."),l(t.length>0,"The `indices` array must contain at least one index name."),t.forEach(i=>{l(O(i),"The `indices` array must contain only strings."),l(n.index.indexOf(i)>-1,`The name "${i}" does not exist in the index.`)});let r=t.map(i=>n.values[n.index.indexOf(i)]);if(r.length===1)return r[0];let a=new e(r);return a.index=t,a.name=n.name,a}var kr=Er;function Fr(e){let n=e.copy(),t=typeof window>"u"?20:10;if(n.index.length>t){n=n.get(T(0,t/2).concat(T(n.index.length-t/2,n.index.length)));let a=M(n.index);a.splice(Math.floor(a.length/2),0,"..."),n.values.push("..."),n.index.push("..."),n=n.get(a)}let r={};return n.values.forEach((a,i)=>{let s={};s[n.name]=a,r[n.index[i]]=s}),console.table(r),console.log("Shape:",e.shape,`
`),e}var Pr=Fr;function Br(e){let n=e.copy();return n.get(ge(n.index))}var Ar=Br;function Jr(e,n,t){t=t||((u,h)=>u<h?-1:1),l(g(t)||D(t),"You must pass undefined, null, or a comparison function as the second argument to the `sort` method!");let r=R([n.values,n.index]),a=G(r,(u,h)=>t(u[0],h[0])),i=[],s=[];a.forEach(u=>{i.push(u[0]),s.push(u[1])});let o=new e;return o._values=i,o._index=s,o.name=n.name,o}var $r=Jr;function zr(e,n){let t=R([n.values,n.index]);t=R(G(t,(a,i)=>{if(a[1]===i[1])return 0;if(a[1]<i[1])return-1;if(a[1]>i[1])return 1}));let r=new e(t[0]);return r.index=t[1],r.name=n.name,r}var Cr=zr;function Rr(e){let n={};return n[e.name]={},e.index.forEach((t,r)=>{n[e.name][t]=e.values[r]}),n}var Yr=Rr,He=Symbol.for("@jrc03c/js-math-tools/series");function qr(e){class n{static[Symbol.hasInstance](r){try{return!!r._symbol&&r._symbol===He}catch{return!1}}constructor(r){if(this.name="data",Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:He}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values},set(a){l(f(a),"The new values must be a 1-dimensional array!");let i=b(a);l(i.length===1,"The new array of values must be 1-dimensional!"),i[0]<this._index.length?this._index=this._index.slice(0,i[0]):i[0]>this._index.length&&(this._index=this._index.concat(T(this._index.length,i[0]).map(s=>"item"+H(s,(a.length-1).toString().length)))),this._values=a}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(a){l(f(a),"The new index must be a 1-dimensional array of strings!"),l(a.length===this.shape[0],"The new index must be the same length as the old index!"),l(b(a).length===1,"The new index must be a 1-dimensional array of strings!"),a.forEach(i=>{l(O(i),"All of the row names must be strings!")}),this._index=a}}),r){if(r instanceof n)this.name=r.name,this.values=M(r.values),this.index=M(r.index);else if(f(r)){let a=b(r);l(a.length===1,"When passing an array into the constructor of a Series, the array must be 1-dimensional!"),this.values=r}else if(r instanceof Object){let a=Object.keys(r).concat(Object.getOwnPropertySymbols(r)).map(o=>o.toString());l(a.length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!");let i=a[0],s=r[i];l(b(s).length===1,"When passing an object into the constructor of a Series, the object must have only 1 key-value pair, where the key is the name of the data and the value is the 1-dimensional array of values!"),this.name=i,this.values=s.slice()}}}get shape(){return b(this.values)}get length(){return this.shape[0]}get isEmpty(){return this.values.filter(r=>!g(r)).length===0}clear(){let r=this.copy();return r.values.forEach((a,i)=>{r.values[i]=void 0}),r}get(r){return Mr(this,r)}getSubsetByNames(r){return kr(n,this,r)}getSubsetByIndices(r){return Ir(this,r)}loc(r){return this.getSubsetByNames(r)}iloc(r){return this.getSubsetByIndices(r)}reverse(){let r=new n(q(this.values));return r.index=q(this.index),r.name=this.name,r}resetIndex(){let r=this.copy();return r.index=T(0,this.shape[0]).map(a=>"item"+H(a,(r.index.length-1).toString().length)),r}copy(){let r=new n;return r._values=M(this.values),r._index=M(this.index),r.name=this.name,r}append(r){return vr(n,this,r)}apply(r){return Nr(this,r)}concat(r){return this.append(r)}dropMissing(r,a){return wr(this,r,a)}dropNaN(){return Sr(n,this)}toObject(){return Yr(this)}print(){return Pr(this)}shuffle(){return Ar(this)}sort(r){return $r(n,this,r)}sortByIndex(){return Cr(n,this)}filter(r){return Tr(n,this,r)}toDataFrame(){let r=new e(R([this.values]));return r.columns=[this.name],r.index=this.index,r}transpose(){let r=this.copy();return r.values=q(r.values),r.index=q(r.index),r}getDummies(){return this.toDataFrame().getDummies()}oneHotEncode(){return this.getDummies()}}return n}var Ve=Symbol.for("@jrc03c/js-math-tools/dataframe");function oe(e){let n="abcdefghijklmnopqrstuvwxyz1234567890",t="";for(let r=0;r<e;r++)t+=n[Math.floor(X()*n.length)];return t}var _=class{static[Symbol.hasInstance](e){try{return!!e._symbol&&e._symbol===Ve}catch{return!1}}constructor(e){if(Object.defineProperty(this,"_symbol",{configurable:!1,enumerable:!1,writable:!1,value:Ve}),Object.defineProperty(this,"_values",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"values",{configurable:!0,enumerable:!0,get(){return this._values.length===0||!g(this._values[0])&&this._values[0].length===0?[[]]:this._values},set(n){l(f(n),"The new values must be a 2-dimensional array!");let t=b(n);l(t.length===2,"The new array of values must be 2-dimensional!"),t[0]<this._index.length?this._index=this._index.slice(0,t[0]):t[0]>this._index.length&&(this._index=this._index.concat(T(this._index.length,t[0]).map(r=>"row"+H(r,(t[0]-1).toString().length)))),t[1]<this._columns.length?this._columns=this._columns.slice(0,t[1]):t[1]>this._columns.length&&(this._columns=this._columns.concat(T(this._columns.length,t[1]).map(r=>"col"+H(r,(t[1]-1).toString().length)))),this._values=n}}),Object.defineProperty(this,"_columns",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"columns",{configurable:!0,enumerable:!0,get(){return this._columns},set(n){l(f(n),"The new columns list must be a 1-dimensional array of strings!"),l(this.isEmpty||n.length===this.shape[1],"The new columns list must be the same length as the old columns list!"),l(b(n).length===1,"The new columns list must be a 1-dimensional array of strings!"),n=n.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+oe(8):r.trim()));let t=(()=>{let r=de(n),a={};return r.values.forEach(i=>{a[i]=r.get(i)}),a})();n=n.map(r=>t[r]>1?r+"_"+oe(8):r),this._columns=n}}),Object.defineProperty(this,"_index",{value:[],configurable:!0,enumerable:!1,writable:!0}),Object.defineProperty(this,"index",{configurable:!0,enumerable:!0,get(){return this._index},set(n){l(f(n),"The new index must be a 1-dimensional array of strings!"),l(this.isEmpty||n.length===this.shape[0],"The new index must be the same length as the old index!"),l(b(n).length===1,"The new index must be a 1-dimensional array of strings!"),n=n.map(r=>(typeof r!="string"&&(r=JSON.stringify(r)||r.toString()),r.trim().length===0?"untitled_"+oe(8):r.trim()));let t=(()=>{let r=de(n),a={};return r.values.forEach(i=>{a[i]=r.get(i)}),a})();n=n.map(r=>t[r]>1?r+"_"+oe(8):r),this._index=n}}),l(g(e)||A(e)||f(e),"The `data` passed into the constructor of a DataFrame must be either (1) an object where the key-value pairs are (respectively) column names and 1-dimensional arrays of values, or (2) a 2-dimensional array of values."),e)if(e instanceof _)this.values=M(e.values),this.columns=M(e.columns),this.index=M(e.index);else if(f(e)){let n=b(e);l(n.length===2,"The `data` array passed into the constructor of a DataFrame must be 2-dimensional!"),l(!ae(e),"The 2-dimensional array passed into the constructor of a DataFrame must not contain sub-arrays (i.e., rows) of different lengths!"),this.values=e}else{this._columns=Object.keys(e).concat(Object.getOwnPropertySymbols(e)).map(i=>i.toString());let n=[],t=null,r=null;this._columns.forEach(i=>{g(r)&&(t=i,r=e[i].length),l(e[i].length===r,`The object passed into the DataFrame constructor contains arrays of different lengths! The key "${t}" points to an array containing ${r} items, and the key "${i}" points to an array containing ${e[i].length} items.`),r=e[i].length;let s=e[i];n.push(s)}),this._values=R(n);let a=b(this.values);this._index=T(0,a[0]).map(i=>"row"+H(i,(a[0]-1).toString().length))}}get shape(){return b(this.values)}get length(){return this.shape[0]}get width(){return this.shape[1]}get rows(){return this.index}set rows(e){this.index=e}get isEmpty(){return this.values.length===0||this.values.every(e=>e.length===0)}clear(){let e=new _(P(this.shape));return e.columns=this.columns.slice(),e.index=this.index.slice(),e}get(e,n){if(arguments.length===0)return this;if(arguments.length===1)try{return this.get(null,e)}catch{return this.get(e,null)}return Yt(this,e,n)}getSubsetByNames(e,n){return Vt(_,I,this,e,n)}getSubsetByIndices(e,n){return Lt(this,e,n)}getDummies(e){return Le(_,this,e)}oneHotEncode(e){return Le(_,this,e)}transpose(){let e=new _(R(this.values));return e.columns=this.index.slice(),e.index=this.columns.slice(),e}get T(){return this.transpose()}resetIndex(e){return nr(this,e)}copy(){return Et(_,this)}assign(e,n){return jt(_,I,this,e,n)}apply(e,n){return Tt(_,I,this,e,n)}dropMissing(e,n,t){return At(_,I,this,e,n,t)}dropNaN(e,n,t){return $t(_,this,e,n,t)}drop(e,n){return Ft(_,I,this,e,n)}dropColumns(e){return this.drop(null,e)}dropRows(e){return this.drop(e,null)}toDetailedObject(e){return cr(this,e)}toObject(){return pr(this)}toJSONString(e){return dn(this,e)}saveAsJSON(e,n){return dr(this,e,n)}print(){return Zt(_,I,this)}sort(e,n){return ur(this,e,n)}sortByIndex(){return this.sort()}filter(e,n){return Ct(_,I,this,e,n)}shuffle(e){return ar(this,e)}append(e,n){return St(this,e,n)}concat(e,n){return this.append(e,n)}join(e,n){return this.append(e,n)}toString(){return JSON.stringify(this)}},I=qr(_);function Ur(e,n){return k(e,{shouldDropNaNs:n}).max}var Ne=Ur;function Wr(e){return l(D(e),"You must pass a function into the `vectorize` function!"),function n(){let t,r,a=[],i=[],s=Object.keys(arguments).filter(o=>{let u=arguments[o];return f(u)?!0:y(u)?(t=!0,a.push(u),!0):v(u)?(r=!0,i.push(u),!0):!1}).map(o=>arguments[o]);if(s.slice(0,-1).forEach((o,u)=>{l(J(f(o)?b(o):o.shape,f(s[u+1])?b(s[u+1]):s[u+1].shape),`When passing multiple arrays into the \`${e.name}\` function, all of the arrays must have the same shape!`)}),s.length>0){let o=Ne(s.map(h=>h.length?h.length:h.values.length)),u=T(0,o).map(h=>{let c=Object.keys(arguments).map(m=>f(arguments[m])?arguments[m][h]:y(arguments[m])||v(arguments[m])?arguments[m].values[h]:arguments[m]);return n(...c)});if(r)try{if(i.length===1&&J(b(i[0]),b(u))){let h=new _(u);return h.index=i[0].index.slice(),h.columns=i[0].columns.slice(),h}else return new _(u)}catch{return u}if(t)try{if(a.length===1&&a[0].length===u.length){let h=new I(u);return h.name=a[0].name,h.index=a[0].index.slice(),h}else return new I(u)}catch{return u}return u}else return e(...arguments)}}var w=Wr;function Te(e){if(v(e)||y(e)){let n=e.copy();return n.values=Te(n.values),n}if(f(e))return e.map(n=>Te(n));try{let n=JSON.parse(e);return d(n)?typeof n=="bigint"?Number(n):n>=0?Math.floor(n):Math.ceil(n):NaN}catch{return NaN}}var $=w(Te);function pe(e,n){function*t(r,a){if(a>r.length)yield r;else if(a<=0)yield[];else if(r.length<2)yield r;else for(let i=0;i<r.length;i++){let s=r[i],o=r.slice(i+1);if(!(o.length<a-1)&&a-1>=0)for(let u of pe(o,a-1))yield[s].concat(u)}}return v(e)||y(e)?pe(e.values,n):(l(f(e),"The `combinations` function only works on arrays, Series, and DataFrames!"),l(d(n)&&$(n)===n&&n>=0,"`r` must be a non-negative integer!"),t(B(e),n))}function pn(e,n){let t=[];for(let r of pe(e,n))t.push(r.slice());return t}function Gr(e){d(e)&&(e=[e]);let n=[],t=be(e);for(let r=0;r<t;r++)n.push(0);return Je(n,e)}var $e=Gr;function ze(e,n){function*t(r,a){if(a=a||r.length,r.length===1){yield[r];return}for(let i of pn(r,a)){if(!i.slice)continue;let s=$e(i.length);yield i;let o=1;for(;o<i.length;)if(s[o]<o){if(o%2===0){let u=i[0];i[0]=i[o],i[o]=u}else{let u=i[s[o]];i[s[o]]=i[o],i[o]=u}yield i,s[o]+=1,o=1}else s[o]=0,o+=1}}return v(e)||y(e)?ze(e.values,n):(l(f(e),"The `permutations` function only works on arrays, Series, and DataFrames!"),g(n)&&(n=e.length),l(d(n)&&$(n)===n&&n>=0,"`r` must be a non-negative integer!"),t(B(e),n))}function Kr(e,n){let t=[];for(let r of ze(e,n))t.push(r.slice());return t}function Xe(e,n){l(D(e),"`fn` must be a function!");let t=new Date;return n?e(...n):e(),new Date-t}async function Lr(e,n){l(D(e),"`fn` must be a function!");let t=new Date;return n?await e(...n):await e(),new Date-t}function Hr(e){try{return d(e)?typeof e=="bigint"?e<0?-e:e:Math.abs(e):NaN}catch{return NaN}}var Ce=w(Hr);function Vr(){try{let e=0,n=!1,t=Object.values(arguments);for(let r of t){if(!d(r))return NaN;typeof r=="bigint"&&(n=!0,r=Number(r)),e+=r}if(n)try{return BigInt(e)}catch{}return e}catch{return NaN}}var ye=w(Vr);function Xr(e,n){try{return n(e)}catch{return NaN}}var xe=w(Xr);function Zr(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.acos(e)):NaN}catch{return NaN}}var Qr=w(Zr);function ea(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.asin(e)):NaN}catch{return NaN}}var na=w(ea);function ta(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.atan(e)):NaN}catch{return NaN}}var ra=w(ta);function De(e,n){if(v(e)){let t=De(e.values,n);return[e.index[t[0]],e.columns[t[1]]]}if(y(e)){let t=De(e.values,n);return e.index[t]}l(f(e),"The `argmax` function only works on arrays, Series, and DataFrames!");try{let t=ve(e,Ne(e,n));return t?t.length===0?void 0:t.length===1?t[0]:t:void 0}catch{return}}var aa=De;function ia(e,n){return k(e,{shouldDropNaNs:n}).min}var yn=ia;function Me(e,n){if(v(e)){let t=Me(e.values,n);return[e.index[t[0]],e.columns[t[1]]]}if(y(e)){let t=Me(e.values,n);return e.index[t]}l(f(e),"The `argmin` function only works on arrays, Series, and DataFrames!");try{let t=ve(e,yn(e,n));return t?t.length===0?void 0:t.length===1?t[0]:t:void 0}catch{return}}var sa=Me;function F(e,n){if(v(e)||y(e))return e.apply(t=>F(t,n));if(f(e))return e.map(t=>F(t,n));if(n==="null")return null;if(n==="number"){if(g(e))return NaN;let t=F(e,"boolean");if(W(t))return t?1:0;try{JSON.parse(e)}catch{let a=F(e,"date");if(C(a))return a.getTime()}let r=parseFloat(e);return isNaN(r)?NaN:r}if(n==="int"){let t=F(e,"number");return t>=0?Math.floor(t):Math.ceil(t)}if(n==="float")return F(e,"number");if(n==="bigint")return typeof e=="bigint"?e:BigInt(F(e,"int"));if(n==="boolean"){if(W(e))return e;if(d(e))return e===0?!1:e===1?!0:null;try{let t=(typeof e=="object"?e.toString()==="null"?"false":JSON.stringify(e):e.toString()).trim().toLowerCase();return t==="true"||t==="yes"||t==="y"?!0:t==="false"||t==="no"||t==="n"?!1:null}catch{return null}}if(n==="date"){if(C(e))return e;if(g(e))return null;let t=parseFloat(e);if(!isNaN(t)){let a=new Date(e);return C(a)?a:null}let r=Date.parse(e);return isNaN(r)?null:new Date(r)}if(n==="object"){if(A(e))return e;let t=F(e,"boolean");if(W(t))return null;try{let a=F(e,"number");if(d(a))return JSON.parse(e),null}catch{}let r=F(e,"date");if(r)return r;try{let a=JSON.parse(e);return f(a)?a.map(i=>F(i,n)):a}catch{return null}}if(n==="string")return g(e)?J(e,void 0)?"undefined":"null":e instanceof Date?e.toJSON():(()=>typeof e=="object"?e===null?"null":JSON.stringify(e):e.toString())()}var vn=F;function oa(e){try{return d(e)?typeof e=="bigint"?e:Math.ceil(e):NaN}catch{return NaN}}var la=w(oa);function ua(e,n){try{if(!d(e))return NaN;if(typeof e=="bigint")return e;if(g(n))n=1e-10;else if(!d(n))return NaN;return Ce(e)<n?0:e}catch{return NaN}}var ha=w(ua);function bn(e,n,t){try{return d(e)?d(n)?d(t)?typeof e=="bigint"?BigInt(bn($(e),n,t)):e<n?n:e>t?t:e:NaN:NaN:NaN}catch{return NaN}}var ca=w(bn);function fa(){let e=Object.values(arguments).map(n=>v(n)||y(n)?E(n.values):(l(f(n),"The `intersect` function only works on arrays, Series, and DataFrames!"),E(n)));return E(e).filter(n=>e.every(t=>t.findIndex(r=>J(r,n))>-1))}var Nn=fa,ne=class{constructor(e){l(g(e)||e===ne.DROP_NAN_MODE||e===ne.DROP_MISSING_MODE,"The `mode` value passed into the `IndexMatcher` constructor must be undefined or one of [IndexMatcher.DROP_NAN_MODE, IndexMatcher.DROP_MISSING_MODE]! (By default, the mode is `Indexer.DROP_MISSING_MODE`.)"),this.mode=g(e)?ne.DROP_NAN_MODE:e,this.index=null}fit(){let e=[];return Object.values(arguments).forEach(n=>{if(f(n)){let t=b(n);if(t.length===1)n=new I(n);else if(t.length===2)n=new _(n);else throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}l(v(n)||y(n),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),this.mode===ne.DROP_MISSING_MODE?e.push(n.dropMissing().index):e.push(n.dropNaN().index)}),this.index=Nn(...e),this}transform(){l(!!this.index,"The IndexMatcher hasn't been fitted yet! Please call the `fit` method before calling the `transform` method.");let e=Object.values(arguments).map(n=>{if(f(n)){let t=b(n);if(t.length===1)return new I(n).get(this.index).values;if(t.length===2)return new _(n).get(this.index,null).values;throw new Error("The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!")}return l(v(n)||y(n),"The `IndexMatcher.fit` method only works on arrays, Series, and DataFrames!"),n.get(this.index,null)});return e.length===1?e[0]:e}fitAndTransform(){return this.fit(...arguments).transform(...arguments)}},je=ne;qe(je,"DROP_NAN_MODE","DROP_NAN_MODE"),qe(je,"DROP_MISSING_MODE","DROP_MISSING_MODE");var xn=je;function ue(e,n,t,r){if(y(e))return ue(e.values,n,t,r);if(y(n))return ue(e,n.values,t,r);if(l(f(e)&&f(n)&&b(e).length===1&&b(n).length===1,"The `covariance` function only works on 1-dimensional arrays and Series!"),l(e.length===n.length,"The two arrays or Series passed into the `covariance` function must have the same length!"),t)return ue(...new xn().fitAndTransform(e,n),!1,r);try{let a=k(e,{stdev:r}),i=k(n,{stdev:r}),s=Number(a.mean),o=Number(i.mean);if(!d(s)||!d(o))return NaN;let u=Math.max(e.length,n.length),h=0;for(let c=0;c<u;c++){let m=e[c],p=n[c];if(!d(m))return NaN;if(!d(p))return NaN;typeof m=="bigint"&&(m=Number(m)),typeof p=="bigint"&&(p=Number(p)),h+=(m-s)*(p-o)}return r?[h/e.length,a,i]:h/e.length}catch{return NaN}}var wn=ue;function Ie(e,n,t){if(y(e))return Ie(e.values,n,t);if(y(n))return Ie(e,n.values,t);l(f(e)&&f(n)&&b(e).length===1&&b(n).length===1,"The `correl` function only works on 1-dimensional arrays and Series!"),l(e.length===n.length,"The two arrays or Series passed into the `correl` function must have the same length!");try{let[r,a,i]=wn(e,n,t,!0),s=a.stdev*i.stdev;return r/s}catch{return NaN}}var ma=Ie;function da(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.cos(e)):NaN}catch{return NaN}}var ga=w(da),pa=Object.freeze({boolean:"boolean",date:"date",null:"null",number:"number",object:"object",string:"string"});function Ee(e,n){if(v(e)||y(e))return Ee(e.values,n);if(v(n)||y(n))return Ee(e,n.values);l(f(e)&&f(n),"The `diff` function only works on arrays, Series, and DataFrames!");let t=E(e),r=E(n),a=[];return t.forEach(i=>{r.findIndex(s=>J(s,i))<0&&a.push(i)}),a}var ya=Ee;function On(e,n){try{if(!d(e))return NaN;if(!d(n))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let t=On(Number(e),Number(n));try{return BigInt(t)}catch{return t}}return Math.pow(e,n)}catch{return NaN}}var Re=w(On);function Sn(e){try{if(!d(e))return NaN;if(typeof e=="bigint"){let n=Sn(Number(e));try{return BigInt(n)}catch{return n}}return Math.sqrt(e)}catch{return NaN}}var _n=w(Sn);function va(){try{let e=Object.values(arguments);if(e.length===0)return NaN;let n=!1,t=1;for(let r of e){if(!d(r))return NaN;typeof r=="bigint"&&(n=!0,r=Number(r)),t*=r}if(n)try{return BigInt(t)}catch{}return t}catch{return NaN}}var Tn=w(va);function ba(){return Tn(...arguments)}var Q=ba;function Na(e,n){return ye(e,Q(n,-1))}var Dn=Na;function xa(e,n){return k(e,{shouldDropNaNs:n}).sum}var Ye=xa;function ke(e,n){if(d(e)&&d(n))return Ce(e-n);if(v(e)||y(e))return ke(e.values,n);if(v(n)||y(n))return ke(e,n.values);f(e)&&f(n)&&l(J(b(e),b(n)),"If passing two arrays, Series, or DataFrames into the `distance` function, then those objects must have the same shape!");try{return _n(Ye(Re(Dn(e,n),2)))}catch{return NaN}}var wa=ke;function Oa(e,n){return Q(e,Re(n,-1))}var Sa=Oa;function Y(e,n){if(v(e)){let a=Y(e.values,n);if(b(a).length===1){let i=new I(a);return i.name=y(n)?n.name:i.name,i.index=e.index.slice(),i}else{let i=new _(a);return i.index=e.index.slice(),v(n)&&(i.columns=n.columns.slice()),i}}if(v(n)){let a=Y(e,n.values);if(b(a).length===1){let i=new I(a);return i.name=y(e)?e.name:i.name,i.index=n.columns.slice(),i}else{let i=new _(a);return i.columns=n.columns.slice(),i}}if(y(e))return Y(e.values,n);if(y(n))return Y(e,n.values);l(f(e)&&f(n),"The `dot` function only works on arrays, Series, and DataFrames!");let t=b(e),r=b(n);if(l(t.length<=2&&r.length<=2,"I'm not smart enough to know how to get the dot-product of arrays that have more than 2 dimensions. Sorry for the inconvenience! Please only pass 1- or 2-dimensional arrays into the `dot` function!"),l(t[t.length-1]===r[0],`There's a dimension misalignment in the two arrays you passed into the \`dot\` function. (${t[t.length-1]} !== ${r[0]})`),t.length===1&&r.length===1)return Ye(Q(e,n));if(t.length===1&&r.length===2)return R(n).map(a=>Y(e,a));if(t.length===2&&r.length===1)return e.map(a=>Y(a,n));if(t.length===2&&r.length===2){let a=R(n),i=[];for(let s=0;s<e.length;s++){let o=[];for(let u=0;u<a.length;u++)o.push(Y(e[s],a[u]));i.push(o)}return i}}var Mn=Y;function jn(e){if(v(e)||y(e))return e.dropMissing(...Object.values(arguments).slice(1));l(f(e),"The `dropMissing` function only works on arrays, Series, and DataFrames!");let n=[];return e.forEach(t=>{try{return n.push(jn(t))}catch{g(t)||n.push(t)}}),n}var In=jn;function he(e,n){if(v(e)||y(e))return he(e.values,n);if(v(n)||y(n))return he(e,n.values);l(f(e)&&f(n),"The `dropMissingPairwise` function only works on arrays, Series, and DataFrames!"),l(J(b(e),b(n)),"The two arrays, Series, and/or DataFrames passed into the `dropMissingPairwise` function must have the same shape!");let t=[],r=[];for(let a=0;a<e.length;a++)try{let[i,s]=he(e[a],n[a]);t.push(i),r.push(s)}catch{!g(e[a])&&!g(n[a])&&(t.push(e[a]),r.push(n[a]))}return[t,r]}var _a=he;function ce(e,n){if(v(e)||y(e))return ce(e.values,n);if(v(n)||y(n))return ce(e,n.values);l(f(e)&&f(n),"The `dropNaNPairwise` only works on arrays, Series, and DataFrames!"),l(J(b(e),b(n)),"The two arrays, Series, and/or DataFrames passed into the `dropNaNPairwise` must have the same shape!");let t=[],r=[];for(let a=0;a<e.length;a++)try{let[i,s]=ce(e[a],n[a]);t.push(i),r.push(s)}catch{d(e[a])&&d(n[a])&&(t.push(e[a]),r.push(n[a]))}return[t,r]}var Ta=ce;function Da(e){return In(e)}var Ma=Da;function Fe(e,n){if(v(e)||y(e))return Fe(e.values,n);l(f(e),"The first argument passed into the `every` function must be an array, Series, or DataFrame!"),l(D(n),"The second argument passed into the `every` function must be a function!");for(let t of e)if(f(t)){if(!Fe(t,n))return!1}else if(!n(t))return!1;return!0}var En=Fe;function ja(e){try{if(!d(e))return NaN;if(typeof e=="bigint"){if(e===0n)return 1n;e=Number(e)}return Math.exp(e)}catch{return NaN}}var Ia=w(ja);function Pe(e){try{return typeof e=="bigint"?BigInt(Pe($(e))):e!==$(e)?NaN:e<=1?1:e*Pe(e-1)}catch{return NaN}}var Ea=w(Pe);function kn(e,n){if(v(e)||y(e))return kn(e.values,n);if(l(A(e)||f(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `find` function!"),!D(n)){let a=n;n=i=>i===a}function t(a,i,s){if(s=s||[],s.indexOf(a)>-1)return null;if(A(a)){s.push(a);let o=Object.keys(a).concat(Object.getOwnPropertySymbols(a));for(let u=0;u<o.length;u++){let h=o[u],c=a[h];if(i(c))return c;let m=t(c,i,s);if(m)return m}}else if(f(a)){s.push(a);for(let o=0;o<a.length;o++){let u=a[o];if(i(u))return u;let h=t(u,i,s);if(h)return h}}else if(i(a))return a;return null}function r(a){try{return n(a)}catch{return!1}}return t(e,r)}var ka=kn;function Fn(e,n){if(v(e)||y(e))return Fn(e.values,n);if(l(A(e)||f(e),"You must pass (1) an object, array, Series, or DataFrame and (2) a function or value into the `findAll` function!"),!D(n)){let i=n;n=s=>s===i}function t(i,s,o){if(o=o||[],o.indexOf(i)>-1)return null;if(A(i)){o.push(i);let u=Object.keys(i).concat(Object.getOwnPropertySymbols(i)),h=[];for(let c=0;c<u.length;c++){let m=u[c],p=i[m],x=!1;s(p)&&(h.push(p),x=!0);let N=t(p,s,o);N&&N.length>0&&N.slice(x?1:0).forEach(z=>h.push(z))}return h}else if(f(i)){o.push(i);let u=[];for(let h=0;h<i.length;h++){let c=i[h],m=!1;s(c)&&(u.push(c),m=!0);let p=t(c,s,o);p&&p.length>0&&p.slice(m?1:0).forEach(x=>u.push(x))}return u}else if(s(i))return[i];return null}function r(i){try{return n(i)}catch{return!1}}let a=t(e,r);return a&&a.length>0?a:null}var Fa=Fn;function Pa(e){try{if(e==="Infinity")return 1/0;if(e==="-Infinity")return-1/0;let n=JSON.parse(e);return d(n)?n:NaN}catch{return NaN}}var Ba=w(Pa);function Aa(e){try{return d(e)?typeof e=="bigint"?e:Math.floor(e):NaN}catch{return NaN}}var Ja=w(Aa);function $a(e){typeof e=="bigint"&&(e=$(e)),l(!g(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),l(d(e),"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),l($(e)===e,"You must pass an integer greater than 0 (representing the size) into the `identity` function!"),l(e>0,"You must pass an integer greater than 0 (representing the size) into the `identity` function!");let n=$e([e,e]);for(let t=0;t<e;t++)n[t][t]=1;return n}var za=$a,Ca=["true","false","yes","no"],Ra=["null","none","nan","na","n/a","","undefined"];function le(e){return e.type==="number"&&(typeof e.value<"u"?e.isInteger=$(e.value)===e.value:e.isInteger=En(e.values,n=>d(n)?$(n)===n:!0)),e}function fe(e){if(v(e)){let a=e.copy(),i=fe(e.values);return a.values=i.values,le({type:i.type,values:a})}if(y(e)){let a=e.copy(),i=fe(e.values);return a.values=i.values,le({type:i.type,values:a})}if(!f(e)){let a=fe([e]);return a.value=a.values[0],delete a.values,le(a)}l(f(e),"The `inferType` function only works on arrays, Series, and DataFrames!");let n=B(e).map(a=>{if(a===void 0)return"null";try{if(typeof a=="object"){let s=new Date(a.getTime());if(C(s))return"date"}}catch{}O(a)||(typeof a=="bigint"?a=a.toString()+"n":a=JSON.stringify(a));let i=a.toLowerCase().trim();if(Ra.indexOf(i)>-1)return"null";if(Ca.indexOf(i)>-1)return"boolean";try{if(a.match(/^-?\d+n$/g))return"bigint";let s=JSON.parse(a);return d(s)?"number":typeof s=="object"?f(s)?"string":"object":"string"}catch{let s=new Date(a);return C(s)?"date":"string"}}),t=de(n),r=t.values.toSorted((a,i)=>t.get(i)-t.get(a))[0];return le({type:r,values:xe(e,a=>vn(a,r))})}var Ya=fe;function me(e){if(v(e)){let t=e.copy();return t.values=me(t.values),t}l(f(e),"The `inverse` function only works on square 2-dimensional arrays or DataFrames!");let n=b(e);if(l(n.length===2,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),l(n[0]===n[1],"The array passed into the `inverse` function must be exactly two-dimensional and square!"),l(n[0]>=0,"The array passed into the `inverse` function must be exactly two-dimensional and square!"),n[0]===0)return e;if(n[0]===1){l(e[0][0]!==0,"This matrix cannot be inverted!");let t=e[0][0];return typeof t=="bigint"&&(t=Number(t)),1/t}else if(n[0]===2){let t=e[0][0],r=e[0][1],a=e[1][0],i=e[1][1];typeof t=="bigint"&&(t=Number(t)),typeof r=="bigint"&&(r=Number(r)),typeof a=="bigint"&&(a=Number(a)),typeof i=="bigint"&&(i=Number(i));let s=t*i-r*a;l(s!==0,"This matrix cannot be inverted!");let o=[[i,-r],[-a,t]];return Q(o,1/s)}else if(n[0]>1){let t=(r,a)=>d(r)||d(a)?Q(r,a):Mn(r,a);for(let r=1;r<n[0]-1;r++)try{let a=e.slice(0,r).map(N=>N.slice(0,r)),i=e.slice(0,r).map(N=>N.slice(r,n[0])),s=e.slice(r,n[0]).map(N=>N.slice(0,r)),o=e.slice(r,n[0]).map(N=>N.slice(r,n[0])),u=me(a),h=me(ye(o,t(-1,t(t(s,u),i)))),c=ye(u,t(t(t(t(u,i),h),s),u)),m=t(-1,t(t(u,i),h)),p=t(-1,t(t(h,s),u)),x=h;return c.map((N,z)=>N.concat(m[z])).concat(p.map((N,z)=>N.concat(x[z])))}catch{}l(!1,"This matrix cannot be inverted!")}}var qa=me,Ua=new Function(`
    try {
      return this === window
    } catch(e) {}

    try {
      return !!importScripts
    } catch(e){}

    return false
  `),Wa=Ua;function Pn(e,n,t){try{if(!d(e))return NaN;if(!d(n))return NaN;if(!d(t))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let r=Pn(Number(e),Number(n),t);try{return BigInt(r)}catch{return r}}return t*(n-e)+e}catch{return NaN}}var Ga=w(Pn);function Bn(e,n){try{if(n=g(n)?Math.E:n,!d(e))return NaN;if(!d(n))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let t=Bn(Number(e),Number(n));try{return BigInt(t)}catch{return t}}return Math.log(e)/Math.log(n)}catch{return NaN}}var Ka=w(Bn);function La(e,n){return k(e,{shouldDropNaNs:n}).mean}var Ha=La;function Va(e,n){return k(e,{shouldDropNaNs:n,median:!0}).median}var Xa=Va;function An(e,n){try{if(!d(e))return NaN;if(!d(n))return NaN;if(typeof e=="bigint"||typeof n=="bigint"){let t=An(Number(e),Number(n));try{return BigInt(t)}catch{return t}}return e%n}catch{return NaN}}var Za=w(An);function Qa(e,n){return k(e,{shouldDropNaNs:n,mode:!0}).mode}var ei=Qa;function Ze(){let e=X(),n=X();return Math.sqrt(-2*Math.log(e))*Math.cos(2*Math.PI*n)}function ni(e){return g(e)?Ze():xe(P(e),Ze)}var ti=ni;function ri(e){return xe(P(e),()=>1)}var ai=ri;function ii(){Object.keys(arguments).forEach(e=>{let n=arguments[e];if(f(n))if(ae(n))console.log(n);else{let t=b(n);t.length===1?new I(n).print():t.length==2?new _(n).print():console.log(n)}else v(n)||y(n)?n.print():console.log(n)})}var si=ii,oi=w((e,n,t,r,a)=>{try{let i=!1;for(let h of[e,n,t,r,a]){if(!d(h))return NaN;typeof h=="bigint"&&(i=!0)}i&&(e=Number(e),n=Number(n),t=Number(t),r=Number(r),a=Number(a));let s=(a-r)*(e-n),o=t-n;if(o===0)return NaN;let u=s/o+r;if(i)try{return BigInt(u)}catch{}return u}catch{return NaN}});function li(e,n,t,r,a){if(f(e)&&g(r)&&g(a)){r=n,a=t;let i=k(e);n=i.min,t=i.max}return oi(e,n,t,r,a)}var ui=li;function hi(e){try{return d(e)?typeof e=="bigint"?e:Math.round(e):NaN}catch{return NaN}}var ci=w(hi);function Jn(e){try{return d(e)?typeof e=="bigint"?BigInt(Jn(Number(e))):e<0?-1:e>0?1:0:NaN}catch{return NaN}}var fi=w(Jn);function mi(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.sin(e)):NaN}catch{return NaN}}var di=w(mi);function Be(e,n){if(v(e)||y(e))return Be(e.values,n);l(f(e),"The first argument passed into the `some` function must be an array, Series, or DataFrame!"),l(D(n),"The second argument passed into the `some` function must be a function!");for(let t of e)if(f(t)){if(Be(t,n))return!0}else if(n(t))return!0;return!1}var gi=Be;function pi(e,n){return k(e,{shouldDropNaNs:n,stdev:!0}).stdev}var $n=pi;function yi(e){return $n(e)}var vi=yi;function bi(e){try{return d(e)?(typeof e=="bigint"&&(e=Number(e)),Math.tan(e)):NaN}catch{return NaN}}var Ni=w(bi);function xi(){return E([...arguments].map(e=>f(e)?e:v(e)||y(e)?e.values:[e]))}var wi=xi;function Oi(e,n){return k(e,{shouldDropNaNs:n,variance:!0}).variance}var Si=Oi;function _i(){let e=[],n=Object.values(arguments).map(t=>((v(t)||y(t))&&(t=t.values),l(f(t),"The `zip` function only works on arrays, Series, and DataFrames!"),t));return T(0,Ne(n.map(t=>t.length))).forEach(t=>{let r=[];n.forEach(a=>{let i=a[t];r.push(g(i)?void 0:i)}),e.push(r)}),e}var Ti=_i,te={abs:Ce,add:ye,apply:xe,arccos:Qr,arcsin:na,arctan:ra,argmax:aa,argmin:sa,assert:l,cast:vn,ceil:la,chop:ha,clamp:ca,combinations:pn,combinationsIterator:pe,copy:M,correl:ma,cos:ga,count:de,covariance:wn,DataFrame:_,dataTypes:pa,decycle:V,diff:ya,distance:wa,divide:Sa,dot:Mn,dropMissing:In,dropMissingPairwise:_a,dropNaN:mn,dropNaNPairwise:Ta,dropUndefined:Ma,every:En,exp:Ia,factorial:Ea,find:ka,findAll:Fa,flatten:B,float:Ba,floor:Ja,identity:za,IndexMatcher:xn,indexOf:ve,inferType:Ya,int:$,intersect:Nn,inverse:qa,isArray:f,isBoolean:W,isBrowser:Wa,isDataFrame:v,isDate:C,isEqual:J,isFunction:D,isJagged:ae,isNested:Ae,isNumber:d,isObject:A,isSeries:y,isString:O,isUndefined:g,lerp:Ga,log:Ka,MathError:U,max:Ne,mean:Ha,median:Xa,min:yn,mod:Za,mode:ei,multiply:Tn,ndarray:P,normal:ti,ones:ai,permutations:Kr,permutationsIterator:ze,pow:Re,print:si,product:be,random:X,range:T,remap:ui,reshape:Je,reverse:q,round:ci,scale:Q,seed:un,Series:I,set:E,shape:b,shuffle:ge,sign:fi,sin:di,some:gi,sort:G,sqrt:_n,stats:k,std:$n,stdev:vi,subtract:Dn,sum:Ye,tan:Ni,timeAsync:Lr,timeSync:Xe,time:Xe,transpose:R,union:wi,variance:Si,vectorize:w,zeros:$e,zip:Ti,dump(){let e=typeof globalThis<"u"?globalThis:typeof global<"u"?global:typeof window<"u"?window:typeof self<"u"?self:void 0;if(!e)throw new te.MathError("Cannot dump functions into global scope because none of `globalThis`, `global`, `window`, or `self` exist in the current context!");Object.keys(te).forEach(n=>{try{Object.defineProperty(e,n,{configurable:!1,enumerable:!0,writable:!1,value:te[n]})}catch{e[n]=te[n]}})}};typeof window<"u"&&(window.JSMathTools=te);var zn="above",Cn="below",se="exactly_on";function ee(e,n){let[t,r]=n;if(r[0]-t[0]===0){if(r[1]-t[1]===0)throw new Error("The pair of points provided are identical and therefore do not form a line!");return e[0]<r[0]?Cn:e[0]===r[0]?se:zn}let a=(r[1]-t[1])/(r[0]-t[0]),i=t[1]-a*t[0],s=a*e[0]+i;return e[1]===s?se:e[1]>s?zn:Cn}function Rn(e,n){let[t,r,a]=n,i=ee(a,[t,r]),s=ee(e,[t,r]);if(i!==s&&s!==se)return!1;let o=ee(r,[t,a]),u=ee(e,[t,a]);if(o!==u&&u!==se)return!1;let h=ee(t,[r,a]),c=ee(e,[r,a]);return!(h!==c&&c!==se)}typeof window<"u"&&(window.pointIsInTriangle=Rn);var Yn=Rn;function Di(e,n){let t=ji(e),r=Math.atan(e[1]/e[0]);return e[0]<0&&(r+=Math.PI),[t*Math.cos(r+n),t*Math.sin(r+n)]}function Mi(e,n){return e[0]*n[0]+e[1]*n[1]}function ji(e){return Math.sqrt(Mi(e,e))}function Ii(e,n,t){let r=[e[0]-n[0],e[1]-n[1]],a=[t[0]-n[0],t[1]-n[1]],i=Math.atan(r[1]/r[0]);return r[0]<0&&(i+=Math.PI),a=Di(a,-i+Math.PI/2),a[0]>0}function qn(e){if(e.length<3)throw new Error("A minimum of 3 points are needed to compute a hull!");let n=e.slice().sort((r,a)=>r[0]<a[0]?-1:1),t=[n[0]];for(;t.length<3||t.at(-1)!==t[0];){let r=t.at(-1),a=n[0]===r?n[1]:n[0];n.forEach(i=>{r!==i&&a!==i&&Ii(r,a,i)&&(a=i)}),t.push(a),n.splice(n.indexOf(a),1)}return E(t.map(r=>JSON.stringify(r))).map(r=>JSON.parse(r))}typeof window<"u"&&(window.getConvexHull=qn);var zi={getConvexHull:qn,pointIsInTriangle:Yn};export{zi as default,qn as getConvexHull,Yn as pointIsInTriangle};
